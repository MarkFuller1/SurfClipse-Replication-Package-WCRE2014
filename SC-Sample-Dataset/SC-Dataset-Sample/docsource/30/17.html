
<!-- Do not edit by hand! Generated by XSLidy 0.5 ($Id: xslidy.xsl 302 2007-04-19 05:14:15Z dret $) on 2009-01-11T21:07:20.796+01:00 -->
<!-- For more information about XSLidy please visit http://dret.net/projects/xslidy/. -->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Die Simple API for XML (SAX) ; Barbara Zengler ; Fachhochschule Augsburg , Fakultät für Informatik , Studiengang Interaktive Medien</title><meta name="copyright" content="Copyright © 2008, Barbara Zengler" /><link rel="stylesheet" type="text/css" media="screen, projection" href="slidy/slidy.css" /><link rel="stylesheet" type="text/css" media="screen, projection" href="../css/xslidy-fha.css" /><link rel="stylesheet" type="text/css" media="screen, projection, print" href="xslidy/xslidy.css" /><link rel="author" href="http://www.barbara-zengler.de/" /><link rel="contents" href="./" title="XML" /><link rel="glossary" href="http://dret.net/glossary/" /><link rel="home" href="./" title="XML" /><link rel="next" href="uebungsaufgabenSAX" title="uebungsaufgabenSAX" /><link rel="last" href="xforms" title="xforms" /><link rel="prev" href="uebungenSchema" title="uebungenSchema" /><link rel="start" href="intro" title="Introduction" /><link rel="first" href="intro" title="Introduction" /><script type="text/javascript" src="slidy/slidy.js"></script><link rel="stylesheet" href="css/xslidy-fha.css" type="text/css" /></head><body><div class="background"></div><div class="slide" id="d1e12422"><h1>Abstract</h1><p class="abstract">
				
			Für diverse Programmiersprachen existieren mittlerweile
			gängige Schnittstellen, um auf XML-Dokumente zuzugreifen und
			diese weiterzuverarbeiten. Die
			<em>Simple API for XML (SAX)</em>
			ist eine sehr einfach (=leichtgewichtig) gehaltene API für
			die
			<em>ereignisbasierte</em>
			Verarbeitung von XML-Dokumenten. Die Charakterisierung als
			leichtgewichtiger Ansatz bezieht sich sowohl auf den
			Implementierungsaufwand der API selbst, als auch ihren
			Integrationsaufwand in eigene Applikationen.
		
			</p></div><div class="slide" id="d1e12429"><h1>XML-APIs - baumorientiert vs. ereignisbasiert</h1><p>
				Für die Verarbeitung von XML-Dokmenten sind im
				Wesentlichen zwei Ansätze verfügbar.
			</p><ul><li>
					<em>Baumorientierte APIs</em>
					:
					<br />
					Baumorientierte APIs bilden das gesamte zu
					verarbeitende Dokument in eine Baumstruktur ab. Eine
					weiterverarbeitende Applikation kann je nach Bedarf
					entlang dieser Baumstruktur navigieren. Das Document
					Object Model (DOM) stellt solche eine
					baumorientierte API zur Verfügung.
				</li><li>
					<em>Ereignisbasierte APIs</em>
					:
					<br />
					Diese Art Programmierschnittstelle liest über ein
					Dokument und berichtet dabei über sogenannte
					berichtenswerte "Ereignisse", die während des Lesens
					auftreten (zum Beispiel den Start oder das Ende
					eines Elementes). Die Applikation wird über
					sogenannte "Callback"-Methoden über diese Ereignisse
					benachrichtigt. Es wird keine interne Baumstruktur
					aufgebaut, die dem XML-Dokument entspricht.
				</li></ul></div><div class="slide" id="d1e12452"><h1>Was ist ein Parser? Was sind seine Aufgaben?</h1><p class="definition">
				Ein Parser (engl. to parse „analysieren“ bzw. von
				lateinisch pars „Teil“; im Deutschen gelegentlich auch
				Zerteiler) ist ein Computerprogramm, das in der
				Computertechnik für die Zerlegung und Umwandlung einer
				beliebigen Eingabe in ein für die Weiterverarbeitung
				brauchbares Format zuständig ist. Häufig werden Parser
				eingesetzt, um im Anschluss an den Analysevorgang die
				Semantik der Eingabe zu erschließen und daraufhin
				Aktionen durchzuführen.
			</p><p>
				Quelle:
				<a class="outlink" href="http://de.wikipedia.org/wiki/Parser" title="http://de.wikipedia.org/wiki/Parser">
					Wikipedia
				</a>
			</p></div><div class="slide" id="d1e12462"><h1>SAX - Einführendes</h1><ul><li>
					Ursprünglich war SAX eine Sammlung generischer
					Java-Schnittstellen für XML-Parser.
				</li><li>
					Weiterentwicklung zur eigenständigen
					Verarbeitungsmöglichkeit für XML-Dokumente in
					verschiedenen weiteren Programmiersprachen:
				<ul><li>C++</li><li>Python</li><li>Perl</li><li>Eiffel</li></ul></li><li>
					In der Vorlesung konzentrieren wir uns auf die
					Java-Umsetzung von SAX2.
				</li><li>
					SAX2 ist eine Weiterentwicklung von SAX und
					unterstützt beispielsweise Namensräume.
				</li><li>
					SAX2 ist seit JDK 1.4 Bestandteil des JDK und ist
					Bestandteil der Java APIs for XML Processing (JAXP).
				</li></ul></div><div class="slide" id="d1e12498"><h1>Bestandteile von SAX Implementierungen</h1><p>
				SAX-Implementierungen weisen üblicherweise drei
				erkennbare Blöcke auf.
			</p><ul><li>
					<em>Die Schnittstellen:</em>
					<br />
					SAX definiert eine Sammlung abstrakter
					Schnittstellen (siehe nächste Seite).
				</li><li>
					<em>Reader (Parser)</em>
					<br />
					Der Parser selbst (= die Implementierung zu den
					Schnittstellen). Die SAX2-Schnittstellen werden
					durch den jeweiligen eingesetzten Parser bedient und
					die definierten (Callback)-Methoden entsprechend
					eingebunden.
				</li><li>
					<em>ReaderFactory</em>
					<br />
					Sie dient zur Erzeugung verschiedener Ausprägungen
					(z.B. validierend/nicht-validierend, Namespace
					berücksichtigend, etc.) SAX-basierter Parser.
					<br />
					Bei einer
					<em>Factory Method</em>
					handelt es sich um ein sogenanntes
					<em>Design Pattern</em>
					(Entwurfsmuster,
					<a class="outlink" href="http://de.wikipedia.org/wiki/Viererbande_(Softwareentwicklung)" title="http://de.wikipedia.org/wiki/Viererbande_(Softwareentwicklung)">
						Gang of Four
					</a>
					). Ziel: Objekte erzeugen, ohne die genaue Klasse
					des zu erzeugenden Objekts anzugeben. Lösung: es
					wird in einer Schnittstelle eine Methode zur
					Erzeugung von Objekten definiert. In den Subklassen
					kann diese Methode dann überschrieben werden, um ein
					abgeleitetes Objekt zu erzeugen.
				</li></ul></div><div class="slide" id="d1e12541"><h1>Die SAX2 Schnittstellen</h1><ul><li>
					<em>ContentHandler:</em>
					<br />
					Versammelt Operationen zur Reaktion auf
					Dokumentereignisse (wie
					<code>startDocument</code>
					,
					<code>startElement</code>
					,
					<code>processingInstruction</code>
					...) Hinweis: In älterer Literatur findet sich
					häufig statt des ContentHandlers eine mit
					DocumentHandler benannte Schnittstelle. Dabei
					handelt es sich um die Schnittstelle der
					Vorgängerversion (SAX1). Sie bietet unter anderem
					keine Namensraumintegration und wurde durch den
					<code>ContentHandler</code>
					ersetzt.
					<br />
					Achtung: Die Java-Standardklassenbibliothek bietet
					im Paket
					<code>java.net</code>
					eine mit
					<code>ContentHandler</code>
					benannte Klasse an. Diese kann durch
					Importanweisungen mit der gleichnamigen
					SAX-Schnittstelle aus dem Paket
					<code>org.xml.sax</code>
					kollidieren!
				</li><li>
					<em>ErrorHandler:</em>
					<br />
					Versammelt Operationen zur Reaktion auf die drei in
					der XML-Spezifikation definierten Fehlerklassen:
					<ul><li>
							<em>error</em>
							(behebbarer Fehler):
							<br />
							Bei einem Fehler ist das Ergebnis der
							aktuellen Verarbeitung undefiniert, der
							Prozessor fährt jedoch mit der Verarbeitung
							eines Dokumentes fort.
							<br />
							Beispiel: Anderer Wert als
							<code>1.0</code>
							oder
							<code>1.1</code>
							im XML-Prolog oder ein
							nichtdeterministisches Inhaltsmodell (siehe
							nächste Seite).
						</li><li>
							<em>fatalError</em>
							:
							<br />
							Ein fataler Fehler führt dazu, daß der
							XML-Prozessor die Verarbeitung eines
							Dokumentes abbricht und einen Fehler an die
							Applikation meldet.
							<br />
							Beispiel: Falsche Codierung eines Dokuments
							(tatsächliche Codierung stimmt nicht mit im
							Prolog angegebener Codierung überein),
							Verletzung der Wohlgeformtheitsregeln
						</li><li>
							<em>warning</em>
							:
							<br />
							Mit einer Warnung können Hinweise gegeben
							werden. Warnungen sind als Hilfestellung
							gedacht und optional. Das bedeutet,
							Prozessoren
							<em>können</em>
							Warnungen ausgeben, müssen dies aber nicht
							tun.
							<br />
							Beispiel: Referenzierung eines nicht
							deklarierten Elements als Kindelement.
						</li></ul>
				</li><li>
					<em>DTDHandler:</em>
					<br />
					Möglichkeit zur Implementierung eigener
					Behandlungsroutinen für Notation-Deklarationen und
					ungeparste Entitäten.
				</li><li>
					<em>EntityResolver:</em>
					<br />
					Möglichkeit zur Implementierung von
					Auflösungsmechanismen für Entitäten gemäß ihres
					System Identifiers und, falls vorhanden, des Public
					Identifiers.
				</li></ul></div><div class="slide" id="d1e12644"><h1>
				Ausflug in den Compilerbau: deterministisches
				Inhaltsmodell
			</h1><ul><li>
					Mit
					<em>Determinismus</em>
					bezeichnet man in der Informatik einen Zustand, zu
					dem nur definierte und reproduzierbare Folgezustände
					auftreten können. Das bedeutet etwa, daß bei der
					Abarbeitung eines Algorithmus nach einer bestimmten
					Anweisung unter den gleichen Voraussetzungen immer
					die gleiche nächste Anweisung folgt. Der nächste
					Abarbeitungsschritt ist immer eindeutig festgelegt.
					<br />
					(Quelle:
					<a class="outlink" href="http://de.wikipedia.org/wiki/Determinismus_(Algorithmus)" title="http://de.wikipedia.org/wiki/Determinismus_(Algorithmus)">
						Wikipedia
					</a>
					)
				</li><li>
					Anders formuliert und in Bezug auf Grammatiken
					gesetzt: Zu jedem Zustand und Eingabesymbol eines
					Automaten darf höchstens ein Folgezustand
					existieren.
					<br />
					(Quelle:
					<a class="outlink" href="http://books.google.de/books?id=Zo7I8kutRVIC" title="http://books.google.de/books?id=Zo7I8kutRVIC">
						Grundkurs Theoretische Informatik, von Gottfried
						Vossen, Kurt-Ulrich Witt
					</a>
					)
				</li><li>
					Beispiel:
					<code>((b, c) | (b, d))</code>
					. Ein Prozessor kann, wenn er das Element
					<code>b</code>
					in einem Dokument liest, nicht wissen, ob als
					nächstes Element
					<code>c</code>
					oder
					<code>d</code>
					erscheint. Welche der beiden Möglichkeiten trifft
					zu? Der Prozessor müßte zur Beantwortung dieser
					Frage im Dokument bereits
					<q>vorauslesen</q>
					. Eine Umformulierung der Grammatik hilft in diesen
					Fällen. Wäre das Inhaltsmodell als
					<code>(b, (c | d))</code>
					definiert, so treten diese Probleme nicht auf, denn
					der Prozessor muß nicht zwischen zwei Regeln
					auswählen, er muß hier nicht
					<q>vorauslesen</q>
					, sowohl
					<code>c</code>
					als auch
					<code>d</code>
					würden akzeptiert.
				</li></ul></div><div class="slide" id="d1e12700"><h1>Das SAX Ausführungsmodell</h1><ul><li>Ereignisbasierte Ausführung von Operationen</li><li>
					Der Parser liest das Eingabedokument und aktiviert
					währenddessen verschiedene Operationen, die der
					Behandlung des soeben eingelesenen Information Items
					dienen.
				</li><li>
					Der Programmierer einer Applikation ruft diese
					Operationen nicht explizit auf!
				</li><li>
					Die Reihenfolge der Abarbeitung wird nicht durch
					einen durchgängigen Programmcode gesteuert.
					Stattdessen ergibt sie sich aus der Reihenfolge der
					Ereignisse, die bei der Verarbeitung des Dokumentes
					aktiviert wird. Die Abarbeitung erfolgt also
					dokumentgesteuert.
				</li></ul></div><div class="slide" id="d1e12717"><h1>SAX - Leichtgewichtiger Ansatz</h1><ul><li>
					SAX-Parser wurden bewußt
					<em>leichtgewichtig</em>
					konzipiert.
				</li><li>
					Sie halten nur die nötigste Information im Speicher,
					die für die Verarbeitung des gerade eingelesenen
					Information Items nötig ist. Das bedeutet, nur die
					Menge an Information, die gerade nötig ist, um die
					Callback-Operation auszuführen (Übergabeparameter),
					ist von Interesse.
				</li><li>
					Aufgrund dieser geringen Anforderungen ist dieses
					Konzept mit nur geringen Anpassungen auf sehr viele
					Programmiersprachen anwendbar.
				</li><li>SAX eignet sich daher für<ul><li>
						Geräte, denen nur geringer Hauptspeicher zur
						Verfügung steht (z.B. Embedded Devices, tragbare
						Geräte, etc.)
					</li><li>
						die Verarbeitung von sehr großen XML-Dokumenten,
						die zu groß sind, um im Hauptpeicher gehalten
						werden zu können. (XML-Dokumente für
						3D-Grafiken, etwa tesselierte Daten, werden
						bspw. sehr schnell sehr groß!)
					</li><li>
						<q>Einfache</q>
						Aufgaben, bei denen es nicht nötig ist, das
						gesamte Dokument mit seiner Struktur im Speicher
						zu behalten.
						<br />
						Beispiel: Finden eines Elements, das einen
						bestimmte Zeichenkette enthält. Für solche
						Aufgaben ist es nicht effizient, die
						Dokumentstruktur als Baum nachzubilden und dann
						so lange im Baum zu navigieren, bis diese
						Information gefunden ist. Eine ereignisbasierte
						API erlaubt die Durchführung dieser Aufgabe
						schnell (keine Nnvigation nötig) und effizient
						(wenig Speicherverbrauch).
					</li></ul></li></ul></div><div class="slide" id="d1e12754"><h1>Push Model</h1><ul><li>
					Eine SAX-Applikation wird nie selbst aktiv, steuert
					nie den Kontrollfluß selbst.
				</li><li>
					Stattdessen wartet sie passiv auf ihre Aktivierung,
					durch Auswerfen der jeweiligen Ereignisse.
				</li><li>
					Ein derartiges Verhalten wird auch
					<em>Push Model</em>
					genannt.
				</li><li>
					Am Eingabedokument sind mit SAX keine großen
					Änderungen möglich, da das
					<q>Blickfeld</q>
					sehr eingeschränkt ist.
				</li><li>
					Möglich sind lediglich einfache Transformationen,
					indem das Eingabedokument verändert wieder
					ausgegeben wird.
				</li></ul></div><div class="slide" id="d1e12780"><h1>SAX - Ein erstes Beispiel</h1><a href="SAXExample1.java" title="SAXExample1.java"><pre class="listing">import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample1 extends DefaultHandler {
 
    public void startDocument() {
        System.out.println("document started");
    } //startDocument()

    public void endDocument() {
        System.out.println("document ended");
    } //endDocument()

    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
     SAXExample1 handler = new SAXExample1();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));

    } //main()

    public SAXExample1 ()
    {
     super();
    }
    
}//class SAXExample1</pre></a></div><div class="slide" id="d1e12784"><h1>SAX - erste Übung</h1><ul><li>
					Führen Sie einen
					<a class="outlink" href="http://www.barbara-zengler.de/vorlesung/SAXExample1.java" title="http://www.barbara-zengler.de/vorlesung/SAXExample1.java">
						Download des ersten SAX-Beispiels
					</a>
					auf Ihren Rechner durch.
				</li><li>Öffnen Sie eine Shell (Befehlseingabefenster).</li><li>
					Prüfen Sie die bei Ihnen installierte Java-Version
					durch Absetzen des Befehls
					<code>java -version</code>
					. Prüfen Sie das Vorhandensein des Java Compilers (
					<code>javac</code>
					).
				</li><li>
					Zur Erstellung der Beispiele und Übungen in diesem
					Skript wurde das
					<a class="outlink" href="http://download.java.net/jdk6/binaries/" title="http://download.java.net/jdk6/binaries/">
						Java SDK 1.6 Update 10
					</a>
					verwendet.
				</li><li>
					Wechseln Sie in das Verzeichnis, in das Sie das
					Beispiel gespeichert haben und compilieren Sie es
					mit dem Befehl
					<code>javac SAXExample1.java</code>
				</li><li>
					Nun können Sie die Anwendung mit beliebigen
					XML-Dokumenten ausführen.
					<br />
					Am Beispiel unseres ersten XML-Dokumentes ergibt
					sich folgende Ausgabe:
				<a href="SAXExample1.output" title="SAXExample1.output"><pre class="listing">$ java SAXExample1 erstes-XML-dokument.xml
document started
document ended</pre></a></li></ul></div><div class="slide" id="d1e12827"><h1>SAX - erstes Beispiel - Analyse (1/2)</h1><p>
				Was ist während der Ausführung des Beispiels passiert?
				<br />
				Eine Analyse.
			</p><ul><li>
					Der SAX-Parser liest das auf der Kommandozeile
					angegebene Dokument (
					<code>erstes-XML-dokument.xml</code>
					) ein.
				<a href="SAXExample1.bat" title="SAXExample1.bat"><pre class="listing">java SAXExample1 erstes-XML-dokument.xml</pre></a></li><li>
					Zu Beginn des Lesevorgangs ruft er die vordefinierte
					callback-Funtion
					<code>startDocument</code>
					auf.
					<br />
					Diese wurde in der Applikation (
					<code>SAXExample2.java</code>
					) implementiert. Sie gibt die eine Zeile mit dem
					Text
					<code>document started</code>
					aus.
				<a href="SAXExample1.java#line=8,11" title="SAXExample1.java (line 9-11)"><pre class="listing">    public void startDocument() {
        System.out.println("document started");
    } //startDocument()</pre></a></li><li>
					Am Ende des Lesevorgangs wird vom Parser eine
					weitere vordefinierte callback-Funktion aufgerufen:
					<code>endDocument</code>
					. Auch diese wurde in der Applikation implementiert,
					sie gibt eine Zeile mit dem Text
					<code>document ended</code>
					aus.
				<a href="SAXExample1.java#line=12,15" title="SAXExample1.java (line 13-15)"><pre class="listing">    public void endDocument() {
        System.out.println("document ended");
    } //endDocument()</pre></a></li><li>
					Unsere im Beispiel erstellte Klasse erweitert die in
					SAX definierte Basisklasse
					<code>
						<a class="outlink" href="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html" title="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html">
							DefaultHandler
						</a>
					</code>
					(definiert im Paket
					<code>
						<a class="outlink" href="https://jaxp-sources.dev.java.net/nonav/docs/api/org/xml/sax/helpers/package-summary.html" title="https://jaxp-sources.dev.java.net/nonav/docs/api/org/xml/sax/helpers/package-summary.html">
							org.xml.sax.helpers
						</a>
					</code>
					).
					<br />
					Hier sind auch die Signaturen der beiden verwendeten
					Operationen
					<code>startDocument</code>
					und
					<code>endDocument</code>
					festgelegt (
					<a class="outlink" href="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html" title="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html">
						In JAXP API Dokumentation nachlesen
					</a>
					).
					<br />
					Unsere Beispielklasse erbt diese beiden Methoden,
					die zunächst einfach
					<q>nichts tun</q>
					, von dieser Klasse. In der Beispielklasse werden
					die Methoden dann überschrieben und die oben
					erwähnten Textausgaben produziert.
				<a href="SAXExample1.java#line=6,7" title="SAXExample1.java (line 7)"><pre class="listing">public class SAXExample1 extends DefaultHandler {</pre></a></li></ul></div><div class="slide" id="d1e12906"><h1>SAX - erstes Beispiel - Analyse (2/2)</h1><ul><li>
					Bevor das Dokument durch einen XML Reader (Parser)
					gelesen werden kann, muß erst ein entsprechendes
					Objekt (eine Instanz) eines Readers erzeugt werden.
					Dies geschieht mit dem Aufruf
					<code>XMLReaderFactory.createXMLReader()</code>
					E stehen verschiedene konfigurierbare SAX-Parser
					Implementierungen zur Verfügung. Unter Nutzung der
					aktuellen Systemkonfiguration wird mittels
					<code>createXMLReader</code>
					ein neuer Parser erzeugt. Im Beispiel wird die
					Vorgabekonfiguration verwendet.
				<a href="SAXExample1.java#line=17,18" title="SAXExample1.java (line 18)"><pre class="listing">     XMLReader xr = XMLReaderFactory.createXMLReader();</pre></a></li><li>
					Danach müssen die EventHandler registriert werden,
					mit deren Hilfe der Parser uns Informationen über
					das gelesene Dokument mitteilt.
					<br />
					Dies geschieht mit Hilfe der Methoden
					<code>setContentHandler</code>
					und
					<code>setErrorHandler</code>
					der XMLReader Schnittstelle. Werden diese Handler
					nicht gesetzt, so werden sämtliche Ereignisse, die
					der Parser meldet, schlichtweg von der Anwendung
					ignoriert. Es passiert
					<q>nichts</q>
					.
					<br />
					Hat man diese Schritte durchgeführt, dann kann die
					(passive) SAX API durch den Parser aufgerufen
					werden.
				<a href="SAXExample1.java#line=18,21" title="SAXExample1.java (line 19-21)"><pre class="listing">     SAXExample1 handler = new SAXExample1();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);</pre></a></li><li>
					Im obigen Codeauszug wird ein Objekt der Klasse
					SAXExample2 erzeugt, mit dem die Ereignisse des
					SAX-Parsers empfangen werden können. Es werden
					EreignisHandler für den Inhalt des Dokuments (
					<em>Content Handler</em>
					) und für Fehler (
					<em>Error Handler</em>
					) registriert.
				</li><li>
					Die Methode
					<code>parse</code>
					des
					<code>XMLReader</code>
					-Objekts führt auf dem über Kommandozeilenparameter
					(
					<code>args[0]</code>
					) übergebenen Dokument den Lesevorgang durch.
					<br />
					<em>Beachten Sie</em>
					: Die Datei muss über ein Objekt der Klasse
					<code>InputSource</code>
					gekapselt werden, damit sie eingelesen werden kann.
				<a href="SAXExample1.java#line=22,24" title="SAXExample1.java (line 23-24)"><pre class="listing">     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));</pre></a></li></ul></div><div class="slide" id="d1e12973"><h1>SAX - Erweiterung des ersten Beispiels</h1><ul><li>
					Das erste Beispiel soll so erweitert werden, daß der
					Parser auch Start und Ende der Elemente eines
					Dokuments ausgeben soll.
				</li><li>
					Dazu werden die beiden Callback-Methoden
					<code>startElement</code>
					und
					<code>endElement</code>
					in der Applikation implementiert.
				<a href="SAXExample2.java#line=17,24" title="SAXExample2.java (line 18-24)"><pre class="listing">    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
     System.out.println("Element " + localName + " started.");
    } //startElement()
    
    public void endElement(String namespaceURI, String localName, String qName){
     System.out.println("Element " + localName + " ended.");     
    } //endElement() </pre></a></li><li>
					Die Signatur der Methode
					<code>startElement</code>
					erfordert das Einbinden der Schnittstelle
					<code>Attributes</code>
					aus dem Paket
					<code>org.xml.sax</code>
					.
				<a href="SAXExample2.java#line=3,4" title="SAXExample2.java (line 4)"><pre class="listing">import org.xml.sax.Attributes;</pre></a></li><li>
					Der komplette Code des erweiterten Beispiels sieht
					demnach nun folgendermaßen aus.
				<a href="SAXExample2.java" title="SAXExample2.java"><pre class="listing">import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.Attributes;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample2 extends DefaultHandler {
 
    public void startDocument() {
        System.out.println("document started");
    } //startDocument()

    public void endDocument() {
        System.out.println("document ended");
    } //endDocument()
    
    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
     System.out.println("Element " + localName + " started.");
    } //startElement()
    
    public void endElement(String namespaceURI, String localName, String qName){
     System.out.println("Element " + localName + " ended.");     
    } //endElement() 

    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
     SAXExample2 handler = new SAXExample2();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));

    } //main()

    public SAXExample2 ()
    {
     super();
    }
    
}//class SAXExample2</pre></a></li></ul></div><div class="slide" id="d1e13012"><h1>Die SAX2-Schnittstellen</h1><p>
				Die grundlegende Schnittstelle der SAX2-API wird mit
				ContentHandler bezeichnet, sie versammelt Operationen
				zur Abbildung des logischen Inhaltes eines
				XML-Dokumentes. Die in unseren Beispielen verwendete
				Basisklasse
				<code>DefaultHandler</code>
				implementiert u.a. diese Schnittstelle und stellt sie so
				der Beispielapplikation zur Verfügung.
				<br />
				Die Übersicht in untenstehender Tabelle stellt die
				wichtigsten Operationen der Schnittstelle mit ihrer
				Signatur und Funktionalität zusammen.
			</p><table border="1">
				<thead>
					<tr>
						<th>Operation</th>
						<th>Funktionalität</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startDocument()" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startDocument()">
									startDocument()
								</a>
							</code>
						</td>
						<td>
							Aufruf zu Beginn eines Dokuments. Naturgemäß
							wird diese Methode nur einmal ausgeführt.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endDocument()" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endDocument()">
									endDocument()
								</a>
							</code>
						</td>
						<td>
							Aufruf am Ende des Einlesevorgangs eines
							Dokuments. Auch diese Methode wird vom SAX
							Parser nur einmal aufgerufen.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startElement(java.lang.String,%20java.lang.String,%20java.lang.String,%20org.xml.sax.Attributes)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startElement(java.lang.String,%20java.lang.String,%20java.lang.String,%20org.xml.sax.Attributes)">
									startElement(String namespaceURI,
									String localName, String qName,
									Attributes atts)
								</a>
							</code>
						</td>
						<td>
							Die Operation wird am Anfang (öffnender Tag)
							eines jeden Elements in einem XML-Dokument
							aufgerufen (auch bei leeren Elementen!). Sie
							gibt unter den Namen des Elementes als Namen
							ohne Namensraumpräfix (
							<code>localName</code>
							) sowie auch den qualifizierten Namen des
							Elements (
							<code>qName</code>
							) zurück.
							<br />
							Anmerkung: Namensrauminformationen werden
							nur erzeugt, wenn der Parser entsprechend
							konfiguriert wurde.
							<div class="note">
								Das bedeutet z.B., der qualifizierte
								Name wird nur dann zurückgegeben, wenn
								der Parser konfiguriert wurde,
								Namensraum-Präfixe zu verwenden.
							</div>
							<br />
							Objekte des Type Attributes enthalten die
							Attribute eines Elements in der Reihenfolge
							ihrer Definition.
							<br />
							Zu jedem Attribut sind neben dem lokalen und
							dem qualifizierten Namen die Namensraum URI
							sowie Typ und Attributwert gemäß XML v1.0
							abrufbar.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endElement(java.lang.String,%20java.lang.String,%20java.lang.String)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endElement(java.lang.String,%20java.lang.String,%20java.lang.String)">
									endElement(String namespaceURI,
									String localName, String qName)
								</a>
							</code>
						</td>
						<td>
							Die Operation wird aufgerufen, wenn das Ende
							eines jeden Elements in einem XML-Dokument
							erreicht ist (auch bei leeren Elementen!)
							<br />
							Die Übergabeparameter entsprechen denen des
							zugehörigen startElement-Aufrufs.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#processingInstruction(java.lang.String,%20java.lang.String)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#processingInstruction(java.lang.String,%20java.lang.String)">
									processingInstruction(String target,
									String data)
								</a>
							</code>
						</td>
						<td>
							Liefert die deklarierten
							Verarbeitungsanweisungen. Diese können vor
							und nach Eintritt des
							<code>startDocument</code>
							-Ereignisses auftreten. Der XML-Prolog wird
							hierbei nicht als Processing Instruction
							behandelt, entsprechend wird daher auch kein
							Ereignis dieses Typs ausgelöst.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startPrefixMapping(java.lang.String,%20java.lang.String)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startPrefixMapping(java.lang.String,%20java.lang.String)">
									startPrefixMapping(String prefix,
									String uri)
								</a>
							</code>
						</td>
						<td>
							Signalisiert den Beginn des
							Gültigkeitsbereits des Namensraumkürzels
							<code>prefix</code>
							.
							<code>uri</code>
							enthält die vollständige URI des gebundenen
							Namensraums. Ist
							<code>prefix</code>
							leer, so handelt es sich um die Redefinition
							des Vorgabenamensraums. Das Ereignis wird
							vor dem ersten Element des Namensraums (d.h.
							dem Element, das die Präfixbindung enthält
							oder den Vorgabenamensraum überschreibt)
							ausgelöst.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endPrefixMapping(java.lang.String)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endPrefixMapping(java.lang.String)">
									endPrefixMapping(String prefix)
								</a>
							</code>
						</td>
						<td>
							Signalisiert das Ende des
							Gültigkeitsbereichs des Namensraumkürzels
							<code>prefix</code>
							. Ist der Übergabeparameter leer, so bezieht
							sich das Ereignis auf den Vorgabenamensraum.
							Das Ereignis tritt nach dem
							<code>endElement</code>
							-Ereignis des letzten Elements im Namensraum
							ein.

						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#characters(char[],%20int,%20int)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#characters(char[],%20int,%20int)">
									characters(char[] ch, int start, int
									length)
								</a>
							</code>
						</td>
						<td>
							Aufruf bei der Verarbeitung von
							Zeichenkettendaten innerhalb eines Elements.
							<code>ch</code>
							enthält ab der Position
							<code>start</code>
							Zeichenketten-artige Daten der Länge
							<code>length</code>
							.
							<br />
							Hinweis: Manche Parser melden Leerzeichen
							innerhalb von Elementen mit Hilfe der
							Operation
							<code>ignorableWhitespace</code>
							. Validierenden Parsern ist dies sogar
							vorgeschrieben.
						</td>
					</tr>
					<tr>
						<td>
							<code>
								<a class="outlink" href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#ignorableWhitespace(char[],%20int,%20int)" title="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#ignorableWhitespace(char[],%20int,%20int)">
									ignorableWhitespace(char[] ch, int
									start, int length)
								</a>
							</code>
						</td>
						<td>
							Diese Operation wird aufgerufen, wenn der
							Parser ignorierbare Leerzeichen im Inhalt
							von Elementen liest.
							<br />
							Validierende Parser müssen hierbei diese
							Operation verwenden, nicht validierende
							Parser können sie verwenden.
						</td>
					</tr>
				</tbody>
			</table></div><div class="slide" id="d1e13227"><h1>Beispiel 3 - Eine kleine Dokumentstatistik</h1><ul><li>
					Erweitern wir unser Beispiel durch ein paar der
					vorgestellten Operationen, um eine kleine
					Dokumentstatistik zu erzeugen.
				</li><li>
					Zunächst werden in der Klasse
					<code>SAXExample3</code>
					einige Variablen deklariert und mit
					<code>0</code>
					vorinitialisiert.
				<a href="SAXExample3.java#line=7,15" title="SAXExample3.java (line 8-15)"><pre class="listing">public class SAXExample3 extends DefaultHandler {

 private int startDocument = 0,
    endDocument = 0,
    characters = 0,
    startElement = 0,
    endElement = 0,
    attributes = 0;</pre></a></li><li>
					In den jeweiligen Operationen (die den Eintritt
					eines Ereignisses widerspiegeln) werden dann die
					Werte dieser Variablen entsprechend inkrementiert.
					Beispiel:
					<code>startElement++;</code>
					in
					<code>startElement()</code>
					.
				<a href="SAXExample3.java#line=38,42" title="SAXExample3.java (line 39-42)"><pre class="listing">    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        startElement++;
        attributes += atts.getLength();
    } //startElement()</pre></a></li><li>
					Nach Abschluß des vollständigen Lesevorganges, d.h.
					Eintritt des Ereignisses
					<code>endDocument</code>
					, werden die aufsummierten Zahlen durch die Methode
					<code>printStatistics</code>
					auf der Standardausgabe dargestellt.
				<a href="SAXExample3.java#line=33,37" title="SAXExample3.java (line 34-37)"><pre class="listing">    public void endDocument() {
        endDocument++;
        printStatistics();
    } //endDocument()</pre></a></li></ul></div><div class="slide" id="d1e13269"><h1>Beispiel 3 - Analyse</h1><ul><li>
					Ein Aufruf des kompilierten Programms auf das erste
					XML-Dokument...
				<a href="SAXExample3.bat" title="SAXExample3.bat"><pre class="listing">java SAXExample3 erstes-XML-dokument.xml
</pre></a><a href="erstes-XML-dokument.xml" title="erstes-XML-dokument.xml"><pre class="listing">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;

&lt;Vorlesung&gt;
  &lt;Pflichtfach/&gt;
  &lt;Hochschule&gt;Fachhochschule Augsburg&lt;/Hochschule&gt;
  &lt;Studiengang semester="3"&gt;IAM&lt;/Studiengang&gt;
  &lt;Titel&gt;XML&lt;/Titel&gt;
  &lt;Semester&gt;WS 2008/2009&lt;/Semester&gt;
  Montag, 08:00h - 09:30h
  &lt;Praktikum&gt;Seminar&lt;/Praktikum&gt;
&lt;/Vorlesung&gt;
</pre></a></li><li>ergibt folgendes Ergebnis:<a href="SAXExample3.output" title="SAXExample3.output"><pre class="listing">Analyzing ...
# startDocument events:1
# endDocument events:1
# startElement events:7
# endElement events:7
# character events:12
# attributes:1

</pre></a></li><li>
					Erwähnenswert ist die Ausgabe für
					<code>character events</code>
					.
					<br />
					Warum ist das so?
				</li><li>
					Ändert man das Eingabedokument testweise
					folgendermaßen ab:
				<a href="erstes-xml-dokument-modified.xml" title="erstes-xml-dokument-modified.xml"><pre class="listing">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;Vorlesung&gt;
  &lt;Pflichtfach/&gt;
  &lt;Hochschule&gt;&lt;/Hochschule&gt;
  &lt;Studiengang semester="3"&gt;&lt;/Studiengang&gt;
  &lt;Titel&gt;&lt;/Titel&gt;
  &lt;Semester&gt;&lt;/Semester&gt;
  &lt;Praktikum&gt;&lt;/Praktikum&gt;
&lt;/Vorlesung&gt;</pre></a></li><li>
					So ergibt sich für die Aufrufe der Methode
					<code>characters</code>
					die Anzahl
					<code>7</code>
					. Der Parser meldet alle Zeilenumbrüche in
					Elementinhalt als Ereignis.
				<a href="SAXExample3-modified.output" title="SAXExample3-modified.output"><pre class="listing">Analyzing ...
# startDocument events:1
# endDocument events:1
# startElement events:7
# endElement events:7
# character events:7
# attributes:1

</pre></a></li></ul></div><div class="slide" id="d1e13312"><h1>Beispiel 3 - komplettes Listing</h1><ul><li>
					Im folgenden ist das gesamte Listing des Beispiels 3
					aufgeführt.
				<a href="SAXExample3.java" title="SAXExample3.java"><pre class="listing">import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.Attributes;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample3 extends DefaultHandler {

 private int startDocument = 0,
    endDocument = 0,
    characters = 0,
    startElement = 0,
    endElement = 0,
    attributes = 0;

    public void printStatistics() {
        System.out.println("# startDocument events:" + startDocument + "\n" +
                "# endDocument events:" + endDocument + "\n" +
                "# startElement events:" + startElement + "\n" +
                "# endElement events:" + endElement + "\n" +
                "# character events:" + characters + "\n" +
                "# attributes:" + attributes + "\n"
        );
    } //printStatistics()


    public void startDocument() {
        System.out.println("Analyzing ...");
        startDocument++;
    } //startDocument()


    public void endDocument() {
        endDocument++;
        printStatistics();
    } //endDocument()

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        startElement++;
        attributes += atts.getLength();
    } //startElement()

    public void endElement(String namespaceURI, String localName, String qName) {
        endElement++;
    } //endElement()

    public void characters(char[] ch, int start, int length) {
        characters++;
    } //characters()

    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
     SAXExample3 handler = new SAXExample3();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));

    } //main()

    public SAXExample3 ()
    {
     super();
    }

    
}//class SAXExample3</pre></a></li></ul></div><div class="slide" id="d1e13322"><h1>
				Beispiel 4 - Häufigkeitsermittlung einzelner
				Elementnamen
			</h1><ul><li>
					In diesem Codebeispiel wird zusätzlich das Paket
					<code>java.util.HashMap</code>
					eingebunden.
				<a href="SAXExample4.java#line=6,7" title="SAXExample4.java (line 7)"><pre class="listing">import java.util.HashMap;</pre></a></li><li>
					Zur Ermittlung der Anzahl der Elemente wird mit
					Hilfe der Java-Collection-API-Klasse
					<code>HashMap</code>
					eine Liste mit Tupeln aus Elementnamen und
					Auftretensanzahlen verwaltet. Eintragungen und
					Aktualisierungen dieser Liste erfolgen bei jedem
					<code>startElement</code>
					-Ereignis.
				<a href="SAXExample4.java#line=13,22" title="SAXExample4.java (line 14-22)"><pre class="listing">    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        Integer freq = (Integer) elementHM.get(qName);
        if (freq == null) {
         elementHM.put(qName, ONE);
        }
        else {
         elementHM.put(qName, new Integer (freq.intValue()+1 ));
        }
    } //startElement()</pre></a></li><li>
					Die Ausgabe der
					<code>HashMap</code>
					erfolgt in der Operation
					<code>endDocument()</code>
					.
				<a href="SAXExample4.java#line=23,26" title="SAXExample4.java (line 24-26)"><pre class="listing">    public void endDocument() {
        System.out.println(elementHM);
    } //endDocument()</pre></a></li><li>
					Ein Aufruf des Programms auf unser erstes XML
					Dokument ergibt folgendes Ergebnis:
				<a href="SAXExample4.output" title="SAXExample4.output"><pre class="listing">{Hochschule=1, Semester=1, Titel=1, Vorlesung=1, Praktikum=1, Studiengang=1, Pflichtfach=1}
</pre></a></li></ul></div><div class="slide" id="d1e13363"><h1>Beispiel 4 - komplettes Listing</h1><ul><li>
					Im folgenden ist das gesamte Listing des Beispiels 4
					aufgeführt.
				<a href="SAXExample4.java" title="SAXExample4.java"><pre class="listing">import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.Attributes;
import java.io.FileReader;
import org.xml.sax.InputSource;
import java.util.HashMap;

public class SAXExample4 extends DefaultHandler {
 
    private HashMap elementHM;
    private final Integer ONE = new Integer(1);

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        Integer freq = (Integer) elementHM.get(qName);
        if (freq == null) {
         elementHM.put(qName, ONE);
        }
        else {
         elementHM.put(qName, new Integer (freq.intValue()+1 ));
        }
    } //startElement()

    public void endDocument() {
        System.out.println(elementHM);
    } //endDocument()

    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
     SAXExample4 handler = new SAXExample4();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));
    } //main()

    public SAXExample4() {
     super();
        elementHM = new HashMap();
    } //constructor
}//class SAXExample4</pre></a></li></ul></div><div class="slide" id="d1e13373"><h1>
				SAX - Probleme des Xerces-Parsers mit der Byte Order
				Mark (1/3)
			</h1><ul><li>Angewendet auf das untenstehendes Dokument...<a href="namespace15.xml" title="namespace15.xml"><pre class="listing">&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;document&gt;
 &lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;g transform="translate(100,100)"&gt;
   &lt;text id="TextElement" x="0" y="0" style="font-family:Verdana; font-size:35.27; visibility:hidden"&gt;
   It's alive!
    &lt;set attributeName="visibility" attributeType="CSS" to="visible" begin="3s" dur="6s" fill="freeze"/&gt;
   &lt;/text&gt;
  &lt;/g&gt;
 &lt;/svg&gt;
 
 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;
  &lt;set&gt;
     &lt;ci&gt; b &lt;/ci&gt;
     &lt;ci&gt; a &lt;/ci&gt;
     &lt;ci&gt; c &lt;/ci&gt;
  &lt;/set&gt;
 &lt;/math&gt;
&lt;/document&gt;</pre></a></li><li>
					... stürzt das Programm ab! Wir erhalten folgende
					Fehlermeldung:
				<a href="SAXExample4-ns.output" title="SAXExample4-ns.output"><pre class="listing">Exception in thread "main" org.xml.sax.SAXParseException: Content is not allowed in prolog.
 at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(Unknown Source)
 at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLScanner.reportFatalError(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(Unknown Source)
 at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)
 at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source)
 at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(Unknown Source)
 at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(Unknown Source)
 at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(Unknown Source)
 at SAXExample4.main(SAXExample4.java:35)
</pre></a></li><li>
					Die Fehlermeldung
					<code>Content is not allowed in prolog.</code>
					deutet auf ein Problem bei der Verarbeitung des
					XML-Prologes hin.
				</li></ul></div><div class="slide" id="d1e13394"><h1>
				SAX - Probleme des Xerces-Parsers mit der Byte Order
				Mark (2/3)
			</h1><ul><li>
					Lädt man die betreffende Datei in einen XML-Editor,
					so sieht sie völlig normal aus.
				</li><li>
					Bedient man sich jedoch eines Kommandozeilenviewers,
					wie beispielsweise des auf UNIX-Systemen vorhandenen
					Pagers
					<code>less</code>
					, so erkennt man, daß vor dem Prolog noch Zeichen
					stehen.
				<a class="img" href="../pics/xerces-exception.jpg" title="View Image"><img style="margin : 4% ; width : 90% ; " src="../pics/xerces-exception.jpg" /></a></li></ul></div><div class="slide" id="d1e13410"><h1>Die Unicode Byte Order Mark</h1><ul><li>
					Es handelt sich hierbei um die sogenannte
					<code>Byte Order Mark</code>
					. Dies sind Zeichen, die in Unicode-codierten
					Dateien an den Anfang der Datei gestellt werden
					können. Die Byte Order Mark gibt an, welche
					Codierung bei der Datei vorliegt (z.B. UTF-16) und
					in welcher Byte-Reihenfolge (Little-Endian,
					Big-Endian) die Datei gespeichert ist.
				</li><li>
					Der
					<a class="outlink" href="http://www.unicode.org/versions/Unicode5.0.0/ch16.pdf#G25817" title="http://www.unicode.org/versions/Unicode5.0.0/ch16.pdf#G25817">
						Unicode Standard, Kapitel 16
					</a>
					listet in Tabelle 16-4 folgende Byte Order
					Mark-Werte für die verschiedenen Codierungen auf:
				<table border="1">
					<thead>
						<tr>
							<th>Codierungsschema</th>
							<th>Signatur</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>UTF-8</td>
							<td>EF BB BF</td>
						</tr>
						<tr>
							<td>UTF-16 Big-endian</td>
							<td>FE FF</td>
						</tr>
						<tr>
							<td>UTF-16 Little-endian</td>
							<td>FF FE</td>
						</tr>
						<tr>
							<td>UTF-32 Big-endian</td>
							<td>00 00 FE FF</td>
						</tr>
						<tr>
							<td>UTF-32 Little-endian</td>
							<td>FF FE 00 00</td>
						</tr>
					</tbody>
				</table></li></ul></div><div class="slide" id="d1e13490"><h1>
				SAX - Probleme des Xerces-Parsers mit der Byte Order
				Mark (3/3) - Lösung
			</h1><ul><li>
					Abhilfe schafft das Entfernen der Byte Order Mark
					aus der betreffenden Datei. Dies können Sie mit
					Hilfe eines Unicode Editors, z.B.
					<a class="outlink" href="http://www.unipad.org/main/" title="http://www.unipad.org/main/">SC Unipad</a>
					, bewerkstelligen.
				</li><li>
					Ist die Byte Order Mark aus der Datei entfernt, so
					verschwindet die Fehlermeldung des Parsers, das
					Dokument ...
				<a href="namespace15-noBOM.xml" title="namespace15-noBOM.xml"><pre class="listing">&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;document&gt;
 &lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;g transform="translate(100,100)"&gt;
   &lt;text id="TextElement" x="0" y="0" style="font-family:Verdana; font-size:35.27; visibility:hidden"&gt;
   It's alive!
    &lt;set attributeName="visibility" attributeType="CSS" to="visible" begin="3s" dur="6s" fill="freeze"/&gt;
   &lt;/text&gt;
  &lt;/g&gt;
 &lt;/svg&gt;
 
 &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;
  &lt;set&gt;
     &lt;ci&gt; b &lt;/ci&gt;
     &lt;ci&gt; a &lt;/ci&gt;
     &lt;ci&gt; c &lt;/ci&gt;
  &lt;/set&gt;
 &lt;/math&gt;
&lt;/document&gt;</pre></a></li><li>
					...kann verarbeitet werden und liefert folgende
					Ausgabe:
				<a href="SAXExample4-ns-korrekt.output" title="SAXExample4-ns-korrekt.output"><pre class="listing">{math=1, g=1, text=1, document=1, svg=1, set=2, ci=3}
</pre></a></li><li>
					Offensichtlich ignoriert der verwendete SAX-Parser
					in der Standardkonfiguration die deklarierten
					Namensräume.
				</li></ul></div><div class="slide" id="d1e13515"><h1>Namensraum-konformer SAX-Parser</h1><ul><li>
					Zunächst müssen wir feststellen, ob der verwendete
					Parser in der Lage ist, Namensraumpräfixe zu
					erkennen und Namensräume als URIs zurückzugeben.
				</li><li>
					Hierfür ist es nötig, den Parser nach seiner
					derzeitigen Unterstützung der beiden
					<em>Features</em>
					<code>namespaces</code>
					und
					<code>namespace-prefixes</code>
					abzufragen.
				<a href="IsParserNSAware.java#line=16,41" title="IsParserNSAware.java (line 17-41)"><pre class="listing">     try {
        String id = "http://xml.org/sax/features/namespaces";
        if (xr.getFeature(id)) {
          System.out.println("Parser supports namespaces.");
        } else {
          System.out.println("Parser does not support namespaces.");
        }
      } catch (SAXNotRecognizedException e) {
        System.out.println("Feature not recognized");
      } catch (SAXNotSupportedException e) {
        System.out.println("Can't set feature currently.");
      }

         try {
          String id = "http://xml.org/sax/features/namespace-prefixes";
          if (xr.getFeature(id)) {
            System.out.println("Parser supports qualified names for elements and attributes.");
          } else {
            System.out.println("Parser does not support qualified names for elements and attributes.");
          }
        } catch (SAXNotRecognizedException e) {
          System.out.println("Feature not recognized");
        } catch (SAXNotSupportedException e) {
          System.out.println("Can't set feature currently.");
        }</pre></a></li><li>Die Abfrage kann folgendes Ergebnis bringen:<a href="IsParserNSAware.output" title="IsParserNSAware.output"><pre class="listing">Parser supports namespaces.
Parser does not support qualified names for elements and attributes.
</pre></a></li><li>
					In diesem Fall kann versucht werden, den Wert mit
					Hilfe der Methode
					<code>setFeature</code>
					auf
					<code>true</code>
					zu setzen und somit die Unterstützung für
					Namensraum-Präfixe zu erhalten.
				<a href="setParserNSAware.java#line=29,47" title="setParserNSAware.java (line 30-47)"><pre class="listing">         try {
          String id = "http://xml.org/sax/features/namespace-prefixes";
          if (xr.getFeature(id)) {
            System.out.println("Parser supports qualified names for elements and attributes.");
          } else {
            System.out.println("Parser does not support qualified names for elements and attributes.\nSetting...");
            xr.setFeature(id, true);
            if (xr.getFeature(id)){
             System.out.println("Parser set to support qNames now.");
            } else {
             System.out.println("Failed to configure parser.");
            }
          }
        } catch (SAXNotRecognizedException e) {
          System.out.println("Feature not recognized");
        } catch (SAXNotSupportedException e) {
          System.out.println("Can't set feature currently.");
        }</pre></a></li><li>Die Ausgabe des Programms:<a href="setParserNSAware.output" title="setParserNSAware.output"><pre class="listing">Parser supports namespaces.
Parser does not support qualified names for elements and attributes.
Setting...
Parser set to support qNames now.
</pre></a></li></ul></div><div class="slide" id="d1e13559"><h1>
				Beispiel 5 - Elemente zählen mit Namensraumunterstützung
			</h1><ul><li>
					Im nachfolgenden Beispiel soll der Code zum Zählen
					der Elemente so modifiziert werden, daß die Elemente
					korrekt gezählt werden.
				</li><li>
					Zunächst wird der Parser so konfiguriert, daß er
					Namensräume unterstützt.
				</li><li>
					Darüber hinaus wird die Routine zur Zählung der
					Elementauftritte entsprechend angepaßt.
				<a href="SAXExample5.java#line=13,25" title="SAXExample5.java (line 14-25)"><pre class="listing">    private HashMap elementHM;
    private final Integer ONE = new Integer(1);

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {

     String elementFullName = new String(namespaceURI + ":" + localName);

     Integer freq = (Integer) elementHM.get(elementFullName);
        if (freq == null) {
         elementHM.put(elementFullName, ONE);
        }
        else {</pre></a></li><li>
					Angewendet auf das
					<a class="outlink" href="namespace15-noBOM.xml" title="namespace15-noBOM.xml">
						Beispiel-Dokument
					</a>
					liefert es nun das erwartete korrekte Ergebnis:
				<a href="SAXExample5.output" title="SAXExample5.output"><pre class="listing">Parser does not support namespace-prefixes.
Setting...
Parser set to support namespace-prefixes now.
{http://www.w3.org/1998/Math/MathML:set=1, 
http://www.w3.org/2000/svg:text=1, 
:document=1, 
http://www.w3.org/1998/Math/MathML:math=1, 
http://www.w3.org/1998/Math/MathML:ci=3, 
http://www.w3.org/2000/svg:svg=1, 
http://www.w3.org/2000/svg:set=1, 
http://www.w3.org/2000/svg:g=1}
</pre></a></li><li>
					Konsequenterweise wird dem Wurzelelement
					<code>document</code>
					, für das kein Namensraum definiert ist (es befindet
					sich daher spezifikationsgemäß im NULL-Namensraum),
					die leere Namensraum-URI vorangestellt.
				</li><li>
					Hinweis: Bei der Ausgabenotation handelt es sich um
					keine syntaktisch korrekte Elementdeklaration, sie
					dient lediglich der Veranschaulichung!
				</li></ul></div><div class="slide" id="d1e13593"><h1>SAX Features</h1><ul><li>
					Neben der eben verwendeten Eigenschaften
					<code>namespaces</code>
					und
					<code>namespace-prefixes</code>
					definiert die SAX2-Schnittstelle noch weitere
					Features.
					<br />
					Untenstehende Tabelle gibt eine Übersicht.
				<table border="1">
					<thead>
						<tr>
							<th>Feature-URI</th>
							<th>Funktionalität</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<code>external-general-entities</code>
							</td>
							<td>
								Zeigt an/Steuert, ob der Parser externe
								Textentitäten verarbeitet. Bei
								validierenden Parsern ist diese
								Eigenschaft immer
								<code>true</code>
								.
							</td>
						</tr>
						<tr>
							<td>
								<code>external-parameter-entities</code>
							</td>
							<td>
								Zeigt an/Steuert, ob der Parser externe
								Parameterentitäten verarbeitet. Bei
								validierenden Parsern ist diese
								Eigenschaft immer
								<code>true</code>
								.
							</td>
						</tr>
						<tr>
							<td>
								<code>is-standalone</code>
							</td>
							<td>
								Diese Eigenschaft kann nur abgefragt
								werden, während der Parser gerade ein
								Dokument einliest (nachdem die Methode
								<code>startDocument()</code>
								abgearbeitet wurde). Der Wert der
								Eigneschaft ist
								<code>true</code>
								, wenn im Prolog des Dokumentes
								<code>standalone="yes"</code>
								spezifiziert wurde, andernfalls
								<code>false</code>
								.
							</td>
						</tr>
						<tr>
							<td>
								<code>
									lexical-handler/parameter-entities
								</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, daß der LexicalHandler (eine
								optionale Erweiterung von SAX, die etwa
								Informationen über die Grenzen von
								lexikalischen Bereichen, wie z.B.
								Kommentarbereichen liefert) den Start
								und das Ende von Parameterentitäten
								anzeigt.
							</td>
						</tr>
						<tr>
							<td>
								<code>namespaces</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, daß Namensraum-URIs und lokale
								Namen für Elemente und Attribute
								abfragbar sind.
							</td>
						</tr>
						<tr>
							<td>
								<code>namespace-prefixes</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, daß qualifizierte Namen und
								Namensraumattribute abfragbar sind.
							</td>
						</tr>
						<tr>
							<td>
								<code>resolve-dtd-uris</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, daß System-IDs in
								Deklarationen als absolute URIs (im
								Gegensatz zu relativen URIs)
								zurückgeliefert werden.
								<code>false</code>
								bedeutet, daß die URIs als relative URIs
								zurückgegeben werden. Zugriff auf die
								Basis-URI ist dann über
								<code>Locator.getSystemId()</code>
								möglich.
							</td>
						</tr>
						<tr>
							<td>
								<code>string-interning</code>
							</td>
							<td>
								<code>true</code>
								bedeutet, daß alle XML-Namen (für
								Elemente, Attribute, Präfixe, Entities,
								Notations) mit Hilfe von
								<code>java.lang.String.intern</code>
								als kanonische Repräsentation vorliegen
								und damit eindeutig sind. Vorteil:
								Schnelles Testen auf Gleichheit mit
								Stringkonstanten (schneller als ein
								Aufruf von
								<code>String.equals()</code>
								).
							</td>
						</tr>
						<tr>
							<td>
								<code>
									unicode-normalization-checking
								</code>
							</td>
							<td>
								Steuert, ob der Parser Fehler meldet,
								die bei der Unicode Normalisierung
								entstehen (siehe
								<a class="outlink" href="http://www.w3.org/TR/xml11/#sec-normalization-checking" title="http://www.w3.org/TR/xml11/#sec-normalization-checking">
									XML 1.1 Spezifikation, Abschnitt
									2.13
								</a>
								).
								<br />
								Derartige Fehler stellen keine
								schwerwiegenden Fehler bei der
								Verarbeitung dar. Ein Dokument bleibt
								wohlgeformt, auch wenn die betreffenden
								Konstrukte nicht vollständig
								normalisiert wurden.
							</td>
						</tr>
						<tr>
							<td>
								<code>use-attributes2</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, ob die Attributobjekte, die
								dieser Parser in der Operation
								<code>startElement()</code>
								übergibt, der Schnittstellen
								<code>org.xml.sax.ext.Attributes2</code>
								entsprechen. Diese Schnittstelle erlaubt
								weitergehende Information, wie etwa, ob
								der Attributwert im Dokument angegeben
								wurde oder ob der Defaultwert, der in
								der DTD spezifiziert war, angenommen
								wurde.
							</td>
						</tr>
						<tr>
							<td>
								<code>use-locator2</code>
							</td>
							<td>
								<code>true</code>
								bedeutet, daß die
								<code>Locator</code>
								objekte, die der Parser in der Methode
								<code>setDocumentLocator()</code>
								übergibt, die Schnittstelle
								<code>org.xml.sax.ext.Locator2</code>
								unterstützt. Diese Schnittstelle
								unterstützt weitergehende Information
								über das Dokument, wie etwa die
								Zeichenkodierung sowie die verwendete
								XML-Version.
							</td>
						</tr>
						<tr>
							<td>
								<code>use-entity-resolver2</code>
							</td>
							<td>
								<code>true</code>
								zeigt an, wenn der Entity Resolver die
								Schnittstelle
								<code>
									org.xml.sax.ext.EntityResolver2
								</code>
								unterstützt. In diesem Fall werden die
								dort definierten (neuen) Methoden
								verwendet.
							</td>
						</tr>
						<tr>
							<td>
								<code>validation</code>
							</td>
							<td>
								Steuert, ob ein validierender Parser
								verwendet wird, der alle
								Validierungsfehler meldet. Wenn ja (
								<code>true</code>
								), werden alle externen Entitäten
								gelesen.
							</td>
						</tr>
						<tr>
							<td>
								<code>xmlns-uris</code>
							</td>
							<td>
								Steuert, ob der Parser Attribute mit
								Namensraumdeklarationen so behandelt,
								daß sie sich im Namensraum
								<code>
									http://www.w3.org/2000/xmlns/
								</code>
								befinden. Ursprünglich befinden sich
								diese Attribute explizit in keinem
								Namensraum (siehe
								<a class="outlink" href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#ns-using" title="http://www.w3.org/TR/1999/REC-xml-names-19990114/#ns-using">
									Namespaces in XML
								</a>
								). Eine spätere Ausgabe der
								Spezifikation (siehe
								<a class="outlink" href="http://www.w3.org/TR/2006/REC-xml-names-20060816/#ns-decl" title="http://www.w3.org/TR/2006/REC-xml-names-20060816/#ns-decl">
									Namespaces in XML 1.0 (Second
									Edition)
								</a>
								oder
								<a class="outlink" href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#ns-decl" title="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#ns-decl">
									Namespaces in XML 1.1 (Second
									Edition)
								</a>
								definiert für diese Attribute jedoch den
								oben angegebenen Namensraum.
							</td>
						</tr>
						<tr>
							<td>
								<code>xml-1.1</code>
							</td>
							<td>
								Wenn der Parser sowohl XML 1.0 als auch
								XML 1.1 unterstützt, so besitzt diese
								Eigenschaft den Wert
								<code>true</code>
								.
							</td>
						</tr>
					</tbody>
				</table></li></ul></div><div class="slide" id="d1e13904"><h1>Fehlerbehandlung</h1><ul><li>
					Während der Arbeit mit der SAX-Schnittstelle können
					innerhalb zweier getrennter Operationsphasen
					Fehlersituationen auftreten.
				<ul><li>
						während der Konstruktionsphase des SAX-basierten
						Parsers, d.h. vor Aufruf der Methode
						<code>parse</code>
					</li><li>
						während des eigentlichen Parsingvorganges beim
						Einlesen des Dokuments
					</li></ul></li><li>
					Die Schnittstelle bietet die drei von
					<code>SAXException</code>
					abgeleiteten Ausnahmeereignisklassen an
				<ul><li>
						<a class="outlink" href="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotRecognizedException.html" title="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotRecognizedException.html">
							SAXNotRecognizedException
						</a>
					</li><li>
						<a class="outlink" href="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotSupportedException.html" title="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotSupportedException.html">
							SAXNotSupportedException
						</a>
					</li><li>
						<a class="outlink" href="http://www.saxproject.org/apidoc/org/xml/sax/SAXParseException.html" title="http://www.saxproject.org/apidoc/org/xml/sax/SAXParseException.html">
							SAXParseException
						</a>
					</li></ul></li></ul></div><div class="slide" id="d1e13952"><h1>Fehlerbehandlung - SAXNotRecognizedException</h1><ul><li>
					Fehler während der Parserkonstruktions- und
					Initialisierungsperiode rühren, abgesehen von
					externen Effekten, zumeist vom Versuch her, einen
					Parser in unzulässiger Weise zu parametrisieren.
				</li><li>So führt etwa der Aufruf von folgendem Code..<a href="SAXExample6.java" title="SAXExample6.java"><pre class="listing">import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample6 extends DefaultHandler {
    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
        SAXExample6 handler = new SAXExample6();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

        try {
            System.out.println(xr.getProperty("http://www.barbara-zengler.de/"));
        } //try
        catch (SAXException e) {
            System.out.println("SAXException:" + e);
        } //catch()
     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));
    } //main()
}//class SAXExample6</pre></a></li><li>... zu folgender Fehlermeldung:<a href="SAXExample6.output" title="SAXExample6.output"><pre class="listing">SAXException:org.xml.sax.SAXNotRecognizedException: Property 'http://www.barbara-zengler.de/' is not recognized.
{http://www.w3.org/1998/Math/MathML:set=1, http://www.w3.org/2000/svg:text=1, :document=1, http://www.w3.org/1998/Math/MathML:math=1, http://www.w3.org/1998/Math/MathML:ci=3, http://www.w3.org/2000/svg:svg=1, http://www.w3.org/2000/svg:set=1, http://www.w3.org/2000/svg:g=1}
</pre></a></li></ul></div><div class="slide" id="d1e13970"><h1>Fehlerbehandlung - SAXParseException</h1><ul><li>
					Tritt während des Parsingvorganges ein Verstoß
					hinsichtlich der well-formedness Regeln auf, so wird
					ein
					<code>SAXParseException</code>
					-Ausnahmeereignis erzeugt. Es stellt Methoden zur
					näheren Lokalisierung der Fehlerstelle im
					Eingabedokument zur Verfügung.
				</li><li>
					Im folgenden Beispiel wird dies umgesetzt: Mittels
					der Methoden
					<code>getColumnNumber</code>
					und
					<code>getLineNumber</code>
					lassen sich Spalten- und Zeilennummer des Fehlers
					ermitteln.
					<code>getSystemId</code>
					und
					<code>getPublicId</code>
					können zur Ausgabe des System-Identifiers, der bei
					lokaler Referenzierung identisch zum Dateisystempfad
					ist, bzw. zur Ausgabe des Public-Identifiers --
					falls gesetzt -- herangezogen werden.
				<a href="SAXExample7.java" title="SAXExample7.java"><pre class="listing">import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample7 extends DefaultHandler {
    public static void main(String args[]) throws Exception {
     XMLReader xr = XMLReaderFactory.createXMLReader();
        SAXExample7 handler = new SAXExample7();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);

        try {
         FileReader r = new FileReader(args[0]);
         xr.parse(new InputSource(r));
        } //try
        catch (SAXParseException spe) {
            System.out.println("A SAXParseException occured ...\n" +
                    "at column " + spe.getColumnNumber() + "\n" +
                    "at line " + spe.getLineNumber() + "\n" +
                    "public identifier of document is: " + spe.getPublicId() + "\n" +
                    "system identifier of document is: " + spe.getSystemId());
        } //catch()
    } //main()
}//class SAXExample7</pre></a></li><li>Angewendet auf folgendes XML-Dokument...<a href="NotWellFormed-noBOM.xml" title="NotWellFormed-noBOM.xml"><pre class="listing">&lt;?xml version="1.0"?&gt;
&lt;root&gt;
 &lt;elementA att=a oder b&gt;
  &lt;elementB&gt; if a&lt;b ==&gt; c
 &lt;/elementA&gt;
 &lt;elementC att1="42" att1="3.14"&gt;
  &lt;elementD &lt;?do-something?&gt; &gt;
 &lt;/elementC&gt;
  &lt;/elementD&gt;

 &lt;!---- dies ist nicht erlaubt ----&gt;
&lt;/root&gt;</pre></a></li><li>... ergibt sich folgende Ausgabe:<a href="SAXExample7.output" title="SAXExample7.output"><pre class="listing">A SAXParseException occured ...
at column 16
at line 3
public identifier of document is: null
system identifier of document is: null
</pre></a></li></ul></div><div class="slide" id="d1e14009"><h1>Fehlerbehandlung - SAXNotSupportedException</h1><ul><li>
					Das Auftreten einer
					<code>SAXNotSupportedException</code>
					wird durch den Versuch ausgelöst, eine zulässige und
					erkannte Parameterisierung des SAX-Parsers
					vorzunehmen, die durch diesen nicht unterstützt
					wird.
				</li><li>
					Diese Fehlersituation läßt sich daher an keinem
					statischen Beispiel zeigen, sondern hängt von der
					konkreten Parser-Implementierung ab.
				</li></ul></div><div class="slide" id="d1e14023"><h1>Abschließendes Beispiel</h1><ul><li>
					Das folgende Abschlußbeispiel zeigt eine
					vollständige Implementierung der verschiedenen
					SAX-Ereignisse der
					<code>ContentHandler</code>
					-Schnittstelle.
				<a href="SAXExample8.java" title="SAXExample8.java"><pre class="listing">import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.Attributes;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;
import org.xml.sax.SAXParseException;

public class SAXExample8 extends DefaultHandler {
 public void startDocument()  {
  System.out.println("EVENT: startDocument");
 } //startDocument()

 public void endDocument()  {
  System.out.println("EVENT: endDocument");
 } //endDocument()

 public void startPrefixMapping(String prefix, String uri)    {
    System.out.println("EVENT: startPrefixMapping");
    System.out.println("prefix="+prefix);
    System.out.println("namespaceURI="+uri);
   } //startPrefixMapping()

   public void endPrefixMapping(String prefix)    {
    System.out.println("EVENT: endPrefixMapping");
    System.out.println("prefix="+prefix);
   } //endPrefixMapping()

   public void processingInstruction(String target, String data)    {
    System.out.println("EVENT: processingInstruction");
    System.out.println("target="+target);
    System.out.println("data="+data);
   } //processingInstruction()

 public void ignorableWhitespace(char[] ch, int start, int length)  {
  System.out.println("EVENT: ignorableWhitespace");
  for (int i=start; i&lt;start+length; i++)
   System.out.print(ch[i]);
  System.out.print("\n");
 } //ignorableWhietespace()

 public void startElement(String namespaceURI, String localName, String qName, Attributes atts)  {
  System.out.println("EVENT: startElement");
  System.out.println("namespaceURI="+namespaceURI);
  System.out.println("localName="+localName);
  System.out.println("qName="+qName);

  for (int i=0; i&lt;atts.getLength(); i++)   {
   System.out.println("attribute:");
   System.out.println("localName="+atts.getLocalName(i));
   System.out.println("qName="+atts.getQName(i));
   System.out.println("type="+atts.getType(i));
   System.out.println("namespaceURI="+atts.getURI(i));
   System.out.println("value="+atts.getValue(i));
  } //for
 } //startElement()

 public void endElement(String namespaceURI, String localName, String qName)  {
  System.out.println("EVENT: endElement");
  System.out.println("namespaceURI="+namespaceURI);
  System.out.println("localName="+localName);
  System.out.println("qName="+qName);
 } //endElement()

 public void characters(char[] ch, int start, int length)  {
  System.out.println("EVENT: characters");
  for (int i=start; i&lt;start+length; i++)
   System.out.print(ch[i]);
  System.out.print("\n");
 } //characters()

   public static void main (String args[]) throws Exception  {
    XMLReader xr = XMLReaderFactory.createXMLReader();
    SAXExample8 handler = new SAXExample8();
 xr.setContentHandler(handler);
 xr.setErrorHandler(handler);
 // set parser namespace-aware
    xr.setFeature("http://xml.org/sax/features/namespaces", true);    
    xr.setFeature("http://xml.org/sax/features/namespace-prefixes", true);
 FileReader r = new FileReader(args[0]);

  try   {
   xr.parse(new InputSource(r));
  } catch (SAXParseException spe) {
         System.out.println("A SAXParseException occured ...\n"+
                            "at column "+spe.getColumnNumber()+"\n"+
                            "at line "+spe.getLineNumber()+"\n"+
                            "public identifier of document is: "+spe.getPublicId()+"\n"+
                            "system identifier of document is: "+spe.getSystemId());
      } //catch()
 } //main(args[])
}//class SAXExample8</pre></a></li><li>Angewendet auf folgendes Eingabedokument...<a href="SAXExample8-input.xml" title="SAXExample8-input.xml"><pre class="listing">&lt;?xml version="1.0"?&gt;
&lt;?myPI this is a test?&gt;
   &lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg"&gt;
   &lt;head&gt;
      &lt;title&gt;Testpage&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;p&gt;This is a &lt;a href="http://www.jeckle.de"&gt;link&lt;/a&gt;
      &lt;svg:svg width="4cm" height="8cm"&gt;
         &lt;svg:ellipse cx="2cm" cy="4cm" rx="2cm" ry="1cm"/&gt;
      &lt;/svg:svg&gt;      
      &lt;/p&gt;
   &lt;/body&gt;
&lt;/html&gt;</pre></a></li><li>... ergibt sich folgende Ausgabe:<a href="" title=""><pre class="listing">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xslidy counter-separator=":&amp;#160;" ?&gt;
&lt;?xslidy counter-format="full" ?&gt;
&lt;?xslidy extension-file="html" ?&gt;
&lt;?xslidy extension-link="" ?&gt;
&lt;?xslidy img-path="../pics" ?&gt;
&lt;?xslidy link-author="http://www.barbara-zengler.de/" ?&gt;
&lt;?xslidy link-contents="./" ?&gt;
&lt;?xslidy link-glossary="http://dret.net/glossary/" ?&gt;
&lt;?xslidy link-home="./" ?&gt;
&lt;?xslidy listing-class="listing" ?&gt;
&lt;?xslidy listing-path="." ?&gt;
&lt;?xslidy outline-class="outline" ?&gt;
&lt;?xslidy outline-title="Inhalt" ?&gt;
&lt;?xslidy outlink-mark="a" ?&gt;
&lt;?xslidy outlink-style="class(outlink)" ?&gt;
&lt;?xslidy part-slide-count="all" ?&gt;
&lt;?xslidy part-slide-text=" [*]" ?&gt;
&lt;?xslidy slidy-prefix="slidy" ?&gt;
&lt;?xslidy style-uri="../css/xslidy-fha.css" ?&gt;
&lt;?xslidy xslidy-prefix="xslidy" ?&gt;
&lt;xslidy
 xmlns="http://dret.net/xmlns/xslidy/1"
 xmlns:xslidy="http://dret.net/xmlns/xslidy/1"&gt;
 &lt;title short="XML"&gt;
  &lt;a href="./"&gt;XML (i3.DATA)&lt;/a&gt;
 &lt;/title&gt;
 &lt;author short="B. Zengler"&gt;
  &lt;a
   href="http://www.barbara-zengler.de/"
   title="Homepage of B. Zengler"&gt;
   Barbara Zengler
  &lt;/a&gt;
 &lt;/author&gt;
 &lt;affiliation short="HSA"&gt;
  &lt;a
   href="http://www.hs-augsburg.de/"
   title="Fachhochschule Augsburg"&gt;
   Fachhochschule Augsburg
  &lt;/a&gt;
  ,
  &lt;a
   href="http://www.hs-augsburg.de/hochschule/fakultaet/informatik/index.html"
   title="Fakultät für Informatik"&gt;
   Fakultät für Informatik
  &lt;/a&gt;
  ,
  &lt;a
   href="http://www.hs-augsburg.de/hochschule/fakultaet/informatik/studium/studiengang/interaktive_medien_bachelor/index.html"
   title="Interaktive Medien"&gt;
   Studiengang Interaktive Medien
  &lt;/a&gt;
 &lt;/affiliation&gt;
 &lt;copyright&gt;2008, Barbara Zengler&lt;/copyright&gt;
 &lt;layout&gt;
  &lt;slide
   class="cover"
   cover="slidycover"&gt;
   &lt;h1&gt;
    &lt;title /&gt;
   &lt;/h1&gt;
   &lt;h3&gt;
    &lt;title level="xslidy" /&gt;
   &lt;/h3&gt;
   &lt;h5&gt;
    &lt;author /&gt;
    &lt;br /&gt;
    &lt;affiliation /&gt;
    &lt;br /&gt;
    Wintersemester 2008/2009
   &lt;/h5&gt;
   &lt;a
    rel="license"
    title="view full text of license"
    href="http://creativecommons.org/licenses/by-nc-sa/2.5/"
    class="bottom-align"
    style="margin-bottom : 2%"&gt;
    &lt;table&gt;
     &lt;tr&gt;
      &lt;td align="left"&gt;
       &lt;img
        alt="Creative Commons License"
        border="0"
        src="../pics/somerights20.png"
        height="31"
        width="88" /&gt;
      &lt;/td&gt;
      &lt;td
       style="font-size : small ; line-height : 120%;"
       valign="middle"
       align="left"&gt;
       &lt;p&gt;
        This work is licensed under a Creative
        Commons
        &lt;br /&gt;
        Attribution-NonCommercial-ShareAlike 2.5
        License.
       &lt;/p&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/a&gt;
  &lt;/slide&gt;
  &lt;class /&gt;
 &lt;/layout&gt;
 &lt;style
  type="text/css"
  src="css/xslidy-fha.css" /&gt;
 &lt;index name="index.html"&gt;
  &lt;category
   element="xml"
   class="xml" /&gt;
  &lt;category
   element="elem"
   class="xml elem" /&gt;
  &lt;category
   element="cssp"
   class="css" /&gt;
  &lt;category
   element="csss"
   class="css" /&gt;
  &lt;category
   element="css"
   class="css" /&gt;
  &lt;category
   element="xpathf"
   class="xpath" /&gt;
  &lt;category
   element="xpath"
   class="xpath" /&gt;
  &lt;category
   element="xslte"
   class="xslt elem" /&gt;
  &lt;category
   element="xslta"
   class="xslt" /&gt;
  &lt;category
   element="xslt"
   class="xslt" /&gt;
  &lt;category
   element="xq"
   class="xq" /&gt;
  &lt;category
   element="xsde"
   class="xsd elem" /&gt;
  &lt;category
   element="xsda"
   class="xsd" /&gt;
  &lt;category
   element="xsd"
   class="xsd" /&gt;
 &lt;/index&gt;
 &lt;toc
  id="html-toc"
  name="toc.html"&gt;
  &lt;table
   rules="all"
   cellspacing="0"
   cellpadding="5"
   width="100%"&gt;
   &lt;thead&gt;
    &lt;tr&gt;
     &lt;th&gt;Date&lt;/th&gt;
     &lt;th&gt;Subject&lt;/th&gt;
     &lt;th&gt;Slides&lt;/th&gt;
     &lt;th&gt;Resources&lt;/th&gt;
    &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
    &lt;xslidy:for-each-presentation&gt;
     &lt;tr&gt;
      &lt;td
       align="right"
       valign="top"&gt;
       &lt;xslidy:date /&gt;
      &lt;/td&gt;
      &lt;td valign="top"&gt;
       &lt;b&gt;
        &lt;xslidy:title /&gt;
        &lt;span class="toggle"&gt;:&lt;/span&gt;
       &lt;/b&gt;
       &lt;span class="toggle"&gt;
        &lt;span class="abstract"&gt;
         &lt;xslidy:toc id="abstract" /&gt;
        &lt;/span&gt;
       &lt;/span&gt;
      &lt;/td&gt;
      &lt;td align="center"&gt;
       &lt;xslidy:presentation-link
        title="Lecture Slides"&gt;
        &lt;xslidy:title form="short" /&gt;
       &lt;/xslidy:presentation-link&gt;
       &lt;xslidy:slides&gt;(* Slides)&lt;/xslidy:slides&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;xslidy:toc id="resources" /&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/xslidy:for-each-presentation&gt;
   &lt;/tbody&gt;
  &lt;/table&gt;
 &lt;/toc&gt;
 &lt;!--  &lt;presentation id="uebungsaufgaben"&gt;
  &lt;title short="uebungsaufgaben"&gt;Übungsaufgaben&lt;/title&gt;
  &lt;date&gt;2007-12-02&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
  Hier finden Sie eine Zusammenstellung der Übungsaufgaben.
  &lt;/toc&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zur Wohlgeformtheit&lt;/title&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgabe zur Wohlgeformtheit&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;Übungsaufgabe zur Wohlgeformtheit&lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Das untenstehende XML-Dokument ist nicht
  wohlgeformt. Wandeln Sie es in ein
  wohlgeformtes XML-Dokument um.
  &lt;/li&gt;
  &lt;listing src="uebung1.xml"&gt;&lt;/listing&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu Namensräumen&lt;/title&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 1
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 1
  &lt;/title&gt;
  &lt;p&gt;
  Nachfolgend finden Sie verschiedene
  Multiple-Choice Aufgaben zu Namensräumen. Es
  können je Aufgabe auch mehrere Antworten korrekt
  sein.
  &lt;/p&gt;
  &lt;p&gt;
  Einblenden der Lösungen (sie befinden sich
  jeweils am Ende der Seite) durch Drücken der
  Taste
  &lt;code&gt;n&lt;/code&gt;
  !
  &lt;/p&gt;
  &lt;ul&gt;
  &lt;li&gt;Verwendung&lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;
  A) XML-Namensräume sind die
  hierarchische Sammlung von
  XML-Elementen.
  &lt;/li&gt;
  &lt;li&gt;
  B) XML-Namensräume gruppieren
  XML-Elemente und -Attribute.
  &lt;/li&gt;
  &lt;li&gt;
  C) XML-Namensräume sind durch einen
  Hyperlink eindeutig adressierbar.
  &lt;/li&gt;
  &lt;li&gt;
  D) XML-Namensräume werden durch eine URL
  identifiziert.
  &lt;/li&gt;
  &lt;li&gt;
  E) XML-Namensräume werden durch eine URI
  benannt.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Alternativen B und D sind
  korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 2
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 2
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;Definition&lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;
  A) Namensräume müssen für jedes
  XML-Vokabular definiert werden.
  &lt;/li&gt;
  &lt;li&gt;
  B) Namensräume können ausschließlich
  durch Standardisierungsgremien definiert
  werden.
  &lt;/li&gt;
  &lt;li&gt;
  C) Namensräume können wahlfrei durch den
  Ersteller eines XML-Vokabulars definiert
  werden.
  &lt;/li&gt;
  &lt;li&gt;
  D) Namensräume müssen beim World Wide
  Web Consortium registriert werden.
  &lt;br /&gt;
  Es weist ihnen dann eine eineindeutige
  URL zu.
  &lt;/li&gt;
  &lt;li&gt;
  E) Namensräume können durch eine URL
  identifiziert werden.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Alternativen C und E sind
  korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 3
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 3
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;Syntax&lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;
  A) Die Deklaration der
  Namensraumattribute muß in der
  Dokumentgrammatik erfolgen.
  &lt;br /&gt;
  Dort sind sie als optionale Attribute
  definiert.
  &lt;/li&gt;
  &lt;li&gt;
  B) Namensräume müssen zwingend als
  Wurzelelement (
  &lt;em&gt;document element&lt;/em&gt;
  ) des XML-Dokuments definiert werden.
  &lt;/li&gt;
  &lt;li&gt;
  C) Namensräume können ausschließlich für
  Elemente definiert werden.
  &lt;/li&gt;
  &lt;li&gt;
  D) Die Redefinition bereits gebundener
  Namensraumpräfixe ist zulässig.
  &lt;/li&gt;
  &lt;li&gt;
  E) Wird für ein Element kein Namensraum
  definiert, so ist sein Verhalten im
  Namensraumkontext undefiniert.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Alternative D ist korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 4
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 4
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Namensraumauflösung - Explizite Definition
  &lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;Gegeben sei folgendes XML-Dokument.&lt;/li&gt;
  &lt;listing
  src="uebung-namensraeume-aufg4.xml"&gt;
  &lt;/listing&gt;
  &lt;li&gt;
  Zur besseren Übersichtlichkeit sind den
  Namensräumen folgende Nummern
  zugewiesen:
  &lt;/li&gt;
  &lt;ol&gt;
  &lt;li&gt;
  &lt;em&gt;(leerer Namensraum)&lt;/em&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;http://www.example.com&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;
  http://www.example.com/bar
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;
  http://www.example.com/foo
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;
  http://www.fh-augsburg.de
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;
  http://www.barbara-zengler.de
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;http://www.beispiel.de&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;http://www.w3.org&lt;/code&gt;
  &lt;/li&gt;
  &lt;/ol&gt;
  &lt;li&gt;
  Folgende Tabelle zeigt unterhalb der
  Buchstaben A-E fünf alternative
  Namensraumzuordnungen für alle Elemente,
  unter Verwendung der soeben definierten
  Nummern.
  &lt;br /&gt;
  Finden Sie die richtige!
  &lt;/li&gt;
  &lt;table
  width="80%"
  border="1"&gt;
  &lt;thead&gt;
  &lt;tr&gt;
  &lt;th&gt;
  Element- oder Attributename
  &lt;/th&gt;
  &lt;th&gt;A&lt;/th&gt;
  &lt;th&gt;B&lt;/th&gt;
  &lt;th&gt;C&lt;/th&gt;
  &lt;th&gt;D&lt;/th&gt;
  &lt;th&gt;E&lt;/th&gt;
  &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;root&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemA&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemB&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemC&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;8&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;attA&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemD&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemE&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;6&lt;/td&gt;
  &lt;td&gt;8&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemF&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;attB&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;6&lt;/td&gt;
  &lt;td&gt;7&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemG&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;8&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;/table&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Alternative E ist korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 5
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 5
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Namensraumauflösung - Implizite Definition
  &lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;Gegeben sei folgendes XML-Dokument.&lt;/li&gt;
  &lt;listing
  src="uebung-namensraeume-aufg5.xml"&gt;
  &lt;/listing&gt;
  &lt;li&gt;
  Zur besseren Übersichtlichkeit sind den
  Namensräumen folgende Nummern
  zugewiesen:
  &lt;/li&gt;
  &lt;ol&gt;
  &lt;li&gt;
  &lt;em&gt;(leerer Namensraum)&lt;/em&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;urn:example.com:bar&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;urn:example.com:foo&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;
  urn:xmlns:fh-augsburg.de:vorlesung:XML
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  &lt;code&gt;urn:xmlns:beispiel.de&lt;/code&gt;
  &lt;/li&gt;
  &lt;/ol&gt;
  
  &lt;li&gt;
  Folgende Tabelle zeigt unterhalb der
  Buchstaben A-E fünf alternative
  Namensraumzuordnungen für alle Elemente,
  unter Verwendung der soeben definierten
  Nummern.
  &lt;br /&gt;
  Finden Sie die richtige!
  &lt;/li&gt;
  &lt;table
  width="80%"
  border="1"&gt;
  &lt;thead&gt;
  &lt;tr&gt;
  &lt;th&gt;
  Element- oder Attributename
  &lt;/th&gt;
  &lt;th&gt;A&lt;/th&gt;
  &lt;th&gt;B&lt;/th&gt;
  &lt;th&gt;C&lt;/th&gt;
  &lt;th&gt;D&lt;/th&gt;
  &lt;th&gt;E&lt;/th&gt;
  &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;theDocument&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemA&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemB&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;att1&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemC&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;att2&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemD&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemE&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemF&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemG&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  &lt;code&gt;elemH&lt;/code&gt;
  &lt;/td&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;/table&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Alternative B ist korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 6
  &lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu Namensräumen - Aufgabe 6
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;Namensraumbildung&lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;Gegeben seien folgende Aussagen.&lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Das Element Information Item
  &lt;code&gt;elemA&lt;/code&gt;
  befindet sich im Namensraum
  &lt;code&gt;
  http://www.fh-augsburg.de
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  Das Element Information Item
  &lt;code&gt;elemB&lt;/code&gt;
  befindet sich im Namensraum
  &lt;code&gt;
  http://www.barbara-zengler.de/vorlesung/
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  Die Attribut Information Items
  &lt;code&gt;href&lt;/code&gt;
  ,
  &lt;code&gt;actuate&lt;/code&gt;
  und
  &lt;code&gt;show&lt;/code&gt;
  befinden sich im Namensraum
  &lt;code&gt;
  http://www.fh-augsburg.de
  &lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  Die Element Information Items
  &lt;code&gt;elemC&lt;/code&gt;
  und
  &lt;code&gt;elemD&lt;/code&gt;
  befinden sich im Namensraum
  &lt;code&gt;http://www.beispiel.de&lt;/code&gt;
  &lt;/li&gt;
  &lt;li&gt;
  Das Element Information Item
  &lt;code&gt;elemE&lt;/code&gt;
  befindet sich im Namensraum
  &lt;code&gt;http://www.example.com&lt;/code&gt;
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;li&gt;
  Frage: Welche der folgenden Dokumente
  erfüllen diese Aussagen?
  &lt;/li&gt;
  &lt;li&gt;Dokument A&lt;/li&gt;
  &lt;listing src="dokumentA.xml"&gt;&lt;/listing&gt;
  &lt;li&gt;Dokument B&lt;/li&gt;
  &lt;listing src="dokumentB.xml"&gt;&lt;/listing&gt;
  &lt;li&gt;Dokument C&lt;/li&gt;
  &lt;listing src="dokumentC.xml"&gt;&lt;/listing&gt;
  &lt;li&gt;Dokument D&lt;/li&gt;
  &lt;listing src="dokumentD.xml"&gt;&lt;/listing&gt;
  &lt;li&gt;Dokument E&lt;/li&gt;
  &lt;listing src="dokumentE.xml"&gt;&lt;/listing&gt;
  &lt;/ul&gt;
  &lt;note&gt;
  &lt;li&gt;
  Lösung: Die Dokumente A, C und E sind
  korrekt!
  &lt;/li&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu DTDs&lt;/title&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgabe zu DTDs&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;Übungsaufgabe zu DTDs&lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Die folgende DTD ist syntaktisch falsch.
  Korrigieren Sie die Fehler.
  &lt;br /&gt;
  Die Lösung (am Ende der Seite) kann durch
  Drücken der Taste
  &lt;code&gt;n&lt;/code&gt;
  eingeblendet werden.
  &lt;/li&gt;
  &lt;listing src="wrong.dtd"&gt;&lt;/listing&gt;
  &lt;note&gt;
  &lt;li&gt;Lösung:&lt;/li&gt;
  &lt;listing src="right.dtd"&gt;&lt;/listing&gt;
  &lt;/note&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XML Schema&lt;/title&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 1&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu XML Schema - Aufgabe 1
  &lt;/title&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Gegeben ist folgende DTD. Erstellen Sie ein
  äquivalentes Schema gemäß der
  &lt;a
  href="http://www.w3.org/TR/xmlschema-1/"&gt;
  W3C XML Schema Recommendation
  &lt;/a&gt;
  .
  &lt;/li&gt;
  &lt;listing src="dtd-fuer-schemaumwandlung.dtd"&gt;&lt;/listing&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 2&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu XML Schema - Aufgabe 2
  &lt;/title&gt;
  &lt;p&gt;
  Erstellen Sie ein Schema, das die nachfolgend
  aufgeführten Zusammenhänge abbildet:
  &lt;/p&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Das Element Information Item
  &lt;code&gt;Autor&lt;/code&gt;
  verfügt über die Kindknoten
  &lt;code&gt;Vorname&lt;/code&gt;
  (mindestens einmaliges, aber höchstens
  zweimaliges Auftreten) sowie
  &lt;code&gt;Nachname&lt;/code&gt;
  .
  &lt;br /&gt;
  Beide Elemente stellen Namen im
  herkömmlichen Sinne dar und verfügen über
  keine interne Formatierung durch Leerzeichen
  oder Zeilenumbrüche
  &lt;/li&gt;
  &lt;li&gt;
  Der Wurzelknoten
  &lt;code&gt;Zeitschrift&lt;/code&gt;
  enthält genau ein als
  &lt;code&gt;Verlag&lt;/code&gt;
  bezeichnetes Kindelement des Typs
  &lt;code&gt;string&lt;/code&gt;
  .
  &lt;/li&gt;
  &lt;li&gt;
  Jeder
  &lt;code&gt;Beitrag&lt;/code&gt;
  besitzt mindestens einen aber beliebig viele
  &lt;code&gt;Autor&lt;/code&gt;
  en.
  &lt;/li&gt;
  &lt;li&gt;
  Jedes Element Information Item des Typs
  &lt;code&gt;Beiträge&lt;/code&gt;
  enthält eine positive Anzahl von Element
  Information Items des Namens
  &lt;code&gt;Beitrag&lt;/code&gt;
  .
  &lt;/li&gt;
  &lt;li&gt;
  Jedes Element Information Item des Typs
  &lt;code&gt;Beitrag&lt;/code&gt;
  enthält das Attribut
  &lt;code&gt;Seitenanzahl&lt;/code&gt;
  (positive Ganzzahl) und
  &lt;code&gt;Annahmedatum&lt;/code&gt;
  (Datum)
  &lt;/li&gt;
  &lt;li&gt;
  Jedes Element Information Item des Typs
  &lt;code&gt;Zeitschrift&lt;/code&gt;
  enthält genau ein Element Information Item
  des Namens
  &lt;code&gt;Beiträge&lt;/code&gt;
  .
  &lt;/li&gt;
  &lt;li&gt;
  Zu jedem
  &lt;code&gt;Beitrag&lt;/code&gt;
  existiert eine Menge von
  &lt;code&gt;Schlagworten&lt;/code&gt;
  . Diese werden in einem Element Information
  Item
  &lt;code&gt;Schlagworte&lt;/code&gt;
  abgelegt. Dieses Element kann zwischen drei
  und fünf Zeichenketten als
  &lt;code&gt;Eintrag&lt;/code&gt;
  beinhalten.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 3&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu XML Schema - Aufgabe 3
  &lt;/title&gt;
  &lt;p&gt;
  Gegeben sei nachfolgendes Schema. Geben Sie dazu
  eine
  &lt;em&gt;schema-gültige&lt;/em&gt;
  Dokumentinstanz an.
  &lt;/p&gt;
  &lt;listing src="uebung-schema-valid-instanz.xsd"&gt;&lt;/listing&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 4&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;
  Übungsaufgaben zu XML Schema - Aufgabe 4
  &lt;/title&gt;
  &lt;p&gt;
  Gegeben sei nachfolgendes Dokument. Entwerfen
  Sie dafür ein gültiges XML-Schema.
  &lt;/p&gt;
  &lt;listing src="uebung-schemaentwurf.xml"&gt;&lt;/listing&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  
  &lt;/part&gt;
  
  &lt;part&gt;
  &lt;title&gt;Übungsaufgaben zu XPath&lt;/title&gt;
  &lt;slide&gt;
  &lt;title&gt;Übungsaufgaben zu XPath&lt;/title&gt;
  &lt;p&gt;
  Folgenden Aufgaben liegt die
  &lt;a
  href="http://www.barbara-zengler.de/vorlesung/projektverwaltung-erweitert.xml"&gt;
  erweiterte Projektverwaltung
  &lt;/a&gt;
  aus der Vorlesung zugrunde.
  &lt;/p&gt;
  &lt;ol&gt;
  &lt;li&gt;
  Wie muß ein XPath-Ausdruck lauten, um folgendes
  zu selektieren?
  &lt;/li&gt;
  &lt;ul&gt;
  &lt;li&gt;
  Selektion aller Personen mit Nachnamen
  „Obermüller“.
  &lt;/li&gt;
  &lt;li&gt;
  Selektion aller Nachnamen von Personen die
  über mehr als eine Qualifikation verfügen.
  &lt;/li&gt;
  &lt;li&gt;
  Selektion der Nachnamen aller Projektleiter.
  &lt;/li&gt;
  &lt;/ul&gt;
  &lt;/ol&gt;
  &lt;/slide&gt;
  &lt;/part&gt;
  
  
  
  &lt;/presentation&gt; --&gt;
 &lt;!-- Ende Übungsaufgaben --&gt;

 &lt;!-- 
  &lt;presentation id="seminarthemen"&gt;
  &lt;title short="seminarthemen"&gt;
  Seminarthemen: Daten und Vortragende
  &lt;/title&gt;
  &lt;date&gt;2007-10-08&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
  Hier finden Sie eine Übersicht der Seminarthemen, sowie die
  Zuteilung zu Vortragenden und das Vortragsdatum.
  &lt;/toc&gt;
  &lt;slide&gt;
  &lt;title&gt;Seminarthemen und Termine&lt;/title&gt;
  &lt;p&gt;
  &lt;b&gt;Achtung:&lt;/b&gt;
  Die Reihenfolge der Themennennungen ist zunächst
  willkürlich und spiegelt nicht eine eventuelle
  Reihenfolge im Seminar wider, solange die Termine für
  die Vorträge noch nicht feststehen.
  &lt;br /&gt;
  &lt;b&gt;Achtung:&lt;/b&gt;
  Die Teilnahme am Seminar ist selbstverständlich
  verpflichtend. Die Bekanntgabe der Noten erfolgt am Ende
  des Semesters.
  &lt;/p&gt;
  &lt;table
  border="1"
  cellpadding="20"&gt;
  &lt;tr&gt;
  &lt;th
  align="left"
  valign="middle"&gt;
  Thema
  &lt;/th&gt;
  &lt;th
  align="left"
  valign="middle"&gt;
  Datum
  &lt;/th&gt;
  &lt;th
  align="left"
  valign="middle"&gt;
  Vortragende
  &lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;Das World Wide Web Consortium (W3C)&lt;/td&gt;
  &lt;td&gt;22.10.2007&lt;/td&gt;
  &lt;td&gt;Peter Alt, Daniel Fontes, Bernhard Leitner&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  Das Vektorgrafikformat Scalable Vector Graphics
  (SVG)
  &lt;/td&gt;
  &lt;td&gt;22.10.2007&lt;/td&gt;
  &lt;td&gt;
  Caroline Jochno, Katja Loos, Lisa Raschupkin
  &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;InkML&lt;/td&gt;
  &lt;td&gt;05.11.2007&lt;/td&gt;
  &lt;td&gt;Alvin Raminger, Krisztina Sárközi&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  Verwendung von XML in Content Management
  Systemen - am Beispiel ZOPE
  &lt;/td&gt;
  &lt;td&gt;05.11.2007&lt;/td&gt;
  &lt;td&gt;Jeanne Haberland, Moritz Meyers&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;Really Simple Syndication (RSS)&lt;/td&gt;
  &lt;td&gt;19.11.2007&lt;/td&gt;
  &lt;td&gt;Andreas Fischer, Boris Heißerer&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  Datenaustausch mit SOAP und bekannte Anwendungen
  &lt;/td&gt;
  &lt;td&gt;19.11.2007&lt;/td&gt;
  &lt;td&gt;
  Eugenia Merkel, Melissa Müller, Jörg Richter
  &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;Die Wireless Markup Language (WML)&lt;/td&gt;
  &lt;td&gt;3.12.2007&lt;/td&gt;
  &lt;td&gt;Michael Ilg, Leon Zarbock&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;XSL-Formatting Objects (XSL-FO)&lt;/td&gt;
  &lt;td&gt;3.12.2007&lt;/td&gt;
  &lt;td&gt;Björn Gottwald, Frank Robnik, Rainer Wagner&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  Das Oasis Open Document Format for Office
  Applications (ODF)
  &lt;/td&gt;
  &lt;td&gt;17.12.2007&lt;/td&gt;
  &lt;td&gt;Veronica Hanglberger, Marie Stöcker&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;XUL&lt;/td&gt;
  &lt;td&gt;17.12.2007&lt;/td&gt;
  &lt;td&gt;Marion Dandl, Melanie Friedrich&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;Das X in Ajax&lt;/td&gt;
  &lt;td&gt;17.12.2007&lt;/td&gt;
  &lt;td&gt;Manuel Piepereit, Susanne Woitsch&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;Adobe Flex&lt;/td&gt;
  &lt;td&gt;14.01.2008&lt;/td&gt;
  &lt;td&gt;Thomas Nolde, Marc Tomona&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;
  Multimedia-Inhalte des Web: Synchronized
  Multimedia Integration Language (SMIL)
  &lt;/td&gt;
  &lt;td&gt;14.01.2008&lt;/td&gt;
  &lt;td&gt;Matthäus Baur, Melanie Schmidt&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/table&gt;
  &lt;/slide&gt;
  &lt;/presentation&gt;
 --&gt;

 &lt;!-- Erste VL am 6.10.2008--&gt;
 &lt;presentation
  id="intro"
  cover="slidycover"&gt;
  &lt;title short="Introduction"&gt;Einführung und Überblick&lt;/title&gt;
  &lt;date&gt;2008-10-06&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/Press/1998/XML10-REC"&gt;
    XML 1.0 Press Release
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Die
   &lt;em&gt;Extensible Markup Language (XML)&lt;/em&gt;
   wurde im Jahr 1998 durch das World Wide Web Consortium (W3C)
   als Standard verabschiedet. Sie wurde vor dem Hintergrund
   der Expansion der Internetnutzung in Richtung
   applikationsspezifischer Formate erdacht. HTML als die
   "Sprache des Web" war rein zum web-basierten Publizieren von
   (Text-)Dokumenten erdacht. Mit XML hingegen eröffnete sich
   zum ersten Mal die Möglichkeit, Daten im Web maschinenlesbar
   und flexibel auszutauschen. Das
   &lt;em&gt;Semantic Web&lt;/em&gt;
   versucht seit nunmehr einigen Jahren, mit XML-Mitteln
   semantische Information darzustellen und nutzbar zu machen.
   Mittlerweile hat sich die XML als weltweit akzeptiertes
   Austauschformat für maschinenlesbare und strukturierte Daten
   etabliert.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;Diverses / Organisatorisches&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Über mich&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wissenschaftliche Mitarbeiterin der
      &lt;a href="http://www.daimlerchrysler.com/"&gt;
       DaimlerChrysler Forschung
      &lt;/a&gt;
      (2004-2006)
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Forschung auf diversen Gebieten der XML,
       u.a. Mitarbeit in der W3C-Arbeitsgruppe zur
       Web Service Description Language
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Beraterin bei der
      &lt;a href="http://www.altran.com/"&gt;
       Altran Group
      &lt;/a&gt;
      (2006-?)
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       für die Altran tätig im Forschungs- und
       Innovationszentrum der BMW AG
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Veröffentlichungen&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Buch über
       &lt;q&gt;
        &lt;a href="http://www.soa-buch.de/"&gt;
         Service-orientierte Architekturen
        &lt;/a&gt;
       &lt;/q&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Buch
       &lt;q&gt;
        &lt;a href="http://www.uml-glasklar.de/"&gt;
         UML glasklar
        &lt;/a&gt;
       &lt;/q&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Diverse Artikel in iX, ObjektSpektrum, ...
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Über Sie&lt;/title&gt;
    &lt;img
     style="margin : 4% ; width : 90% ; "
     src="classroom.jpg" /&gt;
    &lt;p&gt;
     © S. Hofschlaeger /
     &lt;a href="http://www.pixelio.de"&gt;PIXELIO&lt;/a&gt;
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Über diesen Kurs&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Web page:
      &lt;code&gt;
       &lt;a href="./"&gt;
        http://www.barbara-zengler.de/vorlesung/
       &lt;/a&gt;
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;Vorlesungszeiten:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Vorlesung: Montags 08:00 - 09:30. Raum I 102
      &lt;/li&gt;
      &lt;li&gt;
       Praktikum: Montags 09:50 - 11:20. Raum M2.03
       (Betreuung durch Herrn Prof. Klever)
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Prüfung erfolgt durch Studienarbeit im Rahmen
      des Praktikums (gemeinsam mit i3.NETZ)
     &lt;/li&gt;
     &lt;li&gt;Ablauf des Praktikums:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       1. Teil: Übungsaufgaben (1.10.-12.1.2008)
      &lt;/li&gt;
      &lt;li&gt;
       2. Teil: Anfertigen der Studienarbeit (ab
       1.12.2008)
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Ausgabe der Studienarbeiten am 1. Dezember 2008.
      Das Praktikum ist erfolgreich zu absolvieren.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Vorlesungstermine&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Vorlesungstermine im WS 2008/09 (15
      Veranstaltungen).
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;table
     width="90%"
     border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th width="30%"&gt;Termin&lt;/th&gt;
       &lt;th&gt;Inhalt&lt;/th&gt;
       &lt;th&gt;Praktikum&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;06. Oktober 2008&lt;/td&gt;
       &lt;td&gt;Einführungsveranstaltung&lt;/td&gt;
       &lt;td&gt;
        Achtung: An diesem Tag kein Praktikum!
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;13. Oktober 2008&lt;/td&gt;
       &lt;td&gt;XML-Dokumente / Wohlgeformtheit&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;20. Oktober 2008&lt;/td&gt;
       &lt;td&gt;Namensräume&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;27. Oktober 2008&lt;/td&gt;
       &lt;td&gt;DTD / XML Schema&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;03. November 2008&lt;/td&gt;
       &lt;td&gt;XML Schema&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;10. November 2008&lt;/td&gt;
       &lt;td&gt;SAX&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;17. November 2008&lt;/td&gt;
       &lt;td&gt;DOM&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;24. November 2008&lt;/td&gt;
       &lt;td&gt;DOM&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;01. Dezember 2008&lt;/td&gt;
       &lt;td&gt;DOM, Ausgabe der Seminararbeiten&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;08. Dezember 2008&lt;/td&gt;
       &lt;td&gt;XPath&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;15. Dezember 2008&lt;/td&gt;
       &lt;td&gt;RDF und RSS&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;22. Dezember 2008&lt;/td&gt;
       &lt;td&gt;XSLT&lt;/td&gt;
       &lt;td&gt;
        Praktikumsaufgaben zum Vorlesungs-Thema
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;12. Januar 2009&lt;/td&gt;
       &lt;td&gt;XFORMS&lt;/td&gt;
       &lt;td&gt;
        Kleinere Praktikumsaufgabe +
        Fragestellungen zur Studienarbeit
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;19. Januar 2009&lt;/td&gt;
       &lt;td&gt;JAXB&lt;/td&gt;
       &lt;td&gt;Fragestellungen zur Studienarbeit&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;26. Januar 2009&lt;/td&gt;
       &lt;td&gt;SVG und SMIL&lt;/td&gt;
       &lt;td&gt;Fragestellungen zur Studienarbeit&lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Ablauf des Praktikums und der Studienarbeiten
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Ablauf&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Praktikum: Durchführung kleinerer
       Übungsaufgaben bis zum 12.1.2009
      &lt;/li&gt;
      &lt;li&gt;
       Am 1.12. erfolgt die Ausgabe der gemeinsamen
       Studienarbeiten XML (i3.DATA) und
       Datenkommunikation (i3.NETZ).
      &lt;/li&gt;
      &lt;li&gt;
       Ausarbeitung dieser Studienarbeiten bis zum
       Ende des Semesters. Abgabe bei Herrn Klever,
       Datum wird noch bekanntgegeben.
      &lt;/li&gt;
      &lt;li&gt;
       Benotet wird der XML-Anteil Ihrer
       Studienarbeiten sowie die erfolgreiche
       Durchführung der Praktikumsübungen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Ziel&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Eigenständiges Erarbeiten eines neuen
       Themenkomplexes
      &lt;/li&gt;
      &lt;li&gt;Eigenständiges Lösen von Problemen&lt;/li&gt;
      &lt;li&gt;
       Erste Erfahrungen in der
       "Netz-Programmierung" sammeln
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Über dieses Skript&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Dieses Skript wurde aus einer XML-Datei
      generiert, unter Zuhilfenahme des Tools
      &lt;a href="http://dret.net/projects/xslidy/"&gt;
       XSLidy
      &lt;/a&gt;
      von
      &lt;a href="http://dret.net/netdret/"&gt;
       Erik Wilde
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Es besteht aus einer Reihe von
       &lt;a
        href="http://www.w3.org/Talks/Tools/Slidy/"&gt;
        Slidy
       &lt;/a&gt;
       Präsentationen, die alle aus einer Quelle
       erzeugt werden.
      &lt;/li&gt;
      &lt;li&gt;
       Auf der Seite
       &lt;code&gt;
        &lt;a href="./toc.html"&gt;toc.html&lt;/a&gt;
       &lt;/code&gt;
       sehen Sie eine knappe Inhaltsübersicht der
       &lt;a href="./"&gt;Webseite zu diesem Kurs&lt;/a&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Ein Tastendruck auf
       &lt;code&gt;a&lt;/code&gt;
       zeigt Ihnen alle Seiten des Skripts. Diese
       können Sie dann ausdrucken.
      &lt;/li&gt;
      &lt;li&gt;
       Es gibt keine PDF-Version dieses Skripts.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Als Quellen für dieses Skript dienten&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die
       &lt;a
        href="http://dret.net/lectures/xml-fall07/"&gt;
        XML-Vorlesung
       &lt;/a&gt;
       von
       &lt;a href="http://dret.net/netdret/"&gt;
        Erik Wilde
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Die
       &lt;a
        href="http://www.jeckle.de/vorlesung/xml/"&gt;
        XML-Vorlesung
       &lt;/a&gt;
       von
       &lt;a href="http://www.jeckle.de/"&gt;
        Mario Jeckle
       &lt;/a&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Nützliches&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Werkzeuge&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       XML Editoren, z.B.
       &lt;ul&gt;
        &lt;li&gt;
         Der XML Editor der
         &lt;a href="http://www.eclipse.org/"&gt;
          IDE Eclipse
         &lt;/a&gt;
         : Eclipse XML Editors and Tools, als
         Teil der
         &lt;a
          href="http://www.eclipse.org/webtools/"&gt;
          Eclipse Web Tools Platform
         &lt;/a&gt;
         (
         &lt;a
          href="http://download.eclipse.org/webtools/downloads/"&gt;
          Zum Download
         &lt;/a&gt;
         )
        &lt;/li&gt;
        &lt;li&gt;
         &lt;a
          href="http://xml-copy-editor.sourceforge.net/"&gt;
          XML Copy Editor
         &lt;/a&gt;
         (frei verfügbarer Editor mit
         Schemavalidierung und
         XSLT-Unterstützung)
        &lt;/li&gt;
        &lt;li&gt;
         &lt;a href="http://www.altova.com/"&gt;
          Altova XML Spy
         &lt;/a&gt;
         (freie Version ohne
         Schemavalidierung zum Download
         verfügbar, an der Hochschule in
         Vollversion vorhanden)
        &lt;/li&gt;
       &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
       XSLT Prozessor, z.B.
       &lt;a href="http://www.saxonica.com/"&gt;Saxon&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       XQuery Prozessor, z.B.
       &lt;a href="http://www.saxonica.com/"&gt;Saxon&lt;/a&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Weiterführende Links&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das
      &lt;a href="http://www.w3.org/"&gt;
       &lt;em&gt;World Wide Web Consortium (W3C)&lt;/em&gt;
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       die Organisation, die unter anderem XML
       erfunden hat
      &lt;/li&gt;
      &lt;li&gt;
       und auch all die anderen Techniken, die in
       diesem Kurs behandelt werden.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die
      &lt;a href="http://www.edition-w3c.de/"&gt;
       Übersetzungen der W3C-Standards ins Deutsche
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       initiiert und zusammengetragen von
       &lt;a href="http://www.mintert.com/"&gt;
        Stefan Mintert
       &lt;/a&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die
      &lt;a href="http://xml.coverpages.org/"&gt;
       XML Cover Pages
      &lt;/a&gt;
      von Robin Cover
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       stets aktuelle gehaltene Seite mit
       Nachrichten und neuesten Entwicklungen im
       XML-Bereich
      &lt;/li&gt;
      &lt;li&gt;
       nicht nur Hype, sondern durchaus kritische
       Betrachtung mancher Entwicklungen
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;Was ist XML - Struktur der Vorlesung&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Was sagt die Presse? - frühe Definitionsversuche
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;q&gt;
       XML schickt sich an in die Fußstapfen von
       HTML zu treten
      &lt;/q&gt;
      (Aus: c't 10/2000, p. 200)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;
       Das Datenformat [XML] erleichtert den
       Informationsaustausch zwischen vernetzten
       Computern
      &lt;/q&gt;
      (Aus: DER SPIEGEL, 2000-06-19)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;Alle Dokumente sind gleich&lt;/q&gt;
      (Aus: SZ, 1999-02-16)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;Ein digitales Esperanto für das Internet&lt;/q&gt;
      (Aus: Die Welt, 2000-10-07)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;
       Sortieren statt Stottern -
       Programmiersprache HTML stößt an ihre
       Grenzen, XML ist kommender Code im Netz
      &lt;/q&gt;
      (Aus: SZ, 2000-01-11)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;
       Sinnliche Suchmaschine [...] existierende
       Systeme wie [...] XML
      &lt;/q&gt;
      (Aus: DER SPIEGEL, 2000-06-07)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;Streit um Programmiersprache XML&lt;/q&gt;
      (Aus: F.A.Z., 2001-07-26)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;
       Netzwerktechnik versagt oft bei Angriffen
       via XML
      &lt;/q&gt;
      (Aus: Computerzeitung, 2002-08-26)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Vorlesungsstruktur (1/3)&lt;/title&gt;
    &lt;!-- Block 1 --&gt;
    &lt;ul&gt;
     &lt;li&gt;1. Von Dokumenten und Daten&lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;Einführung&lt;/li&gt;
      &lt;li&gt;
       XML-Dokumente / Wohlgeformtheit
       (Strukturelle Grundkonzepte auf Basis des
       &lt;a
        href="http://www.w3.org/TR/xml-infoset/"&gt;
        &lt;em&gt;XML Information Set&lt;/em&gt;
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;XML Namensräume&lt;/li&gt;
      &lt;li&gt;Grammatik eines XML Dokuments&lt;/li&gt;
      &lt;ol&gt;
       &lt;li&gt;Dokument-Typ-Definitionen (DTD)&lt;/li&gt;
       &lt;li&gt;XML Schemasprachen&lt;/li&gt;
      &lt;/ol&gt;
     &lt;/ol&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;!-- Block 2 --&gt;
    &lt;title&gt;Vorlesungsstruktur (2/3)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      2. Anwendungen der XML im praktischen Einsatz /
      Programmierung
     &lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;Die Simple API for XML (SAX)&lt;/li&gt;
      &lt;li&gt;Das Document Object Model (DOM)&lt;/li&gt;
     &lt;/ol&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;!-- Block 3 --&gt;
   &lt;slide&gt;
    &lt;title&gt;Vorlesungsstruktur (3/3)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      3. XML-Standards und weiterführende Anwendungen
     &lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;Die Lokatorsprache XPath&lt;/li&gt;
      &lt;li&gt;
       Der erste Schritt zum Semantic Web: Das
       Resource Description Framework (RDF) und
       Really Simple Syndication (RSS)
      &lt;/li&gt;
      &lt;li&gt;
       Transformation von XML-Dokumenten: XSL
       Transformation
      &lt;/li&gt;
      &lt;li&gt;Formulare für das Web: XForms&lt;/li&gt;
      &lt;li&gt;
       Nahtlose Integration von XML und Hochsprache
       - Java Architecture for XML Binding (JAXB)
      &lt;/li&gt;
      &lt;li&gt;Multimedia im Web: SVG und SMIL&lt;/li&gt;
     &lt;/ol&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;Von Dokumenten und Daten - eine Einführung&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Kleine Geschichte der XML&lt;/title&gt;
    &lt;p&gt;
     Es haben im Grunde zwei Entwicklungen zur Entstehung
     der XML geführt. Zum einen stellt sie eine
     Weiterentwicklung generischer Auszeichnungssprachen
     wie der SGML dar, zum anderen hatte die Entwicklung
     des World Wide Web starken Einfluß auf ihre
     Entstehung.
    &lt;/p&gt;
    &lt;p /&gt;
    &lt;p&gt;Aber gehen wir das ganze chronologisch an...&lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Auszeichnungssprachen&lt;/title&gt;
    &lt;img
     style="margin : 0% ; height : 20% ; position: absolute; top:0px; right: 25px"
     src="Korrektur.jpg" /&gt;
    &lt;p&gt;Was sind Auszeichnungssprachen?&lt;/p&gt;
    &lt;p&gt;
     Auszeichnungssprachen beschreiben Information näher,
     d.h. sie sagen etwas über den Charakter der
     Information aus. Es handelt sich also um Information
     über Information, sog.
     &lt;em&gt;Metainformation&lt;/em&gt;
     .
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Informationen über den Inhalt, die nicht
      Bestandteil des Dokumentinhalts sind. Sie sind
      für den Leser unsichtbar.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Beispiele: Korrekturfahnen bei Schulaufsätzen,
     Buchdruck (Hinweise zu Fettdruck, etc.)
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Hypertext&lt;/title&gt;
    &lt;img
     style="margin : 0% ; width : 10% ; position: fixed; right:25px; top: 25px; float:right; "
     src="img_m.gif" /&gt;
    &lt;p&gt;
     Erste Ideen zum Konzept Hypertext gab es bereits um
     das Jahr 1950.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Vannevar Bush beschreibt in seinem Artikel
      &lt;em&gt;
       &lt;a
        href="http://www.w3.org/History/1945/vbush/vbush-all.shtml"&gt;
        As We May Think
       &lt;/a&gt;
      &lt;/em&gt;
      aus dem Jahr 1945 ein für die damalige Zeit
      futuristisches System
      &lt;em&gt;Memex&lt;/em&gt;
      . Motivation für Bush ist die Frage, wie die
      Unmenge des über Jahrtausende gesammelten
      Wissens leichter zugänglich gemacht werden kann.
      &lt;br /&gt;



      Sein fiktives System Memex basiert auf Mikrofilm
      und erlaubt es dem Benutzer, beliebige Medien
      wie Bücher, Zeitschriften, handschriftliche
      Notizen, Fotografien, etc. zu archivieren, zu
      annotieren sowie sich anhand selbst definierter
      Pfade durch die gespeicherte Information zu
      bewegen.



     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Hypertext&lt;/title&gt;
    &lt;p&gt;
     Bush's Lösung des Problems "schneller Zugang zu
     gesuchter Information":
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verwendung von mechanisierten assoziativen
      Verweisen (sogenannten
      &lt;em&gt;trails&lt;/em&gt;
      ) statt herkömmlicher Indizierung (alphabetisch
      oder numerisch).
     &lt;/li&gt;
     &lt;li&gt;
      Die Verwendung von Verweisen lehnt sich an das
      menschliche Denken an (Gehirn arbeitet mit
      Assoziationen).
     &lt;/li&gt;
     &lt;li&gt;
      Verweise in Lexika sind ein erster Ansatz, haben
      aber Unzulänglichkeiten (Verlassen des
      Informationspfads für neue Suche, fehlende
      Mechanisierung, starke Beschränkung verwendeter
      Quellen).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Hypertext&lt;/title&gt;
    &lt;img
     style="margin : 0% ; width : 4% ; position: fixed; right:25px; top: 25px; float:right; "
     src="Xanadu-Logo.png" /&gt;
    &lt;p&gt;
     1960 gründet
     &lt;a href="http://www.xanadu.com.au/ted/"&gt;
      Ted Nelson
     &lt;/a&gt;
     das
     &lt;em&gt;
      &lt;a href="http://www.xanadu.com/"&gt;
       XANADU Projekt
      &lt;/a&gt;
     &lt;/em&gt;
     und prägt den Begriff des
     &lt;em&gt;Hypertext&lt;/em&gt;
     .
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Nicht sequentielles Schreiben ("non-sequential
      writing")
     &lt;/li&gt;
     &lt;li&gt;
      Stets gültige Verweise zwischen verschiedenen
      Dokumenten
     &lt;/li&gt;
     &lt;li&gt;
      Koexistenz "paralleler" Dokumente (z.B.
      verschiedene Versionen eines Dokuments,
      Übersetzungen)
     &lt;/li&gt;
     &lt;li&gt;Direkter Dokumentvergleich am Bildschirm&lt;/li&gt;
     &lt;li&gt;Annotation des Textes&lt;/li&gt;
     &lt;li&gt;
      Einbindung von Teilen anderer Dokumente, "Pay
      Per View"-Gedanke
     &lt;/li&gt;
     &lt;li&gt;
      Xanadu wurde seither aufgrund seiner Konplexität
      und seines Universalanspruchs jedoch nie
      vollständig implementiert
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Hypertext (Zusammenfassung)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Hauptideen:



      &lt;ul&gt;
       &lt;li&gt;
        Nichtlineares Schreiben und
        Durcharbeiten von Texten
       &lt;/li&gt;
       &lt;li&gt;
        Trennung von Inhalt und Präsentation
       &lt;/li&gt;
      &lt;/ul&gt;



     &lt;/li&gt;
     &lt;img
      style="margin : 0% ; width : 7% ; position: absolute; right:50px; float:left; "
      src="Knoten-Anker-Netz.png" /&gt;
     &lt;li&gt;Begriffe:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Verweis (Link):Eine Verbindung von einer
       Ressource zu einer anderen.
      &lt;/li&gt;
      &lt;li&gt;Anker: Die beiden Enden eines Links.&lt;/li&gt;
      &lt;li&gt;Knoten: Eine Informationseinheit.&lt;/li&gt;
      &lt;li&gt;
       Netz: Eine Menge von Knoten, die mit Hilfe
       von Verweisen miteinander verknüpft sind.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beginnende technische Unterstützung&lt;/title&gt;
    &lt;p&gt;
     In den 60er Jahren begann die technische
     Unterstützung der Hypertext-Idee mit dem Aufkommen
     der ersten Rechenanlagen.
    &lt;/p&gt;
    &lt;p&gt;
     Die damals gewohnten, grafischen Symbole zur
     Textauszeichnung waren auf den Rechenanlagen nicht
     verfügbar, man mußte sich nach einer Alternative
     umsehen. Die Lösung waren beschreibende textuelle
     Pendants wie etwa
     &lt;code&gt;Überschrift&lt;/code&gt;
     .
    &lt;/p&gt;
    &lt;p&gt;
     &lt;u&gt;Wichtiges Konzept:&lt;/u&gt;
     &lt;br /&gt;
     &lt;ul&gt;
      &lt;li&gt;
       semantische Beschreibung des Inhalts statt
       Formatierungsangaben!
      &lt;/li&gt;
      &lt;li&gt;
       Auszeichnung unabhängig von der (späteren)
       Formatierung des Textes
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Von GML zu HTML&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      1969: Goldfarb, Mosher und Loire entwickeln bei
      IBM die
      &lt;em&gt;Generalized Markup Language (GML)&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Weiterentwicklung zur
      &lt;em&gt;Standard GML (SGML)&lt;/em&gt;
      :



      &lt;ul&gt;
       &lt;li&gt;
        erste sogenannte
        &lt;em&gt;Metasprache&lt;/em&gt;
        , d.h. die SGML erlaubt die Definition
        von anderen Sprachen
        &lt;note&gt;
         &lt;em&gt;Meta-&lt;/em&gt;
         drückt in Bildungen mit Substantiven
         aus, dass sich etw. auf einer
         höheren Stufe, Ebene befindet,
         darüber geordnet ist oder hinter
         etw. steht: Metamarketing, -theorie.
         © Duden - Deutsches
         Universalwörterbuch 2001
        &lt;/note&gt;
       &lt;/li&gt;
       &lt;li&gt;kein festes, definiertes Vokabular&lt;/li&gt;
       &lt;li&gt;
        stattdessen zahlreiche Konstrukte zur
        Definition von Grammatiken
       &lt;/li&gt;
       &lt;li&gt;
        Standardisierung der SGML durch die ISO
       &lt;/li&gt;
      &lt;/ul&gt;



     &lt;/li&gt;
     &lt;li&gt;
      Begriffsklärung "Einsatz der SGML"



      &lt;ul&gt;
       &lt;li&gt;
        bedeutet eigentlich, daß mit Hilfe der
        SGML eine auf SGML basierende Sprache
        entwickelt wird, d.h. die Grammatik für
        diese erstallt wird
       &lt;/li&gt;
       &lt;li&gt;
        im Volksmund jedoch synonym mit dem
        Einsatz einer auf SGML basierenden
        Sprache, einer sogenannten
        &lt;em&gt;Anwendung der SGML&lt;/em&gt;
        , gebraucht.
       &lt;/li&gt;
      &lt;/ul&gt;



     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Von GML zu HTML&lt;/title&gt;
    &lt;img
     style="margin : 0% ; width : 9% ; position: fixed; right:25px; top: 25px; float:right; "
     src="screenshot-first-browser_2.gif" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Beginnend Mitte der 80er Jahre:
      &lt;em&gt;
       &lt;a
        href="http://www.w3.org/People/Berners-Lee/"&gt;
        Tim Berners-Lee
       &lt;/a&gt;
      &lt;/em&gt;
      entwickelt am schweizer Kernforschungszentrum
      &lt;em&gt;
       &lt;a href="http://www.cern.ch/"&gt;CERN&lt;/a&gt;
      &lt;/em&gt;
      eine vereinfachte Sprache zur Auszeichnung von
      Dokumenten, die
      &lt;em&gt;
       &lt;a href="http://www.w3.org/html/"&gt;
        Hypertext Markup Language (HTML)
       &lt;/a&gt;
      &lt;/em&gt;
      (basierend auf SGML). Motivation: vereinfachter
      rechnergestützter Austausch von Dokumenten.
     &lt;/li&gt;
     &lt;li&gt;
      Er berücksichtigt hierbei die Konzepte des
      Hypertext.
     &lt;/li&gt;
     &lt;li&gt;
      Entwicklung des Konzeptes
      &lt;em&gt;Uniform Resource Locator (URL)&lt;/em&gt;
      als eindeutiger Identifikator (eindeutige
      Adresse) für beliebige Inhalte.
     &lt;/li&gt;
     &lt;li&gt;
      Damit einher ging die Entwicklung des
      &lt;em&gt;Hypertext Transfer Protocol (HTTP)&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Berners-Lee schlägt im Jahre 1989 mit
      &lt;a
       href="http://www.w3.org/History/1989/proposal.html"&gt;
       Information Management: A Proposal
      &lt;/a&gt;
      dem CERN Management ein auf SGML basierendes
      Hypertextsystem zum Austausch von Dokumenten
      vor.
     &lt;/li&gt;
     &lt;li&gt;
      Im Jahre 1990 schrieb Berners-Lee den ersten
      Web-Server und Web-Client, den WorldWideWeb
      Browser (später umbenannt in Nexus).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Weiterentwicklung der HTML - Browser War&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In den folgenden Jahren wurde das Web immer
      stärker für den kommerziellen Gebrauch
      erschlossen.
     &lt;/li&gt;
     &lt;li&gt;
      Es entstehen unterschiedliche Erweiterungen der
      HTML, initiiert durch die beiden großen
      Browser-Hersteller
      &lt;a href="http://www.microsoft.com/"&gt;
       Microsoft
      &lt;/a&gt;
      und
      &lt;a href="http://browser.netscape.com/"&gt;
       Netscape
      &lt;/a&gt;
      .Angetrieben von der Motivation, den eigenen
      Browser zu stärken (
      &lt;em&gt;Browser War&lt;/em&gt;
      ), entstanden durch diese stark proprietären
      Erweiterungen inkompatible HTML-Abwandlungen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Weiterentwicklung der HTML - semantische
     Sprachanteile
    &lt;/title&gt;
    &lt;p&gt;
     Zunehmend wurden in die HTML immer mehr semantisch
     auszeichnende Elemente aufgenommen.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Zunächst wurde der Inhalt eines Dokuments rein
      darstellungsorientiert ausgezeichnet:



      &lt;ul&gt;
       &lt;li&gt;
        &lt;code&gt;b&lt;/code&gt;
        für Fettdruck
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;u&lt;/code&gt;
        für Unterstreichung
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;i&lt;/code&gt;
        für kursive Schrift
       &lt;/li&gt;
      &lt;/ul&gt;



     &lt;/li&gt;
     &lt;li&gt;
      Später begann man, die Bedeutung (semantik) des
      Dokumentinhalts auszuzeichnen:



      &lt;ul&gt;
       &lt;li&gt;
        &lt;code&gt;strong&lt;/code&gt;
        für stark hervorgehobenen, betonten Text
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;acronym&lt;/code&gt;
        zur Auszeichnung von Abkürzungen
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;address&lt;/code&gt;
        für Adressen
       &lt;/li&gt;
      &lt;/ul&gt;



     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Weiterentwicklung der HTML - Problem Semantik
    &lt;/title&gt;
    &lt;p&gt;
     Die Einführung semantischer Elemente in die HTML
     barg verschiedene Problematiken.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Präsentationsorientierte Auszeichnung stellt
      Benutzer der Sprache irgendwann zufrieden.
     &lt;/li&gt;
     &lt;li&gt;
      Semantische Auszeichnung ist nie ausreichend!
     &lt;/li&gt;
     &lt;li&gt;
      Gefahr, daß die Menge der Elemente ins
      unendliche wächst.
     &lt;/li&gt;
     &lt;li&gt;
      Schwierigkeit der Definition, Abstimmung und
      Verabschiedung der Bedeutung der einzelnen
      Elemente.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Semantik in der HTML war zum Scheitern verurteilt.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;SGML für das Web&lt;/title&gt;
    &lt;p&gt;
     Das 1994 gegründete World Wide Web Consortium, das
     seitdem für die Weiterentwicklung und
     Standardisierung der HTML verantwortlich zeichnet,
     suchte nach einer besseren Lösung zur semantischen
     Auszeichnung von Dokumentinhalten.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Rückgriff auf SGML als die Wurzel der HTML (wir
      erinnern uns: HTML ist eine Anwendung der SGML)
     &lt;/li&gt;
     &lt;li&gt;
      Eine Untermenge der SGML wurde als
      &lt;em&gt;
       &lt;a
        href="http://www.w3.org/TR/1998/REC-xml-19980210"&gt;
        eXtensible Markup Language (XML) 1.0
       &lt;/a&gt;
      &lt;/em&gt;
      als Vorschlag (Recommendation) vom W3C
      verabschiedet.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes XML-Dokument ist ein gültiges
      SGML-Dokument.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Die Entwicklungsziele für XML&lt;/title&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Einfache Nutzung im Internet (im Gegensatz zur
      SGML als offline Dokumentationsformat)
     &lt;/li&gt;
     &lt;li&gt;
      Unterstützung eines breiten Anwendungsspektrums
      (mehr als nur technische Dokumentation, wofür
      die SGML hauptsächlich genutzt wurde)
     &lt;/li&gt;
     &lt;li&gt;
      Kompatibilität zur SGML (XML als echte
      Untermenge von SGML kann durch SGML Tools
      verarbeitet werden)
     &lt;/li&gt;
     &lt;li&gt;
      Einfache Applikationsentwicklung (Untermenge XML
      erlaubt einfachere Entwicklung von
      verarbeitenden Applikationen)
     &lt;/li&gt;
     &lt;li&gt;
      Minimierung optionaler Sprachmerkmale
      (Komplexitätsreduktion führt zu einfacherer
      Benutzbarkeit und einfachere
      Applikationsentwicklung)
     &lt;/li&gt;
     &lt;li&gt;Lesbarkeit (für Mensch und Maschine)&lt;/li&gt;
     &lt;li&gt;
      Kompakte Spezifikation (600 Seiten SGML
      Spezifikation gegeüner 30 Seiten
      XML-Spezifikation)
     &lt;/li&gt;
     &lt;li&gt;
      Formaler und präziser Sprachentwurf
      (XML-Sprachentwurf sollte leicht, schnell und
      eindeutig in Werkzeuge implementierbar sein und
      damit von Anwendern schnell akzeptiert werden.)
     &lt;/li&gt;
     &lt;li&gt;
      Leichte Dokumenterstellung (ohne spezielle
      Werkzeuge möglich)
     &lt;/li&gt;
     &lt;li&gt;
      Nicht notwendigerweise knappes Markup
      (Auszeichnung in Textnotation im Fokus,
      Binärrepräsentation jedoch möglich.)
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;XML in 10 Punkten&lt;/title&gt;
    &lt;p&gt;
     Das W3C hat eine plakative Kurzcharakterisierung
     &lt;a
      href="http://www.w3c.de/Misc/XML-in-10-points.html"&gt;
      XML in 10 Punkten
     &lt;/a&gt;
     veröffentlicht, die als Abschluß unserer Einführung
     dienen soll.
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      XML steht für strukturierte Daten:
      &lt;br /&gt;
      XML ist ein Satz an Regeln für die Erstellung
      von Textformaten zur Strukturierung von Daten.
      XMl ist datenorientiert, nicht
      präsentationsorientiert. XML ist keine
      Programmiersprache und man kann es auch als
      Nicht-Programmierer anwenden und lernen. XML ist
      erweiterbar und plattformunabhängig.
     &lt;/li&gt;
     &lt;li&gt;
      XML sieht ein wenig wie HTML aus:
      &lt;br /&gt;
      Aufgrund der Verwandtschaft zur SGML ähneln sich
      die beiden Sprachen syntaktisch. Wie HTML
      verwendet XML Tags (durch
      &lt;code&gt;&amp;lt;&lt;/code&gt;
      und
      &lt;code&gt;&amp;gt;&lt;/code&gt;
      geklammerte Wörter). In der HTML sind jedoch die
      Bedeutung der Tags und Attribute festgelegt, in
      der XML werden diese nur zur Abgrenzung der
      Daten verwendet. Die Interpretation obliegt
      allein der verarbeitenden Anwendung.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist Text, aber nicht zum Lesen:
      &lt;br /&gt;
      Primärer Zweck des Einsatzes der XML ist der
      Datenaustausch zwischen Maschinen. Menschen
      können die XML sicherlich lesen, sollten dies
      aber eigentlich nicht tun (nur im "Notfall" oder
      wenn sie die XML lernen ;-) )
     &lt;/li&gt;
     &lt;li&gt;
      XML ist vom Design her ausführlich:
      &lt;br /&gt;
      Gemeint ist, daß XML ein verboses
      (=geschwätziges) Format ist. Das W3C
      argumentiert, daß heute Speicherplatz günstig
      ist wie noch nie und Komprimierungsverfahren
      gang und gäbe sind. Dennoch sind XML-Dateien
      aufgrund ihrer Textbasiertheit immer größer als
      entsprechende Binärformate, dies kann man nicht
      abstreiten. Die Verwendung von XML birgt jedoch
      so viele Vorteile, daß dieser Nachteil mehr als
      ausgeglichen wird.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist eine Familie von Techniken:
      &lt;br /&gt;
      Hinter XML steht ein wachsender Satz an Modulen,
      die wichtige Aufgaben erledigen. In ihrer
      Gesamtheit sind sie sehr mächtig. Dazu gehören
      bspw.
      &lt;a href="http://www.w3.org/TR/xlink/"&gt;XLink&lt;/a&gt;
      für Hyperlinks in XML-Dokumenten, das
      &lt;a
       href="http://www.w3.org/TR/xptr-framework/"&gt;
       XPointer
      &lt;/a&gt;
      Framework für den Zugriff auf Teile eines
      XML-Dokuments, die
      &lt;a href="http://www.w3.org/TR/xsl/"&gt;
       Extensible Stylesheet Language (XSL)
      &lt;/a&gt;
      , bestehend aus
      &lt;a href="http://www.w3.org/TR/xslt20/"&gt;
       XSL Transformations (XSLT)
      &lt;/a&gt;
      , einer Sprache zur Transformation von
      XML-Dokumenten, und einem XML-Vokabular zur
      Spezifizierung von Formatierungsangaben
      (Stylesheets) sowie
      &lt;a href="http://www.w3.org/TR/xmlschema-1/"&gt;
       XML Schema, Teil 1
      &lt;/a&gt;
      und
      &lt;a href="http://www.w3.org/TR/xmlschema-2/"&gt;
       Teil 2
      &lt;/a&gt;
      zur genauen Definition der Daten in einem
      eigenen XML-basierten Format.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist neu, aber nicht so neu:
      &lt;br /&gt;
      XML erhebt nicht den Anspruch, vollkommen neu zu
      sein. Vielmehr werden bekannte und erprobte
      Konzepte aus der Informatik wiederverwendet und
      in einem neuen Verwendungskontext
      weiterentwickelt.
     &lt;/li&gt;
     &lt;li&gt;
      XML überführt HTML in XHTML:
      &lt;br /&gt;
      XHTML hat gleich viele Elemente wie HTML, die
      Syntax ist aber ein wenig unterschiedlich, damit
      sie mit den XML-Regeln konform ist. XML löst die
      Abhängigkeit der HTML von der SGML auf, HTML
      wird auf der Basis von XML neu formuliert.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist modular:
      &lt;br /&gt;
      XML erlaubt die Wiederverwendung von Formaten
      (Kombination und Weiterbenutzung) für die
      Definition eines neuen Formats. Sprachen aus der
      XML-Familie können in freier Auswahl zur Lösung
      von Problemen verwendet werden.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist die Basis für RDF und das Semantic Web:
      &lt;br /&gt;
      Das
      &lt;a href="http://www.w3.org/RDF/"&gt;
       Resource Description Framework (RDF)
      &lt;/a&gt;
      ist eine XML-basierte Sprache, um beliebige
      Quellen mit beschreibenden Daten anzureichern.
      Das Semantic Web nutzt diese Beschreibungen, um
      den sichtbaren Teil des Web mit einem Netz von
      Sinnzusammenhängen zu erweitern. Für
      Vereinbarungen über diese Sinnzusammenhänge (die
      Computer benötigen) werden überdies formale
      Beschreibungen, sogenannte
      &lt;em&gt;Ontologien&lt;/em&gt;
      benötigt.
     &lt;/li&gt;
     &lt;li&gt;
      XML ist lizenzfrei, plattformunabhängig und gut
      unterstützt:
      &lt;br /&gt;
      Zunächst ist XML eine kostenfrei zugängliche
      Spezifikation, die ohne Lizenzgebühren in
      eigenen Projekten und kommerziellen Produkten
      verwendet werden kann. Die Standardisierung in
      einem herstellerunabhängigen Gremium ist ein
      Versuch sicherzustellen, daß die Unabhängigkeit
      von einer bestimmten Plattform gewahrt werden
      kann. Zudem gibt es mittlerweile eine beinahe
      unüberschaubar große Menge an XML-Tools für die
      unterschiedlichsten Einsatzzwecke.
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Weiterführende Links&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Stefan Mintert:
      &lt;a
       href="http://mintert.com/xml/leise-revolution/leise_revolution.html"&gt;
       Leise Revolution: Die Standard Generalized
       Markup Language
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://xml.coverpages.org/foottLect08.html"&gt;
       Tutorial zu SGML
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;

 &lt;presentation id="wohlgeformtheit"&gt;
  &lt;title short="dokumente-und-wohlgeformtheit"&gt;
   XML-Dokumente und Wohlgeformtheit
  &lt;/title&gt;
  &lt;date&gt;2008-10-13&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Nach einer einführenden Übersicht über die einzelnen
   Mitglieder der XML-Sprachfamilie werden in diesem Abschnitt
   die grundlegenden Strukturelemente der XML und des XML
   Information Set eingeführt.
   &lt;br /&gt;
   Sie erfahren, welche Strukturelemente es in der XML gibt und
   was die Wohlgeformtheit eines XML-Dokuments bedeutet.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;Die XML Sprachfamilie&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition XML-Sprache&lt;/title&gt;
    &lt;p class="definition"&gt;
     Eine Anwendung der XML wird XML-Sprache genannt. Sie
     besteht aus einem Vokabular, das aus Symbolen und
     der ihnen zugewiesenen Bedeutung (Semantik) gebildet
     wird. Das Vokabular wird durch Regeln ergänzt, die
     die Kombination der Elemente aus dem Vokabular
     steuern: die grammatikalische Struktur sowie die
     Gültigkeitsregeln für den Inhalt (z.B. Datentypen).
     &lt;br /&gt;
     Eine Anwendung einer neu geschaffenen XML-Sprache
     &lt;em&gt;L&lt;/em&gt;
     werden als XML-Dokumente, auch
     &lt;em&gt;L&lt;/em&gt;
     -Dokumente bezeichnet.
    &lt;/p&gt;
    &lt;note&gt;
     Beispiele: XHTML-Dokument, SVG-Dokument,
     XSL-Dokument
    &lt;/note&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Die XML-Sprachfamilie&lt;/title&gt;
    &lt;img
     style="margin : 0% ; width : 4% ; position: absolute; right:25px; top: 25px; float:right; "
     src="languageFamily.gif" /&gt;
    &lt;note&gt;
     Die Abbildung markiert farblich alle Standards, zu
     denen eine XML Darstellung existiert.
    &lt;/note&gt;
    &lt;ul&gt;
     &lt;li&gt;Basis&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;a
        href="http://www.w3.org/TR/xml-infoset/index.html"&gt;
        XML Information Set
       &lt;/a&gt;
       , definiert die Grundbausteine und zentralen
       Konzepte der XML
      &lt;/li&gt;
      &lt;li&gt;
       &lt;a href="http://www.unicode.org/"&gt;
        Unicode
       &lt;/a&gt;
       , ein Standard zur plattformunabhängigen
       Zeichencodierung u.a. internationaler
       Zeichensätze
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Dokumenttypdefinitionen (DTDs): Als Untermenge
      der SGML definiert, besitzt die XML wie diese
      die Möglichkeit der Grammatikdefinition via DTDs
      (=eine textbasierte Sprache, um das Vokabular
      einer XML-Sprache festzulegen).
     &lt;/li&gt;
     &lt;li&gt;XML selbst&lt;/li&gt;
     &lt;li&gt;
      XML Namensräume (Namespaces): mit ihrer Hilfe
      können gleiche Namen von Bezeichnern in einem
      Dokument eindeutig voneinander unterschieden
      werden. Somit kann jeder, der eine XML-Sprache
      definiert, Element- und Attributnamen völlig
      frei wählen. Er muß nicht darauf achten, ob sein
      Dokument irgendwann einmal mit einem anderen
      Dokument kombiniert werden könnte (etwa im
      Rahmen einer Syndikatisierung) und dann
      Namenskonflikte auftreten könnten.
     &lt;/li&gt;
     &lt;li&gt;
      XHTML: eine präsentationsorientierte
      Auszeichnungssprache (die
      Weiterentwicklung/Neuformulierung der HTML 4.01
      aus dem Jahre 1999, die durch das W3C nicht mehr
      weiterentwickelt wird).
     &lt;/li&gt;
     &lt;li&gt;
      XLink: Verknüpfungsmechanismus zur nichtlinearen
      Navigierbarkeit. Erlaubt mehrgliedrige Verweise,
      die auf eine Menge von Dokumenten verweisen,
      sowie unterschiedliche Verhaltensmuster beim
      Verfolgen eines Links. Entspricht dem
      Referenzieren einzelner Dokumente in einem
      XML-Dokument.
     &lt;/li&gt;
     &lt;li&gt;
      XPath: Ermöglicht das extrahieren verschiedener
      Information aus einem XML-Dokument:
      Knotenmengen, Positionsangaben, Werte, ...
     &lt;/li&gt;
     &lt;li&gt;
      XSLT: XML-Sprache zur Umformung von
      XML-Dokumenten (eigentlich: Bäumen).
     &lt;/li&gt;
     &lt;li&gt;
      XSL-FO: Ein Vokabular, um Formatierungsangaben
      für Dokumentstrukturen auszudrücken. Daraus
      können wiederum beispielsweise PDF-Dokumente
      erzeugt werden.
     &lt;/li&gt;
     &lt;li&gt;
      XQuery: Eine SQL-artige algebraische
      Anfragesprache für XML-Quellen. Die
      XML-Repräsentation von XQuery trägt den Namen
      &lt;a href="http://www.w3.org/TR/xqueryx/"&gt;
       XQueryX
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      RDF verwendet Namensräume als Grundlagen.
      Erlaubt die Formulierung und maschinelle
      Auswertung von Aussagen über Web Ressourcen
      (Prädikatenlogik).
     &lt;/li&gt;
     &lt;li&gt;
      XML Schema stellt u.a. ein Typsystem und eine
      Vielzahl von Regeln zur Verfügung, damit eine
      XML-Sprache genau definiert werden kann.
     &lt;/li&gt;
     &lt;li&gt;
      Schema verwendend haben WSDL und SOAP im Bereich
      Web Services große Bedeutung erlangt. Mit WSDL
      werden die Schnittstellen sowie die
      Eigenschaften von Funktionalitäten (=Diensten /
      Services) beschrieben, die über
      Internetprotokolle zur Verfügung gestellt
      werden. SOAP erlaubt die Übertragung von
      XML-basierten Nachrichten unabhängig vom
      verwendeten Transportprotokoll.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;
    Strukturelle Grundkonzepte: Die Extensible Markup
    Language (XML) und das XML Information Set (1)
   &lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Einführende Definitionen (1/3)&lt;/title&gt;
    &lt;p class="definition"&gt;
     XML-Dokument
     &lt;br /&gt;
     Ein XML-Dokument ist ein Datenstrom (der nicht
     zwingend als Datei vorliegen muß), der den
     Strukturierungsprinzipien (=Wohlgeformtheit) der
     Extensible Markup Language genügt.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Einführende Definitionen (2/3)&lt;/title&gt;
    &lt;p class="definition"&gt;
     XML Information Set
     &lt;br /&gt;
     Die Spezifikation des XML Information Sets definiert
     die zentralen Begriffe der XML. Es setzt diese
     Begriffe miteinander in Beziehung und definiert so
     unabhängig von der Syntax die Struktur eines
     XML-Dokumentes.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Einführende Definitionen (3/3)&lt;/title&gt;
    &lt;p class="definition"&gt;
     XML-Prozessor
     &lt;br /&gt;
     Ein XML-Prozessor ist eine maschinelle Komponente
     (typischerweise: Software), die zum Lesen, Speichern
     und Verarbeiten eines XML-Dokuments eingesetzt wird.
     Er erlaubt Zugriff auf den Inhalt und die Struktur
     des XML-Dokuments.
    &lt;/p&gt;
    &lt;note&gt;
     Ein XML-Prozessor ist zumeist in Software
     implementiert, kann aber auch in Hardware realisiert
     sein.
    &lt;/note&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Ein erstes XML-Dokument&lt;/title&gt;
    &lt;p&gt;
     Das folgende Listing zeigt ein einfaches
     XML-Dokument mit den am meisten verwendeten
     Sprachelementen der XML: Element, Attribut, Text.
    &lt;/p&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="1-11" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Das Information Set des ersten XML-Dokuments
    &lt;/title&gt;
    &lt;p&gt;
     Für jedes XML-Dokument gibt es ein abstraktes
     Information Set (auch kurz als "Infoset"
     bezeichnet). In ihm sind alle Informationselemente
     in Form einer Baumstruktur enthalten.
     &lt;br /&gt;
     Die untenstehende Abbildung gibt einen Auszug der
     Knoten aus dem Information Set unseres ersten
     XML-Dokuments in einem UML-Diagramm wieder. Die
     Knoten sind als Objekte, ihre Eigenschaften als
     Attribute dargestellt.
    &lt;/p&gt;
    &lt;img
     style="margin : 4% ;"
     src="Infoset-erstes-Beispiel.png" /&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="1-11" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Ein erstes XHTML-Dokument&lt;/title&gt;
    &lt;p&gt;
     Im folgenden Beispiel ist der Inhalt des ersten
     XML-Dokuments als einfache XHTML Seite dargestellt.
     &lt;br /&gt;
     Sprachelemente der XHTML: Titel, Überschriften 1.
     und 2. Grades, Absatz.
    &lt;/p&gt;
    &lt;listing src="erstes-XML-dokument-html-beispiel.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Die Elemente des Information Set&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;b&gt;Document Information Item (Dokument)&lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;Element Information Item (Element)&lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;Attribute Information Item (Attribut)&lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;Character Information Item (Zeichen)&lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;Comment Information Item (Kommentar)&lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;
       Document Type Declaration Information Item
       (DTD-Deklaration)
      &lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;b&gt;
       Namespace Declaration Information Item
       (Namensraum-Deklaration)
      &lt;/b&gt;
     &lt;/li&gt;
     &lt;li&gt;Processing Instruction Information Item&lt;/li&gt;
     &lt;li&gt;Notation Information Item&lt;/li&gt;
     &lt;li&gt;
      Unexpanded Entity Reference Information Item
     &lt;/li&gt;
     &lt;li&gt;Unparsed Entity Information Item&lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Document Information Item (Dokument)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Jedes Information Set hat genau ein Document
      Information Item
     &lt;/li&gt;
     &lt;li&gt;Rahmen des XML-Dokuments&lt;/li&gt;
     &lt;li&gt;
      enthält Informationen, die das gesamte Dokument
      betreffen
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       geordnete Liste von
       &lt;em&gt;Kindknoten&lt;/em&gt;
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        darunter genau ein
        &lt;code&gt;Element Information Item&lt;/code&gt;
        , nämlich das Wurzelelement des
        Dokuments (auch
        &lt;em&gt;Document Element&lt;/em&gt;
        genannt).
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;
         Processing Instruction Information
         Item
        &lt;/code&gt;
        s, für alle Processing Instructions, die
        außerhalb des Wurzelelements definiert
        sind. Processing Instructions geben
        einem XML-Prozessor Informationen zur
        Verarbeitung des Dokuments.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;Comment Information Item&lt;/code&gt;
        s für Kommentare außerhalb des
        Wurzelelements.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;li&gt;
       &lt;em&gt;Document Element&lt;/em&gt;
       : Der Wurzelknoten des Dokuments als
       &lt;code&gt;Element Information Item&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Notations&lt;/em&gt;
       : eine ungeordnete Menge von
       &lt;code&gt;Notation Information Items&lt;/code&gt;
       , die in einer DTD des Dokuments (sofern
       vorhanden) definiert wurden.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Unparsed Entities&lt;/em&gt;
       : eine ungeordnete Menge von
       &lt;code&gt;
        Unparsed Entity Information Items
       &lt;/code&gt;
       . Ein Parser ist ein Programm, das eine
       Syntaxanalyse eines Eingabestroms ausführt.
       Entities kann man einfach umschreiben als
       "Kürzel", diese Kürzel werden vom Parser
       dann durch einen definierten Wert ersetzt.
       Nicht geparste Entitäten sind Informationen,
       die nicht durch den Parser analysiert
       werden, da sie üblicherweise nicht im
       XML-Format vorliegen (z.B. Binärdaten).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Base URI&lt;/em&gt;
       : Eine URI (zur
       &lt;a
        href="http://www.ietf.org/rfc/rfc2396.txt?number=2396"&gt;
        entsprechenden Spezifikation, RFC 2396
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Character Encoding Scheme&lt;/em&gt;
       : Die Zeichenkodierung (z.B.
       &lt;code&gt;ISO-8859-1&lt;/code&gt;
       ,
       &lt;code&gt;ISO-2022-JP&lt;/code&gt;
       ,
       &lt;code&gt;UTF-8&lt;/code&gt;
       ), in der das Dokument gehalten ist (zur
       &lt;a
        href="http://www.iana.org/assignments/character-sets"&gt;
        Liste international standardisierter
        Zeichenkodierungen
       &lt;/a&gt;
       ). Der Wert wird aus dem XML-Prolog des
       Dokuments übernommen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Standalone&lt;/em&gt;
       : Legt fest, ob es externe
       Markup-Deklarationen gibt, die Einfluß auf
       das XML-Dokument haben, bevor es vom Parser
       an eine Applikation übergeben wird.
       Beispiel: vordefinierte
       default-Attributwerte. Der Wert wird aus dem
       XML-Prolog des Dokuments übernommen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Version&lt;/em&gt;
       : Die verwendete XML-Version (1.0 oder 1.1).
       Der Wert wird aus dem XML-Prolog des
       Dokuments übernommen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;All Declarations Processed&lt;/em&gt;
       : Diese Eigenschaft ist streng genommen
       nicht Bestandteil des Infoset.Der Boole'sche
       Wert zeigt an, ob der verarbeitende
       Prozessor die gesamte DTD gelesen hat.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Der XML-Prolog&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;erste Zeile in einem XML-Dokument.&lt;/li&gt;
     &lt;li&gt;
      in der XML 1.0 optional, in der XML 1.1
      hingegend zwingend vorgeschrieben
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="1" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die Angabe der verwendeten XML-Version ist
      zwingend. Für XML 1.0 ist der Wert
      &lt;code&gt;1.0&lt;/code&gt;
      anzugeben, für XML 1.1 entsprechend
      &lt;code&gt;1.1&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Optional folgt die Angabe der im Dokument
      verwendeten Zeichenkodierung. Hierbei wird
      empfohlen, daß nur bei der
      &lt;a href="http://www.iana.org/"&gt;
       Internet Assigned Numbers Authority (IANA)
      &lt;/a&gt;
      als Zeichensatz registrierte Zeichenkodierungen
      verwendet werden. Andere Kodierungen sollen
      durch das einführende Präfix
      &lt;code&gt;x-&lt;/code&gt;
      im Namen kenntlich gemacht werden.
     &lt;/li&gt;
     &lt;li&gt;
      Ebenfalls optional folgt hierauf die Standalone
      Document Declaration.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Document Information Item - Beispiel XHTML Dokument
    &lt;/title&gt;
    &lt;p&gt;
     Das Document Information Item des ersten XHTML
     Beispiels beinhaltet folgende Informationen
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das Element Information Item
      &lt;code&gt;html&lt;/code&gt;
      als Wurzelelement des Dokuments
     &lt;/li&gt;
     &lt;li&gt;
      Das gleiche Element Information Item als
      einziges Element einer
      &lt;em&gt;geordneten Reihe von Kindknoten&lt;/em&gt;
     &lt;/li&gt;
     &lt;li&gt;Die in der XHTML DTD definierten Notations&lt;/li&gt;
     &lt;li&gt;
      Die Basis URI des Dokuments:
      &lt;code&gt;
       http://www.barbara-zengler.de/vorlesung/erstes-XML-dokument-html-beispiel.xml
      &lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Die im Dokument verwendete Zeichenkodierung:
      &lt;code&gt;UTF-8&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Standalone:
      &lt;code&gt;no&lt;/code&gt;
      , denn es gibt eine DTD zu diesem Dokument, die
      eventuell Vorbelegungen für Attributwerte
      definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Die im Dokument verwendete XML-Version
      &lt;code&gt;1.0&lt;/code&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="erstes-XML-dokument-html-beispiel.xml" /&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Automatische Zeichensatzerkennung (1/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Bevor ein XML-Prozessor die
      XML-Encoding-Deklaration in einem Dokument
      überhaupt erst lesen kann, muß er wissen, welche
      Zeichenkodierung verwendet wird. Genau das aber
      wird erst in der Deklaration mitgeteilt. Hier
      "beißt sich die Katze in den Schwanz".
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="3" /&gt;
    &lt;ul&gt;
     &lt;li&gt;Ausweg durch automatische Zeichenerkennug.&lt;/li&gt;
     &lt;lI&gt;
      XML Prozessoren versuchen, anhand der ersten
      bekannten fünf Zeichen (Position und Inhalt der
      Zeichen ist festgelegt!) den Zeichensatz des
      Dokuments zu erkennen.
     &lt;/lI&gt;
     &lt;li&gt;
      Die Wahrscheinlichkeit, daß dies funktioniert,
      ist relativ hoch.
     &lt;/li&gt;
     &lt;note&gt;
      Man geht davon aus, daß XML-Prozessoren nicht
      alle möglichen Kodierungen verstehen sondern nur
      eine begrenzte Menge davon.
     &lt;/note&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Automatische Zeichensatzerkennung (2/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die folgenden Zeilen zeigen einen Auszug aus der
      XML-Grammatik, notiert in einer erweiterten
      Backus-Naur-Form (EBNF)
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="1-11" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;code&gt;A*&lt;/code&gt;
      : Null oder mehrere Vorkommen von A
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;A?&lt;/code&gt;
      : A oder nichts (optional A)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;A|B&lt;/code&gt;
      : A oder B
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;A+&lt;/code&gt;
      : Ein oder mehrere Vorkommen von A
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unicode&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Unicode ist ein Industriestandard, um
      verschiedene Alphabete und grafische Zeichen
      darzustellen.
     &lt;/li&gt;
     &lt;li&gt;
      Drei verschiedene Codierungsformate: UTF-8,
      UTF-16 und UTF-32
     &lt;/li&gt;
     &lt;li&gt;
      UTF-8: byteorientierte Version des
      Unicode-Standards mit variabler Codierungslänge.
      Die bekannten ASCII-Zeichen liegen werden mit
      den ersten 8 Bit dargestellt und benötigen so
      wenig Speicherplatz.
     &lt;/li&gt;
     &lt;li&gt;
      UTF-16: in 16 Bit codiert, ermöglicht dieser
      Standard unter Zuhilfenahme sogenannter
      "Surrogate" die Codierung von 1.114.111 Zeichen.
      Variable Codierungslänge.
     &lt;/li&gt;
     &lt;li&gt;
      UTF-32: mit einer festen Breite von 32 Bit
      erhöhrt UTF-32 den für ein Dokument benötigten
      Speicherplatz, erleichtert jedoch die
      Implementierung der Zeichencodierung und
      -decodierung.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Platzbedarf der verschiedenen Codierungsformate
    &lt;/title&gt;
    &lt;p&gt;
     Nachstehende Tabelle zeigt einen Überblick über den
     Platzbedarf des Zeichens
     &lt;code&gt;A&lt;/code&gt;
     in den verschiedenen Codierungsformaten, sowie die
     Größe der Beispieldate in Byte
    &lt;/p&gt;
    &lt;table
     border="1"
     cellpadding="20"&gt;
     &lt;tr&gt;
      &lt;th
       align="left"
       valign="middle"&gt;
       Codierung
      &lt;/th&gt;
      &lt;th
       align="left"
       valign="middle"&gt;
       Bitbreite
      &lt;/th&gt;
      &lt;th
       align="left"
       valign="middle"&gt;
       Binärdarstellung
      &lt;/th&gt;
      &lt;th
       align="left"
       valign="middle"&gt;
       Größe der Beispieldatei in Byte
      &lt;/th&gt;
      &lt;th
       align="left"
       valign="middle"&gt;
       Bemerkung
      &lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;erweitertes ASCII (Latin-1), ISO-8859-1&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;0100 0001&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;266&lt;/td&gt;
      &lt;td&gt;
       (
       &lt;code&gt;encoding="ISO-8859-1"&lt;/code&gt;
       )
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;UTF-8&lt;/td&gt;
      &lt;td&gt;&amp;gt;=8&lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;0100 0001&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;266&lt;/td&gt;
      &lt;td&gt;
       (
       &lt;code&gt;encoding="UTF-8"&lt;/code&gt;
       ) keine Byte Order Mark
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;UTF-16&lt;/td&gt;
      &lt;td&gt;&amp;gt;=16&lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;0100 0001 0000 0000&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;532&lt;/td&gt;
      &lt;td&gt;
       (
       &lt;code&gt;encoding="UTF-16"&lt;/code&gt;
       ) keine Byte Order Mark
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;UTF-32&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        0100 0001 0000 0000 0000 0000 0000 0000
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;1.064&lt;/td&gt;
      &lt;td&gt;
       (
       &lt;code&gt;encoding="UTF-32"&lt;/code&gt;
       ) keine Byte Order Mark
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Mimik der UTF-8 Codierung&lt;/title&gt;
    &lt;p&gt;
     Die Nachfolgende Tabelle zeigt die Anwendung der
     UTF-8 Kodierung
    &lt;/p&gt;
    &lt;table
     border="1"
     cellpadding="20"&gt;
     &lt;tr&gt;
      &lt;th&gt;Unicode-Bereich&lt;/th&gt;
      &lt;th&gt;Bitbelegung&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-00000000 - U-0000007F&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;0xxxxxxx&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-00000080 - U-000007FF&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;110xxxxx 10xxxxxx&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-00000800 - U-0000FFFF&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-00010000 - U-001FFFFF&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-00200000 - U-03FFFFFF&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        10xxxxxx
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;U-04000000 - U-7FFFFFFF&lt;/code&gt;
       :
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;

        1111110x 10xxxxxx 10xxxxxx 10xxxxxx
        10xxxxxx 10xxxxxx
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Wahl des Codierungsformats in der Praxis&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die Wahl des Codierungsformats hat Einfluß auf
      die Dateigröße.
     &lt;/li&gt;
     &lt;li&gt;
      Umlaute werden in UTF-8 mit 16 Bit dargestellt.
     &lt;/li&gt;
     &lt;li&gt;Für die Praxis: guten Kompromiß finden.&lt;/li&gt;
     &lt;li&gt;
      Für Dokumente im deutschen Sprachraum hat sie
      die Verwendung von
      &lt;code&gt;ISO-8859-1&lt;/code&gt;
      (latin-1) eingebürgert. Problem: Dieser
      Zeichensatz unterstützt nicht das Euro-Symbol.
      Erst eine aktualisierte Version des
      Zeichensatzes mit dem Namen
      &lt;code&gt;ISO-8859-1&lt;/code&gt;
      hat das Eurozeichen mit an Bord.
     &lt;/li&gt;
     &lt;li&gt;
      Bei zumeist ASCII Zeichen und nur vereinzelten
      Sonderzeichen: UTF-8 (flexibel!).
     &lt;/li&gt;
     &lt;li&gt;
      Bei überwiegend Nicht-ASCII-Zeichen (z.B.
      russische, chinesische, arabische Dokumente)
      besser UTF-16
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel arabisches Dokument&lt;/title&gt;
    &lt;p&gt;
     Auf dieser Seite sehen Sie ein arabisches Dokument,
     das die unterschiedlichen Dateigrößen je nach
     gewähltem Codierungsformat noch einmal
     veranschaulichen soll.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;UTF-8-Codierung: 1299 Byte&lt;/li&gt;
     &lt;li&gt;UTF-16-Codierung: 966 Byte&lt;/li&gt;
    &lt;/ul&gt;
    &lt;img
     style="margin : 4% ;"
     src="arabicDocument.gif" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Element Information Item&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Für jedes Element in einem XML-Dokument gibt es
      ein Element Information Item
     &lt;/li&gt;
     &lt;li&gt;
      Ein Element aus dieser Menge entspricht der
      &lt;em&gt;Document Element&lt;/em&gt;
      -Eigenschaft des
      &lt;code&gt;Document Information Item&lt;/code&gt;
      , es entspricht dem Wurzelknoten des Dokuments.
     &lt;/li&gt;
     &lt;li&gt;
      Auf alle anderen
      &lt;code&gt;Element Information Item&lt;/code&gt;
      s eines Dokuments kann zugegriffen werden, indem
      rekursiv die
      &lt;em&gt;Kindknoten&lt;/em&gt;
      besucht werden.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       geordnete Liste von
       &lt;em&gt;Kindknoten&lt;/em&gt;
       (keine Attribute!)
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Namespace Name&lt;/em&gt;
       : die Identifikation des Namensraums, in dem
       sich das Element befindet.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Lokaler Name&lt;/em&gt;
       : entspricht dem (um Namensraumkürzel und
       trennenden Doppelpunkt gekürzten)
       Elementnamen
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Präfix&lt;/em&gt;
       : das Namensraumkürzel, das zusammen mit dem
       Local Name den kompletten Elementnamen
       bildet. Dient der Identifikation eines
       Elements.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Attribute&lt;/em&gt;
       : ungeordnete Menge von
       &lt;em&gt;Attribute Information Item&lt;/em&gt;
       s. Für jedes Attribut eines Elements, ob
       explizit spezifiziert oder von einer DTD
       übernommen, existiert ein Attribute
       Information Item. Namensraumdeklarationen
       erscheinen hier nicht.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Namespace Attribute&lt;/em&gt;
       : ungeordnete Menge von
       &lt;code&gt;Attribute Information Item&lt;/code&gt;
       s, eines für jede Namensraumdeklaration
       dieses Elements.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;In-Scope Namespaces&lt;/em&gt;
       : ungeordnete Menge von
       &lt;code&gt;Namespace Information Items&lt;/code&gt;
       für jeden Namensraum, der für das aktuelle
       Element gültig ist.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Base URI&lt;/em&gt;
       : die Basis URI des Elements.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Parent&lt;/em&gt;
       : Dasjenige
       &lt;code&gt;Document Information Item&lt;/code&gt;
       oder
       &lt;code&gt;Element Information Item&lt;/code&gt;
       , in dessen
       &lt;em&gt;Kindknoten&lt;/em&gt;
       das aktuelle Element enthalten ist.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Aufbau eines Elementnamens&lt;/title&gt;
    &lt;p&gt;
     Die Listings zeigen Elemente aus unseren
     Beispieldokumenten.
    &lt;/p&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="5-6" /&gt;
    &lt;listing
     src="erstes-XML-dokument-html-beispiel.xml"
     line="8-14" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Grenzen eines Elements:
      &lt;em&gt;Startmarke&lt;/em&gt;
      und
      &lt;em&gt;Endmarke&lt;/em&gt;
      (engl.
      &lt;em&gt;Tag&lt;/em&gt;
      ). Mit den Tagnamen werden die Typen eines
      Dokuments definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Sonderfall leeres Element: Startmarke ist
      gleichzeitig Endmarke. Ein leeres Element
      besitzt folglich keine Kindknoten.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="4" /&gt;

   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Information eines Element Information Items am
     Beispiel
    &lt;/title&gt;
    &lt;listing src="erstes-XML-dokument.xml" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das Element Information Item des Elements
      &lt;code&gt;Studiengang&lt;/code&gt;
      beinhaltet folgende Informationen:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Liste von Kindknoten: Drei Character
       Information Items. Sie formen die
       Zeichenkette
       &lt;code&gt;IAM&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;Namensraum-Name: leer&lt;/li&gt;
      &lt;li&gt;Lokaler Name: Studiengang&lt;/li&gt;
      &lt;li&gt;Präfix: keines&lt;/li&gt;
      &lt;li&gt;
       Ein Attribute Information Item für das
       Attribut
       &lt;code&gt;semester&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Kein Namensraum-Attribut, da keine
       Namensraumdeklaration für das Element
       vorhanden (auch nicht für ein Elternelement,
       von dem es diese erben könnte).
      &lt;/li&gt;
      &lt;li&gt;In-Scope Namespaces: leere Menge.&lt;/li&gt;
      &lt;li&gt;
       Basis-URI:
       &lt;code&gt;
        http://www.barbara-zengler.de/vorlesung/erstes-XML-dokument.xml
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Parent: Das Element Information Item
       (gleichzeitig Document Information Item) des
       Elements
       &lt;code&gt;Vorlesung&lt;/code&gt;
       .
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;

   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Aufbau eines Elementnamens&lt;/title&gt;
    &lt;p&gt;Grammatik des Start-Tags:&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="14-15" /&gt;
    &lt;p&gt;Grammatik des Ende-Tags:&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="16" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Aufbau eines Elementnamens&lt;/title&gt;
    &lt;p&gt;Grammatik der Elementnamen:&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="19-24" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Aufbau der Elementnamen ähnlich wie Regeln aus
      den Programmiersprachen.
     &lt;/li&gt;
     &lt;li&gt;
      Beginn mit einem Buchstaben, Doppelpunkt oder
      Unterstrich.
     &lt;/li&gt;
     &lt;li&gt;
      Danach folgen beliebige für Namen zugelassene
      Zeichen.
     &lt;/li&gt;
     &lt;li&gt;
      Leerzeichen und
      &lt;em&gt;white spaces&lt;/em&gt;
      (z.B. Zeilenumbruch) sind in Namen nicht
      zugelassen!
     &lt;/li&gt;
     &lt;li&gt;
      Auch öffnende und schließende Winkelklammern
      sind nicht erlaubt.
     &lt;/li&gt;
     &lt;li&gt;
      Ein Doppelpunkt ist zwar erlaubt, sollte aber
      nicht verwendet werden, weil er bei der
      Verwendung von Namensräumen das Namenskürzel vom
      Elementnamen trennt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Kleiner Vorgeschmack: Element mit Namensraum
    &lt;/title&gt;
    &lt;p&gt;
     Zur Verdeutlichung der Sonderstellung des
     Doppelpunkts ist hier ein Beispiel für ein Element
     mit deklarierten Namensraum aufgeführt:
    &lt;/p&gt;
    &lt;listing
     src="Element-mit-Namensraum.xml"
     line="1-6" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Im Start-Tag des Elements
      &lt;code&gt;aParent&lt;/code&gt;
      wird der Namensraum
      &lt;code&gt;example.com&lt;/code&gt;
      definiert und dem Kürzel
      &lt;code&gt;myNS&lt;/code&gt;
      zugewiesen.
     &lt;/li&gt;
     &lt;li&gt;
      In Elternelementen deklarierte Bindungen von
      Namensräume an Kürzel stehen den Kindelementen
      automatisch zur Verfügung.
     &lt;/li&gt;
     &lt;li&gt;
      Das Element Information Item
      &lt;code&gt;anElement&lt;/code&gt;
      ergibt sich hiermit aus:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;local name: aElement&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;namespace URI: example.com&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;prefix: myNS&lt;/code&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Nähere Ausführungen zu Namensräumen in der
      nächsten Vorlesung.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Tag vs. Element&lt;/title&gt;
    &lt;p&gt;
     Oftmals werden die Begriffe
     &lt;em&gt;Tag&lt;/em&gt;
     und
     &lt;em&gt;Element&lt;/em&gt;
     synonym verwendet. Dies ist jedoch nicht korrekt!
    &lt;/p&gt;
    &lt;p&gt;
     Ein
     &lt;em&gt;Tag&lt;/em&gt;
     drückt lediglich den Namen eines Elements aus und
     liefert damit Information, die die Natur des
     Elements beschreibt. Dies kann durch beliebige
     erlaubte Zeichenketten geschehen, meistens trifft
     man jedoch sogenannte
     &lt;em&gt;sprechende Tags&lt;/em&gt;
     an.
     &lt;br /&gt;

     Ein Tag hat im Gegensatz zu einem Element keine
     Eltern- oder Kindknoten, etc. Es ist nur ein
     Bezeichner.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Semistrukturierte Information&lt;/title&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="1-11" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verschiedenartige Strukturierungsmöglichkeiten
      in einem XML-Dokument
     &lt;/li&gt;
     &lt;li&gt;
      Starke Verwendung von Elementen und Attributen
      führt zu stark strukturierter Darstellung von
      Daten
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;eingestreuter Freitext&lt;/q&gt;
      ist möglich:
      &lt;q&gt;Semistrukturierung&lt;/q&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Im Beispiel: rein zeichenkettenartiger Inhalt in
      den Elementen
      &lt;code&gt;Hochschule&lt;/code&gt;
      und
      &lt;code&gt;Titel&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Vorlesung&lt;/code&gt;
      mischt strukturierten Inhalt (Kindelemente) und
      unstrukturierte Information (Text
      &lt;code&gt;Montag, 15:40h - 18:50h&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      In der XML-Sprache wird dies als
      &lt;em&gt;mixed Content&lt;/em&gt;
      bezeichnert Charakteristisch für viele
      XML-Dokumente.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Attribute&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In unserem Beispiel ist auch ein Attribut
      enthalten (
      &lt;code&gt;semester="3"&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Attribute werden als Namen-Wert-Paare im
      Start-Tag deklariert
     &lt;/li&gt;
     &lt;li&gt;
      In einem Attribut dürfen keine Symbole wie z.B.
      die öffnende Winkelklammer verwendet werden, die
      falsch interpretiert werden könnten.
     &lt;/li&gt;
     &lt;li&gt;
      Ein Attribut besitzt im Gegensatz zu einem
      Element keine weitere Unterstrukturierung. Der
      gesamte Attributinhalt wird als sogenannter
      &lt;em&gt;Normalisierter Wert&lt;/em&gt;
      dargestellt.
     &lt;/li&gt;
     &lt;li&gt;
      Die Menge der Attribute für ein Element ist
      nicht geordnet
     &lt;/li&gt;
     &lt;li&gt;
      Ein bestimmtes Attribut darf in einem Element
      nur genau ein mal vorkommen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Attribute Information Item&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Für jedes Attribut eines Elements gibt es ein
      &lt;code&gt;Attribute Information Item&lt;/code&gt;
      mit folgenden Eigenschaften:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;Namespace Name&lt;/em&gt;
       : der Namensraum des Attributs, falls
       definiert.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Lokaler Name&lt;/em&gt;
       : entspricht dem (um evtl. Namensraumkürzel
       und trennenden Doppelpunkt gekürzten)
       Attributnamen
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Präfix&lt;/em&gt;
       : Das Namensraumkürzel des Namensraums, in
       dem sich das Attribut befindet.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Normalisierter Wert&lt;/em&gt;
       : Normalisierter Attributinhalt. Die
       Normalisierung von Attributwerten ist in
       &lt;a
        href="http://www.w3.org/TR/REC-xml/#AVNormalize"&gt;
        Abschnitt 3.3.3 der XML-Spezifikation
       &lt;/a&gt;
       beschrieben. Beispielsweise werden dabei
       alle Zeilenumbrüche entfernt und
       Entitätsreferenzen werden aufgelöst.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Specified&lt;/em&gt;
       : zeigt an, ob das Attribut tatsächlich im
       Start-Tag des Elementes spezifiziert wurde,
       oder ob es durch eine DTD vorgegeben ist.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Attributtyp&lt;/em&gt;
       : Typ des Attributs, wie in der DTD
       festgelegt. Zugelassene Werte sind
       &lt;code&gt;ID&lt;/code&gt;
       ,
       &lt;code&gt;IDREF&lt;/code&gt;
       ,
       &lt;code&gt;IDREFS&lt;/code&gt;
       ,
       &lt;code&gt;ENTITY&lt;/code&gt;
       ,
       &lt;code&gt;ENTITIES&lt;/code&gt;
       ,
       &lt;code&gt;NMTOKEN&lt;/code&gt;
       ,
       &lt;code&gt;NMTOKENS&lt;/code&gt;
       ,
       &lt;code&gt;NOTATION&lt;/code&gt;
       ,
       &lt;code&gt;CDATA&lt;/code&gt;
       , und
       &lt;code&gt;ENUMERATION&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Referenzen&lt;/em&gt;
       : Handelt es sich bei dem Attribut um ein
       Referenzattribut (d.h. es ist vom Typ
       &lt;code&gt;IDREF(S)&lt;/code&gt;
       ,
       &lt;code&gt;ENTITY&lt;/code&gt;
       ,
       &lt;code&gt;ENTITIES&lt;/code&gt;
       oder
       &lt;code&gt;NOTATION&lt;/code&gt;
       ), so enthält diese Eigenschaft eine
       Verweisliste auf alle Auftreten des
       Attributwertes
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Eigentümerelement&lt;/em&gt;
       : Ein Verweis auf das Element, zu dem das
       Attribut gehört.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Element oder Attribut?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Vergleicht man die Eigenschaften von Elementen
      und Attributen, so erkennt man, daß sich nicht
      weiter strukturierte Information aus als
      Attribute darstellen ließe.
     &lt;/li&gt;
     &lt;li&gt;
      Wie soll man nun sein XML-Dokument entwerfen,
      wie das Vokabular strukturieren?
     &lt;/li&gt;
     &lt;li&gt;
      Die XML-Spezifikation gibt uns hierauf keine
      Antwort.
     &lt;/li&gt;
     &lt;li&gt;
      Attribute sind nicht weiter strukturiert, daher
      bietet sich ihr Einsatz nur in Sonderfällen an.
     &lt;/li&gt;
     &lt;li&gt;
      Beispiel: Beschreibende Information zum Element,
      Meta-Information.
     &lt;/li&gt;
     &lt;li&gt;
      Elemente werden eingesetzt, wenn Information
      weiter strukturiert werden muß.
     &lt;/li&gt;
     &lt;li&gt;
      Werden DTDs verwendet, sind Attribute die
      einzige Möglichkeit, Daten zu typisieren. Mit
      der Verwendung von XML-Schema, das Typisierung
      auch für Elementinhalt erlaubt, schwindet dieser
      Vorteil.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Character Information Item&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Zeichenketten-Daten, die Inhalt eines Elementes
      sind.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes einzelne dieser Zeichen wird als
      &lt;code&gt;Character Information Item&lt;/code&gt;
      mit folgenden Eigenschaften dargestellt:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;Character Code&lt;/em&gt;
       : Der ISO-10646 Zeichencode des jeweiligen
       Zeichens.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Element Content Whitespace&lt;/em&gt;
       : Ein Boole'scher Wert. Er zeigt an, ob das
       aktuelle Zeichen ein
       &lt;q&gt;white space&lt;/q&gt;
       Zeichen darstellt, das laut DTD als
       Elementinhalt
       &lt;q&gt;erhalten&lt;/q&gt;
       werden soll. Whitespace-Zeichen werden oft
       verwendet, um ein XML-Dokument visuell
       besser zu strukturieren. Wenn die DTD keine
       derartige Deklaration beinhaltet, oder keine
       DTD zum Dokument existiert, so bestitzt
       diese Eigenschaft keinen Wert.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Parent&lt;/em&gt;
       : Verweis auf das Element, in dem das
       Zeichen enthalten ist.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Character Information Item&lt;/title&gt;
    &lt;p&gt;
     Im Folgenden ist zum besseren Verständnis nochmals
     unser Beispieldokument in der Zusammenschau mit
     seinem Information Set aufgeführt.
    &lt;/p&gt;
    &lt;listing
     src="erstes-XML-dokument.xml"
     line="1-11" /&gt;
    &lt;img src="Infoset-erstes-Beispiel.png" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Zeichenersetzungsmuster&lt;/title&gt;
    &lt;p&gt;
     Eine Reihe von Zeichen dürfen nicht als Text in
     einem XML-Dokument vorkommen, weil sie als
     Metasymbole der XML selbst dienen. Für diese Zeichen
     gibt es vordefinierte sogenannte
     &lt;em&gt;Fluchtsymbole&lt;/em&gt;
     (escape characters), die stattdessen verwendet
     werden können (
     &lt;a
      href="http://www.w3.org/TR/2006/REC-xml11-20060816/index.html#sec-predefined-ent"&gt;
      Nachlesen in XML-Spezifikation
     &lt;/a&gt;
     ). XML-Prozessoren berücksichtigen diese Symbole und
     geben sie in der korrekten Darstellung an die
     Applikation weiter.
    &lt;/p&gt;
    &lt;table
     border="1"
     cellpadding="20"&gt;
     &lt;tr&gt;
      &lt;th&gt;Entitätsreferenz&lt;/th&gt;
      &lt;th&gt;Ausgedrücktes Zeichen&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;amp;&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;lt;&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;lt;&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;gt;&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;gt;&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;apos;&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;'&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;&amp;amp;quot;&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;"&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;
    Strukturelle Grundkonzepte: Die Extensible Markup
    Language (XML) und das XML Information Set (2)
   &lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Comment Information Item&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Syntax für Kommentare wie in SGML (und damit
      auch wie in HTML)
     &lt;/li&gt;
     &lt;li&gt;
      Kommentare sind an folgenden Stellen in einem
      XML-Dokument erlaubt:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;Nach dem Prolog&lt;/li&gt;
      &lt;li&gt;
       An jeder beliebigen Stelle des XML-Dokuments
       außerhalb von Markup.
      &lt;/li&gt;
      &lt;li&gt;Folglich:&lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        Keine Kommentare in Tags (innerhalb der
        spitzen Klammern)!
       &lt;/li&gt;
       &lt;li&gt;
        Keine Schachtelung von Kommentaren (weil
        Kommentare selbst Markup darstellen)!
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;li&gt;
       Aus Kompatibilitätsgründen zur SGML darf
       innerhalb von Kommentaren kein doppelter
       Bindestrich vorkommen (
       &lt;code&gt;--&lt;/code&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       Ansonsten dürfen in Kommentaren auch
       Markup-Symbole wie etwa
       &lt;code&gt;&amp;lt;&lt;/code&gt;
       oder
       &lt;code&gt;'&lt;/code&gt;
       vorkommen.
      &lt;/li&gt;
      &lt;li&gt;
       Der Inhalt von Kommentaren wird nicht
       verarbeitet, daher wird auch kein
       verarbeitender Zugriff von Prozessoren und
       APIs unterstützt.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Comment Information Item&lt;/title&gt;
    &lt;p&gt;Grammatik für XML-Kommentare&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="27" /&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-Kommentar.xml"
     line="1-12" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Comment Information Item&lt;/title&gt;
    &lt;p&gt;
     Eigenschaften des
     &lt;em&gt;Comment Information Item&lt;/em&gt;
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Content&lt;/em&gt;
      : Der gesamte Inhalt des Kommentars als
      uninterpretierte Zeichenkette
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Parent&lt;/em&gt;
      : Referenz auf den Elternknoten (
      &lt;em&gt;Document Information Item&lt;/em&gt;
      oder
      &lt;em&gt;Element Information Item&lt;/em&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Document Type Declaration&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wenn für ein Dokument eine Grammatik in Form
      einer DTD existiert, wird dies in einer
      sogenannten
      &lt;em&gt;DOCTYPE&lt;/em&gt;
      -Deklaration angezeigt.
     &lt;/li&gt;
     &lt;li&gt;
      Die
      &lt;em&gt;DOCTYPE&lt;/em&gt;
      -Deklaration befindet sich am Anfang des
      Dokuments vor dem ersten Element. (
      &lt;a
       href="http://www.w3.org/TR/2006/REC-xml11-20060816/#sec-prolog-dtd"&gt;
       In XML-Spezifikation nachschlagen)
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Mit Hilfe dieser Deklaration wird angezeigt, an
      welchem Ort die DTD abgelegt ist.
     &lt;/li&gt;
     &lt;li&gt;
      Alternativ kann eine DTD auch in die
      Doctype-Deklaration eingebettet werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Document Type Declaration - Grammatik&lt;/title&gt;
    &lt;p&gt;Grammatik für DTDs&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="42-47" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Document Type Declaration - Beispiel&lt;/title&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-DTD.xml"
     line="1-4" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Warum ist dieses Dokument fehlerhaft? (Auflösung
      mit Taste
      &lt;code&gt;n&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;note&gt;
      Die Möglichkeit, für ein Dokument zwei
      Grammatiken angeben zu können, ist im
      allgemeinen nicht sinnvoll.
     &lt;/note&gt;
     &lt;note&gt;
      Für jedes XML-Dokument darf es daher maximal
      eine Dokumenttyp-Definition geben, der das
      Dokument genügen muß.
     &lt;/note&gt;
     &lt;note&gt;
      In obigem Beispiel sind zwei DTDs angegeben.
     &lt;/note&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Document Type Declaration Information Item
    &lt;/title&gt;
    &lt;p&gt;
     Das DTD Information Item enthält all die
     Information, die in einem XML-Dokument über die DTD
     verfügbar ist:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;System Identifier&lt;/em&gt;
      : Verweis auf eine externe DTD, sofern
      vorhanden.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Public Identifier&lt;/em&gt;
      :Verweis auf eine externe DTD, die durch einen
      public identifier identifiziert wird.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Kindknoten&lt;/em&gt;
      : geordnete Menge von
      &lt;em&gt;Processing Instruction Information Item&lt;/em&gt;
      s aus der DTD (in der Reihenfolge ihres
      Erscheinens)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Elternknoten (Parent)&lt;/em&gt;
      : Das
      &lt;em&gt;Document Information Item&lt;/em&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namespace Declaration Information Item&lt;/title&gt;
    &lt;p&gt;
     Für jeden Namensraum, der in einem XML-Dokument
     definiert wird, existiert ein
     &lt;em&gt;Namespace Declaration Information Item&lt;/em&gt;
     mit folgenden Eigenschaften:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Präfix&lt;/em&gt;
      : das Präfix, an das der Namensraum gebunden
      wird.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Namespace Name&lt;/em&gt;
      : Der System Identifier der Entität (im Beispiel
      &lt;code&gt;xyz.gif&lt;/code&gt;
      ).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namespace Declaration - Beispiel&lt;/title&gt;
    &lt;p&gt;
     Im folgenden XML-Dokument sehen Sie ein
     Beispieldokument mit Namensräumen.
    &lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-Namensräumen.xml"
     line="1-9" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Im Start-Tag von
      &lt;code&gt;elementB&lt;/code&gt;
      wird der sogenannte
      &lt;em&gt;Vorgabenamensraum&lt;/em&gt;
      mit dem Namensraum
      &lt;code&gt;http://www.fh-augsburg.de&lt;/code&gt;
      überschrieben.
      &lt;code&gt;elementB&lt;/code&gt;
      befindet sich damit automatisch in diesem
      Namensraum.
     &lt;/li&gt;
     &lt;li&gt;
      Im Start-Tag von
      &lt;code&gt;elementC&lt;/code&gt;
      wird der Namensraum
      &lt;code&gt;http://www.example.com&lt;/code&gt;
      dem Kürzel
      &lt;code&gt;abc&lt;/code&gt;
      zugewiesen. Das Element wird diesem Namensraum
      jedoch nicht zugeordnet.
     &lt;/li&gt;
     &lt;li&gt;
      Dessen Kindelement
      &lt;code&gt;elementD&lt;/code&gt;
      &lt;q&gt;kennt&lt;/q&gt;
      die Namensraumdeklarationen seines Elternteils.
      Es wird dem Namensraum
      &lt;code&gt;http://www.example.com&lt;/code&gt;
      zugewiesen, indem das Präfix dem Elementnamen
      (getrennt durch
      &lt;code&gt;:&lt;/code&gt;
      ) vorangestellt wird.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namespace Declaration - Beispiel&lt;/title&gt;
    &lt;p&gt;
     Nachfolgend sehen Sie erneut unser Beispiel mit
     einer Auflistung der Namensräume für jedes Element.
    &lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-Namensräumen.xml"
     line="1-9" /&gt;
    &lt;table
     border="1"
     cellpadding="10"&gt;
     &lt;tr&gt;
      &lt;th&gt;Elementname&lt;/th&gt;
      &lt;th&gt;Namensraum&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;wurzelelement&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;(leerer Namensraum)&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;elementA&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;(leerer Namensraum)&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;elementB&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;http://www.fh-augsburg.de&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;elementC&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;(leerer Namensraum)&lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;elementD&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;http://www.example.com&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Processing Instruction&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mit
      &lt;em&gt;Processing Instructions (PIs)&lt;/em&gt;
      kann man Applikationen Hinweise und Anweisungen
      zur Verarbeitung eines XML-Dokuments geben.
     &lt;/li&gt;
     &lt;li&gt;
      PIs gehören nicht zu den zeichenartigen Daten
      eines XML-Dokuments. Sie werden aber vom
      Prozessor an die Anwendung übergeben.
     &lt;/li&gt;
     &lt;li&gt;
      Der erste Bezeichner in einer Processing
      Instruction dient dazu, die verarbeitende
      Applikation zu identifizieren. Die Zeichenkette
      &lt;code&gt;XML&lt;/code&gt;
      ist in sämtlichen Variationen hiervon
      ausgeschlossen.
     &lt;/li&gt;
     &lt;li&gt;
      PIs können an beliebigen Stellen eines Dokuments
      auftreten: Vor dem Wurzelelement sowie innerhalb
      des Dokuments.
     &lt;/li&gt;
     &lt;li&gt;
      Wie bei Kommentaren ist es nicht erlaubt, PIs in
      Elementbezeichnern und Attributen anzugeben.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Processing Instruction&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      PIs passen eigentlich nicht zur Idee einer
      beschreibenden Auszeichnungssprache für
      Dokumente, da sie keine beschreibende
      Information über den Inhalt des Dokuments
      darstellen.
     &lt;/li&gt;
     &lt;li&gt;
      Aus Kompatibilitätsgründen zur SGML wurden sie
      dennoch beibehalten.
     &lt;/li&gt;
     &lt;li&gt;
      Auch der XML-Prolog ist im Grunde genommen eine
      PI.
     &lt;/li&gt;
     &lt;li&gt;
      Empfehlung: Verwenden Sie
      &lt;em&gt;keine&lt;/em&gt;
      PIs. Auch wenn diese manchmal eine verführerisch
      einfache Möglichkeit zur Lösung eines Problems
      darstellen, lösen Sie Ihr Problem lieber sauber!
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Processing Instruction - Grammatik und Beispiel
    &lt;/title&gt;
    &lt;p&gt;Grammatik für Processing Instructions&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="30-31" /&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-PI.xml"
     line="1-7" /&gt;
    &lt;note&gt;
     Strenggenommen könnte man die Zeichenfolge
     &lt;code&gt;XML&lt;/code&gt;
     als Präfix für einen Bezeichner verwenden, da dies
     nicht verboten wird. Dies ist jedoch nicht zu
     empfehlen.
    &lt;/note&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Processing Instruction Information Item&lt;/title&gt;
    &lt;p&gt;
     Infoset-Eigenschaften eines Processing Instruction
     Information Item
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Target&lt;/em&gt;
      : Der Name der Zielapplikation als Zeichenkette.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Inhalt&lt;/em&gt;
      : Eine Zeichenkette mit dem Inhalt der PI,
      jedoch ohne den Namen der Zielapplikation und
      darauffolgendem WhiteSpace.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Basis URI&lt;/em&gt;
      : Die Basis URI der PI.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Notation&lt;/em&gt;
      : Wenn der Name der Zielapplikation in Form
      einer Notation vorliegt, eine Referenz auf das
      entsprechende
      &lt;em&gt;Notation Information Item&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Parent&lt;/em&gt;
      : Referenz auf das Elternelement der PI,
      entweder ein
      &lt;em&gt;Element Information Item&lt;/em&gt;
      oder ein
      &lt;em&gt;Document Information Item&lt;/em&gt;
      (für PIs außerhalb des Wurzelelementes).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Notation Information Item&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Deklarationen von Notations sind strenggenommen
      Bestandteile von DTDs, nicht von XML-Dokumenten.
     &lt;/li&gt;
     &lt;li&gt;
      Sie werden aber im Infoset berücksichtigt und
      sind stark mit Processing Instruction
      Information Items verknüpft.
     &lt;/li&gt;
     &lt;li&gt;
      Mit Notations kann man Dateninhalten externe
      Quellen zuordnen. Man erhoffte sich hierdurch
      das, was durch ein XML-Dokument ausgedrückt
      werden kann, zu erweitern.
     &lt;/li&gt;
     &lt;li&gt;
      Notations werden jedoch von XML-Parsern nicht
      berücksichtigt! Sollen diese ausgewertet werden,
      so muß dies in der darüberliegenden Applikation
      erfolgen!
     &lt;/li&gt;
     &lt;li&gt;
      Notation-Deklarationen sind in DTD-Syntax und
      &lt;em&gt;kein XML&lt;/em&gt;
      !
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Notation&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Notations werden etwa für sog.
      &lt;em&gt;unparsed Entities&lt;/em&gt;
      angewendet. Hier weden einfach Zeichenketten
      einem Namen zugeordnet.
     &lt;/li&gt;
     &lt;li&gt;
      Die Zeichenketten dienen der Identifikation des
      Systems, das die Information verarbeitet.
     &lt;/li&gt;
     &lt;li&gt;
      Für standardisierte Information sind sogenannte
      &lt;em&gt;Public Identifier&lt;/em&gt;
      verfügbar.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;System Identifier&lt;/em&gt;
      verweisen auf eine bekannte URI oder ein
      installiertes Anwendungsprogramm.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Notation - Grammatik&lt;/title&gt;
    &lt;p&gt;Grammatik für Notations&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="34-39" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Notation - Beispiel&lt;/title&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-Notation.xml"
     line="1-13" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die genaue Bedeutung der DTD Konstrukte werden
      im entsprechenden Teil der Vorlesung noch
      behandelt.
     &lt;/li&gt;
     &lt;li&gt;
      Drei Notationen:
      &lt;code&gt;isoDate&lt;/code&gt;
      ,
      &lt;code&gt;gif&lt;/code&gt;
      und
      &lt;code&gt;hex&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Die
      &lt;code&gt;hex&lt;/code&gt;
      -Notation wird im Dokument verwendet.
     &lt;/li&gt;
     &lt;li&gt;
      Man könnte hiermit auf die Idee kommen,
      Strukturen wie Datentypen nachbilden zu wollen.
      Aber Achtung: Diese Strukturen müssen dann in
      der Programmierung der Applikation
      berücksichtigt werden.
     &lt;/li&gt;
     &lt;li&gt;
      Mithilfe der System-Referenzen alleine wird
      nicht klar, ob auf ein Dokument, ein System oder
      eine ausführbare Anwendung verwiesen wird.
     &lt;/li&gt;
     &lt;li&gt;
      Der Public Identifier
      &lt;code&gt;gif&lt;/code&gt;
      stellt hier nur eine weltweit eindeutige
      Benennung dar.
     &lt;/li&gt;
     &lt;li&gt;
      Soll auf einen Ort im System verwiesen werden,
      der die dargestellte Information verarbeitet,
      kann zusätzlich ein
      &lt;em&gt;System Identifier&lt;/em&gt;
      angegeben werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Notation Information Item&lt;/title&gt;
    &lt;p&gt;
     Infoset-Eigenschaften eines Notation Information
     Item
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Name&lt;/em&gt;
      : Name der Notation
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;System Identifier&lt;/em&gt;
      : Der System Identifier der Notation wie er in
      der Deklaration angegeben wird, ohne
      Fluchtsymbole in der URI.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Public Identifier&lt;/em&gt;
      :Der Public Identifier der Notation, hier wird
      der Inhalt der URI normalisiert
      (Whitespace-Zeichen werden in Leerzeichen
      umgewandelt, Leerzeichen zu Beginn und Ende der
      Zeichenkette werden entfernt)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Declaration Base URI&lt;/em&gt;
      : Die Base URI, zu der der System Identifier
      relativ aufgelöst werden soll (z.B. Die Base URI
      der Ressource, in der die Notation deklariert
      wurde).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unexpanded Entity Reference&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mechanismus, der für die fünf in der XML
      vordefinierten Textersetzungsmuster (
      &lt;code&gt;&amp;amp;amp;&lt;/code&gt;
      ,
      &lt;code&gt;&amp;amp;lt;&lt;/code&gt;
      ,
      &lt;code&gt;&amp;amp;gt;&lt;/code&gt;
      ,
      &lt;code&gt;&amp;amp;apos;&lt;/code&gt;
      ,
      &lt;code&gt;&amp;amp;quot;&lt;/code&gt;
      ) verwendet wurde
     &lt;/li&gt;
     &lt;li&gt;
      Mit diesem Mechanismus können eigene
      Ersetzungsmuster (
      &lt;em&gt;Entities&lt;/em&gt;
      ) definiert werden.
     &lt;/li&gt;
     &lt;li&gt;
      Definition von Textersetzungsmustern ist nur in
      der DTD möglich. Ihre Syntax ist nicht XML!
     &lt;/li&gt;
     &lt;li&gt;
      Die Verwendung der Entitäten ist innerhalb von
      Elementen als sog.
      &lt;em&gt;Element Content&lt;/em&gt;
      gestattet. In Element- und Attributnamen können
      Entitäten demnach nicht verwendet werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unexpanded Entity Reference - Grammatik&lt;/title&gt;
    &lt;p&gt;Grammatik für Unexpanded Entity References&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="50-54" /&gt;
    &lt;ul&gt;
     &lt;li&gt;Zwei Klassen von Entitäten&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Interne Entitäten: ihr Wert ist direkt neben
       dem Schlüsselwort Entity angegeben
      &lt;/li&gt;
      &lt;li&gt;
       Externe Entitäten: sie werden durch eine URI
       oder einen öffentlichen Bezeichner
       identifiziert
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unexpanded Entity Reference - Beispiel&lt;/title&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-Entities.xml"
     line="1-12" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verwendung von Entitäten mit Kaufmanns-Und (
      &lt;code&gt;&amp;amp;&lt;/code&gt;
      ) und abschließendem Strichpunkt (
      &lt;code&gt;;&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entA&lt;/code&gt;
      ist eine interne Entität und wird durch die
      Zeichen
      &lt;code&gt;xyz&lt;/code&gt;
      ersetzt
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entB&lt;/code&gt;
      und
      &lt;code&gt;entC&lt;/code&gt;
      sind Referenzen auf externe Ressourcen.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entC&lt;/code&gt;
      definiert darüberhinaus, daß es eine unter dem
      Namen
      &lt;code&gt;-//FHA//Symbol//DE&lt;/code&gt;
      öffentlich bekannte Quelle (
      &lt;code&gt;file://symbols&lt;/code&gt;
      ) referenziert.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Unexpanded Entity Reference Information Item
    &lt;/title&gt;
    &lt;p&gt;
     Solange die Entitätsreferenzen noch nicht durch den
     Prozessor ersetzt (=expandiert) sind, liegen sie im
     Information Set als
     &lt;code&gt;
      Unexpanded Entity Reference Information Item
     &lt;/code&gt;
     vor. Es hat folgende Eigenschaften:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Name&lt;/em&gt;
      : der Name der referenzierten Entität.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;System Identifier&lt;/em&gt;
      : Der System Identifier der Entität.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Public Identifier&lt;/em&gt;
      : Der normalisierte Public Identifier der
      Entität.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Declaration Base URI&lt;/em&gt;
      : Die Base URI, zu der der System Identifier
      relativ aufgelöst werden soll (z.B. Die Base URI
      der Ressource, in der die Entität deklariert
      wurde).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Elternknoten (Parent)&lt;/em&gt;
      : Das
      &lt;em&gt;Element Information Item&lt;/em&gt;
      , in dessen Inhalt die Entitätsreferenz
      verwendet wurde.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unparsed Entity Reference&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Entität, die explizit durch den XML-Prozessor
      nicht zu analysieren/prüfen ist.
     &lt;/li&gt;
     &lt;li&gt;
      Informationenliegen üblicherweise nicht im
      XML-Format vor, sondern z.B. als Binärdaten. So
      können Bilder, Videos, o.ä. referenziert werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unparsed Entity Reference - Grammatik&lt;/title&gt;
    &lt;p&gt;
     Die Grammatik für ungeprüfte Entitätsreferenzen ist
     Teil der Grammatik für Unexpanded Entity References
     (hier erneut aufgeführt).
    &lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="50-54" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Produktion 76 definiert die nicht zu prüfende
      Entität
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Unparsed Entity Reference - Beispiel&lt;/title&gt;
    &lt;p&gt;Beispiel&lt;/p&gt;
    &lt;listing
     src="XML-Dokument-mit-UnparsedEntity.xml"
     line="1-11" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In Zeile 4 wird die öffentlich bekannte Notation
      &lt;code&gt;gif&lt;/code&gt;
      definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Die Entität
      &lt;code&gt;entA&lt;/code&gt;
      verwendet diese Notation und deklariert sie als
      Referenz auf den nicht zu prüfenden Inhalt (
      &lt;code&gt;NDATA&lt;/code&gt;
      für Non-Parsed-Data) der Ressource
      &lt;code&gt;xyz.gif&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Innerhalb des Elements
      &lt;code&gt;someContent&lt;/code&gt;
      wird die Entitätsreferenz
      &lt;code&gt;entA&lt;/code&gt;
      verwendet. An dieser Stelle wird demnach die
      Grafikdatei in das XML-Dokument aufgenommen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Unparsed Entity Reference Information Item
    &lt;/title&gt;
    &lt;p&gt;
     Für jede nicht geprüfte Entität eines XML-Dokuments
     gibt es ein
     &lt;em&gt;Unparsed Entity Reference Information Item&lt;/em&gt;
     . Es hat folgende Eigenschaften:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Name&lt;/em&gt;
      : der Name der Entität.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;System Identifier&lt;/em&gt;
      : Der System Identifier der Entität (im Beispiel
      &lt;code&gt;xyz.gif&lt;/code&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Public Identifier&lt;/em&gt;
      : Der normalisierte öffentliche Identifier der
      Entität.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Declaration Base URI&lt;/em&gt;
      : Die Base URI, zu der der System Identifier
      relativ aufgelöst werden soll (z.B. Die Base URI
      der Ressource, in der die Entität deklariert
      wurde).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Notation Name&lt;/em&gt;
      : Der Name der Notation, mit der die Entität
      verknüpft ist (im Beispiel
      &lt;code&gt;gif&lt;/code&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Notation&lt;/em&gt;
      : Das
      &lt;em&gt;Notation Information Item&lt;/em&gt;
      der Notation, die durch den
      &lt;em&gt;Notation Name&lt;/em&gt;
      benannt ist.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;



   &lt;slide&gt;
    &lt;title&gt;Infoset - Übersicht&lt;/title&gt;
    &lt;img
     style="margin : 4%"
     src="infoset.gif" /&gt;
    &lt;note&gt;
     Informationseinheiten als Knoten, Beziehungen als
     (gerichtete) Kanten dargestellt.
    &lt;/note&gt;
    &lt;note&gt;
     Ausgangspunkt ist das in der Mitte dargestellte
     &lt;em&gt;Document&lt;/em&gt;
     .
    &lt;/note&gt;
    &lt;note&gt;
     Lediglich Elemente verfügen über weitere Kindknoten
     und spannen so den Baum einen XML-Dokuments auf.
    &lt;/note&gt;
    &lt;note&gt;
     Alle übrigen Primitive sind überwiegend Blattknoten.
    &lt;/note&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Wohlgeformtheit&lt;/title&gt;
    &lt;p&gt;
     Ein XML-Dokument, das den Prinzipien zur
     Strukturierung aus dem Information Set genügt, ist
     ein wohlgeformtes Dokument. Insbesondere genügt es
     folgenden 10 Regeln:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es enthält den Prolog inkl. der XML-Deklaration.
     &lt;/li&gt;
     &lt;li&gt;
      Das XML-Dokument nutzt eine DTD, oder enthält
      die Deklaration standalone="yes".
     &lt;/li&gt;
     &lt;li&gt;Es gibt genau ein Wurzelelement.&lt;/li&gt;
     &lt;note&gt;
      Ein Dokument ohne Wurzelelement ist nicht
      wohlgeformt!
     &lt;/note&gt;
     &lt;li&gt;
      Zu jedem Start-Tag existiert genau ein Ende-Tag.
      Im Fall von leeren Elementen können beide
      zusammenfallen.
     &lt;/li&gt;
     &lt;li&gt;
      Die Elemente sind sauber ineinander
      geschachtelt.
     &lt;/li&gt;
     &lt;li&gt;
      Ein Attributenamen darf nur einmal im selben
      Start-Tag oder Empty-Element-Tag vorkommen.
     &lt;/li&gt;
     &lt;li&gt;
      Alle Attributwerte sind in einfachen oder
      doppelten Anführungszeichen.
     &lt;/li&gt;
     &lt;li&gt;
      Attributwerte dürfen die Zeichen
      &lt;code&gt;&amp;lt;&lt;/code&gt;
      und
      &lt;code&gt;&amp;amp;&lt;/code&gt;
      nicht enhalten.
     &lt;/li&gt;
     &lt;li&gt;
      Keine Kommentare oder Processing Instructions
      innerhalb von Tags.
     &lt;/li&gt;
     &lt;li&gt;
      Kommentare beginnen und enden mit genau zwei
      Bindestrichen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Wohlgeformtheit - Beispiel&lt;/title&gt;
    &lt;p&gt;
     Das folgende Beispiel zeigt ein nicht wohlgeformtes
     XML-Dokument, das mehreren Anforderungen nicht
     genügt.
    &lt;/p&gt;
    &lt;listing
     src="NotWellFormed.xml"
     line="1-12" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Attributwert in Zeile 3 nicht in Hochkommata
      eingeschlossen.
     &lt;/li&gt;
     &lt;li&gt;
      Öffnende Winkelklammer als Elementinhalt in
      Zeile 4. Hier hätte das Fluchtsymbol
      &lt;code&gt;&amp;amp;lt;&lt;/code&gt;
      verwendet werden müssen.
     &lt;/li&gt;
     &lt;li&gt;
      Kein schließendes Tag zu
      &lt;code&gt;elementB&lt;/code&gt;
      vorhanden.
     &lt;/li&gt;
     &lt;li&gt;
      In
      &lt;code&gt;elementC&lt;/code&gt;
      kommt der Attributname
      &lt;code&gt;att1&lt;/code&gt;
      zweimal vor.
     &lt;/li&gt;
     &lt;li&gt;
      Im öffnenden Tag von
      &lt;code&gt;elementD&lt;/code&gt;
      steht eine dort nicht zugelassene Processing
      Instruction.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;elementC&lt;/code&gt;
      und
      &lt;code&gt;elementD&lt;/code&gt;
      sind nicht sauber geschachtelt.
     &lt;/li&gt;
     &lt;li&gt;
      Der Kommentar in Zeile 11 hat fehlerhafte
      Begrenzer (korrekt wären genau zwei
      Bindestriche).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;slide&gt;
   &lt;title&gt;Weiterführende Links&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;a href="http://www.w3.org/TR/xml-infoset/"&gt;
      XML Information Set
     &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;a href="http://www.unicode.org/"&gt;Unicode&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;a href="http://www.unipad.org/"&gt;
      SC Unipad, ein Unicode Texteditor zum freien
      Download (Zeichenanzahl in der freien Version
      beschränkt.)
     &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;a
      href="http://www.xml.com/pub/a/2001/01/31/qanda.html"&gt;
      Artikel über Entitäten auf XML.COM
     &lt;/a&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;



 &lt;/presentation&gt;


 &lt;presentation id="uebungsaufgabenWohlgeformtheit"&gt;
  &lt;title short="uebungsaufgabenWohlgeformtheit"&gt;
   Übungsaufgaben zum Thema XML-Dokumente / Wohlgeformtheit
  &lt;/title&gt;
  &lt;date&gt;2008-10-13&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Übungsaufgaben zum Thema XML-Dokumente / Wohlgeformtheit.
  &lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zur Wohlgeformtheit&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Ein erstes eigenes XML-Dokument erstellen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Erstellen Sie ein erstes einfaches XML-Dokument,
      das den Regeln der Wohlgeformtheit genügt.
     &lt;/li&gt;
     &lt;li&gt;
      Umfang: 6-7 Elemente, ebenso ein paar Attribute.
     &lt;/li&gt;
     &lt;li&gt;
      Zeigen Sie die verschiedenen
      Strukturierungsmöglichkeiten (Hierarchien,
      Elemente, Attribute) in Ihrem Dokument auf.
     &lt;/li&gt;
     &lt;li&gt;
      Überprüfen Sie die Wohlgeformtheit Ihres
      Dokuments mit einem geeigneten Werkzeug. (Wie
      weist Ihr Tool Sie darauf hin, daß das
      vorliegende Dokument NICHT wohlgeformt ist?
      Woran merken Sie das?)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Umwandeln eines nicht wohlgeformten Dokuments in ein
     wohlgeformtes Dokument
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das untenstehende XML-Dokument ist nicht
      wohlgeformt.
     &lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;
       Finden Sie die darin enthaltenen Fehler.
      &lt;/li&gt;
      &lt;li&gt;
       Wandeln Sie es in dann ein wohlgeformtes
       XML-Dokument um.
      &lt;/li&gt;
     &lt;/ol&gt;
     &lt;li&gt;
      &lt;a href="uebung1_lat.xml"&gt;
       Download des Beispiels
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;listing src="uebung1_lat.xml"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Erstellen eines ersten XHTML Dokuments&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Erstellen Sie ein erstes eigenes XHTML Dokument.
     &lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;
       Erstellen Sie ein erstes einfaches XHTML
       Dokument.
      &lt;/li&gt;
      &lt;li&gt;
       Inhalt der Seite soll das Gedicht &amp;apos;Die
       Brück&amp;apos; am Tay&amp;apos; aus der letzten
       Übung sein.
      &lt;/li&gt;
      &lt;li&gt;
       Überlegen Sie, mit welchen Elementen der
       XHTML sie das Gedicht darstellen können.
      &lt;/li&gt;
      &lt;li&gt;
       Welche Information aus dem Quelldokument
       läßt sich nicht 1:1 nach XHTML abbilden?
       Warum?
      &lt;/li&gt;
      &lt;li&gt;
       Überprüfen Sie Ihre XHTML Seite mit dem
       &lt;a href="http://validator.w3.org/"&gt;
        W3C Markup Validaton Service
       &lt;/a&gt;
       des W3C.
      &lt;/li&gt;
     &lt;/ol&gt;
     &lt;li&gt;Hilfestellung zur XHTML&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;a href="http://www.w3.org/MarkUp/"&gt;
        Webseite des XHTML Working Group des W3C
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;a
        href="http://www.w3.org/MarkUp/#xhtml1"&gt;
        Zu XHTML 1.0
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Hilfe zur HTML finden Sie auf den
       &lt;a href="http://de.selfhtml.org/"&gt;
        SELFHTML
       &lt;/a&gt;
       Webseiten.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      &lt;a href="uebung1_lat.xml"&gt;
       Download des Beispiels
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;

 &lt;/presentation&gt;
 &lt;!-- Ende Übungsaufgaben zum Thema XML-Dokumente / Wohlgeformtheit --&gt;


 &lt;!--  Namensräume --&gt;
 &lt;presentation id="namensraeume"&gt;
  &lt;title short="namensräume"&gt;Namensräume&lt;/title&gt;
  &lt;date&gt;2008-10-20&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Nach einer Einführung der Namensräume als Erweiterung zur
   XML und einem Exkurs über IRIs, URIs, URLs und URCs erfahren
   Sie, wie Namensräume syntaktisch deklariert werden können.
   Sie sehen an Beispielen, wie Namensräume schlecht angewendet
   werden und erfahren, wie Sie es besser machen können. Sie
   erhalten Kenntnis über die Vorrang-Regelungen bei
   Namensräumen und erhalten abschließend einen einfachen
   Regelsatz zur Bestimmung von zu Elementen und Attributen
   zugeordneten Namensräumen.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;XML-Namensräume&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;XML-Namensräume&lt;/title&gt;
    &lt;p class="definition"&gt;
     Weil XML in sehr vielen verschiedenen Bereichen
     verwendet werden kann, ist es sehr erfolgreich.
     Unter anderem auch, weil es so einfach ist, eine
     Grammatik (wie beispielsweise eine DTD) für neue
     Anwendungsfelder zu erstellen und damit für das
     spezielle Einsatzszenario ein
     &lt;q&gt;maßgeschneidertes&lt;/q&gt;
     XML Datenmodell zu erstellen. Dies bedeutet, daß
     Namen in einem XML-Dokument immer im Zusammenhang
     mit einem bestimmten Schema verstanden/interpretiert
     werden müssen. Solange ein Dokument nur Namen aus
     einem Bereich verwendet, ist das ziemlich einfach.
     Heute aber kombinieren Dokumente Namen aus
     verschiedenen Anwendungsfeldern. XML-Namensräume
     bieten einem hier die Möglichkeit, die Namen in
     XML-Dokumenten mit einem Namensraum (=virtueller
     Bereich) zu verknüfen und sie so voneinander
     unterscheidbar und eindeutig identifizierbar zu
     halten.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;XML-Namensräume&lt;/title&gt;
    &lt;img
     style="width : 80% ;margin : 10%;"
     src="languageFamily.gif" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;XML-Namensräume&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Wichtige Erweiterung der XML&lt;/li&gt;
     &lt;li&gt;
      Eigene
      &lt;a href="http://www.w3.org/TR/xml-names11"&gt;
       Empfehlung des W3C
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;Enge Beziehung zum XML Kernstandard&lt;/li&gt;
     &lt;li&gt;Große praktische Bedeutung&lt;/li&gt;
     &lt;li&gt;
      Im XML-Kernstandard explizit berücksichtigt
      (Hinweis, den Doppelpunkt besser nicht in
      XML-Namen zu verwenden, es sei denn, für
      Namensraumangaben.)
     &lt;/li&gt;
     &lt;note&gt;Warum? Um Menschen nicht zu verwirren.&lt;/note&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Warum Namensräume?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es werden immer mehr XML-Sprachen entwickelt,
      dies führt zwangsläufig dazu, daß für ähnliche
      Probleme auch Mehrfachentwicklungen stattfinden.
     &lt;/li&gt;
     &lt;li&gt;
      Technisch äußert sich dies dadurch, daß gleiche
      Bezeichner (Namen) in verschiedenen XML-Sprachen
      verwendet werden.
     &lt;/li&gt;
     &lt;li&gt;
      Jede Sprache bildet demnach einen
      Anwendungskontext, in dem die jeweils
      verwendeten Bezeichner eindeutig sind.
     &lt;/li&gt;
     &lt;li&gt;
      Da nun so viele unterschiedliche Sprachen für
      unterschiedliche Problemstellungen zur Verfügung
      stehen, ist es durchaus sinnvoll, bereits
      bestehende Sprachen (oder Teile davon) zur
      Lösung eigener Probleme zu verwenden (das Rad
      muß nicht jedesmal neu erfunden, sondern nur an
      die eigenen Bedürfnisse angepaßt und ggf.
      erweitert, ergänzt oder modifiziert werden).
     &lt;/li&gt;
     &lt;li&gt;
      Hierbei kann unter Umständen eine
      kontextabängige eindeutige Kennzeichnung von
      Elementen nötig werden, um Namenskollisionen zu
      vermeiden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Zwei XML-Dokumente ähnlichen Inhalts&lt;/title&gt;
    &lt;table border="0"&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;listing src="Rechnung1.xml" /&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;listing src="Rechnung2.xml" /&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Infoset der beiden Rechnungsdokumente&lt;/title&gt;
    &lt;note&gt;
     Knoten, die den selben Inhalt repräsentieren, sind
     mit identischen Farben markiert.
    &lt;/note&gt;
    &lt;note&gt;
     Zeichen (Character Information Item) sind nicht
     dargestellt, da sie für diese Betrachtung nicht von
     Interesse sind.
    &lt;/note&gt;
    &lt;note&gt;
     EInige Elemente und Attribute in beiden Dokumenten
     verwendet, mit gleichem Inhalt.
    &lt;/note&gt;
    &lt;note&gt;
     Identische Teilbäume bedeuten strukturelle
     Übereinstimmung (z.B. Name, Ort, PLZ)
    &lt;/note&gt;
    &lt;note&gt;
     Unterschiedliche Teilbäume (z.B. Rechnung, Kunde)
     zeigen Unterschied in der Struktur auf
    &lt;/note&gt;
    &lt;table
     border="0"
     cellpadding="10"&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;img
        src="Infoset-Rechnung-1.png"
        style="margin : 10% ;" /&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;img
        src="Infoset-Rechnung-2.png"
        style="margin : 10% ;" /&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Warum Namensräume?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Keine Probleme, solange die beiden Dokumente in
      unterschiedlichen Anwendungswelten verwendet
      werden
     &lt;/li&gt;
     &lt;li&gt;
      Aber es gibt Anwendungsfälle, in denen dies
      bedenklich wird
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Mischen von Dokumenten: oft möchte man
       Daten, die in XML vorliegen, in anderen
       Dokumenten verwenden. Dabei entsteht eine
       neue Dokumentstruktur.
      &lt;/li&gt;
      &lt;li&gt;
       Zusammenfassen und Veröffentlichen von
       Strukturen in Schemabibliotheken oder
       Datenbanken. Dokumente bleiben hier
       eigenständig und werden nicht vermischt.
       Allerdings stellt sich die Frage, welches
       Vokabular für eine bestimmte
       Anwendungsdomäne (Produktstrukturen,
       Rechnungsverwaltung, Stücklisten, etc.) das
       richtige ist. Dialekte konkurrieren und
       verzögern eine Standardisierung.
      &lt;/li&gt;
      &lt;li&gt;
       Ausdrücklicher Wunsch, fremde Sprachelemente
       in die eigene einzubetten: Lösung des
       eigenen Problems wird nicht durch eine
       bestimmte Sprache abgedeckt, allerdings kann
       eine Kombination von Elementen mehrerer
       anderer Sprachen hilfreich sein.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Warum Namensräume?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      XHTML ist hier ein interessantes und
      augenfälliges Beispiel.
     &lt;/li&gt;
     &lt;li&gt;
      XHTML verwendet Elemente aus verschiedenen
      Sprachen, um Web-Inhalte darzustellen:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Text (
       &lt;a
        href="file:///C:/downloads/w3.org/www.w3.org/TR/xhtml1/index.html"&gt;
        XHTML
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       mathematische Symbole und Formeln (
       &lt;a
        href="http://www.w3.org/TR/MathML2/index.html"&gt;
        MathML
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       sowie Vektorgrafiken (
       &lt;a
        href="http://www.w3.org/TR/SVG11/index.html"&gt;
        SVG
       &lt;/a&gt;
       )
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die Verwendung existierender Sprachen verringert
      die Fehlerqualität und erhöht die Qualität der
      neuen, entstehenden Sprache.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Warum Namensräume?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wiederverwendung bestehender (fremder)
      XML-Strukturen in eigenen Dokumenten.
     &lt;/li&gt;
     &lt;li&gt;Wunsch nach breiteren Standards.&lt;/li&gt;
     &lt;li&gt;Verringerung des Designaufwandes.&lt;/li&gt;
     &lt;li&gt;
      Nutzung bereits gesammelter Designerfahrung.
     &lt;/li&gt;
     &lt;li&gt;
      Zusammenführung verschiedener XML-codierter
      Inhalte (heterogeneous content syndication).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition Namensraum&lt;/title&gt;
    &lt;p class="definition"&gt;
     XML-Namensräume stellen eine XML-basierte Syntax zur
     Verfügung, um Element- und Attributnamen eines
     Vokabulars eindeutig zu identifizieren und so
     Bedeutungsüberschneidungen durch gleichbenannte
     Elemente- oder Attribute in zu unterscheidenden
     Vokabularen auszuschließen. XML-Namensräume bilden
     damit die notwendige Voraussetzung zur freien
     dezentralen Entwicklung eigener Vokabulare ohne die
     Möglichkeit einer späteren Syndikatisierung zu
     verlieren.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Konzept der Namensräume&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die W3C-Empfehlung
      &lt;a
       href="http://www.w3.org/TR/xml-names11/index.html"&gt;
       &lt;em&gt;
        Namespaces in XML 1.1 (Second Edition)
       &lt;/em&gt;
      &lt;/a&gt;
      wurde gleichzeitig mit der Empfehlung
      &lt;a
       href="http://www.w3.org/TR/xml11/index.html"&gt;
       XML 1.1
      &lt;/a&gt;
      veröffentlicht.
     &lt;/li&gt;
     &lt;li&gt;
      Idee: Element- und Attributnamen werden derart
      erweitert, daß eindeutige Bezeichner entstehen.
     &lt;/li&gt;
     &lt;li&gt;Lösungsmöglichkeiten:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       "freier Wildwuchs": Zulassen unkoordinierter
       Erweiterungen, die jeder Benutzer selbst
       definieren kann. Problem: Gefahr der
       Mehrfachnutzung.
      &lt;/li&gt;
      &lt;li&gt;
       Koordination: Zulassen von Erweiterungen,
       diese werden jedoch an einer zentralen
       Stelle erfaßt. Die Bezeichner werden an
       einer Registierungsstelle registriert, die
       die Eindeutigkeit sicherstellt sowie
       Mehfachnutzungen unterbindet. Problem:
       Großer Verwaltungsaufwand (vergleichbar
       Domain Name System).
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Eindeutige Identifikation durch IRIs und URIs
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das W3C wollte mit den Namensräumen einen
      einfachen Mechanismus zur Identifikation
      ermöglichen.
     &lt;/li&gt;
     &lt;li&gt;
      Der Mechanismus sollte dezentral sein (leicht zu
      administrieren), aber dennoch Eindeutigkeit
      garantieren.
     &lt;/li&gt;
     &lt;li&gt;
      Im Web werden Ressourcen eindeutig durch URIs
      identifiziert. Sie sind zentral und dezentral
      gleichzeitig. Es besteht ein zentrales Register,
      aber die Handhabung ist dennoch flexibel.
     &lt;/li&gt;
     &lt;li&gt;
      Ein(e) URL ist eine Untermenge eine(r)
      &lt;a
       href="http://www.rfc-editor.org/rfc/rfc3986.txt"&gt;
       URI
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Namensräume für XML 1.0 verwenden URIs,
      Namensräume für XML 1.1 verwenden
      &lt;a
       href="http://www.rfc-editor.org/rfc/rfc3987.txt"&gt;
       Internationalized Resource Identifiers
       (IRIs)
      &lt;/a&gt;
      .
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Was steckt hinter URIs?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      URIs beinhalten oft Information, ob und wie auf
      eine Ressource zugegriffen werden kann
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       z.B. mit
       &lt;code&gt;
        http://www.barbara-zengler.de/vorlesung/
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       aber auch mit
       &lt;code&gt;urn:ietf:rfc:2648&lt;/code&gt;
       (
       &lt;a
        href="http://www.ietf.org/rfc/rfc2648.txt?number=2648"&gt;
        RFC 2648
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       oder mit
       &lt;code&gt;
        tag:vorlesung@barbara-zengler.de,2007:example
       &lt;/code&gt;
       (
       &lt;a
        href="http://www.ietf.org/rfc/rfc4151.txt?number=4151"&gt;
        RFC 4151
       &lt;/a&gt;
       )
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Oft geben URIs Repräsentationen von Ressourcen
      zurück
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Ressource selbst wird niemals
       zurückgegeben (wie sollte man eine Vorlesung
       zurückgeben?)
      &lt;/li&gt;
      &lt;li&gt;
       Oft sind Repräsentationen sehr wertvoll
       (z.B. PDF-Dateien, Videos, Bilder, ...)
      &lt;/li&gt;
      &lt;li&gt;
       Die Ressource existiert aber auch ohne eine
       Repräsentation!
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      URIs sind also deutlich mehr als nur Adressen
      von HTML-Seiten.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Aufräumen mit falschen Vorstellungen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Instinktive Annahmen von Web-Benutzern&lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;
       URIs identifizieren etwas, das man mit einem
       Browser abholen kann.
      &lt;/li&gt;
      &lt;li&gt;
       URIs identifizieren etwas, das ein Browser
       anzeigen kann.
      &lt;/li&gt;
      &lt;li&gt;
       Wenn man es nicht abholen und anzeigen kann,
       wofür soll es dann gut sein?
      &lt;/li&gt;
     &lt;/ol&gt;
     &lt;li&gt;
      Das sind aber Annahmen, die nicht immer stimmen.
     &lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;
       URIs identifizieren Ressourcen, die oft,
       aber nicht immer über das Web zugreifbar
       sind.
      &lt;/li&gt;
      &lt;li&gt;
       URIs identifizieren Ressourcen, die oft,
       aber nicht immer eine für das Web
       zugängliche Repräsentation haben.
      &lt;/li&gt;
      &lt;li&gt;
       URIs miteinander zu teilen, heißt, eine
       Identität miteinander zu teilen. Das kann
       bedeuten, daß man eine Bedeutung (Semantik)
       teilt, die mit dieser Identität verknüpft
       ist.
      &lt;/li&gt;
     &lt;/ol&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensraumidentifikation&lt;/title&gt;
    &lt;p class="definition"&gt;
     Jeder XML-Namensraum wird durch eine gültige IRI
     oder URI identifziert. Diese dient ausschließlich
     der Benennung, daher muß sie nicht auf eine gültige
     Ressource verweisen.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;IRIs&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      IRIs sind als Ergänzung zu URIs zu verstehen
     &lt;/li&gt;
     &lt;li&gt;
      URIS werden durch eine Untermenge des US-ASCII
      Zeichensatzes gebildet
     &lt;/li&gt;
     &lt;li&gt;
      IRIs erweitern diese Syntax und erlauben die
      Verwendung von Unicode-Zeichen in Identifiern.
     &lt;/li&gt;
     &lt;li&gt;
      Dabei besteht ein Algorithmus zur Abbildung von
      IRIs in URIs und umgekehrt.
     &lt;/li&gt;
     &lt;li&gt;
      IRIs sind jedoch nur dort zu verwenden, wo sie
      explizit genannt werden. Sie können nicht
      überall anstelle von URIs verwendet werden (z.B.
      HTTP).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Syntax von IRIs und URIs&lt;/title&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="58-64" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiele für gültige URIs&lt;/title&gt;
    &lt;p&gt;
     Nachfolgend sehen Sie eine Vielzahl gültiger URIs
     versammelt:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;code&gt;http://www.fh-augsburg.de/&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;http://meinrechner.fh-augsburg.de/&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;mailto:vorlesung@barbara-zengler.de&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;ftp://ftp.shareware.com/&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;
       file:///C:/bsz/web/vorlesung/intro.html#(16)
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;#(16)&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;
       urn:oasis:names:specification:docbook:dtd:xml:4.1.2
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;urn:oid:1.3.6.1.2.1.27&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;org.omg/standards/UML&lt;/code&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;IRIs, URIs, URLs, URNs (1)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Uniform Resource Identification (URI) ist ein
      abstrakter Oberbegriff eineindeutig
      identifizierbarer Web-Ressourcen. Sie sind
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;eindeutig über Zeit und Raum&lt;/li&gt;
      &lt;li&gt;für Menschen leicht zu merken&lt;/li&gt;
      &lt;li&gt;
       mit keinen Registrierungskosten verbunden
      &lt;/li&gt;
      &lt;li&gt;
       unabhängig von der tatsächlichen
       Lokalisation der so identifizierten
       Ressource
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die Menge aller URIs wird gebildet durch die
      drei disjunkten Bezeichnerschemata URL, URN und
      URC.
     &lt;/li&gt;
     &lt;li&gt;IRIs sind eine Obermenge von URIs.&lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;IRIs, URIs, URLs, URNs (2)&lt;/title&gt;
    &lt;img
     src="uriurlurn.gif"
     style="margin : 4%" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;URL&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Uniform Resource Location (URL)&lt;/em&gt;
      : benennt den physischen Aufenthaltsort einer
      Ressource, z.B. den Ablageort einer HTML-Seite
     &lt;/li&gt;
     &lt;li&gt;Beispiele:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;
        http://www.barbara-zengler.de/vorlesung/toc.html
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;http://www.fh-augsburg.de/&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;
        mailto:vorlesung@barbara-zengler.de
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;
        ftp://example.org/aDirectory/aFile
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;news:comp.infosystems.www&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;tel:+1-816-555-1212&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;
        ldap://ldap.example.org/c=GB?objectClass?one
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;urn:oasis:SAML:1.0&lt;/code&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;URN&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Uniform Resource Name (URN)&lt;/em&gt;
      : ein eineindeutiger Name einer beliebigen
      Resource. Für die URN existiert kein
      Auflösungsmechanismus, durch den die physische
      Lokation ermittelt werden könnte. URNs dienen
      daher ausschließlich der eindeutigen Benennung!
     &lt;/li&gt;
     &lt;li&gt;Syntax:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Beginn mit der definierten Zeichenkette
       &lt;code&gt;urn&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Danach folgt eine Zeichenkette, mit der die
       Ressource weiter klassifiziert wird. Der
       URI-Raum wird hiermit weiter partitioniert.
       Diese namespace ID genannten Zeichenketten
       unterliegen einem globalen
       Registrierungszwang, um ihre Eindeutigkeit
       zu gewährleisten. Diese
       Unterstrukturierungen sind in der Abbildung
       als ns1 bis ns3 benannt.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Beispiele:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;
        urn:oasis:names:specification:docbook:dtd:xml:4.1.2
       &lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;urn:oid:1.3.6.1.2.1.27&lt;/code&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;URC&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      URCs verbinden die reine Benennung mit dem
      physischen Aufenthaltsort.
     &lt;/li&gt;
     &lt;li&gt;
      Eine URC verweist in eine Metadatenstruktur, die
      die physischen Ressourcen-Aufenthaltsorte
      katalogisiert. Dieser URI-Typ ist jedoch
      gegenwärtig kaum verbreitet.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume verwenden&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Einfachste Idee: Namensraum komplett einfach vor
      den Element- oder Attributnamen schreiben und
      vielleicht durch einen Doppelpunkt zu trennen.
     &lt;/li&gt;
     &lt;li&gt;
      Als Ergebnis hätte man eindeutige Element- und
      Attributnamen.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="Rechnung1-mit-gewollten-Namensraeumen.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume verwenden&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Problem dabei: Das Zeichen
      &lt;code&gt;/&lt;/code&gt;
      (Slash) ist in Bezeichnern nicht erlaubt:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Unicode des Zeichens
       &lt;code&gt;/&lt;/code&gt;
       :
       &lt;code&gt;U+002F&lt;/code&gt;
       (=
       &lt;code&gt;#x2F&lt;/code&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;Erlaubte Zeichen in Bezeichnern:&lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="19-21" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume verwenden - Bindung (1/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Ausweg: zweistufiges Verfahren.&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       URIs werden einem Präfix zugeordnet (sie
       werden an das Präfix
       &lt;q&gt;gebunden&lt;/q&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       Präfixe werden dann Element- und
       Attributnamen vorangestellt. Sie werden
       damit in den Namensraum übernommen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Deklaration von Namensräumen (in
      &lt;a
       href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#ns-decl"&gt;
       Namespaces in XML 1.1 (Second Edition)
      &lt;/a&gt;
      nachschlagen)
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="67-72" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume verwenden - Bindung (2/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Bindung einer URI an Präfix geschieht durch das
      reservierte Attribut
      &lt;code&gt;xmlns&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Nach der Bindung der URI an das Präfix kann
      dieses jedem Element oder Attribut vorangestellt
      werden.
     &lt;/li&gt;
     &lt;li&gt;
      Es entsteht ein
      &lt;em&gt;qualifizierter Name&lt;/em&gt;
      :
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p class="definition"&gt;
     Ein
     &lt;em&gt;qualifizierter Name&lt;/em&gt;
     ist ein Name, der der Interpretation von
     Namensräumen unterliegt.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Qualifizerte Namen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Setzt sich zusammen aus Präfix und lokalem
      Namen.
     &lt;/li&gt;
     &lt;li&gt;
      Der Doppelpunkt darf kein Bestandteil des
      lokalen Namens mehr sein.
     &lt;/li&gt;
     &lt;li&gt;
      Hiermit wird die Bildung der Namen aus der
      XML-Spezifikation eingeschränkt - dort ist der
      Doppelpunkt prinzipiell erlaubt, wenngleich auch
      seine Verwendung nicht zu empfehlen ist.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="75-80" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Verarbeitung durch XML-Prozessoren&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ein XML-Prozessor ersetzt jedes Auftreten eines
      deklarierten Präfixes während der Verarbeitung
      eines DOkuments durch die gebundene URI.
     &lt;/li&gt;
     &lt;li&gt;
      Man nennt Prozessoren, die die
      Namensraum-spezifikation unterstützen
      &lt;em&gt;namespace aware&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Prozessoren, die Namensräume nicht unterstützen,
      betrachten den qualifizierten Namen einfach als
      Bezeichner.
     &lt;/li&gt;
     &lt;li&gt;
      Auch die Deklaration des Namensraumes wird von
      diesen Prozessoren als gewöhnliches Attribut
      betrachtet.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Clark-Notation&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      James Clark hat eine
      &lt;a href="http://www.jclark.com/xml/xmlns.htm"&gt;
       Notation
      &lt;/a&gt;
      erdacht, mit deren Hilfe er Namensräume zu
      erklären versucht.
     &lt;/li&gt;
     &lt;li&gt;
      Diese Notation findet sich oft in Mailinglisten,
      etc.
     &lt;/li&gt;
     &lt;li&gt;
      Die Syntax hat die Form
      &lt;code&gt;{namespaceName}elementName&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Beispiel:
      &lt;code&gt;
       &amp;lt;{http://www.example.com/sales}Rechnung&amp;gt;
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Diese Schreibweise ist geläufig, aber
      &lt;em&gt;nicht spezifikationskonform&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Strukturen dieses Stils sind
      &lt;em&gt;keine gültigen XML-Dokumente&lt;/em&gt;
      !
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel: Rechnung mit Namensräumen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Bindung der URI
      &lt;code&gt;http://www.xyz.com/sales&lt;/code&gt;
      an das Präfix
      &lt;code&gt;myNS1&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Bindung steht im definierenden Element (local
      name: Rechnung) und allen untergeordneten
      Elementen zur Verfügung.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="namespace11.xml"
     line="1-15" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Stil von Namensraumdeklarationen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In der Praxis begegnen einem oft wilde
      Deklarationen von Namensräumen.
     &lt;/li&gt;
     &lt;li&gt;
      Namensräume können
      &lt;a
       href="http://lists.xml.org/archives/xml-dev/200204/msg00170.html"&gt;
       neurotisch, psychotisch, borderline oder
       normal
      &lt;/a&gt;
      verwendet werden
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Neurotisch: das gleiche Präfix wird in einem
       Dokument verschiedenen Namensräumen
       zugeordnet.
      &lt;/li&gt;
      &lt;li&gt;
       Borderline: der gleiche Namensraum wird in
       einem Dokument an verschiedene Präfixe
       gebunden.
      &lt;/li&gt;
      &lt;li&gt;
       Psychotisch: der gleiche Namensraum wird im
       gleichen Bereich eines Dokuments an
       verschiedene Präfixe gebunden.
      &lt;/li&gt;
      &lt;li&gt;
       Normal: alle Namensräume werden im
       Wurzelelement deklariert und sind nicht
       psychotisch.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die Verarbeitung dieser ungesunden Verwendungen
      erschwert das Verarbeiten von Namensräumen.
     &lt;/li&gt;
     &lt;li&gt;
      Man sollte XML so verwenden, daß es für Menschen
      &lt;q&gt;lesbar&lt;/q&gt;
      bleibt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Beispiele schlechter Namensraumverwendungen
    &lt;/title&gt;
    &lt;listing
     src="neurotic.xml"
     line="1-9" /&gt;
    &lt;listing
     src="borderline.xml"
     line="1-9" /&gt;
    &lt;listing
     src="psychotic.xml"
     line="1-9" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Beispiel normale Namensraumverwendung (XHTML)
    &lt;/title&gt;
    &lt;listing src="namespace12.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensraumpräfixe&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Namensraumpräfixe können durch den Anwender frei
      vergeben werden
     &lt;/li&gt;
     &lt;li&gt;
      Einziger Zweck: abkürzende Schreibweise. Sie
      sind für die Auflösung eines Namensraums
      unerheblich.
     &lt;/li&gt;
     &lt;li&gt;
      Zwei Elemente oder Attribute sind gleich, wenn
      ihr lokaler Name und ihr Namensraumidentifier
      übereinstimmen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel Namensraumauflösung&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die Elemente der hier gezeigten (psychotischen)
      Beispiele sind alle im Namensraum
      &lt;code&gt;http://www.example.com&lt;/code&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="prefix1.xml" /&gt;
    &lt;listing src="prefix2.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Überschreiben des Vorgabenamensraums&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es ist platzraubend, überflüssig und
      unpraktikabel, für jedes Element innerhalb eines
      Namensraumes diesen explizit anzugeben
     &lt;/li&gt;
     &lt;li&gt;
      Einfache Gültigkeitsregel aus den
      Programmiersprachen: ein geöffneter Block
      beinhaltet alle Elemente bis zum Blockendesymbol
      und faßt sie zu einem Gültigkeitsbereich
      zusammen-
     &lt;/li&gt;
     &lt;li&gt;
      Dieses Prinzip wird auch für XML-Dokumente
      angewendet: das
      &lt;code&gt;xmlns&lt;/code&gt;
      -Attribut ohne trennenden Doppelpunkt und Präfix
      definiert einen
      &lt;em&gt;Vorgabenamensraum.&lt;/em&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Da mehrere Attribute gleichen Namens für ein
      Element nicht erlaubt sind, wird verhindert, daß
      der Vorgabenamensraum nicht mehrfach
      überschrieben wird.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel Rechnung&lt;/title&gt;
    &lt;table border="0"&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;listing src="namespace11.xml" /&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;listing src="namespace13.xml" /&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel XHTML&lt;/title&gt;
    &lt;img
     style="margin : 0% ; width : 4% ; position: fixed; right:25px; top: 25px; float:right"
     src="screenshot-amaya.gif" /&gt;
    &lt;table border="0"&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;listing src="namespace12.xml" /&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;listing src="namespace14.xml" /&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel XHTML - grafische Darstellung&lt;/title&gt;
    &lt;img
     style="margin : 4% ;"
     src="namespaces.gif" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Präfix XOR Vorgabenamensraum&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ein Element kann entweder durch ein Präfix oder
      durch Überschreiben des Vorgabenamensraumes
      einem Namensraum zugeordnet werden.
     &lt;/li&gt;
     &lt;li&gt;
      Beides gleichzeitig ist widersprüchlich und
      damit illegal (z.B.
      &lt;code&gt;&amp;lt;xyz:abc xmlns="..." ..&amp;gt;&lt;/code&gt;
      )
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume im realen Einsatz&lt;/title&gt;
    &lt;p&gt;
     Das Beispiel zeigt die Verwendung zweier Vokabulare
     (SVG und MathML), die beide ein mit set benanntes
     Element definieren. Die qualifizierten Namen beider
     Elemente unterscheiden sich, da sie dem Elementnamen
     die Namensraum-URI voranstellen.
    &lt;/p&gt;
    &lt;listing src="namespace15.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Präzedenz von Namensräumen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine Namensraumzuordnung mittels Präfix hat
      Vorrang gegenüber einem evtl. überschriebenen
      Vorgabenamensraum.
     &lt;/li&gt;
     &lt;li&gt;
      Beispiel: Der überschriebene Namensraum wird auf
      die Kinder vererbt.
     &lt;/li&gt;
     &lt;li&gt;
      In welchen Namensräumen befinden sich die
      Elemente
      &lt;code&gt;ElementA&lt;/code&gt;
      ,
      &lt;code&gt;ElementB&lt;/code&gt;
      und
      &lt;code&gt;ElementC&lt;/code&gt;
      ? (Auflösung mit Taste
      &lt;code&gt;n&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;note&gt;
      &lt;li&gt;
       &lt;code&gt;ElementA&lt;/code&gt;
       : Namensraum
       &lt;code&gt;urn:namspaces:Namespace1&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;ElementB&lt;/code&gt;
       : Namensraum
       &lt;code&gt;urn:namspaces:Namespace1&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;ElementC&lt;/code&gt;
       : Namensraum
       &lt;code&gt;urn:namespace:Namespace2&lt;/code&gt;
      &lt;/li&gt;
     &lt;/note&gt;
    &lt;/ul&gt;
    &lt;listing src="namespace16.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Aufheben von Namensraumzuweisungen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine Namensraumdefinition kann aufgehoben
      werden, indem der Vorgabenamensraum mit der
      leeren Zeichenkette überschrieben wird. (z.B.
      &lt;code&gt;&amp;lt;ElementX xmlns=""/&amp;gt;&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Die Zuordnung von Präfixen zu Namensräumen kann
      ab XML 1.1 rückgängig gemacht werden (in
      &lt;a
       href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#scoping"&gt;
       Namensraum-Spezifikation nachlesen
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;Beispiel:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="namespace-undeclared.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensräume für Attribute&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine Namensraumdeklaration auf Elementebene wird
      nicht auf Attribute übertragen.
     &lt;/li&gt;
     &lt;li&gt;
      Dies ist verwunderlich, speziell wenn man sich
      die Baumstruktur eines XML-Dokuments vor Augen
      führt (ein Attribut ist ebenso ein Kindknoten
      eines Elements wie ein evtl. Kindelement)
     &lt;/li&gt;
     &lt;li&gt;
      Es wird damit argumentiert, daß Attribute eine
      besondere Rolle zur Informationsdarstellung
      spielen: Attribute sollten unabhängig vom
      aktuell umgebenden Element sein und daher nur
      zur Darstellung von Daten herangezogen werden,
      die keinen direkten Bezug zum sie umgebenden
      Element haben (Nicht Elementinhalt, sondern
      Information über das Element).
     &lt;/li&gt;
     &lt;li&gt;
      Attribute müssen somit immer explizit mit einem
      Namensraumpräfix ausgezeichnet werden, um sie
      einem Namensraum zuzuordnen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Beispiel: Attribute mit Namensräumen&lt;/title&gt;
    &lt;listing src="Namensraeume-fuer-Attribute.xml" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Weder
      &lt;code&gt;att1&lt;/code&gt;
      von
      &lt;code&gt;ElementB&lt;/code&gt;
      noch von
      &lt;code&gt;ElementD&lt;/code&gt;
      befinden sich in einem Namensraum.
     &lt;/li&gt;
     &lt;li&gt;
      Das Attribut
      &lt;code&gt;att2&lt;/code&gt;
      mit dem Wert
      &lt;code&gt;xyz&lt;/code&gt;
      dagegen ist dem Namensraum
      &lt;code&gt;http://www.example.com/ns2&lt;/code&gt;
      zugeordnet.
     &lt;/li&gt;
     &lt;li&gt;
      Der Namensraum als Bestandteil des
      identifizierenden Namens von Elementen und
      Attributen macht es möglicht, daß
      &lt;code&gt;att2&lt;/code&gt;
      &lt;q&gt;mehrfach auftreten&lt;/q&gt;
      kann. Mit dem Namensraum ist gewährleistet, daß
      es eindeutig identifiziert werden kann.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Namensraumvererbung&lt;/title&gt;
    &lt;p class="definition"&gt;
     Namensräume, die durch Überschreiben des
     Vorgabenamensraumes zugewiesen werden wirken sich
     ausschließlich auf Elemente und deren direkte oder
     transitive Kindelemente aus, sofern diese den
     Namensraum nicht wieder verändern.
     &lt;br /&gt;

     Namensräume, die durch explizite Präfixangabe
     zugewiesen werden, wirken sich ausschließlich auf
     dasjenige Element aus vor dessen Name das Präfix
     plaziert ist.
     &lt;br /&gt;

     Namensräume für Attribute werden ausnahmslos durch
     explizite Präfixangabe festgelegt und gelten
     ausschließlich für das Attribut selbst.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Auswertungsregeln für Namensräume&lt;/title&gt;
    &lt;p&gt;
     Ein Element befindet sich in demjenigen
     Namensraum...
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      ... an den das vorangestellte Präfix gebunden
      ist.
      &lt;br /&gt;
      Verfügt das Element über kein Namensraumpräfix,
      so befindet es sich in demjenigen Namensraum ...
     &lt;/li&gt;
     &lt;li&gt;
      ... der auf diesem Element durch Überschreibung
      des Vorgabenamensraumes definiert wurde.
      &lt;br /&gt;
      Findet für dieses Element keine Überschreibung
      des Vorgabenamensraumes statt, so befindet es
      sich in demjenigen Namensraum ...
     &lt;/li&gt;
     &lt;li&gt;
      ... der für das Elternelement gilt, sofern er
      dort Vorgabenamensraum ist.
      &lt;br /&gt;
      Man beachte: Das
      &lt;q&gt;gilt&lt;/q&gt;
      im vorangehenden Satz umschließt sich nicht nur
      die Überschreibung des Vorgabenamensraumes im
      direkten Elternelement, sondern auch eine dort
      geltende Namensraumüberschreibung die in dessen
      Elternelement oder dessen Elternelement ...
      stattfand.
      &lt;br /&gt;
      Findet in keinem der Elternelemente eine
      Überschreibung des Vorgabenamensraumes statt, so
      befindet sich das Element in demjenigen
      Namensraum ...
     &lt;/li&gt;
     &lt;li&gt;
      ... der leer ist (d.h. im leeren Namensraum).
     &lt;/li&gt;
    &lt;/ol&gt;
    &lt;p&gt;
     Ein Attribut befindet sich in demjenigem Namensraum,
     der durch explizite Präfixangabe festelegt wurde.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Zusammenfassung Namensräume&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Jede beliebige URI kann an eigendefinierte
      Präfixe gebunden werden.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes Element übernimmt den überschriebenen
      Vorgabenamensraum seines Elternelements, sofern
      es keinen eigenen definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Elemente oder Attribute ohne Namensraumzuordnung
      (die auch keine von ihrem hierarchisch
      höherstehenden Element übernehmen) befinden sich
      im Standardnamensraum (=leerer Namensraum).
     &lt;/li&gt;
     &lt;li&gt;
      Attribute ohne Namensraumpräfix befinden sich im
      leeren Namensraum.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Namensräume --&gt;

 &lt;presentation id="uebungsaufgabenNamensraeume"&gt;
  &lt;title short="uebungsaufgabenNamensraeume"&gt;
   Übungsaufgaben zum Thema Namensräume
  &lt;/title&gt;
  &lt;date&gt;2008-10-20&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Übungsaufgaben zum Thema XML-Dokumente / Wohlgeformtheit.
  &lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu Namensräumen&lt;/title&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 1
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 1
     &lt;/title&gt;
     &lt;p&gt;
      Nachfolgend finden Sie verschiedene
      Multiple-Choice Aufgaben zu Namensräumen. Es
      können je Aufgabe auch mehrere Antworten korrekt
      sein.
     &lt;/p&gt;
     &lt;p&gt;
      Finden Sie die richtige(n) Antwort(en)! Nehmen
      Sie bei Bedarf das Vorlesungsskript zu Hilfe.
     &lt;/p&gt;
     &lt;!-- &lt;p&gt;
      Einblenden der Lösungen (sie befinden sich
      jeweils am Ende der Seite) durch Drücken der
      Taste
      &lt;code&gt;n&lt;/code&gt;
      !
      &lt;/p&gt; --&gt;
     &lt;ul&gt;
      &lt;li&gt;Verwendung&lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        A) XML-Namensräume sind die
        hierarchische Sammlung von
        XML-Elementen.
       &lt;/li&gt;
       &lt;li&gt;
        B) XML-Namensräume gruppieren
        XML-Elemente und -Attribute.
       &lt;/li&gt;
       &lt;li&gt;
        C) XML-Namensräume sind durch einen
        Hyperlink eindeutig adressierbar.
       &lt;/li&gt;
       &lt;li&gt;
        D) XML-Namensräume werden durch eine URI
        identifiziert.
       &lt;/li&gt;
       &lt;li&gt;
        E) XML-Namensräume werden durch eine URI
        benannt.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Alternativen B und D sind
       korrekt!
       &lt;/li&gt;
       &lt;/note&gt; --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 2
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 2
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;Definition&lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        A) Namensräume müssen für jedes
        XML-Vokabular definiert werden.
       &lt;/li&gt;
       &lt;li&gt;
        B) Namensräume können ausschließlich
        durch Standardisierungsgremien definiert
        werden.
       &lt;/li&gt;
       &lt;li&gt;
        C) Namensräume können wahlfrei durch den
        Ersteller eines XML-Vokabulars definiert
        werden.
       &lt;/li&gt;
       &lt;li&gt;
        D) Namensräume müssen beim World Wide
        Web Consortium registriert werden.
        &lt;br /&gt;
        Es weist ihnen dann eine eineindeutige
        URL zu.
       &lt;/li&gt;
       &lt;li&gt;
        E) Namensräume können durch eine URL
        identifiziert werden.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Alternativen C und E sind
       korrekt!
       &lt;/li&gt;
       &lt;/note&gt;  --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 3
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 3
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;Syntax&lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        A) Die Deklaration der
        Namensraumattribute muß in der
        Dokumentgrammatik erfolgen.
        &lt;br /&gt;
        Dort sind sie als optionale Attribute
        definiert.
       &lt;/li&gt;
       &lt;li&gt;
        B) Namensräume müssen zwingend als
        Wurzelelement (
        &lt;em&gt;document element&lt;/em&gt;
        ) des XML-Dokuments definiert werden.
       &lt;/li&gt;
       &lt;li&gt;
        C) Namensräume können ausschließlich für
        Elemente definiert werden.
       &lt;/li&gt;
       &lt;li&gt;
        D) Die Redefinition bereits gebundener
        Namensraumpräfixe ist zulässig.
       &lt;/li&gt;
       &lt;li&gt;
        E) Wird für ein Element kein Namensraum
        definiert, so ist sein Verhalten im
        Namensraumkontext undefiniert.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Alternative D ist korrekt!
       &lt;/li&gt;
       &lt;/note&gt;  --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 4
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 4
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Namensraumauflösung -- Explizite Definition
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;Gegeben sei folgendes XML-Dokument.&lt;/li&gt;
       &lt;listing
        src="uebung-namensraeume-aufg4.xml"&gt;
       &lt;/listing&gt;
       &lt;li&gt;
        Zur besseren Übersichtlichkeit sind den
        Namensräumen folgende Nummern
        zugewiesen:
       &lt;/li&gt;
       &lt;ol&gt;
        &lt;li&gt;
         &lt;em&gt;(leerer Namensraum)&lt;/em&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;http://www.example.com&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;
          http://www.example.com/bar
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;
          http://www.example.com/foo
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;
          http://www.fh-augsburg.de
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;
          http://www.barbara-zengler.de
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;http://www.beispiel.de&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;http://www.w3.org&lt;/code&gt;
        &lt;/li&gt;
       &lt;/ol&gt;
       &lt;li&gt;
        Folgende Tabelle zeigt unterhalb der
        Buchstaben A-E fünf alternative
        Namensraumzuordnungen für alle Elemente,
        unter Verwendung der soeben definierten
        Nummern.
        &lt;br /&gt;
        Finden Sie die richtige!
       &lt;/li&gt;
       &lt;table
        width="80%"
        border="1"&gt;
        &lt;thead&gt;
         &lt;tr&gt;
          &lt;th&gt;
           Element- oder Attributename
          &lt;/th&gt;
          &lt;th&gt;A&lt;/th&gt;
          &lt;th&gt;B&lt;/th&gt;
          &lt;th&gt;C&lt;/th&gt;
          &lt;th&gt;D&lt;/th&gt;
          &lt;th&gt;E&lt;/th&gt;
         &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;root&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemA&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemB&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemC&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;attA&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemD&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemE&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemF&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;attB&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;6&lt;/td&gt;
          &lt;td&gt;7&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemG&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;8&lt;/td&gt;
         &lt;/tr&gt;
        &lt;/tbody&gt;
       &lt;/table&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Alternative E ist korrekt!
       &lt;/li&gt;
       &lt;/note&gt; --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 5
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 5
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Namensraumauflösung -- Implizite Definition
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;Gegeben sei folgendes XML-Dokument.&lt;/li&gt;
       &lt;listing
        src="uebung-namensraeume-aufg5.xml"&gt;
       &lt;/listing&gt;
       &lt;li&gt;
        Zur besseren Übersichtlichkeit sind den
        Namensräumen folgende Nummern
        zugewiesen:
       &lt;/li&gt;
       &lt;ol&gt;
        &lt;li&gt;
         &lt;em&gt;(leerer Namensraum)&lt;/em&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;urn:example.com:bar&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;urn:example.com:foo&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;
          urn:xmlns:fh-augsburg.de:vorlesung:XML
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         &lt;code&gt;urn:xmlns:beispiel.de&lt;/code&gt;
        &lt;/li&gt;
       &lt;/ol&gt;

       &lt;li&gt;
        Folgende Tabelle zeigt unterhalb der
        Buchstaben A-E fünf alternative
        Namensraumzuordnungen für alle Elemente,
        unter Verwendung der soeben definierten
        Nummern.
        &lt;br /&gt;
        Finden Sie die richtige!
       &lt;/li&gt;
       &lt;table
        width="80%"
        border="1"&gt;
        &lt;thead&gt;
         &lt;tr&gt;
          &lt;th&gt;
           Element- oder Attributename
          &lt;/th&gt;
          &lt;th&gt;A&lt;/th&gt;
          &lt;th&gt;B&lt;/th&gt;
          &lt;th&gt;C&lt;/th&gt;
          &lt;th&gt;D&lt;/th&gt;
          &lt;th&gt;E&lt;/th&gt;
         &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;theDocument&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemA&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemB&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;att1&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemC&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;att2&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemD&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;5&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemE&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemF&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemG&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
          &lt;td&gt;
           &lt;code&gt;elemH&lt;/code&gt;
          &lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
         &lt;/tr&gt;
        &lt;/tbody&gt;
       &lt;/table&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Alternative B ist korrekt!
       &lt;/li&gt;
       &lt;/note&gt; --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;
     Übungsaufgaben zu Namensräumen - Aufgabe 6
    &lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Übungsaufgaben zu Namensräumen - Aufgabe 6
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;Namensraumbildung&lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;Gegeben seien folgende Aussagen.&lt;/li&gt;
       &lt;ul&gt;
        &lt;li&gt;
         Das Element Information Item
         &lt;code&gt;elemA&lt;/code&gt;
         befindet sich im Namensraum
         &lt;code&gt;
          http://www.fh-augsburg.de
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         Das Element Information Item
         &lt;code&gt;elemB&lt;/code&gt;
         befindet sich im Namensraum
         &lt;code&gt;
          http://www.barbara-zengler.de/vorlesung/
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         Die Attribute Information Items
         &lt;code&gt;href&lt;/code&gt;
         ,
         &lt;code&gt;actuate&lt;/code&gt;
         und
         &lt;code&gt;show&lt;/code&gt;
         befinden sich im Namensraum
         &lt;code&gt;
          http://www.w3.org/1999/xlink
         &lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         Die Element Information Items
         &lt;code&gt;elemC&lt;/code&gt;
         und
         &lt;code&gt;elemD&lt;/code&gt;
         befinden sich im Namensraum
         &lt;code&gt;http://www.beispiel.de&lt;/code&gt;
        &lt;/li&gt;
        &lt;li&gt;
         Das Element Information Item
         &lt;code&gt;elemE&lt;/code&gt;
         befindet sich im Namensraum
         &lt;code&gt;http://www.example.com&lt;/code&gt;
        &lt;/li&gt;
       &lt;/ul&gt;
       &lt;li&gt;
        Frage: Welche der folgenden Dokumente
        erfüllen diese Aussagen?
       &lt;/li&gt;
       &lt;li&gt;Dokument A&lt;/li&gt;
       &lt;listing src="dokumentA.xml"&gt;&lt;/listing&gt;
       &lt;li&gt;Dokument B&lt;/li&gt;
       &lt;listing src="dokumentB.xml"&gt;&lt;/listing&gt;
       &lt;li&gt;Dokument C&lt;/li&gt;
       &lt;listing src="dokumentC.xml"&gt;&lt;/listing&gt;
       &lt;li&gt;Dokument D&lt;/li&gt;
       &lt;listing src="dokumentD.xml"&gt;&lt;/listing&gt;
       &lt;li&gt;Dokument E&lt;/li&gt;
       &lt;listing src="dokumentE.xml"&gt;&lt;/listing&gt;
      &lt;/ul&gt;
      &lt;!-- &lt;note&gt;
       &lt;li&gt;
       Lösung: Die Dokumente A, C und E sind
       korrekt!
       &lt;/li&gt;
       &lt;/note&gt; --&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
  &lt;/part&gt;

 &lt;/presentation&gt;
 &lt;!-- Ende Übungsaufgaben zu Namensräumen --&gt;

 &lt;!--  DTD --&gt;
 &lt;presentation id="dtd"&gt;
  &lt;title short="DTD"&gt;Document Type Definition (DTD)&lt;/title&gt;
  &lt;date&gt;2008-10-27&lt;/date&gt;
  &lt;toc id="resources"&gt;&lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Die XML-Spezifikation definiert ein Format für strukturierte
   Daten (XML-Dokumente) und eine grammatikbasierte Sprache, um
   Regelsätze für diese Dokumente zu definieren (DTD). In
   SGML-basierten Systemen waren DTDs oft sehr komplexe und
   mächtige Konstrukte, mit denen die Verarbeitung von
   SGML-Dokumenten stark gesteuert wurde. XML vereinfacht die
   DTDs sehr stark, und ihre Verwendung hat sich noch mehr
   vereinfacht: DTDs werden oft überhaupt nicht verwendet oder
   von Tools aus Beispieldokumenten generiert (das gilt auch
   für andere Schemata). DTDs haben heute gegenüber den
   XML-Schemasprachen stark an Bedeutung verloren. Schemata an
   sich sollten Sie jedoch für nicht triviale XML-Anwendungen
   sehr ernst nehmen. Sie bilden die Repräsentation des
   Datenmodells der Applikation (das oft viel zu wenig
   spezifiziert wird).
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;DTD Basics&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Grundzüge der DTDs&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine DTD ist ein Schema für eine Menge von
      Dokumenten
     &lt;/li&gt;
     &lt;li&gt;
      Es stellt eine Grammatik für Dokumente bereit.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Es kann ein Dokument zu einer DTD geben, es
       kann aber auch Millionen Dokumente geben
       (HTML)
      &lt;/li&gt;
      &lt;li&gt;
       In den meisten Fällen werden DTDs als
       separate Ressource verwaltet, sie können
       aber auch Bestandteil eines XML-Dokumentes
       sein.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Eigene Informationseinheiten, vom XML-Dokument
      losgelöst.
     &lt;/li&gt;
     &lt;li&gt;Vergleich mit der Objektorientierung:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       DTDs kann man sich als
       &lt;em&gt;Klasse&lt;/em&gt;
       vorstellen, die wie eine Schablone die
       Struktur und die inhaltlichen Eigenschaften
       einer Reihe von Ausprägungen festlegt.
      &lt;/li&gt;
      &lt;li&gt;
       In dieser Analogie kann man sich ein
       XML-Dokument als ein
       &lt;em&gt;Objekt&lt;/em&gt;
       einer bestimmten Klasse vorstellen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Möglichkeiten, den Inhalt eines XML-Dokuments
      mit DTDs zu beschreiben, sind sehr begrenzt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Gültigkeit&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die XML kennt zwei
      &lt;q&gt;Zustände&lt;/q&gt;
      von Dokumenten:
      &lt;em&gt;wohlgeformt&lt;/em&gt;
      und
      &lt;em&gt;gültig&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;
       &lt;a
        href="http://www.barbara-zengler.de/vorlesung/dokumente-und-daten.html#(63)"&gt;
        Wohlgeformte
       &lt;/a&gt;
      &lt;/em&gt;
      XML-Dokumente genügen dem grundlegenden
      Regelsatz der XML-Spezifikation.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Sie entsprechen den Regeln der XML-Grammatik
       und können deshalb von einem XML-Prozessor
       ausgelesen werden.
      &lt;/li&gt;
      &lt;li&gt;
       Sie genügen zusätzlichen Einschränkungen
       (z.B. "Zu jedem Start-Tag existiert genau
       eine Ende-Tag.")
      &lt;/li&gt;
      &lt;li&gt;
       Alles zusammengenommen bedeutet dies, daß
       wohlgeformte XML-Dokumente in eine
       Baumstruktur überführt werden können.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      &lt;em&gt;gültige&lt;/em&gt;
      (valid) Dokumente sind erfolgreich gegen ein
      Schema (DTD oder XML-Schema) validiert worden.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Bevor ein Dokument gültig sein kann, muß es
       wohlgeformt sein.
      &lt;/li&gt;
      &lt;li&gt;
       Alle Elemente und Attribute müssen im Schema
       definiert sein.
      &lt;/li&gt;
      &lt;li&gt;
       Elemente und Attribute müssen gemäß ihrer
       Definition im Dokument verwendet worden
       sein.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Gültigkeit und Wohlgeformtheit&lt;/title&gt;
    &lt;img
     src="valid-documents.png"
     style="width : 80% ; margin : 4% ; " /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition Gültigkeit&lt;/title&gt;
    &lt;p class="definition"&gt;
     Ein XML-Dokument heißt
     &lt;em&gt;gültig&lt;/em&gt;
     (valid), wenn es über eine Dokument-Typ-Definition
     verfügt und konform zu dieser aufgebaut ist.
     &lt;br /&gt;
     (
     &lt;a
      href="http://www.w3.org/TR/2006/REC-xml11-20060816/index.html#dt-valid"&gt;
      In XML-Spezifikation nachschlagen
     &lt;/a&gt;
     )
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Klassen von XML-Prozessoren&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Entsprechend gibt es zwei Klassen von
      XML-Prozessoren
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;Nicht-validierende XML-Prozessoren&lt;/li&gt;
      &lt;li&gt;Validierende XML-Prozessoren&lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Die Wohlgeformtheit eines Dokuments wird durch
      beide Arten von Prozessoren geprüft.
     &lt;/li&gt;
     &lt;li&gt;
      Validierende Prozessoren hingegen testen
      zusätzlich die Konformität eines XML-Dokuments
      zu seiner DTD. (
      &lt;a
       href="http://www.w3.org/TR/2006/REC-xml11-20060816/index.html#proc-types"&gt;
       In XML-Spezifikation nachlesen
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Am Markt verfügbare XML-Editiertools beinhalten
      üblicherweise validierende XML-Prozessoren (auch
      gegenüber anderen Schemasprachen) oder bieten
      diese gegen Aufpreis an.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;a href="http://www.altova.com/"&gt;
        Altova XML Spy
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;a
        href="http://www.eclipse.org/webtools/"&gt;
        Eclipse XML Editors and Tools
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;a
        href="http://xml-copy-editor.sourceforge.net/"&gt;
        XML Copy Editor
       &lt;/a&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Zudem sind eigenständige Parser-Module
      verfügbar, die die Validierung von
      XML-Dokumenten beherrschen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;DTDs in Dokumente einbinden&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      DTDs werden mit Hilfe der sogenannten
      &lt;em&gt;DOCTYPE&lt;/em&gt;
      -Deklaration aus XML-Dokumenten referenziert.
     &lt;/li&gt;
     &lt;li&gt;
      Sie liegen üblicherweise in einer separaten
      Datei vor, deren Ablageort im Prolog einer
      XML-Datei angegeben wird.
     &lt;/li&gt;
     &lt;li&gt;
      DTDs können aber auch (ganz oder teilweise) in
      XML-Dokumente eingebettet sein.
     &lt;/li&gt;
     &lt;li&gt;
      DTD-Anteile, die in eine Dokument eingebettet
      sind, werden als
      &lt;em&gt;internal Subset&lt;/em&gt;
      bezeichnet. Externe Anteile nennt man
      &lt;em&gt;external Subset&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Das external Subset wird mit Hilfe von
      &lt;em&gt;System&lt;/em&gt;
      oder
      &lt;em&gt;Public Identifiern&lt;/em&gt;
      angegeben.
     &lt;/li&gt;
     &lt;li&gt;
      Die DTD-Syntax erinnert leicht an XML-Syntax
      (ist aber keine!) und hat dabei insbesondere
      Ähnlichkeit mit den Kommentaren in XML.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Grammatik und Beispiel&lt;/title&gt;
    &lt;note&gt;
     Öffnende Winkelklammer, Ausrufezeichen, dann SYSTEM-
     oder PUBLIC-Deklaration
    &lt;/note&gt;
    &lt;note&gt;
     System Identifier sind URIs, Public Identifier haben
     oft eine bestimmte Notation
    &lt;/note&gt;
    &lt;p&gt;Grammatik von Dokumenttyp-Deklarationen&lt;/p&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="83-87" /&gt;
    &lt;p&gt;
     Beispiel für ein XML-Dokument, dessen nicht
     öffentliche DTD als externe Ressource vorliegt:
    &lt;/p&gt;
    &lt;listing src="externe-dtd-deklaration.xml" /&gt;
    &lt;p&gt;Beispiel für ein XML-Dokument mit interner DTD:&lt;/p&gt;
    &lt;listing src="interne-dtd-deklaration.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;DTDs definieren...&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Strukturen verschiedener Elemente aus dem XML
      Information Set:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;Elemente&lt;/li&gt;
      &lt;li&gt;Attribute&lt;/li&gt;
      &lt;li&gt;Entitäten&lt;/li&gt;
      &lt;li&gt;Notationen&lt;/li&gt;
      &lt;li&gt;Processing Instructions&lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition von Elementen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Elemente sind offensichtliche Möglichkeit,
      XML-Dokumente zu strukturieren.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes XML-Dokument hat mindestens ein
      Wurzelelement. In einer DTD wird allerdings
      nicht festgelegt, welches Element Wurzelelement
      eines Dokuments ist.
     &lt;/li&gt;
     &lt;li&gt;
      In der DTD werden die
      &lt;em&gt;Namen&lt;/em&gt;
      und
      &lt;em&gt;Inhaltsmodelle&lt;/em&gt;
      von
      &lt;em&gt;Elementtypen&lt;/em&gt;
      angegeben.
     &lt;/li&gt;
     &lt;li&gt;Grammatik:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="90-93" /&gt;
    &lt;ul&gt;
     &lt;li&gt;Mögliche Inhaltsmodelle:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;Empty&lt;/em&gt;
       : Das Element hat keinen Inhalt (auch keinen
       Text!), es handelt sich um ein sogenanntes
       &lt;em&gt;leeres Element&lt;/em&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Any&lt;/em&gt;
       : Alle in der DTD definierten Elementtypen
       sind als Inhalt zugelassen, in beliebiger
       Reihenfolge. Auch Freitext (
       &lt;code&gt;#PCDATA&lt;/code&gt;
       für
       &lt;em&gt;parsed character data&lt;/em&gt;
       , also Text ohne Auszeichnungssymbole) ist
       erlaubt!
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Mixed&lt;/em&gt;
       : Im
       &lt;em&gt;gemischten Inhaltsmodell&lt;/em&gt;
       ist Freitext (ohne Auszeichnungssymbole)
       erlaubt sowie explizit benannte Elementtypen
       aus der DTD.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Children&lt;/em&gt;
       : Hier können Kindelemente namentlich
       benannt werden, die dann in der Reihenfolge
       ihrer Benennung als Kindelemente zugelassen
       sind. Die Kindelemente können darüber hinaus
       in Klammern gruppiert werden.
       &lt;br /&gt;
       Die Häufigkeit ihres Auftretens kann durch
       folgende Operatoren gesteuert werden:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        &lt;code&gt;?&lt;/code&gt;
        : optional (0 oder 1)
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;+&lt;/code&gt;
        : mindestens einmal (1 bis unendlich)
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;*&lt;/code&gt;
        : beliebig oft (0 bis unendlich)
       &lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition von Elementen - Beispiel&lt;/title&gt;
    &lt;listing
     src="erste-dtd.dtd"
     line="1-4" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Definition des Elements
      &lt;code&gt;Person&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Eine Person hat mindestens einen
      &lt;code&gt;Vorname&lt;/code&gt;
      n, genau einen
      &lt;code&gt;Nachname&lt;/code&gt;
      n und eventuell einen
      &lt;code&gt;Geburtsname&lt;/code&gt;
      n.
     &lt;/li&gt;
     &lt;li&gt;
      Die drei Elemente
      &lt;code&gt;Vorname&lt;/code&gt;
      ,
      &lt;code&gt;Nachname&lt;/code&gt;
      und
      &lt;code&gt;Geburtsname&lt;/code&gt;
      haben Freitext als Inhaltsmodell.
     &lt;/li&gt;
     &lt;li&gt;
      Die Reihenfolge, in der die drei Kindelemente
      innerhalb
      &lt;code&gt;Person&lt;/code&gt;
      im Dokument erscheinen können, wird durch die
      obige Definition festgelegt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition Gemischtes Inhaltsmodell&lt;/title&gt;
    &lt;p class="definition"&gt;
     Kann ein Element sowohl über Zeichenketten-artigen
     als auch Element-wertigen Inhalt verfügen, so wird
     sein Inhaltsmodell als
     &lt;em&gt;
      gemisches Inhaltsmodell (mixed content model)
     &lt;/em&gt;
     bezeichnet.
     &lt;br /&gt;
     Innerhalb eines solchen Elements dürfen
     Unicodezeichen und die zugelassenen Elemente in
     beliebiger Kombination auftreten.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Gemischtes Inhaltsmodell&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das
      &lt;em&gt;gemischte Inhaltsmodell&lt;/em&gt;
      erlaubt sowohl explizit benannte Elemente als
      auch beliebigen Freitext (ohne Markup-Symbole)
      als Inhalt von Elementen.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="92-93" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wird mit einem Trick in der Grammatik möglich!
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       exklusives Nebeneinander von markupfreiem
       beliebigen Text (
       &lt;code&gt;#PCDATA&lt;/code&gt;
       ) und benannten Elementen (
       &lt;code&gt;Name&lt;/code&gt;
       ) durch Verknüpfung mit exklusivem Oder (
       &lt;code&gt;|&lt;/code&gt;
       )
      &lt;/li&gt;
      &lt;li&gt;
       Danach aber wird erlaubt, diese gesamte
       Auswahlmöglichkeit durch den Stern beliebig
       oft zu wiederholen.
      &lt;/li&gt;
      &lt;li&gt;
       #PCDATA muß in der Definition des
       Inhaltsmodells an erster Stelle stehen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Damit ist eine beliebige Kombination aus
      Freitext und Markup als Inhaltsmodell möglich.
     &lt;/li&gt;
     &lt;li&gt;
      Die Typen der Kindelemente können demnach
      angegeben werden, aber nicht ihre Reihenfolge
      oder ihre Auftretenshäufigkeit.
     &lt;/li&gt;
     &lt;li&gt;
      Whitespace ist immer als Elementinhalt erlaubt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Gemischtes Inhaltsmodell - Beispiel&lt;/title&gt;
    &lt;listing src="mixed-content.dtd" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Im Beispiel ist für das Element
      &lt;code&gt;p&lt;/code&gt;
      das gemischte Inhaltsmodell definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Erlaubt sind die Kindelemente
      &lt;code&gt;a&lt;/code&gt;
      ,
      &lt;code&gt;ul&lt;/code&gt;
      ,
      &lt;code&gt;b&lt;/code&gt;
      ,
      &lt;code&gt;i&lt;/code&gt;
      und
      &lt;code&gt;em&lt;/code&gt;
      in beliebiger Reihenfolge.
     &lt;/li&gt;
     &lt;li&gt;
      Darüber hinaus können an beliebigen Stellen
      innerhalb
      &lt;code&gt;p&lt;/code&gt;
      beliebige Zeichenketten stehen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Elementdefinition - Beispiel&lt;/title&gt;
    &lt;p&gt;
     Das Beispiel zeigt verschiedene Definitionen von
     Elementen.
    &lt;/p&gt;
    &lt;listing src="projektverwaltung1.dtd" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;code&gt;ProjektVerwaltung&lt;/code&gt;
      : enthält mindestens ein Element
      &lt;code&gt;Person&lt;/code&gt;
      sowie mindestens ein Element
      &lt;code&gt;Projekt&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Person&lt;/code&gt;
      : enthält mindestens ein Element
      &lt;code&gt;Vorname&lt;/code&gt;
      und genau ein Element
      &lt;code&gt;Nachname&lt;/code&gt;
      . Überdies kann optional das Element
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      darin enthalten sein.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      : enthält das gemischte Inhaltsmodell: Freitext,
      in dem an beliebigen Stellen die Elemente
      &lt;code&gt;Qualifikation&lt;/code&gt;
      oder
      &lt;code&gt;Leistungsstufe&lt;/code&gt;
      vorkommen können.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Qualifikation&lt;/code&gt;
      ,
      &lt;code&gt;Leistungsstufe&lt;/code&gt;
      ,
      &lt;code&gt;Vorname&lt;/code&gt;
      und
      &lt;code&gt;Nachname&lt;/code&gt;
      : enthalten jeweils markupfreien Text.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Projekt&lt;/code&gt;
      : leeres Element. Im XML-Dokument darf es keine
      Kindelemente enthalten.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Elementdefinition - Beispieldokument&lt;/title&gt;
    &lt;p&gt;
     Hier sehen Sie ein gegenüber dieser DTD gültiges
     XML-Dokument.
    &lt;/p&gt;
    &lt;listing src="projektverwaltung1.xml" /&gt;
    &lt;p&gt;Insbesondere:&lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mehrfaches Auftreten von
      &lt;code&gt;Vorname&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Gemischtes Inhaltsmodell innerhalb von
      &lt;code&gt;Qualifikationsprofil.&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Mehrfaches Auftreten des Elements
      &lt;code&gt;Qualifikation&lt;/code&gt;
      .
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Parameter Entities&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Parameter Entities bieten die Möglichkeit,
      Definitionen zu "verschachteln" und so die DTD
      leichter lesbar zu machen.
     &lt;/li&gt;
     &lt;li&gt;
      Gruppierungen können erstellt und
      wiederverwendet werden.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="parameter-entities.dtd"
     line="1-18" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ersetzt man die Entität %a.content; für a, so
      ergibt sich folgendes Bild:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="parameter-entities.dtd"
     line="21" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ersetzt man weitere Entitäten (beispielhaft für
      &lt;code&gt;%special;&lt;/code&gt;
      und
      &lt;code&gt;%fontstyle;&lt;/code&gt;
      durchgeführt) so erscheint die Definition von
      &lt;code&gt;a&lt;/code&gt;
      als:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="parameter-entities.dtd"
     line="22" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Parameter Entities am Beispiel der XHTML 1
     Transitional DTD
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In den DTDs für HTML und XHTML, z.B. der
      &lt;a
       href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
       XHTML1 Strict DTD
      &lt;/a&gt;
      , finden Parameter Entities starke Verwendung.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="xhtml1-strict.dtd" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Elementdefinition - Einschränkungen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      DTD erlaubt lediglich die Spezifikation von
      Kindelementen und Freitext sowie deren
      Kombination (gemischter Inhalt).
     &lt;/li&gt;
     &lt;li&gt;
      Das bedeutet: keine Angabe von Datentypen für
      den Inhalt von Elementen möglich!
     &lt;/li&gt;
     &lt;li&gt;
      Starke Einschränkung für Dokumente, die zum
      Datenaustausch dienen sollen!
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition von Attributen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Syntax zur Definition der Attribute ist ähnlich
      zu SGML.
     &lt;/li&gt;
     &lt;li&gt;
      Attribute werden als sogenannte
      &lt;em&gt;Attributlisten&lt;/em&gt;
      angegeben.
     &lt;/li&gt;
     &lt;li&gt;Sie stehen immer in Beziehung zum Element.&lt;/li&gt;
     &lt;li&gt;Grammatik:&lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Grammatik.txt"
     line="96-104" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Anschließend an den Elementnamen werden die für
      dieses Element zugelassenen Attribute definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Einfachster Fall: der (eindeutige) Attributname,
      ein Datentyp (gemäß der Produktionen 55 und 56)
      und die Angabe, ob es sich um ein optionales (
      &lt;code&gt;#IMPLIED&lt;/code&gt;
      ) oder zwingend anzugebendes (
      &lt;code&gt;#REQUIRED&lt;/code&gt;
      ) Attribut handelt..
     &lt;/li&gt;
     &lt;li&gt;
      Darüber hinaus können Attribute als mit
      Vorgabewerten belegt (
      &lt;code&gt;AttValue&lt;/code&gt;
      ) und zusätzlich als konstant (#FIXED)
      deklariert werden. Ihre vorgegebenen Werte
      werden, wenn sie im XML-Dokument nicht angegeben
      sind, durch einen validierenden XML-Parser an
      die verarbeitende Applikation weitergegeben.
      Darüberhinaus prüft der Parser für Konstanten,
      ob der angegebene Attributwert mit der Vorgabe
      übereinstimmt.
     &lt;/li&gt;
     &lt;li&gt;
      Datentypen, die für Attribute zur Verfügung
      stehen:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;CDATA&lt;/code&gt;
       (
       &lt;em&gt;Character Data&lt;/em&gt;
       ): Zeichenketten-artiger Inhalt
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;ID&lt;/code&gt;
       ,
       &lt;code&gt;IDREF&lt;/code&gt;
       ,
       &lt;code&gt;IDREFS&lt;/code&gt;
       : Einfacher Mechanismus zur Referenzierung.
       Ein validierender Prozessor kann prüfen, ob
       die angegebenen Referenzen gültig sind. Alle
       Werte von Attributen des Typs
       &lt;code&gt;ID&lt;/code&gt;
       müssen eindeutige Bezeichner sein
       (andernfalls wird durch einen XML-Prozessor
       ein Fehler gemeldet). Durch
       &lt;code&gt;IDREF&lt;/code&gt;
       wird durch einen eindeutigen Verweis auf ein
       Element referenziert, wohingegen mit
       &lt;code&gt;IDREFS&lt;/code&gt;
       gleich eine ganze Liste von Verweisen
       angegeben werden kann. Die Verweisziele
       müssen existieren, andernfalls wird durch
       einen XML-Prozessor ein Fehler gemeldet.
      &lt;/li&gt;
      &lt;li&gt;
       Schwächen des
       &lt;code&gt;ID/IDREFS&lt;/code&gt;
       -Mechanismus:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        Die IDs befinden sich in einem
        virtuellen Bereich (ähnlich zu den
        XML-Namensräumen). Dieser Bereich kann
        nicht partitioniert werden. Folge:
        Namenskonflikte!
       &lt;/li&gt;
       &lt;li&gt;
        Die Verweisziele können nicht
        eingeschränkt werden (es kann auf jede
        ID referenziert werden, egal ob dies
        sinnvoll ist, oder nicht.).
       &lt;/li&gt;
       &lt;li&gt;
        Der Mechanismus arbeitet nicht
        dokumentübergreifend.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;li&gt;
       &lt;em&gt;Aufzählungstypen&lt;/em&gt;
       : Einfache Variante von anwenderdefinierten
       Datentypen. Sie werden durch Benennung der
       Alternativen gebildet. Syntaktisch werden
       sie durch Oder-Verknüpfungen voneinander
       abgetrennt und in runden Klammern dem
       Attributnamen nachgestellt.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Attributdefinition - Beispiel&lt;/title&gt;
    &lt;p&gt;
     Die bisherigen Elementdeklarationen werden in diesem
     Beispiel um Attributdefinitionen erweitert.
    &lt;/p&gt;
    &lt;listing src="projektverwaltung.dtd" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;code&gt;ProjektVerwaltung&lt;/code&gt;
      : enthält ein Attribut namens
      &lt;code&gt;version&lt;/code&gt;
      . Der Datentyp des Attributs ist
      zeichenketten-artig (
      &lt;code&gt;CDATA&lt;/code&gt;
      ). Darüber hinaus ist der Wert des Attributs auf
      den Wert
      &lt;code&gt;1.0&lt;/code&gt;
      festgelegt, dieser Wert ist auch vorgegeben..
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;Person&lt;/code&gt;
      : Für das Element werden drei Attribute
      definiert:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;PersID&lt;/code&gt;
       : zwingend anzugebendes Attribut vom Typ ID
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;Gehaltsgruppe&lt;/code&gt;
       : anwenderdefinierter Aufzählungstyp, wobei
       &lt;code&gt;1a&lt;/code&gt;
       als Vorgabewert angegeben ist.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;mitarbeitInProjekt&lt;/code&gt;
       : eine zwingend anzugebende Liste von
       Verweisen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      &lt;code&gt;Projekt&lt;/code&gt;
      : Ein Element dieses Typs kann mit fünf
      Attributen ausgestattet werden:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;ID&lt;/code&gt;
       : ein zwingend anzugebendes Attribut vom Typ
       &lt;code&gt;ID&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;date&lt;/code&gt;
       : ein Attribut des Typs
       &lt;code&gt;CDATA&lt;/code&gt;
       ohne Vorgabewert (
       &lt;code&gt;#IMPLIED&lt;/code&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;budget&lt;/code&gt;
       : ein Attribut des Typs
       &lt;code&gt;CDATA&lt;/code&gt;
       mit dem Vorgabewert
       &lt;code&gt;10000&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;Projektleiter&lt;/code&gt;
       : Eine zwingend anzugebende Referenz auf ein
       mit einer ID eindeutig gekennzeichnetes
       Element.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;Mitarbeiter&lt;/code&gt;
       : Eine zwingend anzugebende Verweisliste auf
       mehrere mit IDs gekennzeichnete Elemente
       (Achtung Schwäche: Verweis prinzipiell auch
       auf Projekte möglich!).
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Definition von Entitäten und Notationen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es ist möglich, in einer Dokumenttypdefinition
      eigene Textersetzungsmuster (sog.
      &lt;em&gt;Entitäten&lt;/em&gt;
      ) zu definieren. Dieses Sprachmerkmal ist nicht
      Bestandteil des XML-Schemamechanismus. Daher ist
      es hier nur der Vollständigkeit halber
      aufgeführt.
     &lt;/li&gt;
     &lt;li&gt;
      Aus oben genanntem Grund sollten Sie Entitäten
      besser nicht in neu zu definierenden
      XML-Grammatiken verwenden, da sich die Grammatik
      ansonsten nicht von einer DTD in eine
      Schemasprache umwandeln läßt.
     &lt;/li&gt;
     &lt;li&gt;
      Die Sytax für derartige Referenzierungen
      (einführendes
      &lt;code&gt;&amp;amp;&lt;/code&gt;
      und abschließendes
      &lt;code&gt;;&lt;/code&gt;
      ) ist bereits aus dem Abschnitt
      &lt;em&gt;
       &lt;a
        href="http://www.barbara-zengler.de/vorlesung/wohlgeformtheit.html#(57)"&gt;
        Unexpanded Entity Reference
       &lt;/a&gt;
      &lt;/em&gt;
      aus dem Kapitel
      &lt;a
       href="http://www.barbara-zengler.de/vorlesung/wohlgeformtheit.html"&gt;
       XML-Dokumente und Wohlgeformtheit
      &lt;/a&gt;
      bekannt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Definition von Entitäten und Notationen - Beispiel
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das dort eingeführte Beispiel hier erneut zur
      Wiederholung:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="XML-Dokument-mit-Entities.xml"
     line="1-12" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verwendung von Entitäten mit Kaufmanns-Und (
      &lt;code&gt;&amp;amp;&lt;/code&gt;
      ) und abschließendem Strichpunkt (
      &lt;code&gt;;&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entA&lt;/code&gt;
      ist eine interne Entität und wird durch die
      Zeichen
      &lt;code&gt;xyz&lt;/code&gt;
      ersetzt
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entB&lt;/code&gt;
      und
      &lt;code&gt;entC&lt;/code&gt;
      sind Referenzen auf externe Ressourcen.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;entC&lt;/code&gt;
      definiert darüberhinaus, daß es eine unter dem
      Namen
      &lt;code&gt;-//FHA//Symbol//DE&lt;/code&gt;
      öffentlich bekannte Quelle (
      &lt;code&gt;file://symbols&lt;/code&gt;
      ) referenziert.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Notationen für Ersetzungsmuster, die keine
      XML-kodierten Inhalte beinhalten (sondern etwa
      Binärdaten), wurden bereits in Abschnitt
      &lt;a
       href="file:///C:/bsz/webtest/VorlesungWS2008-09/vorlesung/wohlgeformtheit.html#(63)"&gt;
       Unparsed Entity Reference
      &lt;/a&gt;
      im Kapitel
      &lt;a
       href="http://www.barbara-zengler.de/vorlesung/wohlgeformtheit.html"&gt;
       XML-Dokumente und Wohlgeformtheit
      &lt;/a&gt;
      behandelt:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="XML-Dokument-mit-UnparsedEntity.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Definition von Entitäten und Notationen - Beispiel
     vordefinierte Entitäten
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das folgende Beispiel zeigt die Definition der
      in HTML und XML bekannten vordefinierten
      Entitäten.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="predefined-entities.dtd" /&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!-- Ende DTDs --&gt;



 &lt;presentation id="uebungsaufgabenDTDs"&gt;
  &lt;title short="uebungsaufgabenDTDs"&gt;
   Übungsaufgaben zum Thema DTDs
  &lt;/title&gt;
  &lt;date&gt;2008-10-27&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Übungsaufgaben zum Thema Dokumenttypdefinitionen (DTDs).
  &lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu DTDs&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Korrektur einer syntaktisch fehlerhaften DTD
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die folgende DTD ist syntaktisch falsch.
      Korrigieren Sie die Fehler.
     &lt;/li&gt;
     &lt;listing src="wrong.dtd"&gt;&lt;/listing&gt;
     &lt;!-- &lt;note&gt;
      &lt;li&gt;Lösung:&lt;/li&gt;
      &lt;listing src="right.dtd"&gt;&lt;/listing&gt;
      &lt;/note&gt;--&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Ermittlung einer DTD&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Erstellen Sie zu folgendem Dokument eine
      möglichst restriktive Document Type Definition.
      &lt;br /&gt;
      Ihre Dokumenttypdefinition soll für
      &lt;code&gt;att&lt;/code&gt;
      keine anderen Werte als
      &lt;code&gt;x&lt;/code&gt;
      und
      &lt;code&gt;y&lt;/code&gt;
      zulassen.
     &lt;/li&gt;
     &lt;listing src="uebungsaufgabe-dtd-erstellung.xml"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;DTD-Konformität&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ist das angegebene Dokument konform zur
      dargestellten DTD?
      &lt;br /&gt;
      Welche Änderungen müssen am Dokument vollzogen
      werden, um die Konformität herzustellen, ohne
      Information zu verlieren?
     &lt;/li&gt;
     &lt;listing
      src="uebungsaufgabe-dtd-konformitaet.xml"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!-- Ende Übungsaufgaben DTD --&gt;


 &lt;presentation id="uebungenDTDs"&gt;
  &lt;title short="uebungenDTDs"&gt;Übungen zum Thema DTDs&lt;/title&gt;
  &lt;date&gt;2008-10-27&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Übungen aus der Vorlesung zum Thema Dokumenttypdefinitionen
   (DTDs).
  &lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;
    Übungen aus der Vorlesung zum Thema
    Dokumenttypdefinitionen (DTDs).
   &lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Erstellen eines Beispieldokuments&lt;/title&gt;
    &lt;p&gt;
     Gegeben sei folgende DTD. Erstellen Sie ein
     Beispieldokument dazu.
    &lt;/p&gt;
    &lt;p&gt;
     Eine mögliche Lösung zu dieser Aufgabe finden Sie
     auf der nächsten Seite.
    &lt;/p&gt;
    &lt;listing src="uebung-dtd-1.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Erstellen eines Beispieldokuments - Lösung
    &lt;/title&gt;
    &lt;p&gt;
     Nachfolgendes Listing zeigt ein mögliches
     Instanzdokument für die gegebene DTD.
    &lt;/p&gt;
    &lt;listing src="uebung-dtd-1-loesung.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Erstellen einer DTD&lt;/title&gt;
    &lt;p&gt;
     Gegeben sei folgendes XML-Dokument. Erstellen Sie
     eine DTD dazu.
    &lt;/p&gt;
    &lt;p&gt;
     Eine mögliche Lösung zu dieser Aufgabe finden Sie
     auf der nächsten Seite.
    &lt;/p&gt;
    &lt;listing src="uebung-dtd-2.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Erstellen einer DTD - Lösung&lt;/title&gt;
    &lt;p&gt;
     Nachfolgendes Listing zeigt eine mögliche DTD für
     das angegebene XML-Dokument.
    &lt;/p&gt;
    &lt;listing src="uebung-dtd-2-loesung.xml" /&gt;
   &lt;/slide&gt;

  &lt;/part&gt;
 &lt;/presentation&gt;


 &lt;!-- Schema --&gt;
 &lt;presentation id="schemasprachen"&gt;
  &lt;title short="schemasprachen"&gt;
   XML Schemasprachen am Beispiel XML Schema
  &lt;/title&gt;
  &lt;date&gt;2008-11-03&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/XML/Schema"&gt;
    &lt;em&gt;XML Schema&lt;/em&gt;
    des W3C
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Neben den Document Type Definitions ist in jüngerer Zeit ein
   alternativer Ansatz in den Blickpunkt des Interesses
   gerückt: die XML-Schemasprachen.
   &lt;em&gt;
    &lt;a href="http://www.w3.org/XML/Schema"&gt;XML Schema&lt;/a&gt;
   &lt;/em&gt;
   (im Jahre 2001 als Empfehlung des W3C veröffentlicht) ist
   dabei die heutzutage am meisten verwendete Schemasprache für
   XML. Sie wurde ersonnen, um die Einschränkungen der DTDs,
   die in ihrer Dokumentenorientierung wurzeln, zu umgehen und
   insbesondere die Möglichkeit zur Datentypisierung zu
   realisieren.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;XML Schemasprachen - eine Einführung&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Der Begriff Schema&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Der Begriff
      &lt;em&gt;Schema&lt;/em&gt;
      kommt aus dem Umfeld der Datenbanken.
     &lt;/li&gt;
     &lt;li&gt;
      Man bezeichnet damit Informations- oder
      Datenmodelle, die als Konstruktionsvorlage oder
      Dokumentation für einen Datenbankentwurf dienen.
     &lt;/li&gt;
     &lt;li&gt;
      Ein Schema kann dabei beispielsweise in einer
      graphischen Datenmodellierungssprache (z.B. ERM
      oder E3R) vorliegen oder kann die
      Tabellenstruktur einer relationalen Datenbank
      bezeichnen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Warum ein Schema?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Zum Zeitpunkt, als SGML und damit die DTD
      erfunden wurde, waren diese hauptsächlich dafür
      vorgesehen, Dokumente in Papierform zu
      digitalisieren.
     &lt;/li&gt;
     &lt;li&gt;
      Es war damals noch nicht vorherzusehen, daß 30
      Jahre später eine Weiterentwicklung der Sprache
      hauptsächlich zur Strukturierung von Daten
      eingesetzt werden würde.
     &lt;/li&gt;
     &lt;li&gt;
      Heute werden XML-Sprachen verwendet, um
      beliebige datenorientierte Inhalte darzustellen.
      Für diesen Zweck ist der DTD-Mechanismus
      offenkundig nicht sehr gut geeignet.
     &lt;/li&gt;
     &lt;li&gt;
      Schemata definieren Bedingungen (sog.
      &lt;em&gt;constraints&lt;/em&gt;
      ) für XML-Dokumente. Das Definieren solcher
      Bedingungen mit Schemata ist besser, als diese
      dann später bei der Programmierung der
      Applikationen noch prüfen zu müssen. Die
      Datenvalidierung wird von der Applikationslogik
      getrennt (
      &lt;em&gt;
       &lt;a
        href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html"&gt;
        Separation of Concerns
       &lt;/a&gt;
      &lt;/em&gt;
      ,
      &lt;a href="http://www.cs.utexas.edu/users/EWD/"&gt;
       Edsger W. Dijkstra
      &lt;/a&gt;
      ).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Unzulänglichkeiten und Beschränkungen von DTDs
    &lt;/title&gt;
    &lt;p&gt;
     Für datenintensive Strukturen unterliegt der
     DTD-Mechanismus folgenden Einschränkungen:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;em&gt;Unzureichende Datentypunterstützung&lt;/em&gt;
      :
      &lt;br /&gt;
      Für Elemente kennen DTDs nur die 4
      &lt;a
       href="http://www.barbara-zengler.de/vorlesung/dtd.html#(11)"&gt;
       im letzten Kapitel vorgestellten
       Inhaltsmodelle
      &lt;/a&gt;
      das leere Element (
      &lt;code&gt;EMPTY&lt;/code&gt;
      ),
      &lt;code&gt;ANY&lt;/code&gt;
      , das
      &lt;em&gt;gemischte Inhaltsmodell&lt;/em&gt;
      sowie
      &lt;em&gt;namentlich benannte Kindelemente&lt;/em&gt;
      .
      &lt;br /&gt;
      Für Attribute gibt es neben der
      benutzerdefinierten Aufzählung noch die 8
      weiteren Typen
      &lt;code&gt;CDATA&lt;/code&gt;
      ,
      &lt;code&gt;ID&lt;/code&gt;
      ,
      &lt;code&gt;IDREF&lt;/code&gt;
      ,
      &lt;code&gt;IDREFS&lt;/code&gt;
      ,
      &lt;code&gt;ENTITY&lt;/code&gt;
      ,
      &lt;code&gt;ENTITIES&lt;/code&gt;
      ,
      &lt;code&gt;NMTOKEN&lt;/code&gt;
      ,
      &lt;code&gt;NMTOKENS&lt;/code&gt;
      (vgl.
      &lt;a
       href="http://www.barbara-zengler.de/vorlesung/dtd.html#(21)"&gt;
       Diskussion im letzten Kapitel
      &lt;/a&gt;
      ). Strenggenommen handelt es sich aber bei all
      diesen Datentypen um Zeichenketten, die
      lediglich keine Markup-Symbole enthalten dürfen
      (
      &lt;a
       href="http://www.w3.org/TR/2006/REC-xml11-20060816/#sec-attribute-types"&gt;
       In XML-Spezifikation nachlesen
      &lt;/a&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;
       Unzureichende Strukturierungsunterstützung
      &lt;/em&gt;
      : Die Operatoren
      &lt;code&gt;+&lt;/code&gt;
      ,
      &lt;code&gt;?&lt;/code&gt;
      und
      &lt;code&gt;*&lt;/code&gt;
      ermöglichen die Steuerung der Anzahl von
      Kindelementen. Allerdings ist dies sehr
      fehlerbehaftet und nur sehr schwer lesbar.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;
       Keine Unterstützung von Wiederverwendbarkeit
      &lt;/em&gt;
      : Definierte Elemente können wiederverwendet
      werden, dies gilt jedoch nicht für Attribute.
      Sie sind immer an das Element gebunden, für das
      sie definiert sind.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Starres Typsystem&lt;/em&gt;
      : Es ist nicht möglich, die vorgegebenen Typen
      an eigene Bedürfnisse anzupassen (z.B. durch
      Erweiterung oder Einschränkung).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;Keine Unterstützung von Namensräumen&lt;/em&gt;
      : Namensräume können in der DTD nicht angegeben
      werden.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;
       Nur rudimentärer Referenzierungsmechanismus
      &lt;/em&gt;
      : Die Möglichkeit zur Referenzierung mit dem
      &lt;code&gt;ID/IDREF&lt;/code&gt;
      -Mechanismus ist Einschränkungen unterworfen.
      Verknüpfen sind nur innerhalb eines Dokumentes
      möglich und es gibt keine Unterstützung dafür,
      Elemente sowohl hinsichtlich der Identifizierung
      durch IDs als auch in ihrer Eigenschaft als
      Verweisziel zu differenzieren (vgl. das
      &lt;a
       href="http://www.barbara-zengler.de/vorlesung/dtd.html#(22)"&gt;
       Beispiel der Projektverwaltung im vorigen
       Kapitel
      &lt;/a&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      &lt;em&gt;DTD-Syntax ist nicht XML&lt;/em&gt;
      : Die Syntax der DTD entspricht nicht der
      XML-Syntax. Tools müssen dies zusätzlich
      implementieren.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Schemasprachen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Als (bessere) Alternative zu DTDs wurden
      verschiedene (populäre und weniger populäre)
      Schemasprachen ersonnen, die zueinander in
      Konkurrenz standen und stehen (vgl.
      &lt;a
       href="http://xml.coverpages.org/schemas.html"&gt;
       Robin Covers Übersicht über die
       verschiedenen Schemasprachen
      &lt;/a&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      Teilweise haben verschiedene dieser
      Schemasprachen als Grundlage für die Entwicklung
      umfassenderer / populärerer Schemasprachten
      gedient.
     &lt;/li&gt;
     &lt;li&gt;
      Beispielsweise ist aus den Schemasprachen
      &lt;code&gt;
       &lt;a href="http://www.w3.org/TR/NOTE-ddml"&gt;
        Document Definition Markup Language
        (DDML)
       &lt;/a&gt;
      &lt;/code&gt;
      ,
      &lt;code&gt;
       &lt;a
        href="http://www.w3.org/TR/1998/NOTE-XML-data"&gt;
        XML Data
       &lt;/a&gt;
      &lt;/code&gt;
      ,
      &lt;code&gt;
       &lt;a href="http://www.w3.org/TR/dt4dtd"&gt;
        Datatypes for DTDs (DT4DTD)
       &lt;/a&gt;
      &lt;/code&gt;
      und
      &lt;code&gt;
       &lt;a href="http://www.w3.org/TR/NOTE-SOX/"&gt;
        Schema for Object-Oriented XML (SOX)
       &lt;/a&gt;
      &lt;/code&gt;
      die Schemasprache des W3C,
      &lt;em&gt;
       &lt;a href="http://www.w3.org/XML/Schema"&gt;
        XML Schema
       &lt;/a&gt;
      &lt;/em&gt;
      , entstanden.
     &lt;/li&gt;
     &lt;li&gt;
      Als weitere Schemasprache, die in direkter
      Konkurrenz zu XML Schema steht, ist
      &lt;em&gt;
       &lt;a
        href="http://www.oasis-open.org/committees/download.php/1149/RELAX%20NG%20Specification"&gt;
        Relax NG
       &lt;/a&gt;
      &lt;/em&gt;
      , spezifiziert im Gremium
      &lt;a href="http://www.oasis-open.org/"&gt;OASIS&lt;/a&gt;
      , zu sehen. Für RelaxNG gibt es zwei Notationen:
      eine XML-basierte Notation sowie eine sog.
      &lt;em&gt;Kompakte Syntax&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Die Sprache
      &lt;em&gt;
       &lt;a href="http://www.schematron.com/"&gt;
        Schematron
       &lt;/a&gt;
      &lt;/em&gt;
      verfolgt einen anderen Ansatz. Sie arbeitet
      nicht grammatikbasiert, sondern ermöglicht
      basierend auf
      &lt;em&gt;XPath&lt;/em&gt;
      und
      &lt;em&gt;XSLT Expressions&lt;/em&gt;
      die Erstellung von Regeln, denen jeweils
      bestimmte Teile eines Dokuments folgen müssen
      (=kontextsensitiv). Dabei zielt Schematron
      darauf ab, daß ein Mensch das Ergebnis der
      Überprüfung (eine textbasierte Nachricht) liest
      und auswertet. Schematron ist kein Ersatz für
      eine Grammatik, kann aber durchaus eine
      sinnvolle Ergänzung darstellen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;XML Schema&lt;/title&gt;
   &lt;part&gt;
    &lt;title&gt;Einführendes&lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der W3C Standard
       &lt;em&gt;
        &lt;a
         href="http://www.w3.org/XML/Schema"&gt;
         XML Schema
        &lt;/a&gt;
       &lt;/em&gt;
       (oft durch
       &lt;code&gt;XSD&lt;/code&gt;
       abgekürzt) ist von allen XML-Schemasprachen
       der meist genutzte. Damit kommt ihm die
       größte praktische Bedeutung zu.
      &lt;/li&gt;
      &lt;li&gt;
       XML-Schema bildet zusammen mit Der
       XML-Spezifikation selbst und den
       Namensräumen die Basis aller weiteren
       W3C-XML-Sprachstandards.
      &lt;/li&gt;
      &lt;li&gt;
       XML-Schema-Dokumente sind XML-Dokumente.
      &lt;/li&gt;
      &lt;li&gt;
       DTDs werden aller Wahrscheinlichkeit nach
       nicht komplett durch Schema ersetzt werden
       (das würde der selbstauferlegten Forderung
       der Kompatibilität mit SGML widersprechen).
      &lt;/li&gt;
      &lt;li&gt;
       Allerdings werden neu entwickelte
       XML-Sprachen heutzutage nicht mehr in der
       &lt;q&gt;old style&lt;/q&gt;
       DTD-Grammatik definiert, sondern stattdessen
       durch ein ausdrucksmächtigeres Schema.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema definiert...&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       ... Strukturen folgender Elemente aus dem
       XML Information Set:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;Elemente&lt;/li&gt;
       &lt;li&gt;Attribute&lt;/li&gt;
       &lt;li&gt;Keine Entitäten, keine Notationen&lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Einführendes&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Spezifikation selbst (bestehend aus den
       beiden Teilen
       &lt;a
        href="http://www.w3.org/TR/xmlschema-1/"&gt;
        XML Schema Part 1: Structures
       &lt;/a&gt;
       und
       &lt;a
        href="http://www.w3.org/TR/xmlschema-2/"&gt;
        XML Schema Part 2: Datatypes
       &lt;/a&gt;
       ) ist so schwer zu lesen, daß ein
       eigenständiges, nicht normatives Dokument
       generiert wurde, nämlich
       &lt;a
        href="http://www.w3.org/TR/xmlschema-0/"&gt;
        XML Schema Part 0: Primer
       &lt;/a&gt;
       . In diesem Dokument wird XML Schema an
       vielen Beispielen anschaulich illustriert.
      &lt;/li&gt;
      &lt;li&gt;
       XML Schema erlaubt es, Inhaltsmodelle für
       Elemente, Attributstrukturen und
       wiederverwendbare Strukturen zu definieren.
      &lt;/li&gt;
      &lt;li&gt;
       Der Standard bringt eine Reihe
       vordefinierter Datentypen mit (z.B.
       &lt;code&gt;string&lt;/code&gt;
       ,
       &lt;code&gt;integer&lt;/code&gt;
       ,
       &lt;code&gt;date&lt;/code&gt;
       ). Zusätzlich dazu können aber auch eigene
       Datentypen definiert werden.
      &lt;/li&gt;
      &lt;li&gt;
       XML Schema berücksichtigt Namensräume und
       definiert einen eigenen Namensraum, in dem
       sich alle Primitive zur Definition eines
       eigenen Schemas befinden:
       &lt;code&gt;
        http://www.w3.org/2001/XMLSchema
       &lt;/code&gt;
       (der Namensraum für die
       &lt;q&gt;Sprache XML Schema&lt;/q&gt;
       ). Dieser Namensraum wird sehr oft an das
       Präfix
       &lt;code&gt;xsd&lt;/code&gt;
       gebunden.
      &lt;/li&gt;
      &lt;li&gt;
       Der zweite durch XML Schema vordefinierte
       Namensraum ist der
       &lt;em&gt;Schema-Instance&lt;/em&gt;
       genannte Namensraum
       &lt;code&gt;
        http://www.w3.org/2001/XMLSchema-instance
       &lt;/code&gt;
       . In diesem Namensraum, der oft an das
       Präfix
       &lt;code&gt;xsi&lt;/code&gt;
       gebunden wird, befinden sich Elemente und
       Attribute aus XML-Schema, die in sogenannten
       &lt;em&gt;Instanzdokumenten&lt;/em&gt;
       (dies ist ein anderer Name für
       XML-Dokumente, die den Regeln des Schemas
       genügen) verwendet werden können.
      &lt;/li&gt;
      &lt;li&gt;
       Zusätzlich dazu kann in einem Schema ein
       sogenannter
       &lt;em&gt;Target Namespace&lt;/em&gt;
       angegeben werden. Dieser bezeichnet den
       Namensraum für die Elemente eines
       XML-Dokuments, das mit diesem Schema
       verknüpft ist (der Namensraum für die
       &lt;q&gt;Sprache des XML-Dokuments&lt;/q&gt;
       ). Dieser Namensraum ist nicht vorgegeben
       und frei wählbar.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Gültigkeit hinsichtlich eines Schemas,
      Gültigkeit und Wohlgeformtheit
     &lt;/title&gt;
     &lt;img
      src="schema-valid-documents.png"
      style="width : 80% ; margin : 4% ; " /&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Definition der Gültigkeit hinsichtlich eines
      Schemas
     &lt;/title&gt;
     &lt;p class="definition"&gt;
      Ein XML-Dokument heißt
      &lt;em&gt;
       gültig hinsichtlich eines Schemas (schema
       valid)
      &lt;/em&gt;
      , wenn es über ein Schema verfügt, und konform
      zu diesem aufgebaut ist.
     &lt;/p&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
   &lt;part&gt;
    &lt;title&gt;Bestandteile von XML-Schema&lt;/title&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Verknüpfen eines Dokuments mit einem Schema
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Im Gegensatz zu einer DTD kann ein
       XML-Schema-Dokument üblicherweise nicht als
       &lt;em&gt;internal Subset&lt;/em&gt;
       in ein XML-Dokument eingebettet werden.
      &lt;/li&gt;
      &lt;li&gt;
       Stattdessen wird die Verbindung zu einem
       Schema in einem XML-Dokument durch eines der
       beiden Attribute
       &lt;code&gt;schemaLocation&lt;/code&gt;
       bzw.
       &lt;code&gt;noNamespaceSchemaLocation&lt;/code&gt;
       (für den Fall, daß ein Schema ohne Target
       Namespace vorliegt) angegeben. Eines dieser
       Attribute muß im Wurzelelement des Dokuments
       angegeben werden.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Verknüpfen eines Dokuments mit einem Schema -
      Beispiel
     &lt;/title&gt;
     &lt;listing src="Schemareferenz.xml"&gt;&lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Verknüpfung von Dokument und Schema
       findet im Wurzelelement statt.
      &lt;/li&gt;
      &lt;li&gt;
       Der XML-Schema-Instanzen-Namensraum wird an
       das Präfix
       &lt;code&gt;xsi&lt;/code&gt;
       gebunden. Damit können Elemente und
       Attribute aus Schema in das Dokument
       eingebunden werden.
      &lt;/li&gt;
      &lt;li&gt;
       In der nächsten Zeile wird schon das erste
       Element aus Schema verwendet:
       &lt;code&gt;schemaLocation&lt;/code&gt;
       verknüpft durch Angabe der URI des Schemas
       das Dokument mit dem Schema.
      &lt;/li&gt;
      &lt;li&gt;
       Weil entweder
       &lt;code&gt;schemaLocation&lt;/code&gt;
       oder
       &lt;code&gt;noNamespaceSchemaLocation&lt;/code&gt;
       im Wurzelelement eines Dokuments angegeben
       werden müssen, ist die Angabe des
       Schema-Instanzen-Namensraums für jedes
       Dokument zwingend!
      &lt;/li&gt;
      .
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Schema für Schema - Metaschema!&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Jedes XML-Schema-Dokument ist ein
       XML-Dokument.
      &lt;/li&gt;
      &lt;li&gt;
       Jedes XML-Dokument kann durch ein Schema
       beschrieben werden.
      &lt;/li&gt;
      &lt;li&gt;
       Folge: Jedes XML-Schema-Dokument kann selbst
       wieder durch ein Schema (Schema für Schema)
       beschrieben werden.
      &lt;/li&gt;
      &lt;li&gt;
       Damit kann jedes Schema auf Gültigkeit
       hinsichtlich dieses Metaschemas überprüft
       werden. Das war eine wichtige Forderung beim
       Sprachentwurf von XML Schema. Für DTDs
       besteht diese Möglichkeit nicht.
      &lt;/li&gt;
      &lt;li&gt;
       Dieselben Tools, die die Gültigkeit eines
       Dokuments hinsichtlich eines Schemas prüfen,
       können auch die Gültigkeit eines Schemas
       hinsichtlich des Metaschemas prüfen.
      &lt;/li&gt;
      &lt;li&gt;
       Solch ein Metaschema ist wieder ein
       XML-Dokument - auch hierfür könnte man nun
       wieder ein Schema angeben...
      &lt;/li&gt;
      &lt;li&gt;
       Um zu vermeiden, daß hier eine unendliche
       Kette von Schemavalidierungen entsteht, hat
       man sich dazu entschlossen, das Schema für
       Schema durch sich selbst zu beschreiben.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Schema für Schema - Metaschema!&lt;/title&gt;
     &lt;img
      style="margin : 4%; width : 90%; "
      src="schemaValid.gif" /&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Typsystem&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       XML-Schema definiert insgesamt 44 sogenannte
       &lt;em&gt;Primitivtypen&lt;/em&gt;
       . Darunter finden sich die aus der DTD
       bekannten Element- und Attributtypen, sowie
       eine Fülle Neuer.
      &lt;/li&gt;
      &lt;li&gt;
       Den Datentypen lassen sich folgende
       Eigenschaften zuordnen:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        &lt;em&gt;Atomare&lt;/em&gt;
        versus
        &lt;em&gt;aggregierte&lt;/em&gt;
        Typen:
       &lt;/li&gt;
       &lt;ul&gt;
        &lt;li&gt;
         Unter einem
         &lt;em&gt;atomaren Datentyp&lt;/em&gt;
         versteht man einen Datentyp, der die
         kleinste Informationseinheit
         darstellt. Die Information ist nicht
         mehr weiter unterteilbar, d.h. nicht
         mehr erkennbar weiter
         unterstrukturiert (Beispiel
         &lt;code&gt;string&lt;/code&gt;
         ) oder der Zugriff auf die
         Teilkomponenten ist nicht möglich
         (Beispiel:
         &lt;code&gt;date&lt;/code&gt;
         - kein Zugriff auf Jahr, Monat,
         Tag).
        &lt;/li&gt;
        &lt;li&gt;
         &lt;em&gt;Aggregierte Datentypen&lt;/em&gt;
         sind Datentypen, die sich entweder
        &lt;/li&gt;
        &lt;ul&gt;
         &lt;li&gt;
          aus Werten
          &lt;u&gt;
           eines oder mehrerer
           verschiedenen
          &lt;/u&gt;
          Datentypen zusammensetzen
          (Vereinigungstypen)
         &lt;/li&gt;
         &lt;li&gt;
          oder aus mehreren Werten
          &lt;u&gt;eines&lt;/u&gt;
          atomaren Datentyps
          zusammensetzen (Listen), z.B.
          drei Dezimalzahlen
          &lt;code&gt;8 10.5 12&lt;/code&gt;
          .
         &lt;/li&gt;
        &lt;/ul&gt;
       &lt;/ul&gt;
       &lt;li&gt;
        &lt;em&gt;Primitive&lt;/em&gt;
        versus
        &lt;em&gt;abgeleitete Typen&lt;/em&gt;
        :
       &lt;/li&gt;
       &lt;ul&gt;
        &lt;li&gt;
         &lt;em&gt;Primitive Datentypen&lt;/em&gt;
         existieren unabhängig von anderen
         Datentypen (z.B.
         &lt;code&gt;float&lt;/code&gt;
         ).
        &lt;/li&gt;
        &lt;li&gt;
         &lt;em&gt;Abgeleitete Datentypen&lt;/em&gt;
         benötigen andere Datentypen, von
         deren Definition sie abhängig sind
         (z.B.
         &lt;code&gt;&lt;/code&gt;
         )
        &lt;/li&gt;
       &lt;/ul&gt;
       &lt;li&gt;
        &lt;em&gt;Vorgegebene&lt;/em&gt;
        versus
        &lt;em&gt;anwenderdefinierte Typen&lt;/em&gt;
        :
       &lt;/li&gt;
       &lt;ul&gt;
        &lt;li&gt;
         &lt;em&gt;Vorgegebenen Datentypen&lt;/em&gt;
         sind all diejenigen die in
         &lt;a
          href="http://www.w3.org/TR/xmlschema-2/"&gt;
          XML Schema Part 2
         &lt;/a&gt;
         definiert sind. Es wurden all
         diejenigen Datentypen definiert, die
         mit einer hohen Wahrscheinlichkeit
         von einer großen Anzahl Benutzern
         "neu erfunden" worden wären.
        &lt;/li&gt;
        &lt;li&gt;
         &lt;em&gt;Anwenderdefinierte Typen&lt;/em&gt;
         können vom Benutzer selbst
         festgelegt werden.
        &lt;/li&gt;
       &lt;/ul&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Typsystem&lt;/title&gt;
     &lt;img
      src="type-hierarchy.gif"
      style="margin : 4% ;"&gt;
     &lt;/img&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XML Schema - Datentypen - Datum und Zeit
     &lt;/title&gt;
     &lt;table
      border="1"
      cellpadding="5"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Typname&lt;/th&gt;
        &lt;th&gt;Beispiel&lt;/th&gt;
        &lt;th&gt;Bemerkung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;time&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          13:20:00-05:00, 13:20:00.000
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Uhrzeit, die täglich wiederkehrt,
         ausgedrückt im Format gemäß ISO 8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;date&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;2007-11-13&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Datumsformat: CCYY-MM-DD, gemäß ISO
         8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;gYear&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;1999, 2001, 2004, 2007&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Darstellung von Jahren des
         gregorianischen Kalenders gemäß ISO
         8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;gYearMonth&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;2007-11&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Darstellung eines Monats eines
         bestimmten Jahres des
         gregorianischen Kalenders gemäß ISO
         8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;gDay&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;----05, ----31&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Darstellung eines wiederkehrenden
         Tages eines Monats gemäß ISO 8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;gMonthDay&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;--31-12, --01-01&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Darstellung eines wiederkehrenden
         gregorianischen Datums, gebildet aus
         Tag Monat und Monat im Format
         &lt;code&gt;--MM-DD&lt;/code&gt;
         , gemäß ISO 8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;gMonth&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;--03, --12&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Monatsformat:
         &lt;code&gt;--MM--&lt;/code&gt;
         gemäß ISO 8601
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;dateTime&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          2007-11-13T08:09:46.000+01:00
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Zeitpunkt, ausgedrückt durch Datum
         und Uhrzeit; beide gemäß ISO 8601
         codiert.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;duration&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          P1Y2M3DT10H30M12.3S
          &lt;br /&gt;
          Zeitraum von einem Jahr, zwei
          Monaten, drei Tagen, zehn
          Stunden, 30 Minuten und 12,3
          Sekunden
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Nach Größe (Signifikanz) geordnete
         Koordinate im sechs-dimensionalen
         Raum aus Jahr, Monat, Tag, Stunde,
         Minute und Sekunde. Formatdefinition
         laut ISO 8601
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;

    &lt;slide&gt;
     &lt;title&gt;
      XML Schema - Datentypen - String und davon
      Abgeleitete
     &lt;/title&gt;
     &lt;table
      border="1"
      cellpadding="5"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Typname&lt;/th&gt;
        &lt;th&gt;Beispiel&lt;/th&gt;
        &lt;th&gt;Bemerkung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;string&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          &amp;#x00A0; &amp;#x00A0; Hello
          &amp;amp;#xD;&amp;amp;#xA; World
         &lt;/code&gt;
         &lt;note&gt;
          (Carriage Return, Line Feed)
         &lt;/note&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Jedes beliebige Unicode Symbol gemäß
         &lt;a
          href="http://www.w3.org/TR/2006/REC-xml11-20060816/#charsets"&gt;
          XML-Grammatikregel
          (Syntaxproduktion) 2
         &lt;/a&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;normalizedString&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          &amp;amp;#20;Hello&amp;amp;#20;World
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Jedes beliebige Unicode Symbol außer
         Zeilenvorschub (
         &lt;code&gt;#xA&lt;/code&gt;
         ), Wagenrücklauf (
         &lt;code&gt;#xD&lt;/code&gt;
         ) und Tabulatoren (
         &lt;code&gt;#x9&lt;/code&gt;
         ).
         &lt;br /&gt;
         &lt;code&gt;normalizedString&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;string&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;token&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;Hello World&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Jeder
         &lt;code&gt;normalizedString&lt;/code&gt;
         , unter Weglassung führender,
         abschließender und mehrfacher
         Leerzeichen (
         &lt;code&gt;#x20&lt;/code&gt;
         ), sowie Zeilenvorschüben und
         Tabulatoren.
         &lt;br /&gt;
         &lt;code&gt;token&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;normalizedString&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;language&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;en-GB, en, de-de&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Sprachcodierung gemäß IETF RFC 1766
         und XML Recommendation language
         identification. Die
         Identifikationsnamen werden durch
         ISO 639 sowie ISO 3166 definiert.
         &lt;code&gt;language&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;token&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;Name&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          aName, _helloWorld,
          :notAGoodIdea
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Ein XML Name gemäß
         &lt;a
          href="http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-Name"&gt;
          Syntaxproduktion 5
         &lt;/a&gt;
         .
         &lt;br /&gt;
         &lt;code&gt;Name&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;token&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;QName&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;xsd:element, element&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Durch Namensraumpräfix
         qualifizierter Name gemäß
         &lt;a
          href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-PrefixedName"&gt;
          Produktion 8 der XML Namespace
          Recommendation
         &lt;/a&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;NCName&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;aName, _anotherName, X&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Name, der keinen Doppelpunkt enthält
         (
         &lt;em&gt;non colonized name&lt;/em&gt;
         ), gemäß
         &lt;a
          href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/index.html#NT-NCName"&gt;
          Produktion 4 der XML Namespace
          Recommendation
         &lt;/a&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ID&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;test, XYZ&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;ID&lt;/code&gt;
         . Zugelassen sind alle Ausprägungen
         der Namespaceproduktion 4 (NCName).
         &lt;code&gt;ID&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;NCName&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;IDREF&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;test, XYZ&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;IDREF&lt;/code&gt;
         . Zugelassen sind alle Ausprägungen
         der Namespaceproduktion 4 (NCName).
         &lt;code&gt;IDREF&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;NCName&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;IDREFS&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          test1 test2 test4, test3 test5
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;IDREFS&lt;/code&gt;
         . Zugelassen sind Listen aus white
         space separierten Ausprägungen der
         Namespaceproduktion 4 (NCName).
         &lt;code&gt;IDREFS&lt;/code&gt;
         ist eine nichtleere Aufzählung von
         &lt;code&gt;IDREF&lt;/code&gt;
         -Ausprägungen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ENTITY&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;ENTITY&lt;/code&gt;
         . Zugelassen sind alle Satzformen,
         die der Produktion NCName der
         XML-Namensräume entsprechen und als
         ungeparste Entität definiert sind.
         &lt;code&gt;ENTITY&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;NCName&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ENTITIES&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;ENTITIES&lt;/code&gt;
         . Zugelassen sind Listen aus white
         space separierten Ausprägungen des
         Typs
         &lt;code&gt;ENTITY&lt;/code&gt;
         .
         &lt;code&gt;ENTITIES&lt;/code&gt;
         ist eine nichtleere Aufzählung von
         &lt;code&gt;ENTITY&lt;/code&gt;
         -Ausprägungen
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;NMTOKEN&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;US, Deutschland&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;NMTOKEN&lt;/code&gt;
         . Ausprägungen dieses Typs müssen
         konform zur Produktion 7 der
         XML-Spezifikation sein.
         &lt;code&gt;NMTOKEN&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;token&lt;/code&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;NMTOKENS&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;US UK Aus, Ger&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;NMTOKENS&lt;/code&gt;
         . Zugelassen sind Listen aus white
         space separierten Ausprägungen des
         Typs NMTOKEN. NMTOKENS ist eine
         nichtleere Aufzählung von
         NMTOKEN-Ausprägungen
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;

     &lt;/table&gt;
    &lt;/slide&gt;

    &lt;slide&gt;
     &lt;title&gt;
      XML Schema - Datentypen - decimal und davon
      Abgeleitete
     &lt;/title&gt;
     &lt;table
      border="1"
      cellpadding="5"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Typname&lt;/th&gt;
        &lt;th&gt;Beispiel&lt;/th&gt;
        &lt;th&gt;Bemerkung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;decimal&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -1.23, 12678967.543233,
          +100000.00, 210
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          i*10
          &lt;sup&gt;-n&lt;/sup&gt;
         &lt;/code&gt;
         , mit
         &lt;code&gt;i&lt;/code&gt;
         ,
         &lt;code&gt;n&lt;/code&gt;
         aus
         &lt;code&gt;integer, n&gt;=0&lt;/code&gt;
         &lt;br /&gt;
         Ein Prozessor muß mindestens 18
         Dezimalstellen unterstützen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;integer&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;...-1, 0, 1, ...&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich: entspricht der
         mathematischen Menge der ganzen
         Zahlen (Z)
         &lt;br /&gt;
         &lt;code&gt;integer&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;decimal&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;nonPositiveInteger&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;... -2, -1, 0&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;{..., -2, -1, 0}&lt;/code&gt;
         die unendliche Menge der negativen
         Zahlen, und die Null
         &lt;br /&gt;
         &lt;code&gt;nonPositiveInteger&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;integer&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;negativeInteger&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;... -2, -1&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;{..., -2, -1}&lt;/code&gt;
         , die unendliche Menge der negativen
         Zahlen
         &lt;br /&gt;
         &lt;code&gt;negativeInteger&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;nonPositiveInteger&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;long&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -9223372036854775808, ... -1, 0,
          1, ... 9223372036854775807
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          2
          &lt;sup&gt;63&lt;/sup&gt;
          &amp;lt;= long &amp;lt;= 2
          &lt;sup&gt;63&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;long&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;integer&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;int&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -2147483648, ... -1, 0, 1, ...
          2147483647
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          -2
          &lt;sup&gt;31&lt;/sup&gt;
          &amp;lt;= int &amp;lt;= 2
          &lt;sup&gt;31&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;int&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;long&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;short&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -32768, ... -1, 0, 1, ... 32767
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          -2
          &lt;sup&gt;15&lt;/sup&gt;
          &amp;lt;= short &amp;lt;= 2
          &lt;sup&gt;15&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;short&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;int&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;byte&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -128, ...-1, 0, 1, ... 127
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          -2
          &lt;sup&gt;7&lt;/sup&gt;
          &amp;lt;= byte &amp;lt;= 2
          &lt;sup&gt;7&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;byte&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;short&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;nonNegativeInteger&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;0, 1, 2, ...&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          0 &amp;lt;= nonNegativeInteger
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;nonNegativeInteger&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;integer&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;positiveInteger&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;1, 2, ...&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich: entspricht der
         mathematischen Menge der natürlichen
         Zahlen (N)
         &lt;br /&gt;
         &lt;code&gt;positiveInteger&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;nonNegativeInteger&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;unsignedLong&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          0, 1, ... 18446744073709551615
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          0 &amp;lt;= unsignedLong &amp;lt;= 2
          &lt;sup&gt;64&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;unsignedLong&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;nonNegativeInteger&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;unsignedInt&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;0, 1, ...4294967295&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          0 &amp;lt;= unsignedInt &amp;lt;= 2
          &lt;sup&gt;32&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;unsignedInt&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;unsignedLong&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;unsignedShort&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;0, 1, ... 65535&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          0 &amp;lt;= unsignedShort &amp;lt;= 2
          &lt;sup&gt;16&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;unsignedShort&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;unsignedInt&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;unsignedByte&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;0, 1, ... 255&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Wertebereich:
         &lt;code&gt;
          0 &amp;lt;= unsignedByte &amp;lt;= 2
          &lt;sup&gt;8&lt;/sup&gt;
          -1
         &lt;/code&gt;
         &lt;br /&gt;
         &lt;code&gt;unsignedByte&lt;/code&gt;
         ist eine einschränkende
         Spezialisierung des Typs
         &lt;code&gt;unsignedShort&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;

    &lt;slide&gt;
     &lt;title&gt;
      XML Schema - Datentypen - weitere vordefinierte
      Primitivtypen
     &lt;/title&gt;
     &lt;table
      border="1"
      cellpadding="5"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Typname&lt;/th&gt;
        &lt;th&gt;Beispiel&lt;/th&gt;
        &lt;th&gt;Bemerkung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;boolean&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;true, false, 1, 0&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Unterstützung der klassischen
         zweiwertigen Logik
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;base64Binary&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;SGVsbG8gd29ybGQhCg==&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Base64-Darstellung eines beliebigen
         Binär-interpretierten Inhaltes gemäß
         IETF RFC 2045
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;hexBinary&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;0FB7&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Hexadezimale Darstellung beliebiger
         Binär-interpretierter Inhalte
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;float&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -1E4, 1267.43233E12, 12.78e-2,
          12, INF
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         32-Bit-Zahl mit einfacher
         Genauigkeit gemäß IEEE 754-1985.
         &lt;br /&gt;
         Wertebereich:
         &lt;code&gt;
          m * 2
          &lt;sup&gt;e&lt;/sup&gt;
         &lt;/code&gt;
         , wobei
         &lt;code&gt;m&lt;/code&gt;
         und
         &lt;code&gt;e&lt;/code&gt;
         &lt;code&gt;integer&lt;/code&gt;
         -Elemente mit
         &lt;code&gt;
          m &amp;lt;= 224, und -149 &amp;lt;= e
          &amp;lt; 104
         &lt;/code&gt;
         sind.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;double&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          -1E4, 1267.43233E12, 12.78e-2,
          12, INF
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         64-Bit-Zahl mit doppelter
         Genauigkeit gemäß IEEE 754-1985.
         &lt;br /&gt;
         Wertebereich:
         &lt;code&gt;
          m * 2
          &lt;sup&gt;e&lt;/sup&gt;
         &lt;/code&gt;
         , wobei
         &lt;code&gt;m&lt;/code&gt;
         und
         &lt;code&gt;e&lt;/code&gt;
         &lt;code&gt;integer&lt;/code&gt;
         -Elemente mit
         &lt;code&gt;
          m &amp;lt;= 253, und -1075 &amp;lt;= e
          &amp;lt; 970
         &lt;/code&gt;
         sind.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;anyURI&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          http://www.barbara-zengler.de/
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Jede gemäß IETF RFC 2396 bzw. IETF
         RFC 2732 gültige URI
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;QName&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;xsd:element, element&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Durch Namensraumpräfix
         qualifizierter Name gemäß
         &lt;a
          href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-PrefixedName"&gt;
          Produktion 8 der XML Namespace
          Recommendation
         &lt;/a&gt;
         .
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;NOTATION&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         XSD-Darstellung des DTD-Typen
         &lt;code&gt;NOTATION&lt;/code&gt;
         . Zur Verwendung dieses Typs in
         einem Schema muß eine Ableitung von
         &lt;code&gt;NOTATION&lt;/code&gt;
         durch den Anwender definiert werden.
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XML Schema am Beispiel - Wurzelelement
      &lt;code&gt;schema&lt;/code&gt;
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Den Wurzelknoten bildet das Element
       &lt;code&gt;schema&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Direkt unterhalb dieses Elements werden in
       einer flachen Struktur alle Definitionen
       dieses Schemas angegeben.
      &lt;/li&gt;
      &lt;li&gt;
       Attribute des
       &lt;code&gt;schema&lt;/code&gt;
       -Elements:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        (Optionale) Angabe des Namensraums für
        das Zielvokabular:
        &lt;code&gt;targetNamespace&lt;/code&gt;
        als URI.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;elementFormDefault&lt;/code&gt;
        : kann den Namensraumzwang für Elemente
        des Instanzdokuments lockern.
        &lt;code&gt;qualified&lt;/code&gt;
        gibt an, daß sich die Elemente des
        Dokuments immer im Zielnamensraum
        befinden müssen,
        &lt;code&gt;unqualified&lt;/code&gt;
        hingegen erlaubt das Vorkommen von
        Elementen auch außerhalb dieses
        Namensraums. Vorgabewert:
        &lt;code&gt;unqualified&lt;/code&gt;
        .
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;attributeFormDefault&lt;/code&gt;
        : analog für Attribute.
       &lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
     &lt;listing
      src="projektverwaltung.xsd"
      line="2"&gt;
     &lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Elementdefinitionen&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;Direkt unterhalb des Wurzelelements&lt;/li&gt;
      &lt;li&gt;
       Durch das XSD-Element
       &lt;code&gt;element&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       XML Schema bringt zahlreiche vordefinierte
       Elementtypen mit, darüber hinaus erlaubt es
       auch die Definition eigener Typen.
      &lt;/li&gt;
      &lt;li&gt;
       Es unterstützt auch die Inhaltsmodelle der
       DTD: unstrukturierter Inhalt (Text), leeres
       Inhaltsmodell, explizit benannte
       Kindelemente, beliebige Kindelemente,
       gemischtes Inhaltsmodell.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;listing
      src="schema.xsd"
      line="3-5"&gt;
     &lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Entspricht -- abgesehen von der
       Typdefinition -- bis hierher den
       Möglichkeiten, die auch DTDs bieten.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Elementeigenschaften&lt;/title&gt;
     &lt;p&gt;
      Des weiteren können folgende Eigenschaften für
      Elemente mit Hilfe von Attributen angegeben
      werden:
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;abstract&lt;/em&gt;
       : falls auf
       &lt;code&gt;true&lt;/code&gt;
       gesetzt, darf ein solches Element nicht in
       einem XML-Dokument auftreten. Es kann
       ausschließlich zur Strukturierung des
       Schemaentwurfs eingesetzt werden und als
       Basis von Spezialisierungen dienen.
       Vorgabewert ist
       &lt;code&gt;false&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;block&lt;/em&gt;
       : erlaubt es, die Verwendung abgeleiteter
       Typen zu kontrollieren. Zugelassene
       Belegungen sind beliebige Kombinationen aus
       &lt;code&gt;extension&lt;/code&gt;
       ,
       &lt;code&gt;restriction&lt;/code&gt;
       und
       &lt;code&gt;substitution&lt;/code&gt;
       oder der Einzelwert
       &lt;code&gt;#all&lt;/code&gt;
       .
       &lt;br /&gt;
       Die hier angegebenen Typen dürfen im
       Instanzdokument nicht als Ersatz des
       Originaltyps auftreten.
       &lt;br /&gt;
       Der Wert
       &lt;code&gt;#all&lt;/code&gt;
       verbietet generell die Ersetzung eines
       Elements durch andere.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;default&lt;/em&gt;
       : Vorgabebelegung des Inhalts durch eine
       beliebige Zeichenkette, die konform zum
       gewählten Typ ist. Dieser Wert wird durch
       den XML-Prozessor an die Applikation
       gemeldet, wenn kein Wert im Dokument
       angegeben wird.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;fixed&lt;/em&gt;
       : erlaubt es, Elemente mit einem konstanten
       Wert zu belegen.
       &lt;br /&gt;
       &lt;code&gt;default&lt;/code&gt;
       und
       &lt;code&gt;fixed&lt;/code&gt;
       schließen sich gegenseitig aus.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;final&lt;/em&gt;
       : verhindert die Ableitung von Typen. Die
       zulässigen Belegungen sind mit denen für
       &lt;em&gt;block&lt;/em&gt;
       identisch, nur daß durch dieses Attribut die
       Vererbungsmechanismen bereits auf
       Schemaebene verboten werden, während block
       ihre Nutzung im Instanzdokument einschränkt.
      &lt;/li&gt;
      &lt;li&gt;
       form: legt fest, ob das Element im
       Instanzdokument mit Namensraumpräfix
       erscheint. Zulässige Belegungen:
       &lt;code&gt;qualified&lt;/code&gt;
       (Namensraumpräfix muß angegeben werden) und
       &lt;em&gt;unqualified&lt;/em&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;id&lt;/em&gt;
       : erlaubt die eineindeutige Kennzeichnung
       eines Elements durch eine schemaweit
       eindeutige Zeichenkette.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;minOccurs&lt;/em&gt;
       : Minimalkardinalität, d.h. Mindestzahl
       zulässiger Vorkommen dieses Elements. Der
       Attributinhalt ist ein Element aus
       &lt;code&gt;nonNegativeInteger&lt;/code&gt;
       . Das Attribut ist optional, und wird bei
       fehlender Angabe mit dem Vorgabewert
       &lt;code&gt;1&lt;/code&gt;
       belegt.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;maxOccurs&lt;/em&gt;
       : Maximalkardinalität, d.h. Höchstzahl
       zulässiger Vorkommen dieses Elements. Der
       Attributinhalt ist entweder ein Element aus
       &lt;code&gt;nonNegativeInteger&lt;/code&gt;
       oder die Zeichenkette
       &lt;code&gt;unbounded&lt;/code&gt;
       zur Kennzeichnung beliebig vieler Auftreten.
       Das Attribut ist optional, und wird bei
       fehlender Angabe mit dem Vorgabewert
       &lt;code&gt;1&lt;/code&gt;
       belegt.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;name&lt;/em&gt;
       : Unqualifizierter Name des Elements,
       konform zur NCName-Produktion der
       Namensraum-Spezifikation.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;nillable&lt;/em&gt;
       : Erlaubt Null-Werte im Instanzdokument, die
       Semantik ist dabei an die in relationalen
       Datenbanksystemen verwirklichte angelehnt.
       Die Belegung ist entweder
       &lt;code&gt;true&lt;/code&gt;
       oder
       &lt;code&gt;false&lt;/code&gt;
       , was auch als Vorgabe bei Fehlen dieses
       Attributs angenommen wird.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;ref&lt;/em&gt;
       : Referenz auf eine andere
       Elementdeklaration zur Übernahme der dort
       spezifizierten Definitionen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;substitutionGroup&lt;/em&gt;
       : Name einer Gruppe von Elementen, die
       anstatt des aktuellen Elements im
       Instanzdokument auftreten dürfen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;type&lt;/em&gt;
       : Ein durch Schema Part 2 vordefinierter
       Typ, oder jeder beliebige
       anwenderdefinierte.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XML Schema am Beispiel - Elementdefinitionen
     &lt;/title&gt;
     &lt;p&gt;
      Nachfolgend finden Sie einige beispielhafte
      Elementdeklarationen für nicht strukturierten (=
      keine Kindelemente), aber typisierten,
      Elementinhalt:
     &lt;/p&gt;
     &lt;listing
      src="elementdeklarationen.xsd"
      line="3-15"&gt;
     &lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;geburtsdatum&lt;/code&gt;
       definiert ein XML-Element des Typs
       &lt;code&gt;date&lt;/code&gt;
       zur Darstellung eines Datums. Weitere
       Festlegungen sind nicht getroffen, daher
       wird das Element mit
       &lt;code&gt;minOccurs&lt;/code&gt;
       und
       &lt;code&gt;maxOccurs 1&lt;/code&gt;
       belegt. Damit ist es im Instanzdokument
       zwingend anzugeben.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;pi&lt;/code&gt;
       entspricht mit seiner konstanten Belegung (
       &lt;code&gt;fixed&lt;/code&gt;
       -Attribut) der gleichnamigen mathematischen
       Konstante. Als Datentyp wurde
       &lt;code&gt;double&lt;/code&gt;
       , eine Gleitkommazahl mit doppelter
       Genauigkeit gewählt. Durch die Belegung von
       &lt;code&gt;block&lt;/code&gt;
       mit
       &lt;code&gt;#all&lt;/code&gt;
       wird verhindert, daß eine weitere
       Spezialisierung des Elements durch Vererbung
       oder Aggregation erfolgt.
      &lt;/li&gt;
      &lt;li&gt;
       Die Definition für
       &lt;code&gt;vorname&lt;/code&gt;
       nutzt
       &lt;code&gt;token&lt;/code&gt;
       als Datentyp. Hier werden automatisch
       mehrfache, führende und abschließende
       Leerzeichen sowie sonstige
       Formatierungssymbole entfernt. Der Vorname
       kann darüber hinaus beliebig häufig
       auftreten --
       &lt;code&gt;maxOccurs&lt;/code&gt;
       ist mit dem Wert
       &lt;code&gt;unbounded&lt;/code&gt;
       belegt. Die minimale Auftrittshäufigkeit
       wird mit
       &lt;code&gt;1&lt;/code&gt;
       (
       &lt;code&gt;minOccurs&lt;/code&gt;
       ) festgelegt, dies entspricht der
       Vorgabebelegung.
      &lt;/li&gt;
      &lt;li&gt;
       Für das Element
       &lt;code&gt;artikelNummer&lt;/code&gt;
       ist als Typ
       &lt;code&gt;NCName&lt;/code&gt;
       ausgewählt. Dies entspricht beliebigen
       Zeichenketten, die keinen Doppelpunkt
       enthalten. Darüberhinaus ist das Attribut
       &lt;code&gt;form&lt;/code&gt;
       mit dem Wert
       &lt;code&gt;qualified&lt;/code&gt;
       versehen. Dies führt dazu, daß das
       Namensraumkürzel für dieses Element zwingend
       im Instanzdokument anzugeben ist.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Elementdefinition - freies Inhaltsmodell
     &lt;/title&gt;
     &lt;p&gt;
      Zur Umsetzung des freien Inhaltsmodells, das
      beliebige Inhalte aus den definierten Elementen
      und freien Texten zuläßt, wird ebenfalls auf das
      Typsystem zurückgegriffen.
      &lt;br /&gt;
      Wird das
      &lt;code&gt;type&lt;/code&gt;
      Attribut nicht belegt, so wird gemäß Vorgabe der
      Typ
      &lt;code&gt;anyType&lt;/code&gt;
      angenommen. Elemente dieses Typs können
      beliebige wohlgeformte Inhalte beherbergen.
      &lt;br /&gt;
      Die beiden nachfolgenden Angaben sind daher
      äquivalent:
     &lt;/p&gt;
     &lt;listing
      src="elementdeklarationen.xsd"
      line="15-18" /&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Verwendung von Typen -
      &lt;code&gt;complexType&lt;/code&gt;
      - leeres Inhaltsmodell
     &lt;/title&gt;
     &lt;p&gt;
      XSD hat verglichen mit der DTD einen strengeren
      Typbegriff. Dies zeigt sich deutlich in der
      Existenz des XSD-Elements
      &lt;code&gt;complexType&lt;/code&gt;
      . Dieses Element erlaubt die Bildung von Typen
      losgelöst von ihrere Verwendung. Syntaktisch
      kann die
      &lt;code&gt;complexType&lt;/code&gt;
      -Definition sowohl innerhalb einer
      Elementdefinition, als auch separat erfolgen.
      &lt;br /&gt;
      Den einfachsten Anwendungsfall bildet die
      eingebettete leere
      &lt;code&gt;complexType&lt;/code&gt;
      -Definition zur Darstellung des leeren
      Inhaltsmodells.
      &lt;br /&gt;
      Die Syntax hierfür lautet (der XSD-Namensraum
      sei an das Präfix
      &lt;code&gt;xsd&lt;/code&gt;
      gebunden):
     &lt;/p&gt;
     &lt;listing
      src="elementdeklarationen.xsd"
      line="19-22"&gt;
     &lt;/listing&gt;
     &lt;p&gt;
      In einem Instanzdokument werden für die obige
      Festlegung ausschließlich die beiden
      Darstellungsformen zum leeren Element (
      &lt;code&gt;&amp;lt;elementName/&amp;gt;&lt;/code&gt;
      bzw.
      &lt;code&gt;
       &amp;lt;elementName&amp;gt;&amp;lt;/elementName&amp;gt;
      &lt;/code&gt;
      ) akzeptiert.
     &lt;/p&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Verwendung von Typen -
      &lt;code&gt;complexType&lt;/code&gt;
      - strukturierter Inhalt - Reihenfolgetypen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       In XML Schema wird explizit angegeben, in
       welcher Reihenfolge Kindelemente auftreten
       sollen. Hierfür gibt es folgende drei
       Möglichkeiten, die miteinander kombiniert
       werden können:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        &lt;code&gt;sequence&lt;/code&gt;
        : Sequentielles Auftreten der Elemente
        in der angegebenen Reihenfolge.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;choice&lt;/code&gt;
        : Auswahl - entspricht einer
        &lt;code&gt;ODER&lt;/code&gt;
        -Verknüpfung von einzelnen Elementen.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;all&lt;/code&gt;
        : Erlaubt die Angabe der Kindelemente in
        beliebiger Reihenfolge.
       &lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Elementdefinition und Reihefolgetypen am
      Beispiel Projektverwaltung
     &lt;/title&gt;
     &lt;listing src="projektverwaltung1.xsd"&gt;&lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       In diesem Schema sind alle
       Elementdefinitionen für die
       Projektverwaltung enthalten. In diesem
       Beispiel werden 4 Dinge demonstriert:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        Innerhalb jedes
        &lt;code&gt;element&lt;/code&gt;
        -Elements sind die entsprechenden
        Kindelemente in
        &lt;code&gt;sequence&lt;/code&gt;
        -Strukturen eingebettet. Sie müssen
        genau in der Reihenfolge ihres
        Auftretens im Schema auch im
        Instanzdokument wiedergegeben werden.
       &lt;/li&gt;
       &lt;li&gt;
        Verwendung des leeren Inhaltsmodells für
        &lt;code&gt;Projekt&lt;/code&gt;
       &lt;/li&gt;
       &lt;li&gt;
        Verwendung des gemischten Inhaltsmodells
        (siehe nächste Seite) für
        &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
       &lt;/li&gt;
       &lt;li&gt;
        Referenzierung auf Elementdefinitionen
        mit Hilfe des
        &lt;code&gt;ref&lt;/code&gt;
        -Attributs.
       &lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Gemischtes Inhaltsmodell im Vergleich zur DTD
     &lt;/title&gt;
     &lt;listing
      src="projektverwaltung1.xsd"
      line="23-30"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="projektverwaltung1.dtd"
      line="3-5"&gt;
     &lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Von besonderem Interesse ist die Definition
       des Qualifikationsprofils mit gemischtem
       Inhaltsmodell. Dies wird durch das
       Boole'sche Attribut
       &lt;code&gt;mixed&lt;/code&gt;
       ausgedrückt.
      &lt;/li&gt;
      &lt;li&gt;
       Wichtiger Unterschied zur DTD:
       DTD-validierende Parser können gemischte
       Inhalte nur rudimentär prüfen. Mit XSD
       eröffnet sich die Möglichkeit zur
       vollständigen inhaltlichen Validierung
       gemischter Inhalte. Die DTD erlaubt es zwar,
       (möglicherweise) auftretende Elemente
       innerhalb unstrukturierter Textpassagen zu
       spezifizieren, es ist aber nicht möglich,
       die Häufigkeit oder Reihenfolge der Elemente
       anzugeben (vgl. Beispiel-DTD zur
       Projektverwaltung - dort wäre auch die
       Hintereinanderreihung von Qualifikationen
       ohne zugehörige Leistungsstufe zulässig).
       Insgesamt kann durch DTD-basierte
       Validierung das Auftreten von Elementen in
       gemischten Inhaltsmodellen nicht geprüft
       werden. Durch den Einsatz von XML-Schema
       ergibt sich auch für gemischte
       Inhaltsmodelle die Möglichkeit zur strikten
       Validierung. Dies bedeutet konkret, daß
       Anzahl und Auftretensreihenfolge der
       angegebenen Kindelemente überprüft werden
       können.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Globale und lokale Elementdefinitionen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;Globale Elementdefinitionen&lt;/em&gt;
       werden zunächst deklariert und in einem
       zweiten Schritt durch Referenzierung als
       Kindelemente verwendet (wie Person und
       Projekt innerhalb Projektverwaltung, oder
       Qualifikationsprofil innerhalb des Elements
       Person).
      &lt;/li&gt;
      &lt;li&gt;
       Ihre Gegenstücke, die
       &lt;em&gt;lokalen Elementdeklarationen&lt;/em&gt;
       befinden die sich hingegen vollständig im
       Elternelement finden (wie Vorname, Nachname
       und Qualifikation).
      &lt;/li&gt;
      &lt;li&gt;
       Durch Globale Elementdefinitionen können
       vollständige Elemente an verschiedenen
       Stellen im Schema referenziert und so
       verwendet werden. Die Definition ist der
       lokalen ebenbürtig und wird im
       Instanzdokument identisch behandelt.
      &lt;/li&gt;
      &lt;li&gt;
       Mit dem Referenzierungsmechanismus für
       Elemente kann eine einfache Form der
       Wiederverwendung umgesetzt werden. Jedoch
       werden Elemente hierbei zwingend in ihrer
       vollständigen Definition, d.h. Name, Typ und
       Inhaltsmodell, eingebunden. (Im Grunde
       genommen ist diese Art der Wiederverwendung
       für Elemente bereits mit den Mitteln der DTD
       möglich. Allerdings, wie im eben
       betrachteten Beispiel, auch dergestalt, daß
       nur die vollständige Definition übernommen
       werden kann.)
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Benannte komplexe Typen&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       XML-Schema bietet zusätzlich die
       Möglichkeit, strukturierte Typen, die
       ausschließlich durch ihr Inhaltsmodell
       definiert werden, festzulegen.
      &lt;/li&gt;
      &lt;li&gt;
       Die Benennung des Typs wird hierdurch
       unabhängig von der Namensgebung der
       typisierten Instanz.
      &lt;/li&gt;
      &lt;li&gt;
       Syntaktisch erfolgt die Typbildung durch die
       Benennung des complexType-Elements durch ein
       Attribut name.
      &lt;/li&gt;
      &lt;li&gt;
       Um die mehrfache Verwendung eines solchen
       Typen zu ermöglichen, muß seine Definition
       zwingend auf einer Baumstufe erfolgen, die
       für alle nutzenden Elemente erreichbar ist.
       Üblicherweise werden daher diese
       Definitionen auf der ersten Stufe, direkt
       unterhalb des Wurzelknotens, plaziert.
      &lt;/li&gt;
      &lt;li&gt;
       Zur Unterscheidung dieser benannten
       komplexen Typen werden die bisher genutzten
       -- namenlosen Typen -- als anonyme komplexe
       Typen bezeichnet.
      &lt;/li&gt;
      &lt;li&gt;
       Das nachfolgende Beispiel zeigt die
       Definition des benannten komplexen Typen
       &lt;code&gt;PersonType&lt;/code&gt;
       . Dieser Typ wird zur Festlegung des
       Inhaltsmodells des Elements
       &lt;code&gt;Person&lt;/code&gt;
       verwendet.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;listing src="projektverwaltung2.xsd"&gt;&lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Erweiterung, Einschränkung und Substitution
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       In XML-Schema gibt es die Möglichkeit,
       eigene Datentypen durch Erweiterung
       (Extension), Einschränkung (Restriction) und
       Substitution anderer Datentypen zu
       definieren. In allen Fällen dient ein
       bereits definierter Datentyp als Basis.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Erweiterung (Extension)&lt;/em&gt;
       : Die im bestehenden Datentyp enthaltene
       Information ist jedoch nicht ausreichend, es
       werden zusätzliche Informationen benötigt.
       Der bestehende Datentyp wird daher um diese
       Information ergänzt (erweitert).
       &lt;br /&gt;
       Beispiel: Es gibt einen bereits definierten
       Datentyp eine
       &lt;code&gt;Adresse&lt;/code&gt;
       , der aus Name, Straße und Ort besteht.
       Adressen in D zeichnen sich zusätzlich noch
       durch eine Postleitzahl aus. Der
       ursprungliche Datentyp Adresse kann demnach
       um die Postleitzahl erweitert werden.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Einschränkung (Restriction)&lt;/em&gt;
       : Analog zur Definition von Datentypen durch
       Erweiterung können auch durch
       &lt;em&gt;Einschränkung&lt;/em&gt;
       eigene Datentypen abgeleitet werden. Der
       abgeleitete Datentyp ist dem Originaltyp
       sehr ähnlich, seine Deklarationen sind
       jedoch eingeschränkt, die Werte des
       abgeleiteten Typs entsprechen einer
       Untermenge der Werte des ursprünglichen
       Typs. Mit anderen Worten: Wenn eine
       Anwendung Werte des Originaltyps verarbeiten
       kann, kann sie auch Werte des abgeleiteten
       Typs verarbeiten.
       &lt;br /&gt;
       Beispiel: Setzen eines Vorgabewerts oder
       Beschränkung in der Anzahl von erlaubten
       Kindelementen (etwa von 0 - unendlich auf
       1-5)
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Substitution&lt;/em&gt;
       : Mit Hilfe der
       &lt;em&gt;Substitution&lt;/em&gt;
       kann ein Element durch ein anderes Element
       ersetzt werden. Elemente werden hierzu
       sogenannten
       &lt;em&gt;Substitutionsgruppen&lt;/em&gt;
       zugeordnet. Die Elemente dieser Gruppe
       können dann anstatt eines speziellen
       benannten Elements, des
       &lt;em&gt;Head Elements&lt;/em&gt;
       verwendet werden.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung durch Einschränkung -- Beispiel
     &lt;/title&gt;
     &lt;listing src="ctinhrest.xsd"&gt;&lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Im Beispiel sehen Sie zwei benannte komplexe
       Typen
       &lt;code&gt;childType&lt;/code&gt;
       und
       &lt;code&gt;parentType&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;childType&lt;/code&gt;
       basiert auf
       &lt;code&gt;parentType&lt;/code&gt;
       und erbt von diesem. Die Vererbung ist
       ausgedrückt durch das
       &lt;code&gt;base&lt;/code&gt;
       -Attribut im Element
       &lt;code&gt;restriction&lt;/code&gt;
       , das auf den benannten Elterntypen
       verweist.
      &lt;/li&gt;
      &lt;li&gt;
       Inhalte von
       &lt;code&gt;restriction&lt;/code&gt;
       -Elementen werden genauso angegeben wie
       Inhalte von komplexen Typen: Es werden
       Elemente definiert, sowie die Art und Weise
       ihres Auftretens (Reihenfolge, Häufigkeit).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;elementA&lt;/code&gt;
       in
       &lt;code&gt;childType&lt;/code&gt;
       schränkt
       &lt;code&gt;elementA&lt;/code&gt;
       in
       &lt;code&gt;parentType&lt;/code&gt;
       ein: der Datentyp
       &lt;code&gt;short&lt;/code&gt;
       (
       &lt;code&gt;
        -2
        &lt;sup&gt;15&lt;/sup&gt;
        &amp;lt;= short &amp;lt;= 2
        &lt;sup&gt;15&lt;/sup&gt;
        -1
       &lt;/code&gt;
       ) ist enger gefaßt als der Datentyp
       &lt;code&gt;int&lt;/code&gt;
       (
       &lt;code&gt;
        -2
        &lt;sup&gt;31&lt;/sup&gt;
        &amp;lt;= short &amp;lt;= 2
        &lt;sup&gt;31&lt;/sup&gt;
        -1
       &lt;/code&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       Die beiden Elementdefinitionen
       &lt;code&gt;usage1&lt;/code&gt;
       und
       &lt;code&gt;usage2&lt;/code&gt;
       zeigen die Verwendung der
       anwenderdefinierten Typen.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung durch Einschränkung -- weitere Arten
      der Einschränkung
     &lt;/title&gt;
     &lt;p&gt;
      Es gibt - über die soeben gezeigte Möglichkeit
      der EInschränkung auf Typisierung hinaus --
      weiter Möglichkeiten der Einschränkung, die Sie
      in der folgenden Tabelle zusammengestellt sehen.
     &lt;/p&gt;
     &lt;table border="1"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Basistyp&lt;/th&gt;
        &lt;th&gt;Restriktion&lt;/th&gt;
        &lt;th&gt;Bemerkung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;default&lt;/td&gt;
        &lt;td&gt;
         Zusätzliche Belegung eines Elements
         mit einem Vorgabewert
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;fixed&lt;/td&gt;
        &lt;td&gt;
         Beschränkung eines zunächst frei
         wählbaren Elements auf konstanten
         Inhalt
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;type&lt;/td&gt;
        &lt;td&gt;
         Definition eines Typen für ein
         zunächst untypisiertes Element.
         (Auch hierbei handelt es sich um
         eine einschränkende Redefinition, da
         allen Elementen ohne Typdefinition
         standardmäßig der Typ
         &lt;code&gt;anyType&lt;/code&gt;
         zugeordnet wird.)
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;
          minOccurs=n
          &lt;sub&gt;1&lt;/sub&gt;
          , maxOccurs=m
          &lt;sub&gt;1&lt;/sub&gt;
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          minOccurs=n
          &lt;sub&gt;2&lt;/sub&gt;
          , maxOccurs=m
          &lt;sub&gt;2&lt;/sub&gt;
         &lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Restriktion der Auftrittshäufigkeit
         auf eine geringere Anzahl.Daher
         gilt:
         &lt;code&gt;
          n
          &lt;sub&gt;1&lt;/sub&gt;
          &amp;lt;= n
          &lt;sub&gt;2&lt;/sub&gt;
         &lt;/code&gt;
         und
         &lt;code&gt;
          m
          &lt;sub&gt;1&lt;/sub&gt;
          &gt;&amp;lt;= m
          &lt;sub&gt;2&lt;/sub&gt;
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung durch Erweiterung -- Beispiel
     &lt;/title&gt;
     &lt;listing src="ctinhext.xsd"&gt;&lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Erweiterung definiert zusätzliche
       Elemente zum Basistyp.
      &lt;/li&gt;
      &lt;li&gt;
       Im Beispiel sehen Sie erneut zwei benannte
       komplexe Typen:
       &lt;code&gt;parentElement&lt;/code&gt;
       und
       &lt;code&gt;childElement&lt;/code&gt;
       genannt.
      &lt;/li&gt;
      &lt;li&gt;
       Während
       &lt;code&gt;parentElement&lt;/code&gt;
       genau ein Element
       &lt;code&gt;elementA&lt;/code&gt;
       beinhaltet, wird
       &lt;code&gt;childElement&lt;/code&gt;
       dahingehend erweitert, daß es zusätzlich
       dazu auch noch genau ein Element
       &lt;code&gt;elementB&lt;/code&gt;
       beinhalten kann.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung komplexer Typen von einfachen Typen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;komplexe (Daten-)Typen&lt;/em&gt;
       : XML-artiger, strukturierter Inhalt
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;einfache (Daten-)Typen&lt;/em&gt;
       : die 44 von XML Schema vordefinierten
       Datentypen. Sie entsprechen nicht
       XML-artigem (strukturiertem) Inhalt
      &lt;/li&gt;
      &lt;li&gt;
       XML Schema erlaubt es, komplexe Typen von
       einfachen Typen abzuleiten.
      &lt;/li&gt;
      &lt;li&gt;
       Elemente, die einfache Datentypen
       (simpleTypes) als Werte haben, können
       zunächst keine Attribute haben.
      &lt;/li&gt;
      &lt;li&gt;
       Soll dies ermöglicht werden, muß eine
       derartige Ableitung erfolgen.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung von komplexen Typen durch einfache
      Typen -- Beispiel
     &lt;/title&gt;
     &lt;p&gt;
      Dieses Schema definiert das Element Vorname als
      einfachen Typ (string).
     &lt;/p&gt;
     &lt;table
      width="100%"
      border="0"&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;listing src="verySimpleContent.xsd"&gt;&lt;/listing&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;listing
         src="sehrEinfacherInhalt.xml"&gt;
        &lt;/listing&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/table&gt;
     &lt;p&gt;
      Hier hingegen wird der Datentyp
      &lt;code&gt;string&lt;/code&gt;
      erweitert. Das Element enthält immer noch einen
      einfachen Datentyp (
      &lt;code&gt;simpleContent&lt;/code&gt;
      ), darf aber nun ein Attribut (
      &lt;code&gt;rufname&lt;/code&gt;
      ) enthalten.
     &lt;/p&gt;
     &lt;table
      width="100%"
      border="0"&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;listing src="simpleContent.xsd"&gt;&lt;/listing&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;listing src="einfacherInhalt.xml"&gt;&lt;/listing&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Festlegen eigener primitiver Datentypen --
      &lt;code&gt;simpleType&lt;/code&gt;
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       XML Schema ermöglicht es, eigene (primitive)
       Datentypen festzulegen oder eigene Typen von
       bestehenden abzuleiten.
      &lt;/li&gt;
      &lt;li&gt;
       Dies erfolgt mit Hilfe des Elements
       &lt;code&gt;simpleType&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        &lt;em&gt;Ableitung durch Einschränkung&lt;/em&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;Listen&lt;/em&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;Vereinigungstypen&lt;/em&gt;
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;li&gt;
       Für Ableitung durch Einschränkung gilt: An
       jeder Stelle, an der eine Ausprägung eines
       Supertyps erwartet wird, darf auch eine
       Ausprägung eines davon abgeleiteten Subtypen
       auftreten.
       &lt;br /&gt;
       (Beispiel: wird an einer Stelle des
       Instanzdokumentes durch das Schema das
       Auftreten einer Ausprägung von
       &lt;code&gt;integer&lt;/code&gt;
       verlangt, so kann der Anwender auch
       Ausprägungen der Subtypen
       &lt;code&gt;int&lt;/code&gt;
       ,
       &lt;code&gt;short&lt;/code&gt;
       oder
       &lt;code&gt;byte&lt;/code&gt;
       angeben, ohne die Gültigkeit des
       XML-Dokuments zu beeinträchtigen.)
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Festlegen eigener primitiver Datentypen --
      Listen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Listen bestehen aus einer Aneinanderreihung
       atomarer Datentypen.
      &lt;/li&gt;
      &lt;li&gt;
       Zusätzlich zu den drei in XML Schema
       vordefinierten Listentypen
       &lt;code&gt;NMTOKENS&lt;/code&gt;
       ,
       &lt;code&gt;IDREFS&lt;/code&gt;
       und
       &lt;code&gt;ENTITIES&lt;/code&gt;
       besteht die Möglichkeit, eigene Listentypen
       zu definieren, die sich aus atomaren
       Datentypen zusammensetzen.
      &lt;/li&gt;
      &lt;li&gt;
       Das folgende Beispiel zeigt die Definition
       eines Listentyps
       &lt;code&gt;ListeDerWochentage&lt;/code&gt;
       :
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;listing
      src="simpletype.xsd"
      line="8-21"&gt;
     &lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Zunächst werden durch die aufzählende
       Einschränkung bei
       &lt;code&gt;dieWochentage&lt;/code&gt;
       die Werte des Typs auf eine Menge ganz
       spezieller Werte begrenzt.
      &lt;/li&gt;
      &lt;li&gt;
       Der so definierte Datentyp wird dann als
       Basis für den Listentyp verwendet.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Festlegen eigener primitiver Datentypen --
      Vereinigungstypen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Vereinigungstypen setzen sich aus einer
       Menge von Ausgangstypen zusammen.
      &lt;/li&gt;
      &lt;li&gt;
       Im Beispiel sehen Sie die Definition eines
       Typen
       &lt;code&gt;termin&lt;/code&gt;
       , der eine Vereinigung aus dem vorgegebenen
       Primitivtypen
       &lt;code&gt;date&lt;/code&gt;
       und einer Liste
       &lt;code&gt;ListeDerWochentage&lt;/code&gt;
       darstellt.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;listing
      src="simpletype.xsd"
      line="3-7"&gt;
     &lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Festlegen eigener primitiver Datentypen --
      Ableitung durch Einschränkung
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Im Beispiel ist ein weiteres Beispiel für
       einen einschränkenden Datentyp dargestellt.
      &lt;/li&gt;
      &lt;li&gt;
       Der vorgegebene Typ
       &lt;code&gt;integer&lt;/code&gt;
       wird derart limitiert, daß lediglich die
       Werte zwischen
       &lt;code&gt;10000&lt;/code&gt;
       und
       &lt;code&gt;99999&lt;/code&gt;
       als gültige Wertbelegungen zulässig sind.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;listing
      src="simpletype.xsd"
      line="22-27"&gt;
     &lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Ableitung durch Einschränkung - Arten der
      Einschränkung
     &lt;/title&gt;
     &lt;p&gt;
      XML Schema definiert 12 voneinander unabhängige
      sogenannte
      &lt;em&gt;Fassetten&lt;/em&gt;
      , die zur Begrenzung der erlaubten Werte vom
      Primitivtypen eingesetzt werden können. Nicht
      alle Fassetten können auf alle Typen angewendet
      werden. Eine Übersicht zur Anwendbarkeit findet
      sich in
      &lt;a
       href="http://www.w3.org/TR/xmlschema-0/index.html#SimpleTypeFacets"&gt;
       Anhang B von XML Schema Part 0: Primer
      &lt;/a&gt;
      .
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;length&lt;/em&gt;
       : Gibt die Anzahl der zulässigen Einheiten
       des Datentyps an (bei zeichenkettenartigen
       Datentypen entspricht dies der Anzahl der
       Zeichen) an. Bei Listen kann hiermit die
       Anzahl der Elemente festgelegt werden.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="28-32"&gt;
       &lt;/listing&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;minLength&lt;/em&gt;
       : Definiert die minimale Länge von atomaren
       Datentypen bzw. die minimale Anzahl von
       Elementen einer Liste.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="33-37"&gt;
       &lt;/listing&gt;
       &lt;listing
        src="simpletype.xsd"
        line="38-45" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;maxLength&lt;/em&gt;
       : Definiert die maximale Länge von atomaren
       Datentypen bzw. die maximale Anzahl von
       Elementen einer Liste.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="46-50"&gt;
       &lt;/listing&gt;
       &lt;listing
        src="simpletype.xsd"
        line="51-59" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;pattern&lt;/em&gt;
       : Ein
       &lt;code&gt;pattern&lt;/code&gt;
       legt dem Wertebereich eines atomaren
       Datenyps definierte Bedingungen auf. Die
       Werte werden auf Zeichen begrenzt, die einem
       bestimmten Muster entsprechen. Der Wert des
       Musters muß ein
       &lt;em&gt;regulärer Ausdruck&lt;/em&gt;
       sein (siehe nächste Seite).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;enumeration&lt;/em&gt;
       : Mit einer
       &lt;em&gt;Aufzählung&lt;/em&gt;
       wird der Wertebereich eines Datentyps auf
       eine genau spezifizierte Menge eingeengt.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="65-86" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;whiteSpace&lt;/em&gt;
       : Der Wertebereich des betreffenden
       Datentypen kann nach den drei Regeln, wie
       sie auch für die Normalisierung von
       (zeichenkettenartigen) Attributwerten
       gelten, eingegrenzt werden:
       &lt;ul&gt;
        &lt;li&gt;
         &lt;em&gt;preserve&lt;/em&gt;
         : keine Normalisierung, der Wert
         bleibt unverändert.
        &lt;/li&gt;
        &lt;li&gt;
         &lt;em&gt;replace&lt;/em&gt;
         :Tabulatoren (
         &lt;code&gt;#x9&lt;/code&gt;
         ), Zeilenvorschub (
         &lt;code&gt;#xA&lt;/code&gt;
         ) und Wagenrücklauf (
         &lt;code&gt;#xD&lt;/code&gt;
         ) werden durch Leerzeichen (
         &lt;code&gt;#x20&lt;/code&gt;
         ) ersetzt.
        &lt;/li&gt;
        &lt;li&gt;
         &lt;em&gt;collapse&lt;/em&gt;
         : Es werden die Regeln von
         &lt;em&gt;replace&lt;/em&gt;
         angewandt. Zusätzlich dazu werden
         mehrfach direkt hintereinander
         vorkommende Leerzeichen zu einem
         einzelnen Leerzeichen zusammengefaßt
         sowie führende und abschließende
         Leerzeichen entfernt.
        &lt;/li&gt;
       &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;maxInclusive&lt;/em&gt;
       : Mit
       &lt;code&gt;maxInclusive&lt;/code&gt;
       kann die obere (inklusive) Grenze für den
       Wertebereich eines Datentyps angegeben
       werden.
       &lt;listing
        src="simpletype.xsd"
        line="87-91" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;maxExclusive&lt;/em&gt;
       : Analog
       &lt;code&gt;maxInclusive&lt;/code&gt;
       , mit dem Unterschied, daß der angegebene
       Wert nicht mehr zum Wertebereich zählt.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="92-96"&gt;
       &lt;/listing&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;minInclusive&lt;/em&gt;
       : Gibt die untere (inklusive) Grenze eines
       Wertebereichs an.
       &lt;listing
        src="simpletype.xsd"
        line="97-101" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;minExclusive&lt;/em&gt;
       : Analog
       &lt;code&gt;minInclusive&lt;/code&gt;
       , mit dem Unterschied, daß der angegebene
       Wert nicht mehr zum Wertebereich zählt.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="102-106" /&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;totalDigits&lt;/em&gt;
       : Gibt die Gesamtstellen einer Zahl an,
       gebildet aus der Summe der Vorkomma- und der
       Nachkommastellen.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="107-111"&gt;
       &lt;/listing&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;fractionDigits&lt;/em&gt;
       : Steuert die Anzahl der Nachkommastellen
       eines Dezimalbruches.
       &lt;br /&gt;
       &lt;listing
        src="simpletype.xsd"
        line="112-119" /&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Reguläre Ausdrücke&lt;/title&gt;
     &lt;p class="definition"&gt;
      Ein
      &lt;em&gt;Regulärer Ausdruck&lt;/em&gt;
      ist eine Syntax, die eine Menge von
      Zeichenketten beschreibt.
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Reguläre Ausdrücke haben ihre Wurzeln im
       Betriebssystem UNIX, wo sie seit den 1960ern
       in Editoren Einzug fanden.
      &lt;/li&gt;
      &lt;li&gt;
       Heute werden sie in vielen
       Programmiersprachen verwendet (z.B. Java
       seit JDK1.4, Perl, C++, C#, Python, PHP,
       Ruby, ... )
      &lt;/li&gt;
      &lt;li&gt;
       Verwendung: Erkennen von Zeichenketten, die
       bestimmten Mustern entsprechen.
      &lt;/li&gt;
      &lt;li&gt;
       In XML Schema: Vorgeben von Mustern für
       Zeichenketten.
      &lt;/li&gt;
      &lt;li&gt;
       Syntax: Quantoren, Fluchtsymbole,
       Zeichenklassen
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Reguläre Ausdrücke - Quantoren&lt;/title&gt;
     &lt;p&gt;
      Quantoren steuern die Auftrittshäufigkeit von
      sog. atomaren Einheiten (Zeichen, Zeichenklasse,
      Regulärer Ausdruck).
     &lt;/p&gt;
     &lt;table border="1"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Quantifizierte atomare Einheit&lt;/th&gt;
        &lt;th&gt;Bedeutung&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;Genau S&lt;/q&gt;
         : Alle Zeichenketten, die
         &lt;code&gt;S&lt;/code&gt;
         genau entsprechen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S?&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;Optional&lt;/q&gt;
         : Die leere Zeichenkette oder alle
         Zeichenketten, die
         &lt;code&gt;S&lt;/code&gt;
         genau entsprechen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S*&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;Beliebig&lt;/q&gt;
         : Alle Reihungen von
         &lt;code&gt;S&lt;/code&gt;
         ; insbesondere auch auch die leere
         Zeichenkette.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S+&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;Mindestens einmal&lt;/q&gt;
         : Alle Reihungen von
         &lt;code&gt;S&lt;/code&gt;
         , die
         &lt;code&gt;S&lt;/code&gt;
         mindestens einmal enthalten.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S{n,m}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;
          &lt;code&gt;n&lt;/code&gt;
          bis
          &lt;code&gt;m&lt;/code&gt;
          mal
         &lt;/q&gt;
         : Alle Zeichenketten, die aus
         mindestens
         &lt;code&gt;n&lt;/code&gt;
         , jedoch höchstens
         &lt;code&gt;m&lt;/code&gt;
         Auftreten von
         &lt;code&gt;S&lt;/code&gt;
         bestehen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S{n}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;
          Genau
          &lt;code&gt;n&lt;/code&gt;
          mal
         &lt;/q&gt;
         : Alle Zeichenketten, die aus genau
         &lt;code&gt;n&lt;/code&gt;
         Auftreten von
         &lt;code&gt;S&lt;/code&gt;
         bestehen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S{n,}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;
          Mindestens
          &lt;code&gt;n&lt;/code&gt;
          mal
         &lt;/q&gt;
         : Alle Zeichenketten, die aus
         mindestens
         &lt;code&gt;n&lt;/code&gt;
         Auftreten von
         &lt;code&gt;S&lt;/code&gt;
         bestehen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S{0,m}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;q&gt;
          Höchstens
          &lt;code&gt;m&lt;/code&gt;
          mal
         &lt;/q&gt;
         : Alle Zeichenketten, die aus
         höchstens
         &lt;code&gt;m&lt;/code&gt;
         Auftreten von
         &lt;code&gt;S&lt;/code&gt;
         bestehen.
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;S{0,0}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;Die leere Zeichenkette&lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Reguläre Ausdrücke - Beispiele für Quantoren
     &lt;/title&gt;
     &lt;table border="1"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Ausdruck&lt;/th&gt;
        &lt;th&gt;entsprechende Zeichenketten&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;a*x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;x, ax, aax, aaax ....&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;a?x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ax, x&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;a+x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ax, aax, aaax ...&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;(a|b)+x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          ax, bx, aax, abx, bax, bbx,
          aaax, aabx, abax, abbx, baax,
          babx, bbax, bbbx, aaaax ....
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;[abcde]x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ax, bx, cx, dx, ex&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;[a-e]x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ax, bx, cx, dx, ex&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;[-ae]x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;-x, ax, ex&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;[ae-]x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ax, ex, -x&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;[^0-9]x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          Jedes Zeichen, das keine Ziffer
          darstellt, gefolgt von dem
          Buchstaben x.
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;.x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          Jedes Zeichen gefolgt von dem
          Buchstaben x.
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;.*abc.*&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          1x2abc, abc1x2, z3456abchooray
          ....
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ab{2}x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;abbx&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ab{2,4}x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;abbx, abbbx, abbbbx&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;ab{2,}x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;
          abbx, abbbx, abbbbx ....
         &lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;(ab){2}x&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;ababx&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Reguläre Ausdrücke - Fluchtsymbole&lt;/title&gt;
     &lt;p&gt;
      Ein
      &lt;em&gt;Fluchtsymbol&lt;/em&gt;
      (engl.:
      &lt;em&gt;character escape&lt;/em&gt;
      ) in regulären Ausdrücken dient der Darstellung
      von Zeichen, die anderweitig nur schwer oder
      unmöglich in einen regulären Ausdruck schreiben
      kann (weil sie mit Bedeutung belegt sind oder
      praktisch schwer zu schreiben sind wie etwa
      Zeilenumbrüche, Zeilenvorschub oder
      Tabulatoren). Diese sind in Teilen aus den
      Programmiersprachen bekannt.
     &lt;/p&gt;
     &lt;table border="1"&gt;
      &lt;thead&gt;
       &lt;tr&gt;
        &lt;th&gt;Fluchtsymbol&lt;/th&gt;
        &lt;th&gt;dadurch ausgedrücktes Zeichen&lt;/th&gt;
       &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\n&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Das Zeichen für Zeilenumbruch (
         &lt;code&gt;#xA&lt;/code&gt;
         ).
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\r&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Das Zeichen für Zeilenvorschub (
         &lt;code&gt;#xD&lt;/code&gt;
         ).
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\t&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         Das Tabulator-Zeichen (
         &lt;code&gt;#x9&lt;/code&gt;
         ).
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\\&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;\&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\|&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;|&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\.&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;.&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\-&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;-&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\^&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;^&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\?&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;?&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\*&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;*&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\+&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;+&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\{&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;{&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\}&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;}&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\(&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;(&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\)&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;)&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\[&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;[&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
       &lt;tr&gt;
        &lt;td&gt;
         &lt;code&gt;\]&lt;/code&gt;
        &lt;/td&gt;
        &lt;td&gt;
         &lt;code&gt;]&lt;/code&gt;
        &lt;/td&gt;
       &lt;/tr&gt;
      &lt;/tbody&gt;
     &lt;/table&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Reguläre Ausdrücke - Zeichenklassen&lt;/title&gt;
     &lt;p&gt;
      Verschiedene Zeichen mit ähnlichen Eigenschaften
      werden im XML Schema zu
      &lt;em&gt;Zeichenklassen&lt;/em&gt;
      gruppiert. Diese Zeichen können so in ihrer
      Gesamtheit durch die Verwendung der sie
      bezeichnenden Symbole in den regulären
      Ausdrücken verwendet werden.
      &lt;br /&gt;
      So bezeichnet die Angabe der Zeichenklasse
      &lt;code&gt;\p{X}&lt;/code&gt;
      alle Zeichen aus X. Diese Angaben können durch
      &lt;code&gt;\P{X}&lt;/code&gt;
      invertiert werden. (
      &lt;code&gt;[\P{X}] = [^\p{X}]&lt;/code&gt;
      ).
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;Buchstaben&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;L&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Buchstaben&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Lu&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Großbuchstaben (uppercase)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Ll&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Kleinbuchstaben (lowercase)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Lt&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Titlecase: Großschreibung des
          ersten Zeichens eines Wortes.
          Diese Art der Schreibung ist
          üblicherweise abhängig von der
          verwendeten Sprache. Im
          Englischen jedoch kommt der Name
          aus dem Zeitschriftenwesen, da
          dort oft in Überschriften
          einzelne Wörter großgeschrieben
          werden.
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Lm&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Modifier: Verschiedene Ton- und
          Betonungszeichen
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Lo&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Other: Alle Zeichen, die in
          keine der sonstigen
          L-Zeichenfamilien fallen
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;
       &lt;q&gt;Markierungssymbole&lt;/q&gt;
      &lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;M&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Markierungssymbole&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Mn&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Markierungssymbole ohne
          Leerzeichen (z.B. diakritische
          Zeichen: kleine Zeichen wie
          Punkte, Häkchen, Kringel, sie
          markieren eine besondere
          Betonung oder Aussprache.)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Mc&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Markierungssymbole
          &lt;q&gt;spacing combining&lt;/q&gt;
          : Hauptsächlich im asiatischen
          Sprachraum anzutreffende
          (Myanmar, Khmer, Tibetisch,
          Bengalisch, ...)
          Markierungssymbole, die mit
          Leerzeichen kombiniert sind.
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Me&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Andere Markierungssymbole, die
          andere Zeichen beinhalten (z.B.
          das kyrillische Zeichen für
          Hunderttausend und Million).
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;Zahlen&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;N&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Nummern&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Nd&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Dezimalzahlen, darunter auch
          auch arabisch-indische, gurmukhi
          und gujarati (zwei indische
          Schriften), thailändisch, und
          Weitere,
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Nl&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Durch Buchstaben dargestellte
          Nummern, z.B. die lateinischen
          Zahlen
          &lt;code&gt;I&lt;/code&gt;
          ,
          &lt;code&gt;II&lt;/code&gt;
          ,
          &lt;code&gt;III&lt;/code&gt;
          , ....
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;No&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Andere Darstellungen von Nummern
          (z.B. Brüche 1/4, 1/2, 3/4,
          weitere Khmer-Symbole für 10 bis
          100, hochgestellt und
          tiefgestellte Ziffern, in
          Kreisen dargestellte Zahlen,
          etc.)
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;Interpunktionssymbole&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;P&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Interpunktionssymbole
          (Punctuation)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Pc&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Verbindende
          Interpunktionssymbole wie
          Unterstrich, Bogen über Zeichen,
          etc.
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Pd&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Verbindungsstriche&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Ps&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Bereiche öffnende
          Interpunktionssymbole (z.B.
          öffnende Klammern)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Pe&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Bereiche schließende
          Interpunktionssymbole (z.B.
          schließende Klammern)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Pi&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Zitatbeginn (z.B. öffnende
          Anführungszeichen)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Pf&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Zitatende (z.B. schließende
          Anführungszeichen)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Po&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle anderen
          Interpunktionssymbole (z.B.
          Semikolen, Ausrufezeichen,
          Fragezeichen, etc.)
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;Seperatoren&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Z&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Separatoren&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Zs&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Leerzeichen (einfache,
          diverse Längen (3-fach, 4-fach),
          aber auch mongolische
          vokaltrennende Leerzeichen)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Zl&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Zeilentrenner (
          &lt;code&gt;#x2028&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Zp&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Absatztrenner (
          &lt;code&gt;#x2029&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;Symbole&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;S&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Symbole&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Sm&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;mathematische Symbole&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Sc&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Währungssymbole (
          &lt;code&gt;€, $&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Sk&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Modifier (wenige Akzente,
          Betonungshinweise, etc.)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;So&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          weitere Symbole
          (Copyright-Symbol, Grad Celsius,
          Pfeile, etc.)
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;li&gt;Sonstige&lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;C&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;Alle Sonstigen&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Cc&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Kontrollzeichen (z.B.
          &lt;code&gt;End of Transmission&lt;/code&gt;
          ,
          &lt;code&gt;&gt;Backspace&lt;/code&gt;
          ,
          &lt;code&gt;Delete&lt;/code&gt;
          , etc.)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Cf&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Formatierungszeichen (z.B.
          syrisches Abkürzungszeichen)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Co&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Zeichen aus dem Unicode-Bereich
          zur freien anwenderdefinierten
          Belegung (mit ungefähr 137500
          Zeichen)
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;Cn&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Zeichen, denen innerhalb Unicode
          explizit keine Belegung
          zugewiesen wurde
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      Reguläre Ausdrücke - Negation und
      Zeichensequenzen
     &lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Durch das Zeichen
       &lt;code&gt;^&lt;/code&gt;
       wird eine Negation eines Ausdrucks
       definiert.
      &lt;/li&gt;
      &lt;li&gt;
       Desweiteren existieren noch folgende vor
       definierte Zeichensequenzen mit häufig
       anzutreffenden Zeichen:
      &lt;/li&gt;
      &lt;table border="1"&gt;
       &lt;thead&gt;
        &lt;tr&gt;
         &lt;th&gt;Symbol&lt;/th&gt;
         &lt;th&gt;Bedeutung&lt;/th&gt;
        &lt;/tr&gt;
       &lt;/thead&gt;
       &lt;tbody&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;.&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Zeichen außer Zeilenumbruch
          und Zeilenvorschub (entspricht
          &lt;code&gt;[^\n\r]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\s&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Versammelt Leerzeichen,
          Tabulator, Zeilenumbruch und
          Zeilenvorschub (
          &lt;code&gt;[#x20\t\n\r]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\S&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alles außer Leerzeichen,
          Tabulator, Zeilenumbruch und
          Zeilenvorschub (
          &lt;code&gt;[^\s]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\i&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Die initialen Zeichen eines
          gültigen XML-Namens: ein
          Buchstabe, der Unterstrich
          &lt;code&gt;_&lt;/code&gt;
          oder der Doppelpunkt
          &lt;code&gt;:&lt;/code&gt;
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\I&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Die Negation der vorhergehenden
          Definition (
          &lt;code&gt;[^\i]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\c&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle für XML-Namen zugelassenen
          Zeichen
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\C&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Zeichen, die nicht in
          XML-Namen zugelassen sind
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\d&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Entspricht
          &lt;code&gt;\p{Nd}&lt;/code&gt;
          : Dezimalzahlen, darunter auch
          auch arabisch-indische, gurmukhi
          und ....
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\D&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Zeichen, die nicht
          Dezimalzahlen entsprechen (
          &lt;code&gt;[^\d]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\w&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          &lt;br /&gt;
          Alle Zeichen außerhalb der
          Zeichenklassen
          &lt;q&gt;Interpunktion&lt;/q&gt;
          ,
          &lt;q&gt;Separatoren&lt;/q&gt;
          " und
          &lt;q&gt;Sonstige&lt;/q&gt;
          (
          &lt;code&gt;
           [#x0000-#x10FFFF]-[\p{P}\p{Z}\p{C}]
          &lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
         &lt;td&gt;
          &lt;code&gt;\W&lt;/code&gt;
         &lt;/td&gt;
         &lt;td&gt;
          Alle Zeichen innerhalb der
          Zeichenklassen
          &lt;q&gt;Interpunktion&lt;/q&gt;
          ,
          &lt;q&gt;Separatoren&lt;/q&gt;
          " und
          &lt;q&gt;Sonstige&lt;/q&gt;
          (
          &lt;code&gt;[^\w]&lt;/code&gt;
          )
         &lt;/td&gt;
        &lt;/tr&gt;
       &lt;/tbody&gt;
      &lt;/table&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;Reguläre Ausdrücke - Beispiele&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;KFZ-Kennzeichen&lt;/li&gt;
      &lt;listing
       src="regExp.xsd"
       line="3-7"&gt;
      &lt;/listing&gt;
      &lt;li&gt;
       Social Security Number (vgl.
       &lt;em&gt;Professional XML Schemas&lt;/em&gt;
       . By Kurt Cagle, Jon Duckett, Oliver
       Griffin, Stephen Mohr, Francis Norton,
       Nikola Ozu, Ian Stokes-Rees, Jeni Tennison,
       and Kevin Williams. Wrox Programmer to
       Programmer Series. Birmingham, UK: Wrox
       Press Ltd., [July] 2001. ISBN:
       1-861005-47-4)
      &lt;/li&gt;
      &lt;listing
       src="regExp.xsd"
       line="8-12"&gt;
      &lt;/listing&gt;
      &lt;li&gt;
       Initialen (vgl.
       &lt;a
        href="http://www.w3schools.com/schema/schema_facets.asp"&gt;
        Beispiel auf W3 Schools
       &lt;/a&gt;
       )
      &lt;/li&gt;
      &lt;listing
       src="regExp.xsd"
       line="13-19"&gt;
      &lt;/listing&gt;
      &lt;li&gt;
       Vorwahl (vgl.
       &lt;a
        href="http://goetz.buerkle.org/mat/medien/lernen/studium/2006_ss_ai2tutorium/tutorium04_folien.pdf"&gt;
        Tutorium für angewandte Informatik an
        der Universität Karlsruhe (von Götz
        Bürkle)
       &lt;/a&gt;
      &lt;/li&gt;
      &lt;listing
       src="regExp.xsd"
       line="20-26"&gt;
      &lt;/listing&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Attributdefinitionen&lt;/title&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Definition von Attributen erfolgt mit
       dem Element
       &lt;code&gt;attribute&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Es können analog zu DTDs optionale
       Attribute, zwingend anzugebende Attribute
       und Attribute mit festen Werten angegeben
       werden.
      &lt;/li&gt;
      &lt;li&gt;
       Darüber hinaus könne auch
       Aufzählungsattribute und Mengen realisiert
       werden.
      &lt;/li&gt;
      &lt;li&gt;
       Folgende Eigenschaften können für
       Attributdefinitionen angegeben werden:
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        &lt;em&gt;name&lt;/em&gt;
        : Ein Name ohne Doppelpunkt (
        &lt;code&gt;NCName&lt;/code&gt;
        )
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;id&lt;/em&gt;
        : kann mit einer Schema-weit eindeutigen
        Zeichenkette zum Zweck der
        Identifikation gekennzeichnet werden.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;default&lt;/em&gt;
        : Erlaubt die Angabe eines Vorgabewert.
        Dieser Vorgabewert wird vom
        XML-Prozessor an die verarbeitende
        Applikation geliefert, wenn im
        Instanzdokument kein Wert für das
        Attribut angegeben ist.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;fixed&lt;/em&gt;
        : Erlaubt die Festlegung eines
        konstanten Werts für das Attribut.
        &lt;code&gt;fixed&lt;/code&gt;
        und
        &lt;code&gt;default&lt;/code&gt;
        schließen sich gegenseitig aus.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;type&lt;/em&gt;
        : Mit
        &lt;code&gt;type&lt;/code&gt;
        wird der Typ des Attributes (ein
        &lt;code&gt;simpleType&lt;/code&gt;
        ) bestimmt.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;form&lt;/em&gt;
        : Legt fest, ob der Attributname im
        XML-Instanzdokument durch ein
        Namensraumpräfix eingeleitet wird
        (Belegung:
        &lt;code&gt;qualified&lt;/code&gt;
        , andernfalls
        &lt;code&gt;unqualified&lt;/code&gt;
        ).
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;ref&lt;/em&gt;
        : Verweis auf eine globale
        Attributdefinition.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;em&gt;use&lt;/em&gt;
        : Legt mit den Werten
        &lt;code&gt;optional&lt;/code&gt;
        ,
        &lt;code&gt;required&lt;/code&gt;
        oder
        &lt;code&gt;prohibited&lt;/code&gt;
        die Verwendung des Attributes fest.
        Vorgabewert ist
        &lt;code&gt;optional&lt;/code&gt;
        , das Attribut wird nicht zwingend im
        XML-Dokument erwartet. Den Gegensatz
        hierzu bildet
        &lt;code&gt;required&lt;/code&gt;
        , wodurch das Attribut als zwingend
        anzugeben definiert wird.
        &lt;code&gt;prohibited&lt;/code&gt;
        verbietet die Nutzung des Attributes im
        XML-Dokument.
       &lt;/li&gt;
      &lt;/ul&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XMl Schema am Beispiel - Attributdefinitionen
     &lt;/title&gt;
     &lt;listing src="attDefs.xsd"&gt;&lt;/listing&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Für das Attribut
       &lt;code&gt;myAtt1&lt;/code&gt;
       ist kein Typ vorgegeben. Es ist damit per
       Definition vom Typ
       &lt;code&gt;anySimpleType&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Dem Attribute
       &lt;code&gt;myAtt2&lt;/code&gt;
       wird hingegen der vordefinierte Typ
       &lt;code&gt;decimal&lt;/code&gt;
       zugewiesen.
      &lt;/li&gt;
      &lt;li&gt;
       Der Datentyp für Für
       &lt;code&gt;myAtt3&lt;/code&gt;
       wird innerhalb der Attributdefinition selbst
       definiert (
       &lt;code&gt;simpleType&lt;/code&gt;
       ). Mit einer Einschränkung werden die
       zulässigen Werte limitiert. Diese dürfen
       zwar vom Typ
       &lt;code&gt;int&lt;/code&gt;
       sein, davon sind aber nur die Werte
       &lt;code&gt;10&lt;/code&gt;
       und
       &lt;code&gt;20&lt;/code&gt;
       für das Attribut gültig.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;myAtt4&lt;/code&gt;
       zeigt die Verwendung eines benannten
       komplexen Typs für die Typdefinition eines
       Attributs. Zunächst wird der komplexe Typ
       namens
       &lt;code&gt;myType1&lt;/code&gt;
       definiert. Er erlaubt Zeichenketten mit
       einer maximalen Länge von 5 Zeichen. Dieser
       Typ wird danach in der Typdefinition
      &lt;/li&gt;
      &lt;li&gt;
       In der Elementdefinition für
       &lt;code&gt;foo&lt;/code&gt;
       wird die Verwendung der global definierten
       Attribute
       &lt;code&gt;myAtt1&lt;/code&gt;
       bis
       &lt;code&gt;myAtt4&lt;/code&gt;
       demonstriert. Diese werden mit Hilfe des
       &lt;code&gt;ref&lt;/code&gt;
       -Attributs referenziert.
       &lt;code&gt;myAtt1&lt;/code&gt;
       ist als optional anzugebend deklariert,
       wohingegen
       &lt;code&gt;myAtt2&lt;/code&gt;
       zwingend anzugeben ist. Für
       &lt;code&gt;myAtt3&lt;/code&gt;
       ist die Verwendung im Instanzdokument
       verboten (
       &lt;code&gt;prohibited&lt;/code&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;myAtt5&lt;/code&gt;
       stellt eine lokale Attributdefinition dar,
       sie ist nur innerhalb der Elementdefinition
       von
       &lt;code&gt;foo&lt;/code&gt;
       gültig. Die Attributwerte müssen vom Typ
       &lt;code&gt;date&lt;/code&gt;
       sein. Darüber hinaus erhält das Attribut
       noch eine Zeichenkette zur Identifikation:
       &lt;code&gt;id&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;myAtt6&lt;/code&gt;
       entspricht wiederum der Bildung eines
       anonymen (inneren) Datentyps. Die lokale
       Attributdefinition beschränkt Werte vom Typ
       &lt;code&gt;float&lt;/code&gt;
       auf 5 Stellen.
      &lt;/li&gt;
      &lt;li&gt;
       In der Elementdefinition von
       &lt;code&gt;bar&lt;/code&gt;
       wird die globale Attributdefinition für
       &lt;code&gt;myAtt1&lt;/code&gt;
       wiederverwendet, für dieses Element ist das
       Attribut zwingend anzugeben.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XML Schema am Beispiel - komplettes Schema der
      Projektverwaltung
     &lt;/title&gt;
     &lt;p&gt;
      Das vollständige Schema für das Beispiel
      Projektverwaltung ist hier aufgeführt.
     &lt;/p&gt;
     &lt;listing src="projektverwaltung-komplett.xsd"&gt;&lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;
      XML Schema am Beispiel - schemakonformes
      Instanzdokument der Projektverwaltung
     &lt;/title&gt;
     &lt;p&gt;
      Abschließend eine gültige (sowohl valid als auch
      schema valid) Dokumentinstanz der
      Projektverwaltungsstruktur.
     &lt;/p&gt;
     &lt;listing src="projektverwaltung-komplett.xml"&gt;&lt;/listing&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Tools&lt;/title&gt;
     &lt;p&gt;
      Mittlerweile existieren eine Reihe von
      Werkzeugen, mit deren Hilfe XML-Schemata
      (grafisch) erstellt und gepflegt werden können.
      Eine kleine Auswahl finden Sie hier versammelt.
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der
       &lt;em&gt;&amp;lt;oXygen/&amp;gt;&lt;/em&gt;
       XML Editor beinhaltet einen
       &lt;em&gt;Visual Schema Editor&lt;/em&gt;
       . Erlaubt das Generieren von
       Instanzdokumenten zu einem Schema.
       Kostenpflichtig.
      &lt;/li&gt;
      &lt;li&gt;
       Der Schema Editor aus der
       &lt;em&gt;XML Spy&lt;/em&gt;
       Suite von Altova unterstützt unter anderem
       die grafische Erstellung von Schemata.
       Generieren von Instanzdokumenten möglich.
       Kostenpflichtig.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;Stylus Studio&lt;/em&gt;
       XML Schema Editor: Auch die Stylus Studio
       Suite bringt einen grafischen Schema-Editor
       mit sich. Kostenpflichtig.
      &lt;/li&gt;
      &lt;li&gt;
       Eine umfassende Übersicht über XML
       Schema-Tools findet sich auf der
       &lt;a
        href="http://www.w3.org/XML/Schema#Tools"&gt;
        XML Schema Webseite des W3C
       &lt;/a&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
    &lt;slide&gt;
     &lt;title&gt;XML Schema - Übungsaufgabe&lt;/title&gt;
     &lt;p&gt;
      Erstellen Sie ein Schema, das die folgenden
      Bedingungen abbildet.
     &lt;/p&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Das Element Information Item
       &lt;code&gt;Autor&lt;/code&gt;
       verfügt über die Kindknoten
       &lt;code&gt;Vorname&lt;/code&gt;
       (mindestens einmaliges, aber höchstens
       zweimaliges Auftreten) sowie
       &lt;code&gt;Nachname&lt;/code&gt;
       . Beide Elemente sind Namen und verfügen
       über keine interne Formatierung durch
       Leerzeichen oder Zeilenumbrüche
      &lt;/li&gt;
      &lt;li&gt;
       Der Wurzelknoten
       &lt;code&gt;Zeitschrift&lt;/code&gt;
       enthält genau ein als
       &lt;code&gt;Verlag&lt;/code&gt;
       bezeichnetes Kindelement des Typs
       &lt;code&gt;string&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Jeder
       &lt;code&gt;Beitrag&lt;/code&gt;
       besitzt mindestens einen aber beliebig viele
       &lt;code&gt;Autor&lt;/code&gt;
       en.
      &lt;/li&gt;
      &lt;li&gt;
       Jedes Element Information Item des Typs
       &lt;code&gt;Beiträge&lt;/code&gt;
       enthält eine positive Anzahl von Element
       Information Items des Namens
       &lt;code&gt;Beitrag&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Jedes Element Information Item des Typs
       &lt;code&gt;Beitrag&lt;/code&gt;
       enthält das Attribut
       &lt;code&gt;Seitenanzahl&lt;/code&gt;
       (positive Ganzzahl) und
       &lt;code&gt;Annahmedatum&lt;/code&gt;
       (Datum)
      &lt;/li&gt;
      &lt;li&gt;
       Jedes Element Information Item des Typs
       &lt;code&gt;Zeitschrift&lt;/code&gt;
       enthält genau ein Element Information Item
       des Namens
       &lt;code&gt;Beiträge&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Zu jedem
       &lt;code&gt;Beitrag&lt;/code&gt;
       existiert eine Menge von
       &lt;code&gt;Schlagworten&lt;/code&gt;
       . Diese werden in einem Element Information
       Item
       &lt;code&gt;Schlagworte&lt;/code&gt;
       abgelegt. Dieses Element kann zwischen drei
       und fünf Zeichenketten als Eintrag
       beinhalten.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/slide&gt;
   &lt;/part&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!-- Ende Schema --&gt;

 &lt;!--  Übungen zu XML Schema --&gt;
 &lt;presentation id="uebungsaufgabenXMLSchema"&gt;
  &lt;title short="uebungsaufgabenXMLSchema"&gt;
   Übungsaufgaben zu XML Schema.
  &lt;/title&gt;
  &lt;date&gt;2008-11-03&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;Übungsaufgaben zu XML Schema.&lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 1&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 1&lt;/title&gt;
    &lt;p&gt;
     Gegeben sei nachfolgendes Schema. Geben Sie dazu
     eine
     &lt;em&gt;schema-gültige&lt;/em&gt;
     Dokumentinstanz an.
    &lt;/p&gt;
    &lt;listing src="uebung-schema-valid-instanz.xsd"&gt;&lt;/listing&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 2&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 2&lt;/title&gt;
    &lt;p&gt;
     Erstellen Sie ein Schema, das die nachfolgend
     aufgeführten Zusammenhänge abbildet. Erstellen Sie
     ein Instanzdokument und validieren Sie dieses gegen
     Ihr Schema.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das Element Information Item
      &lt;code&gt;Autor&lt;/code&gt;
      verfügt über die Kindknoten
      &lt;code&gt;Vorname&lt;/code&gt;
      (mindestens einmaliges, aber höchstens
      zweimaliges Auftreten) sowie
      &lt;code&gt;Nachname&lt;/code&gt;
      .
      &lt;br /&gt;
      Beide Elemente stellen Namen im herkömmlichen
      Sinne dar und verfügen über keine interne
      Formatierung durch Leerzeichen oder
      Zeilenumbrüche
     &lt;/li&gt;
     &lt;li&gt;
      Der Wurzelknoten
      &lt;code&gt;Zeitschrift&lt;/code&gt;
      enthält genau ein als
      &lt;code&gt;Verlag&lt;/code&gt;
      bezeichnetes Kindelement des Typs
      &lt;code&gt;string&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Jeder
      &lt;code&gt;Beitrag&lt;/code&gt;
      besitzt mindestens einen aber beliebig viele
      &lt;code&gt;Autor&lt;/code&gt;
      en.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes Element Information Item des Typs
      &lt;code&gt;Beiträge&lt;/code&gt;
      enthält eine positive Anzahl von Element
      Information Items des Namens
      &lt;code&gt;Beitrag&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Jedes Element Information Item des Typs
      &lt;code&gt;Beitrag&lt;/code&gt;
      enthält das Attribut
      &lt;code&gt;Seitenanzahl&lt;/code&gt;
      (positive Ganzzahl) und
      &lt;code&gt;Annahmedatum&lt;/code&gt;
      (Datum)
     &lt;/li&gt;
     &lt;li&gt;
      Jedes Element Information Item des Typs
      &lt;code&gt;Zeitschrift&lt;/code&gt;
      enthält genau ein Element Information Item des
      Namens
      &lt;code&gt;Beiträge&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Zu jedem
      &lt;code&gt;Beitrag&lt;/code&gt;
      existiert eine Menge von
      &lt;code&gt;Schlagworten&lt;/code&gt;
      . Diese werden in einem Element Information Item
      &lt;code&gt;Schlagworte&lt;/code&gt;
      abgelegt. Dieses Element kann zwischen drei und
      fünf Zeichenketten als
      &lt;code&gt;Eintrag&lt;/code&gt;
      beinhalten.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 3&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu XML Schema - Aufgabe 3&lt;/title&gt;
    &lt;p&gt;
     Gegeben sei nachfolgendes Dokument. Entwerfen Sie
     dafür ein gültiges XML-Schema.
    &lt;/p&gt;
    &lt;listing src="uebung-schemaentwurf.xml"&gt;&lt;/listing&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Übungen zu XML Schema --&gt;

 &lt;presentation id="uebungenSchema"&gt;
  &lt;title short="uebungenSchema"&gt;Übungen zu XML Schema&lt;/title&gt;
  &lt;date&gt;2008-10-27&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;
   Übungen aus der Vorlesung zu XML Schema.
  &lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungen aus der Vorlesung zu XML Schema.&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Umwandlung einer DTD in ein XML Schema&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Gegeben ist folgende DTD. Erstellen Sie ein
      äquivalentes Schema gemäß der
      &lt;a href="http://www.w3.org/TR/xmlschema-1/"&gt;
       W3C XML Schema Recommendation
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;listing src="dtd-fuer-schemaumwandlung.dtd"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

  &lt;/part&gt;
 &lt;/presentation&gt;

 &lt;presentation id="SAX"&gt;
  &lt;title short="SAX"&gt;Die Simple API for XML (SAX)&lt;/title&gt;
  &lt;date&gt;2008-11-10&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.megginson.com/"&gt;
    Die
    &lt;em&gt;ursprüngliche SAX Seite&lt;/em&gt;
    von David Megginson
   &lt;/a&gt;
   &lt;br /&gt;
   &lt;a href="http://www.saxproject.org/"&gt;
    Webseite des SAX Projekts
   &lt;/a&gt;
   &lt;br /&gt;
   &lt;a href="https://jaxp.dev.java.net/"&gt;
    Die JAXP Projektseite
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Für diverse Programmiersprachen existieren mittlerweile
   gängige Schnittstellen, um auf XML-Dokumente zuzugreifen und
   diese weiterzuverarbeiten. Die
   &lt;em&gt;Simple API for XML (SAX)&lt;/em&gt;
   ist eine sehr einfach (=leichtgewichtig) gehaltene API für
   die
   &lt;em&gt;ereignisbasierte&lt;/em&gt;
   Verarbeitung von XML-Dokumenten. Die Charakterisierung als
   leichtgewichtiger Ansatz bezieht sich sowohl auf den
   Implementierungsaufwand der API selbst, als auch ihren
   Integrationsaufwand in eigene Applikationen.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XML-APIs - baumorientiert vs. ereignisbasiert&lt;/title&gt;
   &lt;p&gt;
    Für die Verarbeitung von XML-Dokmenten sind im
    Wesentlichen zwei Ansätze verfügbar.
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;em&gt;Baumorientierte APIs&lt;/em&gt;
     :
     &lt;br /&gt;
     Baumorientierte APIs bilden das gesamte zu
     verarbeitende Dokument in eine Baumstruktur ab. Eine
     weiterverarbeitende Applikation kann je nach Bedarf
     entlang dieser Baumstruktur navigieren. Das Document
     Object Model (DOM) stellt solche eine
     baumorientierte API zur Verfügung.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;Ereignisbasierte APIs&lt;/em&gt;
     :
     &lt;br /&gt;
     Diese Art Programmierschnittstelle liest über ein
     Dokument und berichtet dabei über sogenannte
     berichtenswerte "Ereignisse", die während des Lesens
     auftreten (zum Beispiel den Start oder das Ende
     eines Elementes). Die Applikation wird über
     sogenannte "Callback"-Methoden über diese Ereignisse
     benachrichtigt. Es wird keine interne Baumstruktur
     aufgebaut, die dem XML-Dokument entspricht.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Was ist ein Parser? Was sind seine Aufgaben?&lt;/title&gt;
   &lt;p class="definition"&gt;
    Ein Parser (engl. to parse „analysieren“ bzw. von
    lateinisch pars „Teil“; im Deutschen gelegentlich auch
    Zerteiler) ist ein Computerprogramm, das in der
    Computertechnik für die Zerlegung und Umwandlung einer
    beliebigen Eingabe in ein für die Weiterverarbeitung
    brauchbares Format zuständig ist. Häufig werden Parser
    eingesetzt, um im Anschluss an den Analysevorgang die
    Semantik der Eingabe zu erschließen und daraufhin
    Aktionen durchzuführen.
   &lt;/p&gt;
   &lt;p&gt;
    Quelle:
    &lt;a href="http://de.wikipedia.org/wiki/Parser"&gt;
     Wikipedia
    &lt;/a&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX - Einführendes&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Ursprünglich war SAX eine Sammlung generischer
     Java-Schnittstellen für XML-Parser.
    &lt;/li&gt;
    &lt;li&gt;
     Weiterentwicklung zur eigenständigen
     Verarbeitungsmöglichkeit für XML-Dokumente in
     verschiedenen weiteren Programmiersprachen:
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;C++&lt;/li&gt;
     &lt;li&gt;Python&lt;/li&gt;
     &lt;li&gt;Perl&lt;/li&gt;
     &lt;li&gt;Eiffel&lt;/li&gt;
    &lt;/ul&gt;
    &lt;li&gt;
     In der Vorlesung konzentrieren wir uns auf die
     Java-Umsetzung von SAX2.
    &lt;/li&gt;
    &lt;li&gt;
     SAX2 ist eine Weiterentwicklung von SAX und
     unterstützt beispielsweise Namensräume.
    &lt;/li&gt;
    &lt;li&gt;
     SAX2 ist seit JDK 1.4 Bestandteil des JDK und ist
     Bestandteil der Java APIs for XML Processing (JAXP).
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Bestandteile von SAX Implementierungen&lt;/title&gt;
   &lt;p&gt;
    SAX-Implementierungen weisen üblicherweise drei
    erkennbare Blöcke auf.
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;em&gt;Die Schnittstellen:&lt;/em&gt;
     &lt;br /&gt;
     SAX definiert eine Sammlung abstrakter
     Schnittstellen (siehe nächste Seite).
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;Reader (Parser)&lt;/em&gt;
     &lt;br /&gt;
     Der Parser selbst (= die Implementierung zu den
     Schnittstellen). Die SAX2-Schnittstellen werden
     durch den jeweiligen eingesetzten Parser bedient und
     die definierten (Callback)-Methoden entsprechend
     eingebunden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;ReaderFactory&lt;/em&gt;
     &lt;br /&gt;
     Sie dient zur Erzeugung verschiedener Ausprägungen
     (z.B. validierend/nicht-validierend, Namespace
     berücksichtigend, etc.) SAX-basierter Parser.
     &lt;br /&gt;
     Bei einer
     &lt;em&gt;Factory Method&lt;/em&gt;
     handelt es sich um ein sogenanntes
     &lt;em&gt;Design Pattern&lt;/em&gt;
     (Entwurfsmuster,
     &lt;a
      href="http://de.wikipedia.org/wiki/Viererbande_(Softwareentwicklung)"&gt;
      Gang of Four
     &lt;/a&gt;
     ). Ziel: Objekte erzeugen, ohne die genaue Klasse
     des zu erzeugenden Objekts anzugeben. Lösung: es
     wird in einer Schnittstelle eine Methode zur
     Erzeugung von Objekten definiert. In den Subklassen
     kann diese Methode dann überschrieben werden, um ein
     abgeleitetes Objekt zu erzeugen.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Die SAX2 Schnittstellen&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;em&gt;ContentHandler:&lt;/em&gt;
     &lt;br /&gt;
     Versammelt Operationen zur Reaktion auf
     Dokumentereignisse (wie
     &lt;code&gt;startDocument&lt;/code&gt;
     ,
     &lt;code&gt;startElement&lt;/code&gt;
     ,
     &lt;code&gt;processingInstruction&lt;/code&gt;
     ...) Hinweis: In älterer Literatur findet sich
     häufig statt des ContentHandlers eine mit
     DocumentHandler benannte Schnittstelle. Dabei
     handelt es sich um die Schnittstelle der
     Vorgängerversion (SAX1). Sie bietet unter anderem
     keine Namensraumintegration und wurde durch den
     &lt;code&gt;ContentHandler&lt;/code&gt;
     ersetzt.
     &lt;br /&gt;
     Achtung: Die Java-Standardklassenbibliothek bietet
     im Paket
     &lt;code&gt;java.net&lt;/code&gt;
     eine mit
     &lt;code&gt;ContentHandler&lt;/code&gt;
     benannte Klasse an. Diese kann durch
     Importanweisungen mit der gleichnamigen
     SAX-Schnittstelle aus dem Paket
     &lt;code&gt;org.xml.sax&lt;/code&gt;
     kollidieren!
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;ErrorHandler:&lt;/em&gt;
     &lt;br /&gt;
     Versammelt Operationen zur Reaktion auf die drei in
     der XML-Spezifikation definierten Fehlerklassen:
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;error&lt;/em&gt;
       (behebbarer Fehler):
       &lt;br /&gt;
       Bei einem Fehler ist das Ergebnis der
       aktuellen Verarbeitung undefiniert, der
       Prozessor fährt jedoch mit der Verarbeitung
       eines Dokumentes fort.
       &lt;br /&gt;
       Beispiel: Anderer Wert als
       &lt;code&gt;1.0&lt;/code&gt;
       oder
       &lt;code&gt;1.1&lt;/code&gt;
       im XML-Prolog oder ein
       nichtdeterministisches Inhaltsmodell (siehe
       nächste Seite).
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;fatalError&lt;/em&gt;
       :
       &lt;br /&gt;
       Ein fataler Fehler führt dazu, daß der
       XML-Prozessor die Verarbeitung eines
       Dokumentes abbricht und einen Fehler an die
       Applikation meldet.
       &lt;br /&gt;
       Beispiel: Falsche Codierung eines Dokuments
       (tatsächliche Codierung stimmt nicht mit im
       Prolog angegebener Codierung überein),
       Verletzung der Wohlgeformtheitsregeln
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;warning&lt;/em&gt;
       :
       &lt;br /&gt;
       Mit einer Warnung können Hinweise gegeben
       werden. Warnungen sind als Hilfestellung
       gedacht und optional. Das bedeutet,
       Prozessoren
       &lt;em&gt;können&lt;/em&gt;
       Warnungen ausgeben, müssen dies aber nicht
       tun.
       &lt;br /&gt;
       Beispiel: Referenzierung eines nicht
       deklarierten Elements als Kindelement.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;DTDHandler:&lt;/em&gt;
     &lt;br /&gt;
     Möglichkeit zur Implementierung eigener
     Behandlungsroutinen für Notation-Deklarationen und
     ungeparste Entitäten.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;EntityResolver:&lt;/em&gt;
     &lt;br /&gt;
     Möglichkeit zur Implementierung von
     Auflösungsmechanismen für Entitäten gemäß ihres
     System Identifiers und, falls vorhanden, des Public
     Identifiers.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Ausflug in den Compilerbau: deterministisches
    Inhaltsmodell
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Mit
     &lt;em&gt;Determinismus&lt;/em&gt;
     bezeichnet man in der Informatik einen Zustand, zu
     dem nur definierte und reproduzierbare Folgezustände
     auftreten können. Das bedeutet etwa, daß bei der
     Abarbeitung eines Algorithmus nach einer bestimmten
     Anweisung unter den gleichen Voraussetzungen immer
     die gleiche nächste Anweisung folgt. Der nächste
     Abarbeitungsschritt ist immer eindeutig festgelegt.
     &lt;br /&gt;
     (Quelle:
     &lt;a
      href="http://de.wikipedia.org/wiki/Determinismus_(Algorithmus)"&gt;
      Wikipedia
     &lt;/a&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     Anders formuliert und in Bezug auf Grammatiken
     gesetzt: Zu jedem Zustand und Eingabesymbol eines
     Automaten darf höchstens ein Folgezustand
     existieren.
     &lt;br /&gt;
     (Quelle:
     &lt;a
      href="http://books.google.de/books?id=Zo7I8kutRVIC"&gt;
      Grundkurs Theoretische Informatik, von Gottfried
      Vossen, Kurt-Ulrich Witt
     &lt;/a&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     Beispiel:
     &lt;code&gt;((b, c) | (b, d))&lt;/code&gt;
     . Ein Prozessor kann, wenn er das Element
     &lt;code&gt;b&lt;/code&gt;
     in einem Dokument liest, nicht wissen, ob als
     nächstes Element
     &lt;code&gt;c&lt;/code&gt;
     oder
     &lt;code&gt;d&lt;/code&gt;
     erscheint. Welche der beiden Möglichkeiten trifft
     zu? Der Prozessor müßte zur Beantwortung dieser
     Frage im Dokument bereits
     &lt;q&gt;vorauslesen&lt;/q&gt;
     . Eine Umformulierung der Grammatik hilft in diesen
     Fällen. Wäre das Inhaltsmodell als
     &lt;code&gt;(b, (c | d))&lt;/code&gt;
     definiert, so treten diese Probleme nicht auf, denn
     der Prozessor muß nicht zwischen zwei Regeln
     auswählen, er muß hier nicht
     &lt;q&gt;vorauslesen&lt;/q&gt;
     , sowohl
     &lt;code&gt;c&lt;/code&gt;
     als auch
     &lt;code&gt;d&lt;/code&gt;
     würden akzeptiert.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Das SAX Ausführungsmodell&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;Ereignisbasierte Ausführung von Operationen&lt;/li&gt;
    &lt;li&gt;
     Der Parser liest das Eingabedokument und aktiviert
     währenddessen verschiedene Operationen, die der
     Behandlung des soeben eingelesenen Information Items
     dienen.
    &lt;/li&gt;
    &lt;li&gt;
     Der Programmierer einer Applikation ruft diese
     Operationen nicht explizit auf!
    &lt;/li&gt;
    &lt;li&gt;
     Die Reihenfolge der Abarbeitung wird nicht durch
     einen durchgängigen Programmcode gesteuert.
     Stattdessen ergibt sie sich aus der Reihenfolge der
     Ereignisse, die bei der Verarbeitung des Dokumentes
     aktiviert wird. Die Abarbeitung erfolgt also
     dokumentgesteuert.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX - Leichtgewichtiger Ansatz&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     SAX-Parser wurden bewußt
     &lt;em&gt;leichtgewichtig&lt;/em&gt;
     konzipiert.
    &lt;/li&gt;
    &lt;li&gt;
     Sie halten nur die nötigste Information im Speicher,
     die für die Verarbeitung des gerade eingelesenen
     Information Items nötig ist. Das bedeutet, nur die
     Menge an Information, die gerade nötig ist, um die
     Callback-Operation auszuführen (Übergabeparameter),
     ist von Interesse.
    &lt;/li&gt;
    &lt;li&gt;
     Aufgrund dieser geringen Anforderungen ist dieses
     Konzept mit nur geringen Anpassungen auf sehr viele
     Programmiersprachen anwendbar.
    &lt;/li&gt;
    &lt;li&gt;SAX eignet sich daher für&lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Geräte, denen nur geringer Hauptspeicher zur
      Verfügung steht (z.B. Embedded Devices, tragbare
      Geräte, etc.)
     &lt;/li&gt;
     &lt;li&gt;
      die Verarbeitung von sehr großen XML-Dokumenten,
      die zu groß sind, um im Hauptpeicher gehalten
      werden zu können. (XML-Dokumente für
      3D-Grafiken, etwa tesselierte Daten, werden
      bspw. sehr schnell sehr groß!)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;q&gt;Einfache&lt;/q&gt;
      Aufgaben, bei denen es nicht nötig ist, das
      gesamte Dokument mit seiner Struktur im Speicher
      zu behalten.
      &lt;br /&gt;
      Beispiel: Finden eines Elements, das einen
      bestimmte Zeichenkette enthält. Für solche
      Aufgaben ist es nicht effizient, die
      Dokumentstruktur als Baum nachzubilden und dann
      so lange im Baum zu navigieren, bis diese
      Information gefunden ist. Eine ereignisbasierte
      API erlaubt die Durchführung dieser Aufgabe
      schnell (keine Nnvigation nötig) und effizient
      (wenig Speicherverbrauch).
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Push Model&lt;/title&gt;

   &lt;ul&gt;
    &lt;li&gt;
     Eine SAX-Applikation wird nie selbst aktiv, steuert
     nie den Kontrollfluß selbst.
    &lt;/li&gt;
    &lt;li&gt;
     Stattdessen wartet sie passiv auf ihre Aktivierung,
     durch Auswerfen der jeweiligen Ereignisse.
    &lt;/li&gt;
    &lt;li&gt;
     Ein derartiges Verhalten wird auch
     &lt;em&gt;Push Model&lt;/em&gt;
     genannt.
    &lt;/li&gt;
    &lt;li&gt;
     Am Eingabedokument sind mit SAX keine großen
     Änderungen möglich, da das
     &lt;q&gt;Blickfeld&lt;/q&gt;
     sehr eingeschränkt ist.
    &lt;/li&gt;
    &lt;li&gt;
     Möglich sind lediglich einfache Transformationen,
     indem das Eingabedokument verändert wieder
     ausgegeben wird.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX - Ein erstes Beispiel&lt;/title&gt;
   &lt;listing src="SAXExample1.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX - erste Übung&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Führen Sie einen
     &lt;a
      href="http://www.barbara-zengler.de/vorlesung/SAXExample1.java"&gt;
      Download des ersten SAX-Beispiels
     &lt;/a&gt;
     auf Ihren Rechner durch.
    &lt;/li&gt;
    &lt;li&gt;Öffnen Sie eine Shell (Befehlseingabefenster).&lt;/li&gt;
    &lt;li&gt;
     Prüfen Sie die bei Ihnen installierte Java-Version
     durch Absetzen des Befehls
     &lt;code&gt;java -version&lt;/code&gt;
     . Prüfen Sie das Vorhandensein des Java Compilers (
     &lt;code&gt;javac&lt;/code&gt;
     ).
    &lt;/li&gt;
    &lt;li&gt;
     Zur Erstellung der Beispiele und Übungen in diesem
     Skript wurde das
     &lt;a href="http://download.java.net/jdk6/binaries/"&gt;
      Java SDK 1.6 Update 10
     &lt;/a&gt;
     verwendet.
    &lt;/li&gt;
    &lt;li&gt;
     Wechseln Sie in das Verzeichnis, in das Sie das
     Beispiel gespeichert haben und compilieren Sie es
     mit dem Befehl
     &lt;code&gt;javac SAXExample1.java&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     Nun können Sie die Anwendung mit beliebigen
     XML-Dokumenten ausführen.
     &lt;br /&gt;
     Am Beispiel unseres ersten XML-Dokumentes ergibt
     sich folgende Ausgabe:
    &lt;/li&gt;
    &lt;listing src="SAXExample1.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;SAX - erstes Beispiel - Analyse (1/2)&lt;/title&gt;
   &lt;p&gt;
    Was ist während der Ausführung des Beispiels passiert?
    &lt;br /&gt;
    Eine Analyse.
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Der SAX-Parser liest das auf der Kommandozeile
     angegebene Dokument (
     &lt;code&gt;erstes-XML-dokument.xml&lt;/code&gt;
     ) ein.
    &lt;/li&gt;
    &lt;listing src="SAXExample1.bat" /&gt;
    &lt;li&gt;
     Zu Beginn des Lesevorgangs ruft er die vordefinierte
     callback-Funtion
     &lt;code&gt;startDocument&lt;/code&gt;
     auf.
     &lt;br /&gt;
     Diese wurde in der Applikation (
     &lt;code&gt;SAXExample2.java&lt;/code&gt;
     ) implementiert. Sie gibt die eine Zeile mit dem
     Text
     &lt;code&gt;document started&lt;/code&gt;
     aus.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="9-11" /&gt;
    &lt;li&gt;
     Am Ende des Lesevorgangs wird vom Parser eine
     weitere vordefinierte callback-Funktion aufgerufen:
     &lt;code&gt;endDocument&lt;/code&gt;
     . Auch diese wurde in der Applikation implementiert,
     sie gibt eine Zeile mit dem Text
     &lt;code&gt;document ended&lt;/code&gt;
     aus.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="13-15" /&gt;
    &lt;li&gt;
     Unsere im Beispiel erstellte Klasse erweitert die in
     SAX definierte Basisklasse
     &lt;code&gt;
      &lt;a
       href="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html"&gt;
       DefaultHandler
      &lt;/a&gt;
     &lt;/code&gt;
     (definiert im Paket
     &lt;code&gt;
      &lt;a
       href="https://jaxp-sources.dev.java.net/nonav/docs/api/org/xml/sax/helpers/package-summary.html"&gt;
       org.xml.sax.helpers
      &lt;/a&gt;
     &lt;/code&gt;
     ).
     &lt;br /&gt;
     Hier sind auch die Signaturen der beiden verwendeten
     Operationen
     &lt;code&gt;startDocument&lt;/code&gt;
     und
     &lt;code&gt;endDocument&lt;/code&gt;
     festgelegt (
     &lt;a
      href="http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html"&gt;
      In JAXP API Dokumentation nachlesen
     &lt;/a&gt;
     ).
     &lt;br /&gt;
     Unsere Beispielklasse erbt diese beiden Methoden,
     die zunächst einfach
     &lt;q&gt;nichts tun&lt;/q&gt;
     , von dieser Klasse. In der Beispielklasse werden
     die Methoden dann überschrieben und die oben
     erwähnten Textausgaben produziert.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="7" /&gt;
   &lt;/ul&gt;


  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;SAX - erstes Beispiel - Analyse (2/2)&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Bevor das Dokument durch einen XML Reader (Parser)
     gelesen werden kann, muß erst ein entsprechendes
     Objekt (eine Instanz) eines Readers erzeugt werden.
     Dies geschieht mit dem Aufruf
     &lt;code&gt;XMLReaderFactory.createXMLReader()&lt;/code&gt;
     E stehen verschiedene konfigurierbare SAX-Parser
     Implementierungen zur Verfügung. Unter Nutzung der
     aktuellen Systemkonfiguration wird mittels
     &lt;code&gt;createXMLReader&lt;/code&gt;
     ein neuer Parser erzeugt. Im Beispiel wird die
     Vorgabekonfiguration verwendet.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="18" /&gt;
    &lt;li&gt;
     Danach müssen die EventHandler registriert werden,
     mit deren Hilfe der Parser uns Informationen über
     das gelesene Dokument mitteilt.
     &lt;br /&gt;
     Dies geschieht mit Hilfe der Methoden
     &lt;code&gt;setContentHandler&lt;/code&gt;
     und
     &lt;code&gt;setErrorHandler&lt;/code&gt;
     der XMLReader Schnittstelle. Werden diese Handler
     nicht gesetzt, so werden sämtliche Ereignisse, die
     der Parser meldet, schlichtweg von der Anwendung
     ignoriert. Es passiert
     &lt;q&gt;nichts&lt;/q&gt;
     .
     &lt;br /&gt;
     Hat man diese Schritte durchgeführt, dann kann die
     (passive) SAX API durch den Parser aufgerufen
     werden.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="19-21" /&gt;
    &lt;li&gt;
     Im obigen Codeauszug wird ein Objekt der Klasse
     SAXExample2 erzeugt, mit dem die Ereignisse des
     SAX-Parsers empfangen werden können. Es werden
     EreignisHandler für den Inhalt des Dokuments (
     &lt;em&gt;Content Handler&lt;/em&gt;
     ) und für Fehler (
     &lt;em&gt;Error Handler&lt;/em&gt;
     ) registriert.
    &lt;/li&gt;
    &lt;li&gt;
     Die Methode
     &lt;code&gt;parse&lt;/code&gt;
     des
     &lt;code&gt;XMLReader&lt;/code&gt;
     -Objekts führt auf dem über Kommandozeilenparameter
     (
     &lt;code&gt;args[0]&lt;/code&gt;
     ) übergebenen Dokument den Lesevorgang durch.
     &lt;br /&gt;
     &lt;em&gt;Beachten Sie&lt;/em&gt;
     : Die Datei muss über ein Objekt der Klasse
     &lt;code&gt;InputSource&lt;/code&gt;
     gekapselt werden, damit sie eingelesen werden kann.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample1.java"
     line="23-24" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX - Erweiterung des ersten Beispiels&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Das erste Beispiel soll so erweitert werden, daß der
     Parser auch Start und Ende der Elemente eines
     Dokuments ausgeben soll.
    &lt;/li&gt;
    &lt;li&gt;
     Dazu werden die beiden Callback-Methoden
     &lt;code&gt;startElement&lt;/code&gt;
     und
     &lt;code&gt;endElement&lt;/code&gt;
     in der Applikation implementiert.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample2.java"
     line="18-24" /&gt;
    &lt;li&gt;
     Die Signatur der Methode
     &lt;code&gt;startElement&lt;/code&gt;
     erfordert das Einbinden der Schnittstelle
     &lt;code&gt;Attributes&lt;/code&gt;
     aus dem Paket
     &lt;code&gt;org.xml.sax&lt;/code&gt;
     .
    &lt;/li&gt;
    &lt;listing
     src="SAXExample2.java"
     line="4" /&gt;
    &lt;li&gt;
     Der komplette Code des erweiterten Beispiels sieht
     demnach nun folgendermaßen aus.
    &lt;/li&gt;
    &lt;listing src="SAXExample2.java" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die SAX2-Schnittstellen&lt;/title&gt;
   &lt;p&gt;
    Die grundlegende Schnittstelle der SAX2-API wird mit
    ContentHandler bezeichnet, sie versammelt Operationen
    zur Abbildung des logischen Inhaltes eines
    XML-Dokumentes. Die in unseren Beispielen verwendete
    Basisklasse
    &lt;code&gt;DefaultHandler&lt;/code&gt;
    implementiert u.a. diese Schnittstelle und stellt sie so
    der Beispielapplikation zur Verfügung.
    &lt;br /&gt;
    Die Übersicht in untenstehender Tabelle stellt die
    wichtigsten Operationen der Schnittstelle mit ihrer
    Signatur und Funktionalität zusammen.
   &lt;/p&gt;
   &lt;table border="1"&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt;Operation&lt;/th&gt;
      &lt;th&gt;Funktionalität&lt;/th&gt;
     &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startDocument()"&gt;
         startDocument()
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Aufruf zu Beginn eines Dokuments. Naturgemäß
       wird diese Methode nur einmal ausgeführt.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endDocument()"&gt;
         endDocument()
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Aufruf am Ende des Einlesevorgangs eines
       Dokuments. Auch diese Methode wird vom SAX
       Parser nur einmal aufgerufen.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startElement(java.lang.String,%20java.lang.String,%20java.lang.String,%20org.xml.sax.Attributes)"&gt;
         startElement(String namespaceURI,
         String localName, String qName,
         Attributes atts)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Die Operation wird am Anfang (öffnender Tag)
       eines jeden Elements in einem XML-Dokument
       aufgerufen (auch bei leeren Elementen!). Sie
       gibt unter den Namen des Elementes als Namen
       ohne Namensraumpräfix (
       &lt;code&gt;localName&lt;/code&gt;
       ) sowie auch den qualifizierten Namen des
       Elements (
       &lt;code&gt;qName&lt;/code&gt;
       ) zurück.
       &lt;br /&gt;
       Anmerkung: Namensrauminformationen werden
       nur erzeugt, wenn der Parser entsprechend
       konfiguriert wurde.
       &lt;note&gt;
        Das bedeutet z.B., der qualifizierte
        Name wird nur dann zurückgegeben, wenn
        der Parser konfiguriert wurde,
        Namensraum-Präfixe zu verwenden.
       &lt;/note&gt;
       &lt;br /&gt;
       Objekte des Type Attributes enthalten die
       Attribute eines Elements in der Reihenfolge
       ihrer Definition.
       &lt;br /&gt;
       Zu jedem Attribut sind neben dem lokalen und
       dem qualifizierten Namen die Namensraum URI
       sowie Typ und Attributwert gemäß XML v1.0
       abrufbar.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endElement(java.lang.String,%20java.lang.String,%20java.lang.String)"&gt;
         endElement(String namespaceURI,
         String localName, String qName)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Die Operation wird aufgerufen, wenn das Ende
       eines jeden Elements in einem XML-Dokument
       erreicht ist (auch bei leeren Elementen!)
       &lt;br /&gt;
       Die Übergabeparameter entsprechen denen des
       zugehörigen startElement-Aufrufs.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#processingInstruction(java.lang.String,%20java.lang.String)"&gt;
         processingInstruction(String target,
         String data)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Liefert die deklarierten
       Verarbeitungsanweisungen. Diese können vor
       und nach Eintritt des
       &lt;code&gt;startDocument&lt;/code&gt;
       -Ereignisses auftreten. Der XML-Prolog wird
       hierbei nicht als Processing Instruction
       behandelt, entsprechend wird daher auch kein
       Ereignis dieses Typs ausgelöst.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#startPrefixMapping(java.lang.String,%20java.lang.String)"&gt;
         startPrefixMapping(String prefix,
         String uri)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Signalisiert den Beginn des
       Gültigkeitsbereits des Namensraumkürzels
       &lt;code&gt;prefix&lt;/code&gt;
       .
       &lt;code&gt;uri&lt;/code&gt;
       enthält die vollständige URI des gebundenen
       Namensraums. Ist
       &lt;code&gt;prefix&lt;/code&gt;
       leer, so handelt es sich um die Redefinition
       des Vorgabenamensraums. Das Ereignis wird
       vor dem ersten Element des Namensraums (d.h.
       dem Element, das die Präfixbindung enthält
       oder den Vorgabenamensraum überschreibt)
       ausgelöst.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#endPrefixMapping(java.lang.String)"&gt;
         endPrefixMapping(String prefix)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Signalisiert das Ende des
       Gültigkeitsbereichs des Namensraumkürzels
       &lt;code&gt;prefix&lt;/code&gt;
       . Ist der Übergabeparameter leer, so bezieht
       sich das Ereignis auf den Vorgabenamensraum.
       Das Ereignis tritt nach dem
       &lt;code&gt;endElement&lt;/code&gt;
       -Ereignis des letzten Elements im Namensraum
       ein.

      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#characters(char[],%20int,%20int)"&gt;
         characters(char[] ch, int start, int
         length)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Aufruf bei der Verarbeitung von
       Zeichenkettendaten innerhalb eines Elements.
       &lt;code&gt;ch&lt;/code&gt;
       enthält ab der Position
       &lt;code&gt;start&lt;/code&gt;
       Zeichenketten-artige Daten der Länge
       &lt;code&gt;length&lt;/code&gt;
       .
       &lt;br /&gt;
       Hinweis: Manche Parser melden Leerzeichen
       innerhalb von Elementen mit Hilfe der
       Operation
       &lt;code&gt;ignorableWhitespace&lt;/code&gt;
       . Validierenden Parsern ist dies sogar
       vorgeschrieben.
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        &lt;a
         href="http://java.sun.com/javase/6/docs/api/org/xml/sax/ContentHandler.html#ignorableWhitespace(char[],%20int,%20int)"&gt;
         ignorableWhitespace(char[] ch, int
         start, int length)
        &lt;/a&gt;
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       Diese Operation wird aufgerufen, wenn der
       Parser ignorierbare Leerzeichen im Inhalt
       von Elementen liest.
       &lt;br /&gt;
       Validierende Parser müssen hierbei diese
       Operation verwenden, nicht validierende
       Parser können sie verwenden.
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Beispiel 3 - Eine kleine Dokumentstatistik&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Erweitern wir unser Beispiel durch ein paar der
     vorgestellten Operationen, um eine kleine
     Dokumentstatistik zu erzeugen.
    &lt;/li&gt;
    &lt;li&gt;
     Zunächst werden in der Klasse
     &lt;code&gt;SAXExample3&lt;/code&gt;
     einige Variablen deklariert und mit
     &lt;code&gt;0&lt;/code&gt;
     vorinitialisiert.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample3.java"
     line="8-15" /&gt;
    &lt;li&gt;
     In den jeweiligen Operationen (die den Eintritt
     eines Ereignisses widerspiegeln) werden dann die
     Werte dieser Variablen entsprechend inkrementiert.
     Beispiel:
     &lt;code&gt;startElement++;&lt;/code&gt;
     in
     &lt;code&gt;startElement()&lt;/code&gt;
     .
    &lt;/li&gt;
    &lt;listing
     src="SAXExample3.java"
     line="39-42" /&gt;
    &lt;li&gt;
     Nach Abschluß des vollständigen Lesevorganges, d.h.
     Eintritt des Ereignisses
     &lt;code&gt;endDocument&lt;/code&gt;
     , werden die aufsummierten Zahlen durch die Methode
     &lt;code&gt;printStatistics&lt;/code&gt;
     auf der Standardausgabe dargestellt.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample3.java"
     line="34-37" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Beispiel 3 - Analyse&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Ein Aufruf des kompilierten Programms auf das erste
     XML-Dokument...
    &lt;/li&gt;
    &lt;listing src="SAXExample3.bat" /&gt;
    &lt;listing src="erstes-XML-dokument.xml" /&gt;
    &lt;li&gt;ergibt folgendes Ergebnis:&lt;/li&gt;
    &lt;listing src="SAXExample3.output" /&gt;
    &lt;li&gt;
     Erwähnenswert ist die Ausgabe für
     &lt;code&gt;character events&lt;/code&gt;
     .
     &lt;br /&gt;
     Warum ist das so?
    &lt;/li&gt;
    &lt;li&gt;
     Ändert man das Eingabedokument testweise
     folgendermaßen ab:
    &lt;/li&gt;
    &lt;listing src="erstes-xml-dokument-modified.xml" /&gt;
    &lt;li&gt;
     So ergibt sich für die Aufrufe der Methode
     &lt;code&gt;characters&lt;/code&gt;
     die Anzahl
     &lt;code&gt;7&lt;/code&gt;
     . Der Parser meldet alle Zeilenumbrüche in
     Elementinhalt als Ereignis.
    &lt;/li&gt;
    &lt;listing src="SAXExample3-modified.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Beispiel 3 - komplettes Listing&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Im folgenden ist das gesamte Listing des Beispiels 3
     aufgeführt.
    &lt;/li&gt;
    &lt;listing src="SAXExample3.java" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Beispiel 4 - Häufigkeitsermittlung einzelner
    Elementnamen
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     In diesem Codebeispiel wird zusätzlich das Paket
     &lt;code&gt;java.util.HashMap&lt;/code&gt;
     eingebunden.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample4.java"
     line="7" /&gt;
    &lt;li&gt;
     Zur Ermittlung der Anzahl der Elemente wird mit
     Hilfe der Java-Collection-API-Klasse
     &lt;code&gt;HashMap&lt;/code&gt;
     eine Liste mit Tupeln aus Elementnamen und
     Auftretensanzahlen verwaltet. Eintragungen und
     Aktualisierungen dieser Liste erfolgen bei jedem
     &lt;code&gt;startElement&lt;/code&gt;
     -Ereignis.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample4.java"
     line="14-22" /&gt;
    &lt;li&gt;
     Die Ausgabe der
     &lt;code&gt;HashMap&lt;/code&gt;
     erfolgt in der Operation
     &lt;code&gt;endDocument()&lt;/code&gt;
     .
    &lt;/li&gt;
    &lt;listing
     src="SAXExample4.java"
     line="24-26" /&gt;
    &lt;li&gt;
     Ein Aufruf des Programms auf unser erstes XML
     Dokument ergibt folgendes Ergebnis:
    &lt;/li&gt;
    &lt;listing src="SAXExample4.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Beispiel 4 - komplettes Listing&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Im folgenden ist das gesamte Listing des Beispiels 4
     aufgeführt.
    &lt;/li&gt;
    &lt;listing src="SAXExample4.java" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    SAX - Probleme des Xerces-Parsers mit der Byte Order
    Mark (1/3)
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;Angewendet auf das untenstehendes Dokument...&lt;/li&gt;
    &lt;listing src="namespace15.xml" /&gt;
    &lt;li&gt;
     ... stürzt das Programm ab! Wir erhalten folgende
     Fehlermeldung:
    &lt;/li&gt;
    &lt;listing src="SAXExample4-ns.output" /&gt;
    &lt;li&gt;
     Die Fehlermeldung
     &lt;code&gt;Content is not allowed in prolog.&lt;/code&gt;
     deutet auf ein Problem bei der Verarbeitung des
     XML-Prologes hin.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    SAX - Probleme des Xerces-Parsers mit der Byte Order
    Mark (2/3)
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Lädt man die betreffende Datei in einen XML-Editor,
     so sieht sie völlig normal aus.
    &lt;/li&gt;
    &lt;li&gt;
     Bedient man sich jedoch eines Kommandozeilenviewers,
     wie beispielsweise des auf UNIX-Systemen vorhandenen
     Pagers
     &lt;code&gt;less&lt;/code&gt;
     , so erkennt man, daß vor dem Prolog noch Zeichen
     stehen.
    &lt;/li&gt;
    &lt;img
     style="margin : 4% ; width : 90% ; "
     src="xerces-exception.jpg" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die Unicode Byte Order Mark&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Es handelt sich hierbei um die sogenannte
     &lt;code&gt;Byte Order Mark&lt;/code&gt;
     . Dies sind Zeichen, die in Unicode-codierten
     Dateien an den Anfang der Datei gestellt werden
     können. Die Byte Order Mark gibt an, welche
     Codierung bei der Datei vorliegt (z.B. UTF-16) und
     in welcher Byte-Reihenfolge (Little-Endian,
     Big-Endian) die Datei gespeichert ist.
    &lt;/li&gt;
    &lt;li&gt;
     Der
     &lt;a
      href="http://www.unicode.org/versions/Unicode5.0.0/ch16.pdf#G25817"&gt;
      Unicode Standard, Kapitel 16
     &lt;/a&gt;
     listet in Tabelle 16-4 folgende Byte Order
     Mark-Werte für die verschiedenen Codierungen auf:
    &lt;/li&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Codierungsschema&lt;/th&gt;
       &lt;th&gt;Signatur&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;UTF-8&lt;/td&gt;
       &lt;td&gt;EF BB BF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;UTF-16 Big-endian&lt;/td&gt;
       &lt;td&gt;FE FF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;UTF-16 Little-endian&lt;/td&gt;
       &lt;td&gt;FF FE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;UTF-32 Big-endian&lt;/td&gt;
       &lt;td&gt;00 00 FE FF&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;UTF-32 Little-endian&lt;/td&gt;
       &lt;td&gt;FF FE 00 00&lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;

   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    SAX - Probleme des Xerces-Parsers mit der Byte Order
    Mark (3/3) - Lösung
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Abhilfe schafft das Entfernen der Byte Order Mark
     aus der betreffenden Datei. Dies können Sie mit
     Hilfe eines Unicode Editors, z.B.
     &lt;a href="http://www.unipad.org/main/"&gt;SC Unipad&lt;/a&gt;
     , bewerkstelligen.
    &lt;/li&gt;
    &lt;li&gt;
     Ist die Byte Order Mark aus der Datei entfernt, so
     verschwindet die Fehlermeldung des Parsers, das
     Dokument ...
    &lt;/li&gt;
    &lt;listing src="namespace15-noBOM.xml" /&gt;
    &lt;li&gt;
     ...kann verarbeitet werden und liefert folgende
     Ausgabe:
    &lt;/li&gt;
    &lt;listing src="SAXExample4-ns-korrekt.output" /&gt;
    &lt;li&gt;
     Offensichtlich ignoriert der verwendete SAX-Parser
     in der Standardkonfiguration die deklarierten
     Namensräume.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Namensraum-konformer SAX-Parser&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Zunächst müssen wir feststellen, ob der verwendete
     Parser in der Lage ist, Namensraumpräfixe zu
     erkennen und Namensräume als URIs zurückzugeben.
    &lt;/li&gt;
    &lt;li&gt;
     Hierfür ist es nötig, den Parser nach seiner
     derzeitigen Unterstützung der beiden
     &lt;em&gt;Features&lt;/em&gt;
     &lt;code&gt;namespaces&lt;/code&gt;
     und
     &lt;code&gt;namespace-prefixes&lt;/code&gt;
     abzufragen.
    &lt;/li&gt;
    &lt;listing
     src="IsParserNSAware.java"
     line="17-41" /&gt;
    &lt;li&gt;Die Abfrage kann folgendes Ergebnis bringen:&lt;/li&gt;
    &lt;listing src="IsParserNSAware.output" /&gt;
    &lt;li&gt;
     In diesem Fall kann versucht werden, den Wert mit
     Hilfe der Methode
     &lt;code&gt;setFeature&lt;/code&gt;
     auf
     &lt;code&gt;true&lt;/code&gt;
     zu setzen und somit die Unterstützung für
     Namensraum-Präfixe zu erhalten.
    &lt;/li&gt;
    &lt;listing
     src="setParserNSAware.java"
     line="30-47" /&gt;
    &lt;li&gt;Die Ausgabe des Programms:&lt;/li&gt;
    &lt;listing src="setParserNSAware.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Beispiel 5 - Elemente zählen mit Namensraumunterstützung
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Im nachfolgenden Beispiel soll der Code zum Zählen
     der Elemente so modifiziert werden, daß die Elemente
     korrekt gezählt werden.
    &lt;/li&gt;
    &lt;li&gt;
     Zunächst wird der Parser so konfiguriert, daß er
     Namensräume unterstützt.
    &lt;/li&gt;
    &lt;li&gt;
     Darüber hinaus wird die Routine zur Zählung der
     Elementauftritte entsprechend angepaßt.
    &lt;/li&gt;
    &lt;listing
     src="SAXExample5.java"
     line="14-25" /&gt;
    &lt;li&gt;
     Angewendet auf das
     &lt;a href="namespace15-noBOM.xml"&gt;
      Beispiel-Dokument
     &lt;/a&gt;
     liefert es nun das erwartete korrekte Ergebnis:
    &lt;/li&gt;
    &lt;listing src="SAXExample5.output" /&gt;
    &lt;li&gt;
     Konsequenterweise wird dem Wurzelelement
     &lt;code&gt;document&lt;/code&gt;
     , für das kein Namensraum definiert ist (es befindet
     sich daher spezifikationsgemäß im NULL-Namensraum),
     die leere Namensraum-URI vorangestellt.
    &lt;/li&gt;
    &lt;li&gt;
     Hinweis: Bei der Ausgabenotation handelt es sich um
     keine syntaktisch korrekte Elementdeklaration, sie
     dient lediglich der Veranschaulichung!
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;SAX Features&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Neben der eben verwendeten Eigenschaften
     &lt;code&gt;namespaces&lt;/code&gt;
     und
     &lt;code&gt;namespace-prefixes&lt;/code&gt;
     definiert die SAX2-Schnittstelle noch weitere
     Features.
     &lt;br /&gt;
     Untenstehende Tabelle gibt eine Übersicht.
    &lt;/li&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Feature-URI&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;external-general-entities&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Zeigt an/Steuert, ob der Parser externe
        Textentitäten verarbeitet. Bei
        validierenden Parsern ist diese
        Eigenschaft immer
        &lt;code&gt;true&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;external-parameter-entities&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Zeigt an/Steuert, ob der Parser externe
        Parameterentitäten verarbeitet. Bei
        validierenden Parsern ist diese
        Eigenschaft immer
        &lt;code&gt;true&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;is-standalone&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Diese Eigenschaft kann nur abgefragt
        werden, während der Parser gerade ein
        Dokument einliest (nachdem die Methode
        &lt;code&gt;startDocument()&lt;/code&gt;
        abgearbeitet wurde). Der Wert der
        Eigneschaft ist
        &lt;code&gt;true&lt;/code&gt;
        , wenn im Prolog des Dokumentes
        &lt;code&gt;standalone="yes"&lt;/code&gt;
        spezifiziert wurde, andernfalls
        &lt;code&gt;false&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         lexical-handler/parameter-entities
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, daß der LexicalHandler (eine
        optionale Erweiterung von SAX, die etwa
        Informationen über die Grenzen von
        lexikalischen Bereichen, wie z.B.
        Kommentarbereichen liefert) den Start
        und das Ende von Parameterentitäten
        anzeigt.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;namespaces&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, daß Namensraum-URIs und lokale
        Namen für Elemente und Attribute
        abfragbar sind.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;namespace-prefixes&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, daß qualifizierte Namen und
        Namensraumattribute abfragbar sind.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;resolve-dtd-uris&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, daß System-IDs in
        Deklarationen als absolute URIs (im
        Gegensatz zu relativen URIs)
        zurückgeliefert werden.
        &lt;code&gt;false&lt;/code&gt;
        bedeutet, daß die URIs als relative URIs
        zurückgegeben werden. Zugriff auf die
        Basis-URI ist dann über
        &lt;code&gt;Locator.getSystemId()&lt;/code&gt;
        möglich.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;string-interning&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        bedeutet, daß alle XML-Namen (für
        Elemente, Attribute, Präfixe, Entities,
        Notations) mit Hilfe von
        &lt;code&gt;java.lang.String.intern&lt;/code&gt;
        als kanonische Repräsentation vorliegen
        und damit eindeutig sind. Vorteil:
        Schnelles Testen auf Gleichheit mit
        Stringkonstanten (schneller als ein
        Aufruf von
        &lt;code&gt;String.equals()&lt;/code&gt;
        ).
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         unicode-normalization-checking
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Steuert, ob der Parser Fehler meldet,
        die bei der Unicode Normalisierung
        entstehen (siehe
        &lt;a
         href="http://www.w3.org/TR/xml11/#sec-normalization-checking"&gt;
         XML 1.1 Spezifikation, Abschnitt
         2.13
        &lt;/a&gt;
        ).
        &lt;br /&gt;
        Derartige Fehler stellen keine
        schwerwiegenden Fehler bei der
        Verarbeitung dar. Ein Dokument bleibt
        wohlgeformt, auch wenn die betreffenden
        Konstrukte nicht vollständig
        normalisiert wurden.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;use-attributes2&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, ob die Attributobjekte, die
        dieser Parser in der Operation
        &lt;code&gt;startElement()&lt;/code&gt;
        übergibt, der Schnittstellen
        &lt;code&gt;org.xml.sax.ext.Attributes2&lt;/code&gt;
        entsprechen. Diese Schnittstelle erlaubt
        weitergehende Information, wie etwa, ob
        der Attributwert im Dokument angegeben
        wurde oder ob der Defaultwert, der in
        der DTD spezifiziert war, angenommen
        wurde.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;use-locator2&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        bedeutet, daß die
        &lt;code&gt;Locator&lt;/code&gt;
        objekte, die der Parser in der Methode
        &lt;code&gt;setDocumentLocator()&lt;/code&gt;
        übergibt, die Schnittstelle
        &lt;code&gt;org.xml.sax.ext.Locator2&lt;/code&gt;
        unterstützt. Diese Schnittstelle
        unterstützt weitergehende Information
        über das Dokument, wie etwa die
        Zeichenkodierung sowie die verwendete
        XML-Version.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;use-entity-resolver2&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;code&gt;true&lt;/code&gt;
        zeigt an, wenn der Entity Resolver die
        Schnittstelle
        &lt;code&gt;
         org.xml.sax.ext.EntityResolver2
        &lt;/code&gt;
        unterstützt. In diesem Fall werden die
        dort definierten (neuen) Methoden
        verwendet.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;validation&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Steuert, ob ein validierender Parser
        verwendet wird, der alle
        Validierungsfehler meldet. Wenn ja (
        &lt;code&gt;true&lt;/code&gt;
        ), werden alle externen Entitäten
        gelesen.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;xmlns-uris&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Steuert, ob der Parser Attribute mit
        Namensraumdeklarationen so behandelt,
        daß sie sich im Namensraum
        &lt;code&gt;
         http://www.w3.org/2000/xmlns/
        &lt;/code&gt;
        befinden. Ursprünglich befinden sich
        diese Attribute explizit in keinem
        Namensraum (siehe
        &lt;a
         href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#ns-using"&gt;
         Namespaces in XML
        &lt;/a&gt;
        ). Eine spätere Ausgabe der
        Spezifikation (siehe
        &lt;a
         href="http://www.w3.org/TR/2006/REC-xml-names-20060816/#ns-decl"&gt;
         Namespaces in XML 1.0 (Second
         Edition)
        &lt;/a&gt;
        oder
        &lt;a
         href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#ns-decl"&gt;
         Namespaces in XML 1.1 (Second
         Edition)
        &lt;/a&gt;
        definiert für diese Attribute jedoch den
        oben angegebenen Namensraum.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;xml-1.1&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Wenn der Parser sowohl XML 1.0 als auch
        XML 1.1 unterstützt, so besitzt diese
        Eigenschaft den Wert
        &lt;code&gt;true&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Fehlerbehandlung&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Während der Arbeit mit der SAX-Schnittstelle können
     innerhalb zweier getrennter Operationsphasen
     Fehlersituationen auftreten.
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;
      während der Konstruktionsphase des SAX-basierten
      Parsers, d.h. vor Aufruf der Methode
      &lt;code&gt;parse&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      während des eigentlichen Parsingvorganges beim
      Einlesen des Dokuments
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;li&gt;
     Die Schnittstelle bietet die drei von
     &lt;code&gt;SAXException&lt;/code&gt;
     abgeleiteten Ausnahmeereignisklassen an
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotRecognizedException.html"&gt;
       SAXNotRecognizedException
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.saxproject.org/apidoc/org/xml/sax/SAXNotSupportedException.html"&gt;
       SAXNotSupportedException
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.saxproject.org/apidoc/org/xml/sax/SAXParseException.html"&gt;
       SAXParseException
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Fehlerbehandlung - SAXNotRecognizedException&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Fehler während der Parserkonstruktions- und
     Initialisierungsperiode rühren, abgesehen von
     externen Effekten, zumeist vom Versuch her, einen
     Parser in unzulässiger Weise zu parametrisieren.
    &lt;/li&gt;
    &lt;li&gt;So führt etwa der Aufruf von folgendem Code..&lt;/li&gt;
    &lt;listing src="SAXExample6.java" /&gt;
    &lt;li&gt;... zu folgender Fehlermeldung:&lt;/li&gt;
    &lt;listing src="SAXExample6.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Fehlerbehandlung - SAXParseException&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Tritt während des Parsingvorganges ein Verstoß
     hinsichtlich der well-formedness Regeln auf, so wird
     ein
     &lt;code&gt;SAXParseException&lt;/code&gt;
     -Ausnahmeereignis erzeugt. Es stellt Methoden zur
     näheren Lokalisierung der Fehlerstelle im
     Eingabedokument zur Verfügung.
    &lt;/li&gt;
    &lt;li&gt;
     Im folgenden Beispiel wird dies umgesetzt: Mittels
     der Methoden
     &lt;code&gt;getColumnNumber&lt;/code&gt;
     und
     &lt;code&gt;getLineNumber&lt;/code&gt;
     lassen sich Spalten- und Zeilennummer des Fehlers
     ermitteln.
     &lt;code&gt;getSystemId&lt;/code&gt;
     und
     &lt;code&gt;getPublicId&lt;/code&gt;
     können zur Ausgabe des System-Identifiers, der bei
     lokaler Referenzierung identisch zum Dateisystempfad
     ist, bzw. zur Ausgabe des Public-Identifiers --
     falls gesetzt -- herangezogen werden.
    &lt;/li&gt;
    &lt;listing src="SAXExample7.java" /&gt;
    &lt;li&gt;Angewendet auf folgendes XML-Dokument...&lt;/li&gt;
    &lt;listing src="NotWellFormed-noBOM.xml" /&gt;
    &lt;li&gt;... ergibt sich folgende Ausgabe:&lt;/li&gt;
    &lt;listing src="SAXExample7.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Fehlerbehandlung - SAXNotSupportedException&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Das Auftreten einer
     &lt;code&gt;SAXNotSupportedException&lt;/code&gt;
     wird durch den Versuch ausgelöst, eine zulässige und
     erkannte Parameterisierung des SAX-Parsers
     vorzunehmen, die durch diesen nicht unterstützt
     wird.
    &lt;/li&gt;
    &lt;li&gt;
     Diese Fehlersituation läßt sich daher an keinem
     statischen Beispiel zeigen, sondern hängt von der
     konkreten Parser-Implementierung ab.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Abschließendes Beispiel&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Das folgende Abschlußbeispiel zeigt eine
     vollständige Implementierung der verschiedenen
     SAX-Ereignisse der
     &lt;code&gt;ContentHandler&lt;/code&gt;
     -Schnittstelle.
    &lt;/li&gt;
    &lt;listing src="SAXExample8.java" /&gt;
    &lt;li&gt;Angewendet auf folgendes Eingabedokument...&lt;/li&gt;
    &lt;listing src="SAXExample8-input.xml" /&gt;
    &lt;li&gt;... ergibt sich folgende Ausgabe:&lt;/li&gt;
    &lt;listing arc="SAXExample8.output" /&gt;
    &lt;li&gt;
     Die Ausführung liefert eine textuelle Ausgabe, deren
     Ereignisreihenfolge der der folgenden Abbildung
     entspricht
    &lt;/li&gt;
    &lt;img src="saxEvents.gif" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Einfache Transformationen&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Bedingt durch die sequentielle Aktivierung der
     verschiedenen Ereignisbehandlungsroutinen lassen
     sich mit SAX sehr komfortabel einfache
     Dokumenttransformationen, wie z.B. die Umbenennung
     von Elementen, realisieren.
    &lt;/li&gt;
    &lt;li&gt;
     Der Code aus untenstehendem Beispiel zeigt die
     Umbenennung eines Elements von
     &lt;code&gt;foo&lt;/code&gt;
     nach
     &lt;code&gt;bar&lt;/code&gt;
     . Alle anderen Elemente, Attribute und
     Zeichenketten-artigen Elementinhalte werden
     unverändert kopiert.
     &lt;br /&gt;
     Hinweis: Das Beispiel berücksichtigt dabei jedoch
     weder Namensräume noch Processing Instructions.
    &lt;/li&gt;
    &lt;li&gt;
     Zur Realisierung komplexer Transformationen,
     insbesondere solcher, die die Zwischenspeicherung
     von Dokumentinformationen erfordern sind jedoch
     Ansätze mit expliziter Abbildung in
     Hauptspeicherstrukturen wie DOM oder XSLT besser
     geeignet.
    &lt;/li&gt;
    &lt;listing src="SAXExample9.java" /&gt;
    &lt;li&gt;Angewendet auf folgendes Eingabedokument...&lt;/li&gt;
    &lt;listing src="SAXExample9-input.xml" /&gt;
    &lt;li&gt;...ergibt sich folgende Ausgabe:&lt;/li&gt;
    &lt;listing src="SAXExample9.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Einbindung von SAX in Applikationsprogramme&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Untenstehendes Beispiel zeigt die Einbindung eines
     SAX-Parsers in ein Applikationsprogramm. Die
     Anwendung überführt beliebige XML-Eingabedokumente
     in eine Java-SWING-konforme Baumdarstellung.
    &lt;/li&gt;
    &lt;listing src="TreeViewer.java" /&gt;
    &lt;li&gt;
     Der Code zeigt die sukzessive Konstruktion der
     Baumansicht entlang der beim Lesevorgang
     eintretenden SAX-Ereignisse.
    &lt;/li&gt;
    &lt;li&gt;
     Hervorzuheben ist hierbei die Erzeugung je eines
     Baumknotens innerhalb der
     Ereignisbehandlungsroutinen
     &lt;code&gt;startElement&lt;/code&gt;
     ,
     &lt;code&gt;processingInstruction&lt;/code&gt;
     und
     &lt;code&gt;characters&lt;/code&gt;
     . All diese Methoden fügen einen neuen Kindknoten
     zum aktuell bearbeiteten Baumknoten zu. Zusätzlich
     wird innerhalb der Behandlung des
     &lt;code&gt;startElement&lt;/code&gt;
     -Ereignisses der neu erzeugte Kindknoten für die
     weitere Verarbeitung als Aktueller definiert und
     damit eine zusätzliche Baumstufe eröffnet.
    &lt;/li&gt;
    &lt;li&gt;
     Das rekursive Aufsteigen im Baum findet beim
     Verlassen eines Elements (Ereignis:
     &lt;code&gt;endElement&lt;/code&gt;
     ) statt.
    &lt;/li&gt;
    &lt;li&gt;
     Untenstehende Abbildung zeigt die durch Verarbeitung
     des Dokuments
     &lt;a href="namespace15-noBOM.xml"&gt;
      namespace15-noBOM.xml
     &lt;/a&gt;
     erzeugte Bildschirmansicht. Die vermeintlich
     „leeren“ CHARACTER-Elemente entstehen durch die
     nichtdruckbaren Zeichen wie Zeilenumbrüche und
     Wagenrückläufe.
    &lt;/li&gt;
    &lt;img src="TreeViewer.gif" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Abschlußbemerkungen und Einsatzempfehlungen&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     SAX offenbart sich als leicht einzusetzende und
     trotzdem für geeignete Anwendungsfälle sehr mächtige
     Schnittstelle. Insbesondere ist der serielle
     Verarbeitungsansatz, der nur geringe
     Hauptspeicheranforderungen stellt, sehr gut für
     große XML-Dokumente geeignet. Gleichzeitig skalieren
     SAX-basierte Anwendungen vergleichsweise gut, da das
     Eingabedokument nur einmal durchlaufen wird.
    &lt;/li&gt;
    &lt;li&gt;
     Als gravierende Nachteile offenbaren sich jedoch die
     fehlenden Navigationsmöglichkeiten, die der
     Applikation die Reihenfolge der Elemente im Dokument
     als Verarbeitungsreihenfolge aufzwingen.
     Festzuhalten bleibt, daß es sich bei SAX lediglich
     um eine Schnittstelle handelt, auf der Parser
     realisiert werden können. SAX selbst ist jedoch kein
     solcher.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
 &lt;/presentation&gt;

 &lt;!--  Übungen zu SAX --&gt;
 &lt;presentation id="uebungsaufgabenSAX"&gt;
  &lt;title short="uebungsaufgabenSAX"&gt;
   Übungsaufgaben zum Thema SAX.
  &lt;/title&gt;
  &lt;date&gt;2008-11-10&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;Übungsaufgaben zum Thema SAX.&lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu SAX&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übersicht Übungsaufgaben SAX&lt;/title&gt;
    &lt;p&gt;
     In den folgenden Übungsaufgaben werden Sie Schritt
     für Schritt eine umfangreichere Programmieraufgabe
     lösen.
     &lt;br /&gt;
     Im Laufe der nächsten Wochen werden weitere
     Teilaufgaben hinzukommen.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu SAX - Teilaufgabe 1&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Melden Sie sich beim
      &lt;a
       href="http://pages.ebay.de/entwickler/api.html"&gt;
       eBay-Entwicklerprogramm
      &lt;/a&gt;
      an.
      &lt;br /&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Arbeiten Sie sich dort zunächst durch den
      &lt;em&gt;Quick Start&lt;/em&gt;
      .
      &lt;br /&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Verschaffen Sie sich eine Übersicht über die
      &lt;a
       href="http://developer.ebay.com/DevZone/shopping/docs/Concepts/ShoppingAPIGuide.html"&gt;
       eBay Shopping API
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Lernen Sie, wie Sie einen
      &lt;a
       href="http://developer.ebay.com/DevZone/Shopping/docs/Concepts/ShoppingAPI_FormatOverview.html"&gt;
       Aufruf an die eBay Shopping API absetzen
       können
      &lt;/a&gt;
      .
      &lt;br /&gt;
      Hinweis: Die URL, an die Sie Ihre Anfrage
      schicken müssen, lautet
      &lt;code&gt;http://open.api.ebay.com/shopping?&lt;/code&gt;
      .
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu SAX - Teilaufgabe 2&lt;/title&gt;
    &lt;p&gt;
     Formulieren Sie eine Anfragedatei im XML-Format, um
     die eBay Shopping API anzufragen. Ihre Anfrage
     sollte folgenden Kriterien genügen:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verwendung der Methode
      &lt;code&gt;FindItems&lt;/code&gt;
      . Es sollen maximal 50 Suchergebnisse
      zurückgeliefert werden.
     &lt;/li&gt;
     &lt;li&gt;
      Angabe der Zeichenkette
      &lt;q&gt;
       eBay Anfrage Praktikum XML, Name: X. XXXXX
      &lt;/q&gt;
      als Parameter
      &lt;code&gt;MessageID&lt;/code&gt;
      .
      &lt;br /&gt;
      Bitte ersetzen Sie X. XXXXX durch Ihre(n) Namen.
     &lt;/li&gt;
     &lt;li&gt;
      Doppelte Suchergebnisse sollen nicht angezeigt
      werden.
     &lt;/li&gt;
     &lt;li&gt;
      Die Suchergebnisse sollen nach der Endzeit der
      Auktion sortiert werden. Bald endende Angebote
      sollen zuerst angezeigt werden.
     &lt;/li&gt;
     &lt;li&gt;
      Schränken Sie die Suche bei sehr vielen
      Suchergebnissen durch Angabe Ihrer Postleitzahl
      ein.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Testen Sie die von Ihnen erstellte XML-Datei mit
     Hilfe des
     &lt;a
      href="https://developer.ebay.com/DevZone/build-test/test-tool/Default.aspx"&gt;
      eBay API Test Tools
     &lt;/a&gt;
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu SAX - Teilaufgabe 3&lt;/title&gt;
    &lt;p&gt;
     Schreiben Sie ein Java-Programm, das die eBay
     Shopping API mittels einer XML-Anfrage über das
     Protokoll HTTP mit der Methode
     &lt;code&gt;POST&lt;/code&gt;
     abfragt und die Rückantwort von eBay im XML-Format
     erwartet. Ihr Programm soll diese Rückantwort in
     einem ersten Schritt zunächst entgegennehmen und in
     eine Datei speichern.
    &lt;/p&gt;
    &lt;p&gt;... To Be Continued!&lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgaben zu SAX - Teilaufgabe 4&lt;/title&gt;
    &lt;p&gt;
     Geben Sie die durch die eBay API zurückgegebenen
     Objekte in eine HTML-Datei als Tabelle formatiert
     aus.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Erstellen Sie sich hierfür zunächst ein
      Rohgerüst einer HTML-Datei, anhand der Sie sich
      überlegen, wie Sie die erhaltenen Daten anzeigen
      möchten (Anzahl der Spalten, etc.).
     &lt;/li&gt;
     &lt;li&gt;
      Erstellen Sie dann eine SAX-Applikation, mit der
      Sie diese HTML-Datei erzeugen und sie
      entsprechend befüllen.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Übungen zu SAX --&gt;

 &lt;!--  Exkurs: Netzwerken mit Java --&gt;
 &lt;presentation id="JavaNetworking"&gt;
  &lt;title short="JavaNetworking"&gt;
   Exkurs: Netzwerken mit Java
  &lt;/title&gt;
  &lt;date&gt;2008-11-17&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;Zugriff auf das Internet mit Java&lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Mit einem Webserver verbinden&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Mit HTTP auf eine URL zugreifen&lt;/title&gt;
    &lt;p&gt;
     Um auf einen Webserver zuzugreifen, ist es nötig,
     Mit Hilfe des
     &lt;em&gt;Hypertext Transfer Protocols (HTTP)&lt;/em&gt;
     eine Verbindung zu einer URL aufzubauen.
     &lt;br /&gt;
     Im Folgenden wird Schritt für Schritt erklärt, wie
     dies in Java zu bewerkstelligen ist.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In Java existiert eine Klasse
      &lt;code&gt;HttpURLConnection&lt;/code&gt;
      . Wird die Methode
      &lt;code&gt;openConnection()&lt;/code&gt;
      dieser Klasse auf einer URL ausgeführt, so
      erhält man eine Instanz.
     &lt;/li&gt;
     &lt;listing
      src="callEbay.java"
      line="16-21" /&gt;
     &lt;li&gt;
      Ist die Instanz dieser Klasse erzeugt, so kann
      diese in einem zweiten Schritt konfiguriert
      werden. So wird etwa festgelegt, ob für die
      Verbindung Benutzereingaben vorgesehen ist (hat
      Auswirkungen auf die Dauer der Verbindung) sowie
      ob seitens der Applikation Ein- und Ausgaben für
      die Verbindung vorgesehen sind.
     &lt;/li&gt;
     &lt;listing
      src="callEbay.java"
      line="23-28" /&gt;
     &lt;li&gt;
      Anschließend können dann die Parameter für diese
      Verbindung gesetzt werden. Dazu gehören
      beispielsweise die Festlegung der Methode, mit
      der auf den HTTP Server zugegriffen wird, sowie
      das Setzen diverser HTTP Header. Außerdem wird
      die Verbindung konfigurier
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der Zugriff auf die eBay API erfolgt mittels
       der Methode
       &lt;code&gt;HTTP POST&lt;/code&gt;
       . Aus diesem Grund muß die soeben erzeugte
       &lt;code&gt;HttpURLConnection&lt;/code&gt;
       entsprechend konfiguriert werden.
      &lt;/li&gt;
      &lt;listing
       src="callEbay.java"
       line="31-32" /&gt;
      &lt;li&gt;
       Nun sind noch die entsprechenden Header der
       HTTP Anfrage zu setzen. Dies ist mit Hilfe
       der Methode
       &lt;code&gt;
        setRequestProperty(String key, String
        value)
       &lt;/code&gt;
       möglich.
      &lt;/li&gt;
      &lt;li&gt;
       Die eBay API verlangt zwingend folgende HTTP
       Header:
       &lt;br /&gt;
       &lt;code&gt;X-EBAY-API-REQUEST-ENCODING&lt;/code&gt;
       ,
       &lt;code&gt;X-EBAY-API-RESPONSE-ENCODING&lt;/code&gt;
       ,
       &lt;code&gt;X-EBAY-API-APP-ID&lt;/code&gt;
       ,
       &lt;code&gt;X-EBAY-API-CALL-NAME&lt;/code&gt;
       und
       &lt;code&gt;X-EBAY-API-VERSION&lt;/code&gt;
      &lt;/li&gt;
      &lt;listing
       src="callEbay.java"
       line="33-38" /&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Sind die Parameter gesetzt und die generellen
      Eigenschaften einer Anfrage festgelegt, so wird
      die eigentliche Verbindung zur Ressource
      geöffnet (
      &lt;code&gt;connect()&lt;/code&gt;
      ).
     &lt;/li&gt;
     &lt;listing
      src="callEbay.java"
      line="41-47" /&gt;
     &lt;li&gt;
      Der Aufruf der Applikation erfordert unter
      Umständen die Angabe eines Proxys per
      Kommandozeile, abhängig von der vorhandenen
      Netzwerkinfrastruktur.
     &lt;/li&gt;
     &lt;listing src="callEbay.bat" /&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Ein- und Ausgabe für eine Verbindung setzen
    &lt;/title&gt;
    &lt;p&gt;
     Zu Demonstrationszwecken soll verschaulicht werden,
     wie die Ausgabe von Daten auf die Netzwerkverbindung
     sowie das Einlesen von Daten von der
     Netzwerkverbindung bewerkstelligt werden kann.
    &lt;/p&gt;
    &lt;p&gt;
     Es soll eine XML-Datei auf die Netzwerkverbindung
     übertragen werden. Diese Datei wird zunächst mit
     einem
     &lt;code&gt;BufferedReader&lt;/code&gt;
     eingelesen.
    &lt;/p&gt;
    &lt;listing
     src="callEbay.java"
     line="52-54" /&gt;
    &lt;p&gt;
     Für die Ausgabe von Daten auf die Netzwerkverbindung
     kann ein
     &lt;code&gt;OutputStreamWriter&lt;/code&gt;
     verwendet werden. Dieser wird dann etwa Zeile für
     Zeile mit der Eingabedatei befüllt.
    &lt;/p&gt;
    &lt;listing
     src="callEbay.java"
     line="56-63" /&gt;
    &lt;p&gt;
     Das Einlesen von Daten aus einer Netzwerkverbindung
     erfolgt ähnlich. Es wird ein
     &lt;code&gt;BufferedReader&lt;/code&gt;
     erzeugt und mit einem
     &lt;code&gt;InputStreamReader&lt;/code&gt;
     der Netzwerkverbindung verbunden. Danach wird der
     Puffer zeilenweise ausgelesen und auf
     &lt;code&gt;stdout&lt;/code&gt;
     ausgegeben.
    &lt;/p&gt;
    &lt;listing
     src="callEbay.java"
     line="65-76" /&gt;
    &lt;p&gt;
     Am Ende wird die Netzwerkverbindung wieder
     geschlossen.
    &lt;/p&gt;
    &lt;listing
     src="callEbay.java"
     line="78-79" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Fehlersuche bei Netzwerkverbindungen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Um feststellen zu können, was genau von einer
      Applikation über eine Netzwerkverbindung
      geschickt wird, bietet sich der Einsatz des frei
      verfügbaren Tools
      &lt;a href="http://www.wireshark.org/"&gt;
       Wireshark
      &lt;/a&gt;
      an.
     &lt;/li&gt;
     &lt;li&gt;
      Es handelt sich dabei um ein Werkzeug zur
      Netzwerkprotokollanalyse.
     &lt;/li&gt;
     &lt;li&gt;
      Der mitgeschnittene Netzwerkverkehr erscheint
      ungefähr in folgender Form auf dem Bildschirm:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;img
     src="wireshark-connection.gif"
     style="margin : 4% ; width : 80% ;" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Über den Menüpunkt "Follow TCP Stream" kann die
      Darstellung gefiltert und lesbarer gestaltet
      werden:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;img
     src="wireshark.gif"
     style="margin : 4% ; width : 80% ;" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Gesamtes Beispiel&lt;/title&gt;
    &lt;p&gt;
     Das gesamte Codebeispiel.
     &lt;br /&gt;
     Hinweis: Der Code hat Beispielcharakter und stellt
     lediglich
     &lt;em&gt;eine mögliche Lösung&lt;/em&gt;
     für die Aufgabenstellung dar.
    &lt;/p&gt;
    &lt;listing src="callEbay.java" /&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Netzwerken mit Java--&gt;


 &lt;!--  DOM --&gt;
 &lt;presentation id="DOM"&gt;
  &lt;title short="DOM"&gt;Das Document Object Model (DOM)&lt;/title&gt;
  &lt;date&gt;2008-11-17&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/DOM/index.html"&gt;
    W3C DOM Webseite
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Die W3C-Spezifikation des
   &lt;em&gt;Document Object Models&lt;/em&gt;
   (abgekürzt als: DOM) definiert eine
   Programmiersprachen-unabhängige und plattformneutrale Menge
   abstrakter Schnittstellen, mit denen Programme und Skripte
   lesend und schreibend auf gültige HTML-Dokumente und
   wohlgeformte XML-Dokumente sowie eine Reihe weiterer Formate
   zugreifen können.
   &lt;br /&gt;
   HTML: Das Dokument kann weiterverarbeitet werden, das
   Ergebnis dieser Verarbeitung kann direkt in die angezeigte
   Seite eingebunden werden.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Was ist DOM?&lt;/title&gt;
   &lt;p&gt;
    DOM versteht sich als Application Programming Interface
    (API) für beliebige XML-Dokumente (und damit auch
    XHTML-Dokumente). Es definiert die logische Struktur
    eines Dokumentes und die Art und Weise, wie auf diese
    Struktur zugegriffen und die Information verändert
    werden kann. Hierzu versammelt es auf Basis einer
    generischen Speicherrepräsentation für XML eine Menge
    von Operationen.
   &lt;/p&gt;
   &lt;p&gt;
    Programmierer können mit DOM Dokumente erstellen,
    entlang ihrer Struktur navigieren, Elemente und deren
    Inhalt hinzufügen, verändern oder löschen.
   &lt;/p&gt;
   &lt;p&gt;
    Als W3C-Spezifikation zielt DOM nicht auf eine spezielle
    Programmierumgebung ab, sondern wurde vor dem
    Hintergrund entworfen, für beliebige unterschiedlicher
    Programmiersprachen einsetzbar zu sein.
    &lt;br /&gt;
    Aus diesem Grund wurde die Spezifikation in einer
    besonderen Sprache für Schnittstellen, der sogenannten
    &lt;em&gt;
     &lt;a
      href="http://www.omg.org/technology/documents/formal/corba_2.htm"&gt;
      Interface Definition Language (IDL)
     &lt;/a&gt;
    &lt;/em&gt;
    entworfen.
    &lt;br /&gt;
    Es existiert eine Abbildung der IDL Spezifikation auf
    die Programmiersprache Java.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM ist...&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Eine Programmier-API für Dokumente. Es basiert auf
     einer Objektstruktur, die die Struktur eines
     Dokumentes recht genau widerspiegelt.
    &lt;/li&gt;
    &lt;li&gt;
     Betrachten wir folgendes Beispieldokument in XHTML:
    &lt;/li&gt;
    &lt;listing src="DOMExample1.xml" /&gt;
    &lt;li&gt;
     Eine grafische Repräsentation des DOM dieser XHTML-
     Tabelle wäre:
    &lt;/li&gt;
    &lt;img src="DOMExample1.png" /&gt;
    &lt;li&gt;
     Eine beispielhafte DOM Manipulation in Pseudocode
     wäre etwa:
    &lt;/li&gt;
    &lt;listing src="DOMExample1.pseudocode" /&gt;
    &lt;li&gt;
     Der Name DOM rührt davon her, daß es sich dabei um
     ein "Objektmodell" im traditionellen
     objektorientierten Sinn handelt. Dokumente werden
     mit Objekten modelliert. Das Modell umfasst nicht
     nur die Struktur eines Dokuments, sondern auch das
     Verhalten des Dokuments und der Objekte, aus denen
     es sich zusammensetzt. Mit anderen Worten stellen
     die Knoten in o.g. Diagramm keine Datenstruktur dar,
     sondern Objekte mit Funktionen und einer Identität.
    &lt;/li&gt;
    &lt;li&gt;
     Als ein Objektmodell identifiziert DOM folgendes:
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;Die Objekte, die ein Objekt repräsentieren&lt;/li&gt;
     &lt;li&gt;
      Die Schnittstellen, mit denen es verändert
      werden kann
     &lt;/li&gt;
     &lt;li&gt;
      Die Bedeutungen dieser Schnittstellen und
      Objekte - inkl. ihres Verhaltens und ihrer
      Attribute
     &lt;/li&gt;
     &lt;li&gt;
      Die Beziehungen und Zusammenarbeit zwischen
      diesen Schnittstellen und Objekten.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM ist nicht...&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     DOM ist keine binäre Spezifikation. DOM Programme,
     die in einer bestimmten Programmiersprache
     geschrieben sind, sind kompatibel zu Sourcecode, der
     in einer anderen Programmiersprache geschrieben
     sind. Binär kompatibel sind die Programme jedoch
     nicht.
    &lt;/li&gt;
    &lt;li&gt;
     DOM ist keine Methodik, mit der beliebige Objekte
     nach XML überführt werden können. DOM spezifiziert
     stattdessen, wie XML und XHTML-DOkumente als Objekte
     repräsentiert werden können, so daß man in
     objektorientierten Programmiersprachen einfach damit
     arbeiten kann.
    &lt;/li&gt;
    &lt;li&gt;
     DOM ist keine Sammlung von Datenstrukturen, sondern
     ein Objektmodell, das Schnittstellen spezifiziert.
     Auch wenn Dokumente oft mit Diagrammen dargestellt
     werden, die Elten/Kind-Beziehungen darstellen, sind
     dies logische Beziehungen, die von
     Programmierschnittstellen definiert sind. Es handelt
     sich dabei nicht um irgendwelche internen
     Datenstrukturen.
    &lt;/li&gt;
    &lt;li&gt;
     DOM definiert nicht, welche Information in einem
     Dokument relevant ist, oder wie die Information in
     einem Dokument strukturiert ist. Dies wird vielmehr
     durch das XML Infoset spezifiziert. DOM ist
     lediglich eine API für dieses Infoset.
    &lt;/li&gt;
    &lt;li&gt;
     DOM ist kein Wettbewerber zu COM, auch wenn man das
     aufgrund der Namensähnlichkeit vermuten könnte. COM
     dient wie CORBA dazu, programmiersprachenunabhängig
     Schnittstellen und Objekte zu
     &lt;em&gt;spezifizieren&lt;/em&gt;
     . DOM hingegen besteht aus einer Menge von
     Schnittstellen und Objekten, mit denen man XML und
     XHTML-Dokumente bearbeiten kann. DOM kann mit
     Systemen wie COM und CORBA implementiert werden. Es
     kann aber auch Abbildungen in eine
     Programmiersprache wie Java geben (wie etwa in der
     DOM Spezifikation selbst spezifiziert).
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - Herkunft&lt;/title&gt;
   &lt;p&gt;
    DOM spezifizierte ursprünglich, wie JavaScript Skripte
    und Java-Programme über Web Browser hinweg portabel sein
    konnten. "Dynamisches HTML" war der direkte Vorgänger
    des DOM. Der Fokus lag damals stark auf Browsern. Im
    Rahmen der Weiterentwicklung hatte die SGML und
    schließlich die XML so starken Einfluß auf DOM, daß
    mittlerweile der Hauptfokus auf XML-Dokumenten liegt.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die DOM Module&lt;/title&gt;
   &lt;p&gt;
    DOM bietet eine Menge von einzelner APIs, die zusammen
    die DOM API bilden. Jede dieser Spezifikationen
    definiert ein oder mehrere Module, von denen wiederum
    jedes mit ein oder mehr Feature-Namen assoziiert ist.
   &lt;/p&gt;
   &lt;p&gt;
    Die DOM Core spezifikation definiert beispielsweise zwei
    Module:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Das Core Modul, in dem die grundlegenden
     Schnittstellen spezifiziert sind, die von allen
     DOM-konformen Implementierungen zur Verfügung
     gestellt werden müssen.
     &lt;br /&gt;
     Das damit verbundene Feature hat den Namen
     &lt;q&gt;Core&lt;/q&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     Das XML Modul, das die Schnittstellen enthält, die
     von allen XML 1.0-konformen DOM Implementierungen
     zur Verfügung gestellt werden müssen.
     &lt;br /&gt;
     Das damit verbundene Feature hat den Namen
     &lt;q&gt;XML&lt;/q&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Die folgende Abbildung zeigt alle DOM Module mit ihren
    Feature-Namen, die in DOM spezifiziert sind:
   &lt;/p&gt;
   &lt;img
    src="dom-architecture.png"
    style="margin : 4%;" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - Übersicht über die verschiedenen Spezifikationen
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Die erste verabschiedete Spezifikation (Status einer
     W3C-Recommendation) ist das sog.
     &lt;em&gt;
      &lt;a
       href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/index.html"&gt;
       DOM Level 1
      &lt;/a&gt;
     &lt;/em&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     Die darauf aufsetzende Spezifikation
     &lt;em&gt;DOM Level 2&lt;/em&gt;
     besteht aus folgenden Teilspezifikationen:
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/index.html"&gt;
       Document Object Model Level 2 Core
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Views-20001113/index.html"&gt;
       Document Object Model Level 2 Views
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/index.html"&gt;
       Document Object Model Level 2 Events
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/index.html"&gt;
       Document Object Model Level 2 Style
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/index.html"&gt;
       Document Object Model Level 2 Traversal and
       Range
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a
       href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/index.html"&gt;
       Document Object Model Level 2 HTML
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;li&gt;
     Es wird bereits an der als DOM Level 3 bezeichneten
     Weiterentwicklung gearbeitet.
     &lt;br /&gt;
     Davon sind
     &lt;ul&gt;
      &lt;li&gt;
       &lt;em&gt;DOM Level 3 Core&lt;/em&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;DOM Level 3 Load and Save&lt;/em&gt;
      &lt;/li&gt;
      &lt;li&gt;
       &lt;em&gt;
        Document Object Model Level 3 Validation
       &lt;/em&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
     im Status einer W3C Recommendation.
     &lt;br /&gt;
     Die anderen DOM Level 3 Spezifikationen (z.B.
     &lt;em&gt;DOM Level 3 XPath&lt;/em&gt;
     oder
     &lt;em&gt;DOM Level 3 Views and Formatting&lt;/em&gt;
     ) haben erst den Stand eines
     &lt;em&gt;Working Drafts&lt;/em&gt;
     erreicht.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - Vergleich Level 1 - Level 2 - Level 3&lt;/title&gt;
   &lt;p&gt;
    DOM Level 2 erweitert die in Level 1 eingeführten
    Schnittstellen hinsichtlich der Erfordernisse des
    aktuellen XML-Standes um Namensräume und bietet einige
    neue Operationen, die seitens der Anwendergemeinde
    gefordert wurden. Die bisherigen Operationen existieren
    aus Kompatibilitätsgründen weiter, die
    Namespace-berücksichtigenden Pendants sind identisch
    benannt, jedoch um ein angehängtes NS erweitert.
   &lt;/p&gt;
   &lt;p&gt;
    DOM Level 3 komplettiert im Vergleich zu DOM Level 2 die
    Abbildung zwischen DOM und dem XML Information Set. Dies
    beinhaltet Unterstützung für XML Base, Unterstützung zur
    Auflösung von Namensraumpräfixen oder der Manipulation
    von
    &lt;em&gt;ID&lt;/em&gt;
    Attributen, etc.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM Conformance&lt;/title&gt;
   &lt;p&gt;
    Eine Implementierung darf sich als
    &lt;em&gt;konform zur DOM Level 3 Spezifikation&lt;/em&gt;
    bezeichnen, wenn sie das
    &lt;em&gt;Core&lt;/em&gt;
    -Modul unterstützt.
   &lt;/p&gt;
   &lt;p&gt;
    Eine Implementierung darf sich als
    &lt;em&gt;konform zu einem DOM Level 3 Modul&lt;/em&gt;
    bezeichnen, wenn sie alle zu diesem Modul definierten
    Schnittstellen unterstützt, sowie die damit verbundene
    Semantik.
   &lt;/p&gt;
   &lt;p&gt;
    Ob eine DOM-Implementierung ein einzelnes Modul
    unterstützt, kann durch die Schnittstellenfunktion
    &lt;code&gt;hasFeature&lt;/code&gt;
    der Schnittstelle
    &lt;code&gt;DOMImplementation&lt;/code&gt;
    des Moduls
    &lt;em&gt;Core&lt;/em&gt;
    ermittelt werden.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - erstes Beispiel: Ermitteln der unterstützten
    DOM-Module
   &lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Die Pakete zur Realisierung des Einlesevorganges
     sind in der Hierarchie
     &lt;code&gt;javax.xml.parsers&lt;/code&gt;
     organisiert.
    &lt;/li&gt;
    &lt;li&gt;
     Die in Java implementierten DOM-Attribute und
     Operationen finden sich in der Hierarchie
     &lt;code&gt;org.w3c.dom&lt;/code&gt;
    &lt;/li&gt;
    &lt;listing
     src="DOMExample2.java"
     line="1-3" /&gt;
    &lt;li&gt;
     Zunächst muß ein DOM Parser erzeugt werden, mit
     dessen Hilfe ein Dokument eingelesen werden kann.
     Das geschieht analog zur Erzeugungs- und
     Initialisierungsphase eines SAX-Parsers auch bei DOM
     über eine
     &lt;code&gt;factory&lt;/code&gt;
     -Instanz, die den Parser (ein Objekt der Klasse
     &lt;code&gt;DocumentBuilder&lt;/code&gt;
     ) liefert.
    &lt;/li&gt;
    &lt;listing
     src="DOMExample2.java"
     line="8-9" /&gt;
    &lt;li&gt;
     Die Methode
     &lt;code&gt;hasFeature&lt;/code&gt;
     ist abhängig von der konkreten Implementierung des
     Parsers und wird auf der Schnittstelle
     &lt;code&gt;DOMImplementation&lt;/code&gt;
     aufgerufen. Diese muß zunächst erzeugt werden.
    &lt;/li&gt;
    &lt;listing
     src="DOMExample2.java"
     line="10" /&gt;
    &lt;li&gt;
     Danach sollen alle in DOM Level 3 spezifizierten
     Features...
    &lt;/li&gt;
    &lt;listing
     src="DOMExample2.java"
     line="13-19" /&gt;
    &lt;li&gt;... abgefragt werden.&lt;/li&gt;
    &lt;listing
     src="DOMExample2.java"
     line="21-30" /&gt;
    &lt;li&gt;
     Ein Aufruf des Programms ergibt für JDK 1.6 Update
     10 folgendes Ergebnis:
    &lt;/li&gt;
    &lt;listing src="DOMExample2.output" /&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - erstes Beispiel: komplettes Listing&lt;/title&gt;
   &lt;listing src="DOMExample2.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Document
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle Document stellt eine spezialisierte
    Schnittstelle von
    &lt;code&gt;Node&lt;/code&gt;
    dar. Sie stellt den Einstieg in ein XML-Dokument dar und
    wird deshalb zuerst behandelt.
   &lt;/p&gt;
   &lt;p&gt;
    Diese Schnittstelle steht für das gesamte XML oder
    XHTML-Dokument. Sie bildet die Wurzel des Dokumentbaumes
    und bietet den ersten Einstiegspunkt, um auf die Daten
    des Dokuments zuzugreifen.
   &lt;/p&gt;
   &lt;p&gt;
    Weil es außerhalb des Kontexts eines Dokuments keine
    Textknoten, Kommentare, Processing Instructions, etc.
    geben kann, enthält die Schnittstelle
    &lt;code&gt;Document&lt;/code&gt;
    auch die Fabrikmethoden zur Erzeugung dieser Objekte.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die vier durch DOM definierten Datentypen&lt;/title&gt;
   &lt;p&gt;DOM definiert folgende vier Datentypen&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;DOMString&lt;/code&gt;
     :
     &lt;br /&gt;
     Mit dem Datentyp
     &lt;code&gt;DOMString&lt;/code&gt;
     werden Zeichen als Sequenz von 16-Bit Einheiten
     codiert. Die Codierung ist UTF-16.
     &lt;br /&gt;
     &lt;em&gt;Achtung:&lt;/em&gt;
     Ein einzelnes Zeichen aus einem XML oder
     XHTML-Dokument kann aufgrund der Codierung des
     Dokumentes auch in zwei 16-Bit Einheiten eines
     &lt;code&gt;DOMString&lt;/code&gt;
     abgebildet werden.
     &lt;br /&gt;
     In Java wird
     &lt;code&gt;DOMString&lt;/code&gt;
     durch den Datentyp
     &lt;code&gt;String&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;DOMTimeStamp&lt;/code&gt;
     :
     &lt;br /&gt;
     Mit dem Datentyp
     &lt;code&gt;DOMTimeStamp&lt;/code&gt;
     werden absolute und relative Zeiten abgespeichert.
     Die Einheit von
     &lt;code&gt;DOMTimeStamp&lt;/code&gt;
     sind Millisekunden.
     &lt;br /&gt;
     In Java wird
     &lt;code&gt;DOMTimeStamp&lt;/code&gt;
     durch den Datentyp
     &lt;code&gt;long&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;DOMUserData&lt;/code&gt;
     :
     &lt;br /&gt;
     In Form von
     &lt;code&gt;DOMUserData&lt;/code&gt;
     werden Applikationsdaten abgelegt.
     &lt;br /&gt;
     In Java wird
     &lt;code&gt;DOMUserData&lt;/code&gt;
     mit dem Datentyp
     &lt;code&gt;Object&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;DOMObject&lt;/code&gt;
     :
     &lt;br /&gt;
     &lt;code&gt;DOMObject&lt;/code&gt;
     repräsentiert ein Objekt, es stellt eine
     Objektreferenz dar.
     &lt;br /&gt;
     In Java wird
     &lt;code&gt;DOMObject&lt;/code&gt;
     mit dem Datentyp
     &lt;code&gt;Object&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Document -
    Attribute
   &lt;/title&gt;
   &lt;p&gt;Die Schnittstelle besitzt folgende Eigenschaften&lt;/p&gt;
   &lt;listing
    src="DOMDocument.txt"
    line="3-17" /&gt;
   &lt;p&gt;
    Einige wenige Attribute der Schnittstelle erlauben
    einfachen und schnellen Zugriff auf Kindelemente, ohne
    daß dorthin navigiert werden muss:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;doctype&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;documentElement&lt;/code&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;Bedeutung DOM-sezifischer Attribute:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;domConfig&lt;/code&gt;
     :
     &lt;br /&gt;
     Entspricht der Konfiguration, die beim Aufruf von
     &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;
     verwendet wird.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;implementation&lt;/code&gt;
     :
     &lt;br /&gt;
     Das
     &lt;code&gt;DOMImplementation&lt;/code&gt;
     Objekt, das das Dokument bearbeitet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;inputEncoding&lt;/code&gt;
     :
     &lt;br /&gt;
     Das Attribut gibt die Kodierung an, die während des
     Parsens des Dokuments erkannt wurde. Ist sie
     unbekannt, entspricht der Wert
     &lt;code&gt;null&lt;/code&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;strictErrorChecking&lt;/code&gt;
     :
     &lt;br /&gt;
     Mit diesem Attribut kann spezifiziert werden, wie
     strikt die Fehlerüberprüfung auf DOM Operationen
     durchgeführt werden soll. Der Vorgabewert ist
     &lt;code&gt;true&lt;/code&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;Abbildung nach Java:&lt;/p&gt;
   &lt;table
    border="1"
    cellpadding="5"&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt;DOM Attribut&lt;/th&gt;
      &lt;th&gt;Java Methode(n)&lt;/th&gt;
     &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;doctype&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;DocumentType getDoctype()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;implementation&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        DOMImplementation getImplementation()
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;documentElement&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Element getDocumentElement()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;inputEncoding&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getInputEncoding()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;xmlEncoding&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getXmlEncoding()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;xmlStandalone&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;boolean getXmlStandalone()&lt;/code&gt;
       ,
       &lt;br /&gt;
       &lt;code&gt;
        void setXmlStandalone(boolean
        xmlStandalone)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;xmlVersion&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getXmlVersion()&lt;/code&gt;
       ,
       &lt;br /&gt;
       &lt;code&gt;
        void setXmlVersion(String xmlVersion)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;strictErrorChecking&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        boolean getStrictErrorChecking()
       &lt;/code&gt;
       ,
       &lt;br /&gt;
       &lt;code&gt;
        void setStrictErrorChecking(boolean
        strictErrorChecking)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;documentURI&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getDocumentURI()&lt;/code&gt;
       ,
       &lt;br /&gt;
       &lt;code&gt;
        void setDocumentURI(String documentURI
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;


  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Document -
    Operationen
   &lt;/title&gt;
   &lt;p&gt;
    Folgende Operationen sind für die Schnittstelle
    &lt;code&gt;Document&lt;/code&gt;
    definiert:
   &lt;/p&gt;
   &lt;listing
    src="DOMDocument.txt"
    line="20-56" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;adoptNode&lt;/code&gt;
     &lt;q&gt;Adoptiert&lt;/q&gt;
     einen Knoten aus einem anderen Dokument. Wenn die
     Operation unterstützt wird, ändert sich die
     Eigenschaft
     &lt;code&gt;ownerDocument&lt;/code&gt;
     des Knotens, seiner Kinder und aller evtl.
     vorhandenen Attributknoten. Der Knoten wird aus der
     Kindknoten-Liste seines ursprünglichen
     Elternelements entfernt. Auf diese Weise kann ein
     Teilbaum sehr effektiv von einem Dokument zum
     anderen bewegt werden. Ist diese Operation nicht
     unterstützt, sollte stattdessen
     &lt;code&gt;importNode&lt;/code&gt;
     verwendet werden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;importNode&lt;/code&gt;
     bewegt keine Teilbäume durch Umkopieren, sondern
     erzeugt eine Kopie des Quellknotens. Das
     Quelldokument wird dabei nicht verändert. Ergebnis
     der Operation ist ein neu erzeugter Knoten (die
     Kopie), der noch an kein Elternelement angehängt
     ist. Beim Kopiervorgabg werden auch sämtliche
     Attributwerte inkl. der Namensraumattribute kopiert.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;createElement&lt;/code&gt;
     ,
     &lt;code&gt;createAttribute&lt;/code&gt;
     ,
     &lt;code&gt;createTextNode&lt;/code&gt;
     ,
     &lt;code&gt;createComment&lt;/code&gt;
     ,
     &lt;code&gt;createCDATASection&lt;/code&gt;
     ,
     &lt;code&gt;createProcessingInstruction&lt;/code&gt;
     ,
     &lt;code&gt;createEntityReference&lt;/code&gt;
     und
     &lt;code&gt;createDocumentFragment&lt;/code&gt;
     dienen zum Erzeugen neuer Knoten des jeweiligen
     Knotentyps.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;createElementNS&lt;/code&gt;
     und
     &lt;code&gt;createAttributeNS&lt;/code&gt;
     erzeugen Element- bzw. Attributknoten mit
     entsprechenden Namensrauminformationen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getElementsByTagNameNS&lt;/code&gt;
     gibt eine Liste von Knoten zurück, die den
     angegebenen lokalen Namen besitzen und sich im
     angegebenen Namensraum befinden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getElementById&lt;/code&gt;
     gibt das Element zurück, das ein ID-Attribut
     enthält, dessen Wert dem angegebenen Wert
     entspricht.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;normalizeDocument&lt;/code&gt;
     &lt;q&gt;Normalisiert&lt;/q&gt;
     das Dokument. Dies betrifft insbesondere Textknoten,
     die wie in der Methode
     &lt;code&gt;Node.normalize()&lt;/code&gt;
     normalisiert werden (z.B. Entfernen leerer
     Textknoten). Welche weiteren
     Normalisierungsmöglichkeiten auf das Dokument
     angewendet werden sollen, wird in der
     &lt;code&gt;DOMConfiguration&lt;/code&gt;
     festgelegt.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;renameNode&lt;/code&gt;
     Dient zur Umbenennung eines Element- oder
     Attributknotens. Optimalerweise wird einfach der
     Name des betreffenden Knotens verändert, andernfalls
     ein neuer Knoten mit einem entsprechenden Namen
     erzeugt und der vorhandene Knoten durch den neuen
     ersetzt.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;Abbildung in Java&lt;/p&gt;
   &lt;table
    border="1"
    cellpadding="5"&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt;DOM Methode&lt;/th&gt;
      &lt;th&gt;Java Methode(n)&lt;/th&gt;
     &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createElement(in DOMString tagName)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Element createElement(String tagName)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;createDocumentFragment()&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        DocumentFragment
        createDocumentFragment()
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createTextNode(in DOMString data)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Text createTextNode(String data)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createComment(in DOMString data)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Comment createComment(String data)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createCDATASection(in DOMString data)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;

       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createProcessingInstruction(in DOMString
        target, in DOMString data)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        CDATASection createCDATASection(String
        data)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createAttribute(in DOMString name)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Attr createAttribute(String name)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createEntityReference(in DOMString name)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        EntityReference
        createEntityReference(String name)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        getElementsByTagName(in DOMString
        tagname)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        NodeList getElementsByTagName(String
        tagname)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        importNode(in Node importedNode, in
        boolean deep)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Node importNode(Node importedNode,
        boolean deep)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createElementNS(in DOMString
        namespaceURI, in DOMString
        qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Element createElementNS(String
        namespaceURI, String qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        createAttributeNS(in DOMString
        namespaceURI, in DOMString
        qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Attr createAttributeNS(String
        namespaceURI, String qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        getElementsByTagNameNS(in DOMString
        namespaceURI, in DOMString localName)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        NodeList getElementsByTagNameNS(String
        namespaceURI, String localName)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        getElementById(in DOMString elementId)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Element getElementById(String elementId)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;adoptNode(in Node source)&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node adoptNode(Node source)&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;normalizeDocument()&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;void normalizeDocument()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;
        renameNode(in Node n, in DOMString
        namespaceURI, in DOMString
        qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        Node renameNode(Node n, String
        namespaceURI, String qualifiedName)
       &lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
   &lt;p&gt;
    Es ist festzustellen, daß die Abbildung der DOM
    Attribute und Operationen in die Programmiersprache Java
    sich sehr übersichtlich gestaltet.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - zweites Codebeispiel: einfacher Parser&lt;/title&gt;
   &lt;p&gt;
    In diesem Codebeispiel soll eine DOM-basierte
    Speicherstruktur mit SUNs JDK erzeugt werden.
   &lt;/p&gt;
   &lt;ul&gt;

    &lt;li&gt;
     Die Methode
     &lt;code&gt;parse&lt;/code&gt;
     erzeugt ein Document-Objekt gemäß der W3C
     Spezifikation.
    &lt;/li&gt;
    &lt;listing
     src="DOMExample3.java"
     line="9" /&gt;
    &lt;li&gt;
     Die entsprechenden Schnittstellendefinitionen sind
     im Paket
     &lt;code&gt;org.w3c.dom&lt;/code&gt;
     zusammengefaßt.
    &lt;/li&gt;
    &lt;listing
     src="DOMExample3.java"
     line="1-3" /&gt;
    &lt;li&gt;Das gesamte dritte Codebeispiel:&lt;/li&gt;
    &lt;listing src="DOMExample3.java" /&gt;
    &lt;li&gt;
     Der Zugriff auf das Wurzelelement des verarbeiteten
     Dokuments wird über das Attribut
     &lt;code&gt;documentElement&lt;/code&gt;
     bereitgestellt. Es liefert ein Objekt des Typs
     &lt;em&gt;Element&lt;/em&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;


  &lt;slide&gt;
   &lt;title&gt;Die grundlegenden DOM-Schnittstellen - Node&lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
    ist der wichtigste Datentyp für das gesamte DOM. Sie
    stellt einen einzelnen Knoten im gesamten Dokumentbaum
    dar.
   &lt;/p&gt;
   &lt;p&gt;
    Die Schnittstelle konzentriert alle gemeinsamen Anteile
    der verschiedenen Knoten eines XML-Baumes. Hierzu
    gehören:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;Das Dokument selbst&lt;/li&gt;
    &lt;li&gt;alle darin enthaltenen Attribute&lt;/li&gt;
    &lt;li&gt;alle darin enthaltenen Elemente&lt;/li&gt;
    &lt;li&gt;alle darin enthaltenen Kommentare&lt;/li&gt;
    &lt;li&gt;alle darin enthaltenen Textelemente&lt;/li&gt;
    &lt;li&gt;
     weitere durch die InfoSet-Spezifikation definierte
     Primitive
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Alle Objekte, die die Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
    implementieren, stellen Methoden zur Verfügung, um mit
    Kindknoten umzugehen. Gleichzeitig verfügen jedoch nicht
    alle dieser Objekte über Kindknoten (z.B. Textknoten,
    diese haben keine Kindknoten).
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node -
    Knotentypisierung
   &lt;/title&gt;
   &lt;p&gt;
    In der Schnittstelle sind verschiedene Konstanten
    definiert, die dazu dienen, eine Typisierung für die
    verschiedenen Arten von Knoten zu realisieren. Ein
    Integer weist darauf hin, um welchen Knotentyp es sich
    handelt (die Zahlen bis 200 sind hierfür reserviert).
    Für jeden dieser Knotentypen existiert jeweils eine
    eigene DOM-Schnittstelle.
   &lt;/p&gt;
   &lt;listing
    src="DOMNode.txt"
    line="4-15" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node -
    Knotentypisierung - Beispiel
   &lt;/title&gt;
   &lt;p&gt;
    Der Knotentyp eines jeden Knotens kann über das in DOM
    spezifizierte Attribut
    &lt;code&gt;nodeType&lt;/code&gt;
    abgefragt werden.
    &lt;br /&gt;
    In Java ist dieses DOM-Attribut durch die Operation
    &lt;code&gt;getNodeType()&lt;/code&gt;
    abgebildet.
   &lt;/p&gt;
   &lt;p&gt;
    Im vorgestellten Beispiel wird diese Operation auf
    verschiedenen Knotentypen aufgerufen:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;document (9)&lt;/li&gt;
    &lt;li&gt;element (1)&lt;/li&gt;
    &lt;li&gt;text (3)&lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Auszug aus dem Sourcecode: Aufruf der Operation auf
    Inhaltsknoten des Wurzelelementes
   &lt;/p&gt;
   &lt;listing
    src="DOMNodeType.java"
    line="20-22" /&gt;
   &lt;p&gt;Angewendet auf das folgendes XML-Dokument...&lt;/p&gt;
   &lt;listing src="erstes-XML-dokument.xml" /&gt;
   &lt;p&gt;... ergibt sich folgende Ausgabe:&lt;/p&gt;
   &lt;listing src="DOMNodeType.output" /&gt;
   &lt;p&gt;
    Die gefundenen Textknoten entsprechen dem textuellen
    Inhalt in
    &lt;code&gt;Vorlesung&lt;/code&gt;
    inkl. der Zeilenumbrüche.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node -
    grundlegende Attribute
   &lt;/title&gt;
   &lt;p&gt;
    Mit den Attributen
    &lt;code&gt;nodeName&lt;/code&gt;
    ,
    &lt;code&gt;nodeValue&lt;/code&gt;
    und
    &lt;code&gt;attributes&lt;/code&gt;
    stehen grundlegende Attribute zur Verfügung, die es
    erlauben, einfach auf die Information der betreffenden
    Knoten zuzugreifen, ohne daß auf die spezifische
    Schnittstelle des jeweiligen Knotentyps direkt
    zugegriffen werden muß.
    &lt;br /&gt;
    Hinweis: die spezifischen Schnittstellen enthalten unter
    Umständen zusätzliche Mechanismen, mit denen man sehr
    einfach relevante Informationen erhalten oder setzen
    kann.
   &lt;/p&gt;
   &lt;listing
    src="DOMNode.txt"
    line="17-21" /&gt;
   &lt;p&gt;Abbildung nach Java:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Das Attribut
     &lt;code&gt;nodeName&lt;/code&gt;
     bildet sich auf die Methode
     &lt;code&gt;String getNodeName()&lt;/code&gt;
     ab.
     &lt;br /&gt;
     &lt;code&gt;nodeName&lt;/code&gt;
     ist für alle Knotentypen verfügbar.
    &lt;/li&gt;
    &lt;listing
     src="DOMNode.java"
     line="16" /&gt;
    &lt;li&gt;
     Das Attribut
     &lt;code&gt;nodeValue&lt;/code&gt;
     bildet sich auf die Methode
     &lt;code&gt;String getNodeValue()&lt;/code&gt;
     ab.
     &lt;br /&gt;
     Die Eigenschaft
     &lt;code&gt;nodeValue&lt;/code&gt;
     ist für Knoten des Typs
     &lt;code&gt;ATTRIBUTE_NODE&lt;/code&gt;
     ,
     &lt;code&gt;CDATA_SECTION_NODE&lt;/code&gt;
     ,
     &lt;code&gt;COMMENT_NODE&lt;/code&gt;
     ,
     &lt;code&gt;PROCESSING_INSTRUCTION_NODE&lt;/code&gt;
     und
     &lt;code&gt;TEXT_NODE&lt;/code&gt;
     gesetzt.
    &lt;/li&gt;
    &lt;listing
     src="DOMNode.java"
     line="22-24" /&gt;
    &lt;li&gt;
     Das Attribut
     &lt;code&gt;attributes&lt;/code&gt;
     bildet sich auf die Methode
     &lt;code&gt;NamedNodeMap getAttributes()&lt;/code&gt;
     ab.
     &lt;br /&gt;
     Die Eigenschaft
     &lt;code&gt;attributes&lt;/code&gt;
     liefert erwartungsgemäß nur für Knoten des Typs
     &lt;code&gt;ELEMENT_NODE&lt;/code&gt;
     , die auch Attribute besitzen, ein positives
     Ergebnis, ansonsten
     &lt;code&gt;null&lt;/code&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Das vorige Beispiel erweitert um Ausgaben zu
    &lt;code&gt;nodeName&lt;/code&gt;
    und
    &lt;code&gt;nodeValue&lt;/code&gt;
    liefert folgende Ausgabe:
   &lt;/p&gt;
   &lt;listing src="DOMNode1.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node - weitere
    Attribute
   &lt;/title&gt;
   &lt;p&gt;
    Des weiteren versammelt die Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
    folgende weiteren Attribute:
   &lt;/p&gt;
   &lt;listing
    src="DOMNode.txt"
    line="23-44" /&gt;
   &lt;p&gt;Abbildung nach Java:&lt;/p&gt;
   &lt;table
    border="1"
    cellpadding="5"&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt;DOM Attribut&lt;/th&gt;
      &lt;th&gt;Java Methode(n)&lt;/th&gt;
     &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;nodeType&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;short getNodeType()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;parentNode&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node getParentNode()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;childNodes&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;NodeList getChildNodes()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;firstChild&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node getFirstChild()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;lastChild&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node getLastChild()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;previousSibling&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node getPreviousSibling()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;nextSibling&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Node getNextSibling()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;ownerDocument&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;Document getOwnerDocument()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;namespaceURI&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getNamespaceURI()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;prefix&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getPrefix()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;localName&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getLocalName()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;baseURI&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getBaseURI()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;textContent&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;String getTextContent()&lt;/code&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node -
    Operationen
   &lt;/title&gt;
   &lt;p&gt;
    Die aufgeführten Operationen erlauben Veränderungen der
    Knotenstruktur. So können etwa neue Knoten in eine
    bestehendes DOM-Objektmodell eingefügt werden.
    Darüberhinaus können existierende Knoten ersetzt,
    gelöscht und kopiert werden. Die Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
    wird von allen im folgenden diskutierten nach Knotentyp
    spezialisierten Schnittstellen erweitert.
   &lt;/p&gt;
   &lt;listing
    src="DOMNode.txt"
    line="46-81" /&gt;
   &lt;p&gt;
    Die Abbildung in Java wird ab hier nicht mehr explizit
    aufgeführt. Für eine Übersicht der Java Schnittstellen
    siehe
    &lt;a
     href="http://java.sun.com/javase/6/docs/api/index.html"&gt;
     Java API Dokumentation
    &lt;/a&gt;
    , Paket
    &lt;code&gt;org.w3c.dom&lt;/code&gt;
    .
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Node - Beispiel
   &lt;/title&gt;
   &lt;p&gt;
    Das komplette Beispiel zur Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
   &lt;/p&gt;
   &lt;listing src="DOMNode.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Element
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle
    &lt;code&gt;Element&lt;/code&gt;
    entspricht einem Element eines XML- oder
    HTML-Dokumentes. Da die Schnittstelle
    &lt;code&gt;Node&lt;/code&gt;
    erweitert wird, können die dort definierte generischen
    Attribute verwendet werden, um beispielsweise die Menge
    von Attributen zu einem Element zu erhalten.
    &lt;br /&gt;
    Des weiteren enthält die Schnittstelle eine Reihe von
    Operationen zum Zugriff auf XML-Elemente.
   &lt;/p&gt;
   &lt;p&gt;Die Schnittstelle versammelt folgende Eigenschaften:&lt;/p&gt;
   &lt;listing
    src="DOMElement.txt"
    line="2-4" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;schemaTypeInfo&lt;/code&gt;
     :
     &lt;br /&gt;
     Die Typinformation (aus einem Schema), die mit
     diesem Element verknüpft ist.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;tagName&lt;/code&gt;
     :
     &lt;br /&gt;
     Der Name des Elements in qualifizierter Form.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Element -
    Operationen
   &lt;/title&gt;
   &lt;p&gt;
    Folgende Operationen sind für die Schnittstelle
    &lt;code&gt;Element&lt;/code&gt;
    definiert:
   &lt;/p&gt;
   &lt;listing
    src="DOMElement.txt"
    line="6-52" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Auffallend ist, daß es jeweils zwei unterschiedliche
     Methoden zum Zugriff auf Attribute gibt (z.B.
     &lt;code&gt;getAttribute&lt;/code&gt;
     und
     &lt;code&gt;getAttributeNode&lt;/code&gt;
     .
     &lt;br /&gt;
     Der Unterschied bei diesem Methoden liegt darin,
     dass mit der einen ein Objekt vom Typ
     &lt;code&gt;Attr&lt;/code&gt;
     erhalten wird, mit der anderen jedoch der
     Attributwert.
    &lt;/li&gt;
    &lt;li&gt;
     Beachtenswert sind auch die drei Methoden zur
     Erstellung eines Attributs vom Typ
     &lt;code&gt;ID&lt;/code&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    DOM - Beispiel: Zugriff auf das Wurzelelement eines
    Dokuments
   &lt;/title&gt;
   &lt;p&gt;
    In diesem Beispiel soll der Einsatz der Operation
    &lt;code&gt;hasAttributes&lt;/code&gt;
    gezeigt werden. Die Methode testet, ob für das gegebene
    Element Attribute existieren.
   &lt;/p&gt;
   &lt;p&gt;
    Zunächst wird mit der Methode
    &lt;code&gt;getDocumentElement&lt;/code&gt;
    auf das Wurzelelement des Dokuments zugegriffen. Diese
    Methode entspricht keiner DOM-Operation, sondern dem
    DOM-Attribut
    &lt;code&gt;documentElement&lt;/code&gt;
    .
    &lt;br /&gt;
    Grund: Java erlaubt in Schnittstellen keine änderbaren
    Attribute. Daher stellt die DOM-Implementierung des JDK
    für diese Attribute eigene Zugriffsmethoden zur
    Verfügung.
   &lt;/p&gt;
   &lt;listing
    src="DOMExample4.java"
    line="12" /&gt;
   &lt;p&gt;
    In einem weiteren Schritt wird mittels
    &lt;code&gt;getTagName()&lt;/code&gt;
    der Name des Wurzelelements ermittelt. Diese
    Java-Methode entspricht dem DOM-Attribut
    &lt;code&gt;tagName&lt;/code&gt;
    .
   &lt;/p&gt;
   &lt;listing
    src="DOMExample4.java"
    line="14" /&gt;
   &lt;p&gt;
    Mit der Methode
    &lt;code&gt;hasAttributes()&lt;/code&gt;
    wird schließlich abgefragt, ob das Element Attribute
    besitzt, und eine entsprechende Ausgabe erzeugt.
   &lt;/p&gt;
   &lt;listing
    src="DOMExample4.java"
    line="16-19" /&gt;
   &lt;p&gt;Das gesamte Listing:&lt;/p&gt;
   &lt;listing src="DOMExample4.java" /&gt;
   &lt;p&gt;
    Angewandt auf die XML-Datei der Projektverwaltung
    liefert das Programm die Ausgabe:
   &lt;/p&gt;
   &lt;listing src="DOMExample4.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - Beispiel: Ein Dokument modifizieren&lt;/title&gt;
   &lt;p&gt;
    Mit DOM kann -- im Gegensatz zu SAX -- ein eingelesenes
    Dokument verändert werden. Das hier diskutierte Beispiel
    demonstriert dies.
   &lt;/p&gt;
   &lt;p&gt;
    Dem Wurzelelement eines Dokuments (das Objekt
    &lt;code&gt;theRootElement&lt;/code&gt;
    vom Typ
    &lt;code&gt;Element&lt;/code&gt;
    ) soll ein Attribut (benannt mit
    &lt;code&gt;myFirstNewAttribute&lt;/code&gt;
    ) hinzugefügt und mit dem Wert
    &lt;code&gt;01&lt;/code&gt;
    belegt werden.
    &lt;br /&gt;
   &lt;/p&gt;
   &lt;listing
    src="DOMExample5.java"
    line="12-20" /&gt;
   &lt;p&gt;
    Zudem soll ein neues Element
    &lt;code&gt;myNewElement&lt;/code&gt;
    als Kindelement des Wurzelelements erzeugt werden.
   &lt;/p&gt;
   &lt;listing
    src="DOMExample5.java"
    line="22-28" /&gt;
   &lt;p&gt;
    Achtung:
    &lt;br /&gt;
    Die Methode
    &lt;code&gt;createElement&lt;/code&gt;
    ist für die Schnittstelle
    &lt;code&gt;document&lt;/code&gt;
    definiert und muß auf dieser aufgerufen werden.
    &lt;br /&gt;
    Das neu erzeugte Element muß mit
    &lt;code&gt;appendChild&lt;/code&gt;
    (von der Schnittstelle
    &lt;code&gt;Element&lt;/code&gt;
    ) an das Wurzelelement angehängt werden.
   &lt;/p&gt;
   &lt;p&gt;
    Hinweis: In früheren JDK-Versionen konnte durch den
    Aufruf der Methode
    &lt;code&gt;String.println&lt;/code&gt;
    ein DOM-Baum in eine Zeichenkettenrepräsentation
    serialisiert und über die Standardausgabe ausgegeben
    werden. Dies ist inzwischen nicht mehr der Fall!
   &lt;/p&gt;
   &lt;p&gt;
    Angewendet auf eine sehr einfache
    &lt;a href="DOMExample5-input.xml"&gt;Eingabedatei&lt;/a&gt;
    mit dem (einzigen) Element
    &lt;code&gt;empty&lt;/code&gt;
    als Wurzelelement ergibt sich folgende Ausgabe:
   &lt;/p&gt;
   &lt;listing src="DOMExample5.output" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - NodeList
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle
    &lt;code&gt;NodeList&lt;/code&gt;
    definiert einen Container zur Aufnahme beliebiger
    Objekte des Typs
    &lt;code&gt;Node&lt;/code&gt;
    . Sie definiert das Attribut
    &lt;code&gt;length&lt;/code&gt;
    , welches zu jedem Zeitpunkt die Anzahl der verwalteten
    Elemente enthält. Der Zugriff auf die verwalteten Knoten
    erfolgt indexsequentiell durch die Methode
    &lt;code&gt;item&lt;/code&gt;
    .
   &lt;/p&gt;
   &lt;listing src="DOMNodeList.txt" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - Beispiel NodeList: Ein Dokument modifizieren
   &lt;/title&gt;
   &lt;p&gt;
    Das Beispiel zeigt die Verwendung der Schnittstelle, um
    festzustellen, wie oft ein als Kommandozeilenparameter
    übergebener Elementname in einem Dokument auftritt.
   &lt;/p&gt;
   &lt;p&gt;
    Die Methode
    &lt;code&gt;getElementsByTagName&lt;/code&gt;
    der Schnittstelle
    &lt;code&gt;Document&lt;/code&gt;
    fügt während der Ausführung alle Auftreten von Elementen
    mit dem gesuchten Namen in die Ergebnismenge ein.
   &lt;/p&gt;
   &lt;listing src="DOMExample6.java" /&gt;
   &lt;p&gt;
    Angewendet auf die XML-Datei der
    &lt;a href="projektverwaltung-erweitert.xml"&gt;
     erweiterte Projektverwaltung
    &lt;/a&gt;
    ergibt die Suche nach Elementen mit dem Namen
    &lt;code&gt;Vorname&lt;/code&gt;
    ...
   &lt;/p&gt;
   &lt;listing src="DOMExample6.bat" /&gt;
   &lt;p&gt;... folgende Ausgabe:&lt;/p&gt;
   &lt;listing src="DOMExample6.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - Beispiel NodeList: Anzahl enthaltener Elemente
    zählen
   &lt;/title&gt;
   &lt;p&gt;
    In diesem Beispiel (aus der Praxis) soll eine
    statistische Aussage getroffen werden:
    &lt;q&gt;
     Wie viele Fehlerspeicher sind für ein Steuergerät in
     einer XML-Datei definiert?
    &lt;/q&gt;
   &lt;/p&gt;
   &lt;p&gt;
    Für die Definition von Diagnosedaten für Steuergeräte
    existiert ein XML-Standard namens
    &lt;em&gt;ODX&lt;/em&gt;
    . In diesem XML-Vokabular werden sogenannte
    &lt;em&gt;Fehlerspeicher&lt;/em&gt;
    und
    &lt;em&gt;Diagnosejobs&lt;/em&gt;
    definiert.
   &lt;/p&gt;
   &lt;p&gt;
    Eine Fehlerspeicher wird in ODX durch ein Element mit
    dem Namen
    &lt;code&gt;DTC&lt;/code&gt;
    definiert. Möchte man wissen, wie viele Fehlerspeicher
    definiert sind, so benötigt man die Anzahl der
    &lt;code&gt;DTC&lt;/code&gt;
    -Elemente.
   &lt;/p&gt;
   &lt;p&gt;
    Diese werden analog zum vorherigen Beispiel durch die
    Methode
    &lt;code&gt;getElementsByTagName&lt;/code&gt;
    in einer Knotenliste gesammelt. Die Länge der
    Knotenliste ergibt die Anzahl der enthaltenen
    &lt;code&gt;DTC&lt;/code&gt;
    -Elemente.
   &lt;/p&gt;
   &lt;listing src="countDTCs.java" /&gt;
   &lt;listing src="countDTCs.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die grundlegenden DOM-Schnittstellen - Attr&lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle
    &lt;code&gt;Attr&lt;/code&gt;
    erweitert Node. Sie steht für ein Attribut eines
    Elements. Objekte vom Typ
    &lt;code&gt;Attr&lt;/code&gt;
    erben von
    &lt;code&gt;Node&lt;/code&gt;
    . Dabei wird
    &lt;code&gt;Node&lt;/code&gt;
    um drei Attribute zur Abbildung der Charakteristika
    eines XML-Attributs erweitert.
   &lt;/p&gt;
   &lt;p&gt;
    DOM betrachtet Attribute eher als Eigenschaften von
    Elementen denn als eigenständige Objekte mit einer
    eigenen Identität. Sie werden in DOM demnach nicht als
    Kindknoten des Elements betrachtet, das sie beschreiben.
    Attribute werden werden von DOM nicht als Teil des
    Dokumentbaums gesehen. Die Eigenschaften
    &lt;code&gt;parentNode&lt;/code&gt;
    ,
    &lt;code&gt;previousSibling&lt;/code&gt;
    und
    &lt;code&gt;nextSibling&lt;/code&gt;
    sind für
    &lt;code&gt;Attr&lt;/code&gt;
    -Objekte nicht definiert und haben den Nullwert.
   &lt;/p&gt;
   &lt;p&gt;
    In DOM werden alle Attributwerte als einfache
    Zeichenketten dargestellt, auch wenn eine DTD oder ein
    Schema sie als einem bestimmten Typ zugehörig (z.B. als
    Token) definiert.
   &lt;/p&gt;
   &lt;listing src="DOMAttr.txt" /&gt;
   &lt;p&gt;
    Die Attribut-spezifischen Eigenschaften werden durch den
    Attributnamen (
    &lt;code&gt;name&lt;/code&gt;
    ) und seinen Wert (
    &lt;code&gt;value&lt;/code&gt;
    ) abgebildet.
    &lt;br /&gt;
    Ferner ist verfügbar, ob es sich um ein im eingelesenen
    Quelldokument auftretendes Attribut handelt (
    &lt;code&gt;specified&lt;/code&gt;
    hat den Wert
    &lt;code&gt;true&lt;/code&gt;
    ), oder durch den Parser der in der DTD oder dem Schema
    festgelegte Vorgabewert geliefert wird.
    &lt;code&gt;schemaTypeInfo&lt;/code&gt;
    liefert Information über den Typ, der mit dem Attribut
    verbunden ist. Einen Verweis auf das umgebende Element
    liefert das Attribut
    &lt;code&gt;ownerElement&lt;/code&gt;
    .
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - Beispiel: Zugriff auf Attributinformation
   &lt;/title&gt;
   &lt;p&gt;
    Im folgenden Codebeispiel sollen verschiedene
    Informationen, die in Form von Attributen vorliegen,
    ermittelt werden. Als Eingabe dient eine um die
    DOCTYPE-Deklaration erweiterte Variante der
    Projektverwaltung.
   &lt;/p&gt;
   &lt;listing src="projektverwaltung2DTD.xml" /&gt;
   &lt;p&gt;
    Zunächst werden alle Elemente des Typs
    &lt;code&gt;Projekt&lt;/code&gt;
    in einer
    &lt;code&gt;NodeList&lt;/code&gt;
    zusammengestellt.
   &lt;/p&gt;
   &lt;listing
    src="DOMExample7.java"
    line="10-16" /&gt;
   &lt;p&gt;
    Danach werden alle Elemente der Knotenmenge durchlaufen,
    und im Falle der Existenz (geprüft mit hasAttributes)
    verschiedene Charakteristika des Attributs ausgegeben.
   &lt;/p&gt;
   &lt;listing
    src="DOMExample7.java"
    line="18-31" /&gt;
   &lt;p&gt;Ein Aufruf ergibt folgendes Ergebnis:&lt;/p&gt;
   &lt;listing src="DOMExample7.output" /&gt;
   &lt;p&gt;
    Die Auswertungen zum ID-Attribut sind direkt aus dem
    XML-Eingabedokument ersichtlich.
   &lt;/p&gt;
   &lt;p&gt;
    Woher jedoch kommen die Werte für das Attribut
    &lt;code&gt;budget&lt;/code&gt;
    (Auflösung mit Taste
    &lt;code&gt;n&lt;/code&gt;
    )?
   &lt;/p&gt;
   &lt;note&gt;
    &lt;p&gt;
     Der XML-Prozessor erhält seine Informationen über
     &lt;code&gt;budget&lt;/code&gt;
     aus der referenzierten Dokument Typ Deklaration. In
     ihr ist das Attribut mit dem Vorgabwert 10.000
     definiert. Dieser Wert wird an die Applikation
     zurückgegeben, wenn keine andere Belegung im
     Dokument gefunden wird. Dies ist für beide
     &lt;code&gt;Projekt&lt;/code&gt;
     -Elemente der Fall. Verfügt das Eingabedokument über
     keine DOCTYPE-Deklaration, so kann diese Information
     nicht ausgewertet werden.
    &lt;/p&gt;
   &lt;/note&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Processing
    Instruction
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle ProcessingInstruction steht für eine
    &lt;code&gt;processing instruction&lt;/code&gt;
    , wie sie in XML verwendet wird, um dem verarbeitenden
    Prozessor Hinweise zur Verarbeitung des XML-Dokuments zu
    übergeben.
    &lt;br /&gt;
    Der Inhalt einer
    &lt;code&gt;processing instruction&lt;/code&gt;
    wird keiner Prüfung unterzogen.
    &lt;br /&gt;
    Die Processing Instruction enthält folgende zwei
    Eigenschaften:
   &lt;/p&gt;
   &lt;listing src="DOMProcessingInstruction.txt" /&gt;
   &lt;p&gt;
    &lt;code&gt;target&lt;/code&gt;
    : Der Name des Prozessors / der Applikation, die die
    Processing Instruction berücksichtigen soll.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;data&lt;/code&gt;
    : der Inhalt der Processing Instruction.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    Die grundlegenden DOM-Schnittstellen - Character Data
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle
    &lt;code&gt;CharacterData&lt;/code&gt;
    erweitert
    &lt;code&gt;Node&lt;/code&gt;
    um eine Reihe von Attributen und Methoden, mit denen auf
    Zeichendaten in DOM zugegriffen werden kann. Es gibt
    kein DOM Objekt, das direkt dieser Schnittstelle
    entspricht. Es handelt sich hierbei vielmehr um eine
    Sammlung von Methoden und Attribute, die ansonsten für
    jedes Objekt, das diese Schnittstelle erweitert (z.B.
    &lt;code&gt;Text&lt;/code&gt;
    , neu definiert werden hätten müssen.
   &lt;/p&gt;
   &lt;listing src="DOMCharacterData.txt" /&gt;
   &lt;p&gt;
    &lt;code&gt;data&lt;/code&gt;
    : Die Zeichendaten des Knotens als
    &lt;code&gt;DOMString&lt;/code&gt;
    Datentyp. The DOM implementation may not put arbitrary
    limits on the amount of data that may be stored in a
    CharacterData node. However, implementation limits may
    mean that the entirety of a node's data may not fit into
    a single DOMString. In such cases, the user may call
    substringData to retrieve the data in appropriately
    sized pieces.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;length&lt;/code&gt;
    : Gibt die Anzahl der 16-bit Einheiten an, die über die
    Methoden
    &lt;code&gt;data&lt;/code&gt;
    und
    &lt;code&gt;substringData&lt;/code&gt;
    verfügbar sind. Leere Zeichenketten liefern den Wert
    &lt;code&gt;0&lt;/code&gt;
    .
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;appendData&lt;/code&gt;
    : dient dazu, den übergebenen String and Ende der Daten
    des Knotens anzuhängen. Bei Erfolg, kann mit
    &lt;code&gt;data&lt;/code&gt;
    auf die so zusammengefügte Zeichenkette zugegriffen
    werden.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;deleteData&lt;/code&gt;
    : Entfernt einen Bereich von 16-bit Einheiten vom
    Knoten.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;insertData&lt;/code&gt;
    : Fügt einen String am angegebenen Ort ein.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;replaceData&lt;/code&gt;
    : Ersetzt die Zeichen am angegebenen Ort durch die
    übergebene Zeichenkette.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;substringData&lt;/code&gt;
    : Liefert einen Teilstring aus dem angegebenen Bereich
    zurück.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Die grundlegenden DOM-Schnittstellen - Text&lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle Text erweitert
    &lt;code&gt;CharacterData&lt;/code&gt;
    . Sie steht für textuellen Inhalt von ELementen oder
    Attributen.
   &lt;/p&gt;
   &lt;p&gt;
    Wenn innerhalb eines Elements kein Markup vorkommt, ist
    der enthaltene Text in einem einzigen Objekt vom Typ
    &lt;code&gt;Text&lt;/code&gt;
    enthalten. Dieses Objekt ist das einzige Kind des
    Elements.
   &lt;/p&gt;
   &lt;p&gt;
    Andernfalls wird das enthaltene Markup analysiert und
    entsprechende Knoten (Elemente, Attribute, Kommentare,
    Text) als Kindknoten des Elements erzeugt.
   &lt;/p&gt;
   &lt;p&gt;
    Zusätzlich zu den in
    &lt;code&gt;CharacterData&lt;/code&gt;
    bereits definierten Attributen und Methoden definiert
    &lt;code&gt;Text&lt;/code&gt;
    folgende:
   &lt;/p&gt;
   &lt;listing src="DOMText.txt" /&gt;
   &lt;p&gt;
    &lt;code&gt;isElementContentWhitespace&lt;/code&gt;
    : Gibt zurück, ob dieser Textkniten Leerzeichen enthält,
    der
    &lt;q&gt;ignoriert&lt;/q&gt;
    werden kann.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;wholeText&lt;/code&gt;
    :Gibt den Text all der Textknoten zurück, die vom
    aktuellen Knoten aus besucht werden können, ohne die
    Grenzen von Elementmarkup, Kommentaren oder Processing
    Instructions zu überschreiten.
    &lt;br /&gt;
   &lt;/p&gt;
   &lt;listing
    src="DOMText.java"
    line="26-27" /&gt;
   &lt;p&gt;
    &lt;code&gt;replaceWholeText&lt;/code&gt;
    : Ersetzt den Text des aktuellen Knotens, der vom
    aktuellen Knoten aus besucht werden kann, ohne die
    Grenzen von Elementmarkup, Kommentaren oder Processing
    Instructions zu überschreiten.
   &lt;/p&gt;
   &lt;listing
    src="DOMText.java"
    line="40" /&gt;
   &lt;p&gt;
    &lt;code&gt;splitText&lt;/code&gt;
    : Spaltet den Knoten an der angegebenen Position in zwei
    Geschwisterknoten auf.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM - Beispiel Textknotenverarbeitung&lt;/title&gt;
   &lt;p&gt;
    Das hier vorgestellte Beispiel versammelt Zugriff auf
    alle vorgestellten Methoden zur Textknotenverarbeitung.
   &lt;/p&gt;
   &lt;p&gt;
    Es extrahiert zunächst alle Paragraphen
    &lt;code&gt;p&lt;/code&gt;
    (in denen üblicherweise Textinhalt steht) aus dem
    Eingabedokument. Die weitere Textverarbeitung findet
    dann aus Gründen der Einfachheit auf dem Inhalt des
    ersten extrahierten Paragraphen statt.
   &lt;/p&gt;
   &lt;p&gt;
    Es werden zuerst einige Statistiken zum textuellen
    Inhalt auf
    &lt;code&gt;stdout&lt;/code&gt;
    ausgegegeben, bevor der Text zum besseren Verständnis
    dieser ermittelten Statistiken zeichenweise ausgegeben
    wird.
   &lt;/p&gt;
   &lt;p&gt;
    Im Anschluß wird der Textinhalt des einen Knotens auf
    zwei Textknoten aufgeteilt, um danach durch neuen Text
    ersetzt zu werden.
   &lt;/p&gt;
   &lt;listing src="DOMText.java" /&gt;
   &lt;p&gt;Angewendet auf folgendes Eingabedokument...&lt;/p&gt;
   &lt;listing src="DOMText.xml" /&gt;
   &lt;p&gt;... ergibt sich folgende Ausgabe:&lt;/p&gt;
   &lt;listing src="DOMText.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM - abschließendes Beispiel - Erzeugen eines Dokuments
    im Hauptspeicher
   &lt;/title&gt;
   &lt;p&gt;
    Das abschließende Beispiel zeigt die Nutzung aller
    vorgestellten Schnittstellen zur Konstruktion eines
    neuen XML-Dokuments.
   &lt;/p&gt;
   &lt;p&gt;
    Folgendes Dokument soll komplett im Hauptspeicher
    erzeugt werden und danach über die Standardausgabe
    ausgegeben werden.
   &lt;/p&gt;
   &lt;listing src="DOMFinalExample.xml" /&gt;
   &lt;p&gt;
    Zuerst wird ein Dokument erzeugt und die Processing
    Instruction als Kindelement an das Dokument hinzugefügt.
   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="12-20" /&gt;
   &lt;p&gt;
    Danach wird das
    &lt;code&gt;html&lt;/code&gt;
    -Element als Kindelement des Dokuments im korrekten
    Namensraum erzeugt sowie die beiden Attribute
    &lt;code&gt;xmlns&lt;/code&gt;
    und
    &lt;code&gt;xmlns:svg&lt;/code&gt;
    hinzugeügt.
   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="22-26" /&gt;
   &lt;p&gt;
    In einem nächsten Schritt werden
    &lt;code&gt;head&lt;/code&gt;
    - und
    &lt;code&gt;title&lt;/code&gt;
    -Element samt textuellem Inhalt erzeugt und an den
    jeweils korrekten Stellen in den Baum eingefügt.
   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="28-35" /&gt;
   &lt;p&gt;
    Analog zum
    &lt;code&gt;head&lt;/code&gt;
    -Element wird das
    &lt;code&gt;body&lt;/code&gt;
    -Element erzeugt und als Kindelement an das
    &lt;code&gt;html&lt;/code&gt;
    -Element angehängt.
   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="37-38" /&gt;
   &lt;p&gt;
    Element
    &lt;code&gt;p&lt;/code&gt;
    sowie dessen Kindelement
    &lt;code&gt;a&lt;/code&gt;
    werden samt textuellem Inhalt erstellt und in die
    Dokumentstruktur eingebunden.
   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="41-47" /&gt;
   &lt;p&gt;
    Schließlich wird das Element
    &lt;code&gt;svg&lt;/code&gt;
    im Namensraum
    &lt;code&gt;http://www.w3.org/2000/svg&lt;/code&gt;
    mit seinen Attributen
    &lt;code&gt;width&lt;/code&gt;
    und
    &lt;code&gt;height&lt;/code&gt;
    sowie dessen Kindelement
    &lt;code&gt;ellipse&lt;/code&gt;
    mit Attributen erzeugt und in den Dokumentbaum
    eingehängt.

   &lt;/p&gt;
   &lt;listing
    src="DOMFinalExample.java"
    line="49-60" /&gt;
   &lt;p&gt;
    In früheren DOM Spezifikationen wurden durch den
    Standard weder lesende Operationen definiert, noch die
    Möglichkeiten zum Schreiben der erstellen
    Objektstrukturen. Die hierfür notwendigen Operationen
    wurden in konkreten Implementierungen durch proprietären
    Code umgesetzt.
    &lt;br /&gt;
    Im vorliegenden Beispiel wurde mit einer früheren
    Implementierung von SUNs JDK die dort vorgeschlagene
    (umständliche) Verfahrensweise genutzt: zur Ausgabe ein
    StreamResult-Objekt als Ergebnis der
    Dokumenttransformation mittels XSLT zu erzeugen. Dies
    funktioniert mit aktuellen JDK-Versionen nicht mehr.
   &lt;/p&gt;
   &lt;p&gt;
    Ein- und Ausgabe sind seit DOM Level 3 wesentlich
    einfacher gestaltet:
    &lt;em&gt;DOM Load and Save&lt;/em&gt;
    .
   &lt;/p&gt;
   &lt;listing src="DOMFinalExample.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Ausgabe mit DOM Level 3: Load and Save&lt;/title&gt;
   &lt;p class="definition"&gt;
    Die Spezifikation
    &lt;em&gt;DOM Level 3: Load and Save&lt;/em&gt;
    definiert eine plattform- und
    programmiersprachenunabhängige Schnittstelle zum Laden
    und Speichern von XML-Dokumenten. Sie beinhaltet das
    dynamische Laden eines Dokumentinhalts in ein DOM
    Dokument und umgekehrt die Serialisierung eines DOM
    Dokumentes in ein XML-Dokument. Softwareentwickler und
    Autoren von Webskripten können hiermit XML-Inhalt sehr
    komfortabel laden und speichern. Auch die Filterung des
    Inhalts während des Ladens und Speicherns ist möglich.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM Load and Save - die Schnittstellen&lt;/title&gt;
   &lt;p&gt;
    Folgende Schnittstellen werden in
    &lt;em&gt;DOM Load and Save&lt;/em&gt;
    definiert
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;DOMImplementationLS&lt;/code&gt;
     &lt;br /&gt;
     Die Schnittstelle entspeicht einer erweiterten
     &lt;code&gt;DOMImplementation&lt;/code&gt;
     Schnittstelle und bringt Fabrikmethoden mit sich, um
     die zum Laden und Speichern nötigen Objekte zu
     erzeugen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSParser&lt;/code&gt;
     &lt;br /&gt;
     Mit dieser Schnittstelle können Daten in DOM
     Dokumente
     &lt;q&gt;geparst&lt;/q&gt;
     werden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSSerializer&lt;/code&gt;
     &lt;br /&gt;
     Dient der Serialisierung von DOM Dokumenten oder
     Knoten.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSParserFilter&lt;/code&gt;
     &lt;br /&gt;
     Während des Parsing-Vorgangs können hiermit Knoten
     untersucht und eventuell entfernt werden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSSerializerFilter&lt;/code&gt;
     &lt;br /&gt;
     Analog zum Filtern während des Einlesens können
     hiermit auch während der Serialisierung Filter auf
     Knoten angewendet werden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSInput&lt;/code&gt;
     &lt;br /&gt;
     Dient der Kapselung der Daten, die geladen werden
     sollen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSOutput&lt;/code&gt;
     &lt;br /&gt;
     Kapselt Information über die Ausgabe der Daten.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSResourceResolver&lt;/code&gt;
     &lt;br /&gt;
     Applikationen können hiermit Referenzen auf externe
     Ressourcen während des Parsens auflösen.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;DOM Load and Save - die Datentypen&lt;/title&gt;
   &lt;p&gt;
    Folgende zu DOM Core zusätzlichen Datentypen werden in
    Load and Save definiert:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;LSInputStream&lt;/code&gt;
     &lt;br /&gt;
     Repräsentiert eine Folge von Eingabebytes, eine
     Bytestream-Quelle eines XML-Eingabedokuments. In
     Java mit
     &lt;code&gt;java.io.InputStream&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSOutputStream&lt;/code&gt;
     &lt;br /&gt;
     Repräsentiert eine Folge von Ausgabebytes, ein Ziel
     für einen Ausgabe-Bytestream in XML. In Java mit
     &lt;code&gt;java.io.OutputStream&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSReader&lt;/code&gt;
     &lt;br /&gt;
     Steht für eine Folge von Eingabezeichen in 16-bit
     Einheiten, in UTF-16 codiert. In Java mit
     &lt;code&gt;java.io.Reader&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;LSWriter&lt;/code&gt;
     &lt;br /&gt;
     Steht für eine Folge von Eingabezeichen in 16-bit
     Einheiten, in UTF-16 codiert. In Java mit
     &lt;code&gt;java.io.Writer&lt;/code&gt;
     abgebildet.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - die grundlegenden Schnittstellen
   &lt;/title&gt;
   &lt;p&gt;
    Die im folgenden besprochenen grundlegenden
    Schnittstellen müssen von zu DOM Load and Save konformen
    Modulen unterstützt werden.
    &lt;br /&gt;
    Sie sind mit der Methode
    &lt;code&gt;hasFeature&lt;/code&gt;
    mit den Parametern
    &lt;q&gt;LS&lt;/q&gt;
    (für
    &lt;em&gt;Load and Save&lt;/em&gt;
    ) und
    &lt;q&gt;3.0&lt;/q&gt;
    (für
    &lt;em&gt;DOM Level 3.0&lt;/em&gt;
    )abfragbar.
   &lt;/p&gt;
   &lt;listing src="DOMExample2.output" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;DOM Load and Save - Fehlerbehandlung&lt;/title&gt;
   &lt;p&gt;
    Während Lese- oder Schreibvorgängen können Fehler
    auftreten, die dazu führen, daß die Verarbeitung nicht
    fortgesetzt werden kann. In diesem Fall tritt ein Fehler
    der Art
    &lt;code&gt;LSException&lt;/code&gt;
    auf. Durch die Abfrage eines Integerwerts kann die Art
    des Fehler noch näher bestimmt werden:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;81 (PARSE_ERR)&lt;/code&gt;
     &lt;br /&gt;
     Trit auf, wenn beim Laden eines Dokuments oder
     XML-Fragments ein Fehler aufgetreten ist und die
     Verarbeitung nicht fortgesetzt werden kann.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;82 (SERIALIZE_ERR)&lt;/code&gt;
     &lt;br /&gt;
     Tritt auf, wenn während des Serialisierens eines
     Knotens ein Fehler aufgetreten ist und die
     Verarbeitung nicht fortgesetzt werden kann.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - die Schnittstelle
    &lt;code&gt;DOMImplementationLS&lt;/code&gt;
   &lt;/title&gt;
   &lt;p&gt;
    &lt;code&gt;DOMImplementationLS&lt;/code&gt;
    enthält die Fabrikmethoden, um Parser, Serializer, sowie
    Input- und Outputobjekte aus
    &lt;em&gt;Load and Save&lt;/em&gt;
    zu erzeugen.
   &lt;/p&gt;
   &lt;listing src="DOMImplementationLS.txt" /&gt;
   &lt;p&gt;
    Eine Instanz dieser Schnittstelle kann durch Aufruf der
    Methode
    &lt;code&gt;DOMImplementation.getFeature("LS", "3.0")&lt;/code&gt;
    erhalten werden (sofern DOM Level 3 Core unterstützt
    wird) , oder alternativ durch
    &lt;em&gt;Casten&lt;/em&gt;
    einer
    &lt;code&gt;DOMImplementation&lt;/code&gt;
    -Instanz.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="14-21" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSParser&lt;/code&gt;
   &lt;/title&gt;
   &lt;p&gt;
    Die Schnittstelle bietet die Möglichkeit, aus
    verschiedenen Eingabequellen einen DOM Baum zu
    erstellen.
    &lt;br /&gt;
   &lt;/p&gt;
   &lt;p&gt;
    Asynchrone LSParser bieten die Möglichkeit, Event
    Listener für Ereignisse zu registrieren. Sie
    implementieren die Schnittstelle
    &lt;code&gt;EventTarget&lt;/code&gt;
    .
    &lt;br /&gt;
    Folgende Ereignisse sind unterstützt:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;load&lt;/code&gt;
     &lt;br /&gt;
     Der Parser hat den Ladevorgang des Dokuments
     abgeschlossen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;progress&lt;/code&gt;
     &lt;br /&gt;
     Der Parser erzeugt Information über den Fortschritt
     beim Verarbeiten der Daten. In welchen Abständen der
     Parser über seinen Fortschritt informiert, und ob
     dies überhaupt geschieht, ist von der
     Implementierung des Parsers abhängig.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSParser - Attribute&lt;/code&gt;
   &lt;/title&gt;
   &lt;listing
    src="LSParser.txt"
    line="1-5" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;domConfig&lt;/code&gt;
     &lt;br /&gt;
     Das DOMConfiguration Objekt, das während der
     Verarbeitung einer Eingabequelle verwendet wird. Es
     ist spezifisch für die jeweilige Verarbeitung und
     unterscheidet sich von dem DOMConfiguration-Objekt
     des Dokuments, das verarbeitet wird.
     &lt;br /&gt;
     Mit DOMConfiguration-Objekten für LSParser können
     spezifische Verhaltensweisen festgelegt werden, wie
     etwa, ob der gültige Zeichensatz eines Dokuments aus
     dem Dokument selbst entnommen wird oder aus dem
     Protokoll, mit dem das Dokument übertragen wurde,
     oder ob Namensräume verarbeitet werden sollen.
     &lt;br /&gt;
     Für Details, siehe
     &lt;a
      href="http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html#LS-LSParser"&gt;
      Abschnitt LSParser in der DOM Spezifikation
     &lt;/a&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;filter&lt;/code&gt;
     &lt;br /&gt;
     Mit einem Filter können beim Einlesen des Dokuments
     bestimmte Elemente "ausgefiltert" werden. Der Filter
     wird vom Parser berücksichtigt, während die
     DOM-Baumstruktur erzeugt wird. Er wird aufgerufen,
     nachdem allgemeine, von der DOMConfiguration
     abhängige Operationen, wie z.B. die Validierung
     eines Dokumentes, abgearbeitet wurden.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;async&lt;/code&gt;
     &lt;br /&gt;
     Zeigt an, ob es sich um einen asynchronen oder
     synchronen LSParser handelt.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;busy&lt;/code&gt;
     &lt;br /&gt;
     Gibt einen Hinweis darauf, ob der Parser gerade
     damit beschäftigt ist, ein Dokument zu laden.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSParser - Operationen&lt;/code&gt;
   &lt;/title&gt;
   &lt;listing
    src="LSParser.txt"
    line="7-18" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;parse&lt;/code&gt;
     &lt;br /&gt;
     Verarbeitet ein XML-Dokument über eine mit
     &lt;code&gt;LSInput&lt;/code&gt;
     identifizierte Ressource. Gibt das erstellte
     &lt;code&gt;Document&lt;/code&gt;
     zurück.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;parseURI&lt;/code&gt;
     &lt;br /&gt;
     Verarbeitet ein XML-Dokument, das an einer durch
     eine URI identifizierte Ressource verfügbar ist.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;abort&lt;/code&gt;
     &lt;br /&gt;
     Bricht die Verarbeitung des aktuellen Dokuments ab.
     Wenn der LSParser gerade nicht beschäftigt ist, hat
     der Aufruf dieser Methode keinerlei Auswirkungen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;parseWithContext&lt;/code&gt;
     &lt;br /&gt;
     Verarbeitet ein XML Fragment, das durch
     &lt;code&gt;LSInput&lt;/code&gt;
     identifiziert wird. Der Inhalt wird in ein
     existierendes Dokument eingefügt, und zwar an der
     Position, die durch das Attribute
     &lt;code&gt;context&lt;/code&gt;
     festgelegt wird. Die Art der Verarbeitung wird durch
     &lt;code&gt;action&lt;/code&gt;
     (
     &lt;code&gt;
      ACTION_APPEND_AS_CHILDREN,
      ACTION_REPLACE_CHILDREN, ACTION_INSERT_BEFORE,
      ACTION_INSERT_AFTER, ACTION_REPLACE
     &lt;/code&gt;
     ) spezifiziert.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Beispiel: Datei per URI einlesen
   &lt;/title&gt;
   &lt;p&gt;
    Zunächst muß mit Hilfe der Methode
    &lt;code&gt;DOMImplementationLS.createLSParser()&lt;/code&gt;
    eine Instanz eines LSParsers erzeugt werden.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="23-24" /&gt;
   &lt;p&gt;
    Mit der Methode
    &lt;code&gt;parseURI&lt;/code&gt;
    kann ein Dokument eingelesen werden, z.B. auch eine
    durch Kommandozeile übergebene Datei.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="25-26" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSInput&lt;/code&gt;
   &lt;/title&gt;
   &lt;p&gt;
    Die andere Alternative, ein Dokument einzulesen, ist
    über die Schnittstelle
    &lt;code&gt;LSInput&lt;/code&gt;
    . Sie repräsentiert eine Eingabequelle für Daten.
   &lt;/p&gt;
   &lt;p&gt;
    Die Schnittstelle kapselt Information über die
    Informationsquelle, z.B. einen Public Identifier, einen
    System Identifier, einen Basis-URI, einen ByteStream
    und/oder einen CharacterStream.
   &lt;/p&gt;
   &lt;p&gt;
    Die Schnittstelle kann erzeugt werden, indem die
    Fabrikmethode
    &lt;code&gt;createLSInput()&lt;/code&gt;
    auf die Schnittstelle
    &lt;code&gt;DOMImplementationLS&lt;/code&gt;
    angewendet wird.
   &lt;/p&gt;
   &lt;p&gt;
    Mit
    &lt;code&gt;LSInput&lt;/code&gt;
    ist ein Parser in der Lage, verschiedene Eingabequellen
    komfortabel einzulesen. Die Engabequellen können durch
    entsprechende
    &lt;code&gt;set&lt;/code&gt;
    - Methoden auf der Schnittstelle angegeben werden. Sie
    werden in der angegebenen Reihenfolge ausgewertet:
   &lt;/p&gt;
   &lt;listing src="LSInput.txt" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;characterStream&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;
      setCharacterStream(Reader characterStream)
     &lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;byteStream&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setByteStream(InputStream byteStream)&lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;stringData&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setStringData(String stringData)&lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;systemId&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setSystemId(String systemId)&lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;publicId&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setPublicId(String publicId)&lt;/code&gt;
     )
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Mit der Methode
    &lt;code&gt;parse(LSInput input)&lt;/code&gt;
    wird schlußendlich die Eingabe durch den Parser
    verarbeitet.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="28-32" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSSerializer&lt;/code&gt;
   &lt;/title&gt;
   &lt;p&gt;
    Der
    &lt;code&gt;LSSerializer&lt;/code&gt;
    dient der Serialisierung (dem Schreiben) eines DOM
    Knotens, typischerweise eines ganzen Dokuments, nach
    XML. Die XML Daten werden dabei entweder in einen String
    oder in einen OutputStream geschrieben. Während der
    Serialisierung werden Namensräume insofern "korrigiert",
    daß der leere Namensraum (der prinzipiell in
    XML-Dokumenten vorkommen darf) nicht ausgegeben wird
    sowie Namensräume nach einem spezifizierten Algorithmus
    auf ihre Konsistenz geprüft und bei Bedarf korrigiert
    werden (vgl. Appendix B.1, "Namespace normalization",
    aus [DOM Level 3 Core]).
   &lt;/p&gt;
   &lt;p&gt;
    Das (konfigurierbare) Standardverhalten eines
    LSSerializers beinhaltet, daß für Dokumentknoten der
    XML-Prolog sowie das gesamte Dokument ausgegeben wird.
    &lt;br /&gt;
    Für Dokumentteilbäume (Knotentyp
    &lt;code&gt;DocumentFragment&lt;/code&gt;
    ) werden alle Kindknoten in der Reihenfolge ihres
    Auftretens ausgegeben.
    &lt;br /&gt;
    Alle anderen Knotentypen werden in ihrer entsprechenden
    XML-Repräsentation ausgegeben.
   &lt;/p&gt;
   &lt;listing src="LSSerializer.txt" /&gt;
   &lt;p&gt;
    Hinweis: Die Serialisierung von Knoten erzeugt nicht
    immer wohlgeformtes XML!
   &lt;/p&gt;
   &lt;p&gt;
    Im nachfolgenden Beispiel werden zwei Serializer für
    zwei Dokumente erzeugt. Dabei wird jeweils der
    Dokumentknoten mit Hilfe der Methode
    &lt;code&gt;writeToString&lt;/code&gt;
    serialisiert. Das erste Dokument wird mit
    &lt;code&gt;System.out.println&lt;/code&gt;
    direkt auf die Standardausgabe ausgegeben. Das zweite
    Dokument wird zunächst in der Variable
    &lt;code&gt;outStr&lt;/code&gt;
    vom Typ
    &lt;code&gt;String&lt;/code&gt;
    gespeichert.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="34-40" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    DOM Load and Save - Die Schnittstelle
    &lt;code&gt;LSOutput&lt;/code&gt;
   &lt;/title&gt;
   &lt;p&gt;
    &lt;code&gt;LSOutput&lt;/code&gt;
    repräsentiert (und kapselt) ein Ausgabeziel für Daten,
    z.B. eine URI, einen ByteStream, eine Basis-URI und/oder
    einen CharacterStream.
   &lt;/p&gt;
   &lt;p&gt;
    Die Schnittstelle kann erzeugt werden, indem die
    Fabrikmethode
    &lt;code&gt;createLSOutput()&lt;/code&gt;
    auf die Schnittstelle
    &lt;code&gt;DOMImplementationLS&lt;/code&gt;
    angewendet wird.
   &lt;/p&gt;
   &lt;p&gt;
    Mit
    &lt;code&gt;LSOutput&lt;/code&gt;
    ist ein Parser in der Lage, verschiedene Ausgabequellen
    komfortabel zu verwenden. Die Ausgabequellen können
    durch entsprechende
    &lt;code&gt;set&lt;/code&gt;
    - Methoden auf der Schnittstelle angegeben werden. Sie
    werden in der angegebenen Reihenfolge ausgewertet:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;characterStream&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;
      setCharacterStream(Writer characterStream)
     &lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;byteStream&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setByteStream(OutputStream byteStream)&lt;/code&gt;
     )
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;systemId&lt;/code&gt;
     &lt;br /&gt;
     (Methode
     &lt;code&gt;setSystemId(String systemId)&lt;/code&gt;
     )
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Im nachfolgenden Codeauszug werden Daten in eine Datei
    ausgegeben. Dazu wird ein
    &lt;code&gt;FileOutputStream&lt;/code&gt;
    erzeugt und dieser durch
    &lt;code&gt;setByteStream&lt;/code&gt;
    mit LSOutput verbunden.
   &lt;/p&gt;
   &lt;listing
    src="DOMImplementationExample.java"
    line="42-46" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;DOM Load and Save - Das komplette Beispiel&lt;/title&gt;
   &lt;p&gt;
    Im nachfolgenden Beispiel ist die Verwendung aller
    Schnittstellen aus DOM Load and Save demonstriert.
   &lt;/p&gt;
   &lt;listing src="DOMImplementationExample.java" /&gt;
   &lt;p&gt;Ein Aufruf des Beispiels ...&lt;/p&gt;
   &lt;listing src="DOMImplementationExample.bat" /&gt;
   &lt;p&gt;
    ... ergibt folgendes Ausgabe auf
    &lt;code&gt;stdout&lt;/code&gt;
    :
   &lt;/p&gt;
   &lt;listing src="DOMImplementationExample.output" /&gt;
   &lt;p&gt;
    Zusätzlich wird die Datei
    &lt;code&gt;DOMImplementationExampleOutput.xml&lt;/code&gt;
    erzeugt und mit dem Inhalt der zweiten eingelesenen
    Datei befüllt.
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;DOM Load and Save - Abschließendes Beispiel&lt;/title&gt;
   &lt;p&gt;
    Das nach DOM LS einführende Beispiel (im Hauptspeicher
    erzeugtes Dokument) soll hier nochmals aufgeführt und
    mit DOM LS ausgegeben werden.
   &lt;/p&gt;
   &lt;listing src="DOMFinalExample_LS.java" /&gt;
   &lt;p&gt;
    Die Ausgabe erfolgt zunächst nach
    &lt;code&gt;stdout&lt;/code&gt;
    sowie in eine Datei.
   &lt;/p&gt;
   &lt;listing src="DOMFinalExample_LS_Output.xml" /&gt;
  &lt;/slide&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende DOM --&gt;

 &lt;presentation id="uebungsaufgabenDOM"&gt;
  &lt;title short="uebungsaufgabenDOM"&gt;
   Übungsaufgaben zum Thema DOM.
  &lt;/title&gt;
  &lt;date&gt;2008-12-01&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;Übungsaufgaben zum Thema DOM.&lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu DOM&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übungsaufgabe zu DOM&lt;/title&gt;
    &lt;p&gt;
     Aufbauend auf die zu SAX ausgearbeitete
     Übungsaufgabe soll hier ebenfalls die ebay Shopping
     API ausgewertet und als HTML-Datei dargestellt
     werden. Einziger Unterschied ist die zu verwendende
     API.
    &lt;/p&gt;
    &lt;p&gt;
     Lesen Sie mit Hilfe der DOM API die HTML-Datei, die
     Sie sich bereits als Rohgerüst überlegt haben, ein.
     Befüllen Sie den so erstellten Dokumentbaum dann mit
     den Ergebnissen der ebay Shopping API.
    &lt;/p&gt;
    &lt;p&gt;
     Das so erhaltene DOM Dokument soll mit Hilfe der DOM
     Load and Save-API in eine (HTML-)Ausgabedatei
     serialisiert werden.
    &lt;/p&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Übungen zu DOM --&gt;


 &lt;!--  XML Pull Parser --&gt;
 &lt;presentation id="XMLPP"&gt;
  &lt;title short="XMLPP"&gt;XML Pull Parser&lt;/title&gt;
  &lt;date&gt;2008-12-01&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.xmlpull.org/"&gt;
    Webseite der XML Pull API
   &lt;/a&gt;
   und
   &lt;a href="http://www.extreme.indiana.edu/xgws/xsoap/xpp/"&gt;
    Webseite der Implementierung XPP3
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   In letzter Zeit hat sich ein weiterer Ansatz zur lesenden
   Verarbeitung von XML-Dokumenten durch Programmiersprachen
   etabliert: die sogenannten
   &lt;em&gt;extrahierenden Parser&lt;/em&gt;
   (engl. pull parser). Ihr Verarbeitungsmodell wurde gezielt
   im Kontrast zu den bisher vorgestellten Mechanismen
   entwickelt.
   &lt;br /&gt;
   SAX und DOM verarbeiten XML-Eingaben, ohne dabei dem
   Anwender den Eingriff in den Fluß der Verarbeitung zu
   gestatten. Der Kontrollfluß wird nicht durch den Code im
   Programm definiert, sondern wird zur Ausführungszeit durch
   die Struktur des verarbeiteten XML-Dokuments bestimmt. Bei
   SAX spiegelt sich dies in der Reihenfolge der durch den
   Parser aufgerufenen Call-back-Routinen wieder, bei DOM sind
   im Verlauf der Baumkonstruktion durch einen Parsers
   keinerlei Eingriffsmöglichkeiten für den Programmierer
   vorgesehen.
   &lt;br /&gt;
   Extrahierende Parser kehren dies Paradigma um. Sie
   definieren eine Schnittstelle um innerhalb des
   Programmflusses aktiv Inhalte eines XML-Dokumentes zu
   extrahieren. Allerdings erfolgt der Zugriff nicht wahlfrei
   (wie es beispielsweise bei Abfragen mit XPath der Fall ist),
   sondern konsekutiv entlang der Reihenfolge der einzelnen
   Primitive im XML-Dokument. Dieses Verhalten ist daher
   weniger mit einer Anfrage, als eher mit dem Vorrücken eines
   Dateizeigers bei linearer Konsumption vergleichbar.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract" /&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Definition extrahierender Parser&lt;/title&gt;
   &lt;p class="definition"&gt;
    Ein extrahierender Parser gestattet dem Programmierer
    die konsekutive lesende Verarbeitung der einzelnen
    Primitive eines XML-Dokuments gemäß der Dokumentordnung.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;extrahierende Parser: Implementierungen&lt;/title&gt;
   &lt;p&gt;
    Gegenwärtig sind Pull-Parser für die Java-Sprachwelt
    verfügbar. Es liegt auch eine Implementierung als
    Bestandteil des Microsoft .NET-Frameworks vor. Jedoch
    konnte sich für diese Art der Verarbeitung noch kein
    allgemein anerkanntes und unterstütztes API
    herausbilden.
   &lt;/p&gt;
   &lt;p&gt;
    Lediglich die
    &lt;em&gt;Common API for XML Pull Parsing (XPP)&lt;/em&gt;
    konnte im Java-Umfeld einige Bedeutung erlangen und ist
    verfügbar. Dieser Schnittstellenvorschlag bildet auch
    die Grundlage eines Standardisierungsansatzes (JSR 173)
    im Rahmen des Java Community Processes: Die
    &lt;em&gt;Streaming API for XML (StAX)&lt;/em&gt;
    .
    &lt;br /&gt;
    Das vorliegende Kapitel stützt sich auf eine
    Implementierung dieser API die unter dem Namen XPP3/MXP1
    &lt;a
     href="http://www.extreme.indiana.edu/xgws/xsoap/xpp/"&gt;
     kostenfrei verfügbar
    &lt;/a&gt;
    ist.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XPP API - Die grundlegenden Schnittstellen&lt;/title&gt;
   &lt;p&gt;
    Das XPP-API definiert zur Verwaltung mindestens die
    folgenden Schnittstellen:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;XmlPullParserFactory&lt;/code&gt;
     : Fabrikklasse zur Erzeugung eines Parsers
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;XmlPullParser&lt;/code&gt;
     : Abstrakte Klasse, die den tatsächlichen Parser
     repräsentiert. Alle konkret instantiierbaren Parser
     erben von dieser Klasse
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;XmlPullException&lt;/code&gt;
     : Generische Ausnahmeklasse zur Signalisierung
     verschiedenster Fehler
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Bereits diese Übersicht zeigt als einen ersten
    wesentlichen Unterschied zu den klassischen
    Parserschnittstellen: Bei der XPP-API wurde Wert auf die
    Standardisierung der Infrastruktur zur Erzeugung des
    Parsers sowie die Darstellung auftretender Fehler
    gelegt.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XPP API - Schnittstellen&lt;/title&gt;
   &lt;p&gt;
    Zur Extraktion der Inhalte eines XML-Dokuments sieht die
    XPP-Schnittstelle folgende durch Instanzen der Klasse
    XmlPullParser umgesetzte Methoden vor:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;getEventType&lt;/code&gt;
     : liefert Aufschluß darüber welche XML-Primitive
     (START_TAG, END_TAG, CONTENT ...) extrahiert wurde
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getLocalName&lt;/code&gt;
     : liefert für Ereignisse des Typs START_TAG und
     END_TAG den lokalen Namen des extrahierten Elements
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getNamespaceUri&lt;/code&gt;
     : liefert die URI des Namensraumes dem das
     extrahierte Element zugeordnet ist
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getPrefix&lt;/code&gt;
     : liefert -- sofern vorhanden -- das
     Namensraum-Präfix des extrahierten Elements
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;readContent&lt;/code&gt;
     : liefert den textuellen Inhalt des extrahierten
     Elements
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributeCount&lt;/code&gt;
     : liefert für Ereignisse des Typs START_TAG die
     Anzahl der für das extrahierte Element definierten
     Attribute
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributeLocalName(int i)&lt;/code&gt;
     : liefert den lokalen Namen des i-ten Attributs für
     Ereignisse des Typs START_TAG
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributeNamespaceUri(int i)&lt;/code&gt;
     : liefert die URI des Namensraumes dem das i-te
     Attribut zugeordnet ist
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributePrefix(int i)&lt;/code&gt;
     : liefert -- sofern vorhanden -- das
     Namensraum-Präfix des i-ten Attributs
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributeType(int i)&lt;/code&gt;
     : liefert -- sofern durch Zugriff auf eine DTD oder
     ein XML-Schema möglich -- den Datentyp des i-ten
     Attributs
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;getAttributeValue(int i)&lt;/code&gt;
     : liefert den Wert des i-ten Attributs
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;
      getAttributeValue(String namespace, String
      localName)
     &lt;/code&gt;
     : liefert den Wert des durch Namen und Namensraum
     bezeichneten Attributs
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XPP API - ein erstes Beispiel&lt;/title&gt;
   &lt;p&gt;
    Der Code des hier vorgestellten Beispiels zeigt die
    Nutzung der XPP-API.
    &lt;br /&gt;
    Zuerst wird eine Parser-Fabrik erzeugt, mit der wiederum
    später der tatsächlichen Parsers erzeugt wird.
   &lt;/p&gt;
   &lt;listing
    src="XPPsimple.java"
    line="11" /&gt;
   &lt;p&gt;
    Diese wird durch Aufruf der Methode
    &lt;code&gt;setNamespaceAware&lt;/code&gt;
    dahingehend parametrisiert, daß die von ihr zur
    Verfügung gestellten Parser in einem Modus konform zur
    Namensraumspezifikation arbeiten.
   &lt;/p&gt;
   &lt;listing
    src="XPPsimple.java"
    line="12" /&gt;
   &lt;p&gt;
    Anschließend wird von der Fabrik eine neue Parserinstanz
    angefordert deren Eingabekanal auf die als
    Kommandozeilenparameter übergebene Datei gelenkt wird.
   &lt;/p&gt;
   &lt;listing
    src="XPPsimple.java"
    line="13-14" /&gt;
   &lt;p&gt;
    Die Extraktion der einzelnen Bestandteile des
    Eingabedokuments vollzieht sich in der Schleife ab Zeile
    17. Dort wird, solange nicht das Ereignis
    &lt;code&gt;END_DOCUMENT&lt;/code&gt;
    gelesen wurde, mittels Aufruf der Methode
    &lt;code&gt;next&lt;/code&gt;
    ein weiteres Ereignis aus dem XML-Eingabestrom
    angefordert.
    &lt;br /&gt;
    Nach Feststellung des Ereignistyps (Zeilen 18 und 20)
    kann eine Verarbeitung der mit dem Ereignis verknüpften
    XML-Primitive erfolgen.

   &lt;/p&gt;
   &lt;listing
    src="XPPsimple.java"
    line="17-22" /&gt;
   &lt;p&gt;Das gesamte Codebeispiel:&lt;/p&gt;
   &lt;listing src="XPPsimple.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XMLPP - unterstützte Ereignistypen&lt;/title&gt;
   &lt;p&gt;
    Einschließlich der im vorherigen Beispiel verwendeten
    Ereignistypen unterstützen XPP-konforme Parser folgende
    Ereignistypen:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;START_DOCUMENT&lt;/code&gt;
     : Beginn eines Dokuments bevor XML-Anteile durch den
     Parser verarbeitet wurden. Dieses Ereignis wird
     nicht durch alle Implementierungen zur Verfügung
     gestellt, da es implizit für den gesamten
     programmiersprachlichen Quellcode vor dem ersten
     Aufruf des XPP-Parsers gilt.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;CDSECT&lt;/code&gt;
     : Markiert das Auftreten einer CDATA-Sektion
     innerhalb des XML-Dokumentes.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;COMMENT&lt;/code&gt;
     : Markiert das Auftreten eines XML-Kommentars
     innerhalb des Eingabedokumentes.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;START_TAG&lt;/code&gt;
     : Markiert durch Extraktion des Start-Tags den
     Beginn eines Elements.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;END_TAG&lt;/code&gt;
     : Markiert durch Extraktion des End-Tags den
     Abschluß eines Elements. Für leere Elemente wird
     dieses Ereignis, unabhängig von der möglicherweise
     genutzten Minimierungssyntax, direkt nach dem
     zugehörigen START_TAG-Ereignis extrahiert.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;ENTITY_REF&lt;/code&gt;
     : Markiert das Auftreten einer Entitätsreferenz.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;IGNORABLE_WHITESPACE&lt;/code&gt;
     : Markiert das Auftreten von Leerraumsymbolen, die
     durch den Parser ohne Informationsverlust überlesen
     werden können.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;PROCESSING_INSTRUCTION&lt;/code&gt;
     : Markiert das Auftreten einer Processing
     Instruction.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;TEXT&lt;/code&gt;
     : Markiert das Auftreten freien Textes als
     Elementinhalt.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;END_DOCUMENT&lt;/code&gt;
     : Markiert das Ende des Dokuments. Nach diesem
     Ereignis können keine Weiteren extrahiert werden.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;
    XMLPP - zweites Beispiel: Zählen der einzelnen
    XML-Primitive
   &lt;/title&gt;
   &lt;p&gt;
    In diesem Beispiel sollen die Auftreten der einzelnen
    XML-Primitive auf der Basis eines extrahierenden Parsers
    gezählt werden. Damit entspricht das Programm einer
    Re-Implementierung des im Kapitel SAX vorgestellten
    Beispiels mit der gleichen Funktionalität.
   &lt;/p&gt;
   &lt;listing src="XPPsample3.java" /&gt;
   &lt;p&gt;
    Insbesondere im Vergleich zum ereignisbasierten Lesen
    unter Nutzung der SAX-Schnittstelle fällt die veränderte
    Umsetzung auf.
    &lt;br /&gt;
    So muß der Gesamtablauf nun nicht mehr in verschiedene
    Methoden aufgespalten werden, die durch den Parser
    aufgerufen werden, sondern kann innerhalb einer Methode
    realisiert werden.
    &lt;br /&gt;
    Aus diesem Grunde kann auch die konzeptionell
    suboptimale Verwendung globaler Variablen unterbleiben.
    &lt;br /&gt;
    Im Code fällt die Initialisierung der Zählvariable
    &lt;code&gt;startDocument&lt;/code&gt;
    mit
    &lt;code&gt;1&lt;/code&gt;
    auf (Zeile 15). Diese wird notwendig, da die verwendete
    Parserimplementierung keine Extraktion von
    &lt;code&gt;START_DOCUMENT&lt;/code&gt;
    leistet. Dieses Ereignis liegt immer implizit vor dem
    Start des Extraktionsvorganges an.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XPP Beispiel 3: Elementhäufigkeit zählen&lt;/title&gt;
   &lt;p&gt;
    Auch dieses Beispiel entspricht funktional einem
    Beispiel des SAX-Kapitels, es zählt die
    Auftretenshäufigkeit der Elemente in einem XML-Dokument.
    Jedoch unterstreicht es -- insbesondere im Vergleich zum
    SAX-basierten Beispiel -- die Natur der
    XPP-Schnittstelle. Im vorliegenden Fall werden durch den
    Parser keine Methodenaufrufe durchgeführt. Die
    Extraktion und Verarbeitung der einzelnen Elemente des
    betrachteten XML-Dokuments liegt ausschließlich in der
    Verantwortung des Programmierers.
   &lt;/p&gt;
   &lt;listing src="XPPsample2.java" /&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XPP - Fehlerbehandlung&lt;/title&gt;
   &lt;p&gt;
    Ausgehend von den vorstehend beschriebenen Ereignistypen
    läßt sich leicht eine Prüfung auf Wohlgeformtheit
    realisieren. Üblicherweise wird dies von allen
    verfügbaren XPP-Implementierungen durchgeführt.
    Allerdings können Verletzungen der grundlegenden
    XML-Strukturierungsregeln auch bei diesem Parsingmodell,
    wie auch für SAX, nicht während eines nach außen
    abgeschlossenen Aufrufs erkannt werden. Stattdessen
    werden diese erst im Verlaufe des Extraktionsvorganges
    offenbar.
   &lt;/p&gt;
   &lt;listing src="XPPsample4.java" /&gt;
   &lt;p&gt;
    Führt man den Code des Beispiels mit einem nicht
    wohlgeformten Dokument als Eingabedokument aus, so
    erzeugt der Parser folgende Ausnahme:
   &lt;/p&gt;
   &lt;listing src="XPPsample4.out" /&gt;
  &lt;/slide&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende XML Pull Parser --&gt;

 &lt;!-- XPath --&gt;
 &lt;presentation id="xpath"&gt;
  &lt;title short="xPath"&gt;Die Lokatorsprache XPath&lt;/title&gt;
  &lt;date&gt;2007-12-10&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/Style/XSL/"&gt;
    W3C Webseite zu XSL
   &lt;/a&gt;
   ,
   &lt;a href="http://www.w3.org/TR/xpath20/"&gt;
    XPath Spezifikation
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   XML strukturiert Daten in einigen wenigen Konstrukten,
   hauptsächlich in Elementen und Attributen. Die Sprache
   &lt;em&gt;XML Path Language (XPath)&lt;/em&gt;
   definiert eine Möglichkeit, wie Teile von XML-Dokumenten für
   die weitere Verarbeitung selektiert werden können. XPath
   wird hauptsächlich von XSL Transformations (XSLT) verwendet,
   aber auch von anderen XML-Sprachen wie etwa XML Schema.
   XPath ist eine sehr kompakte Sprache mit einer Syntax, die
   Pfadausdrücke widerspiegelt, wie sie aus Dateisystemen wohl
   bekannnt sind. Diese Pfadausdrücke sind jedoch generalisiert
   und damit sehr viel mächtiger als die vergleichsweise
   einfachen Pfadausdrücke für Dateisysteme. Aufgrund ihrer
   Verwendung in vielen verschiedenen XML-Sprachen ist XPath
   eine der wichtigsten XML Sprachkomponenten.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract"&gt;&lt;/toc&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;XPath&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;Übersicht&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Zur Extraktion beliebiger Teile eines
      wohl-geformten XML-Dokuments verabschiedete das
      W3C 1999 die Sprache XPath.
     &lt;/li&gt;
     &lt;li&gt;
      Sie bildet eine pfadorientierte Lokatorsprache
      und erlaubt damit das Auffinden von
      Dokumentteilen (einzelnen Elementen, Attributen,
      etc.) durch Pfadausdrücke, die sich an der
      Struktur des XML-Dokuments orientieren.
     &lt;/li&gt;
     &lt;li&gt;
      XPath wurde in erster Linie für die Nutzung in
      Kombination mit der Transformationssprache XSLT
      und den erweiterten Verweisen der Sprache
      XPointer konzipiert.
     &lt;/li&gt;
     &lt;li&gt;
      Die Sprache ist ausschließlich für den lesenden
      Zugriff auf XML-Dokumente ausgelegt.
     &lt;/li&gt;
     &lt;li&gt;
      XPath unterscheidet XML-üblich zwischen Groß-
      und Kleinschreibung. Daher sind Element- und
      Attributnamen unbedingt in der im Dokument
      gewählten Schreibweise anzugeben.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Lokalisierungspfade&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mit Lokalisierungspfaden wird eine Menge von
      Informationsknoten in einem Dokument abstrakt
      beschrieben.
     &lt;/li&gt;
     &lt;li&gt;
      Einfachster Lokalisierungspfad ist der Pfad zur
      Lokalisierung des Wurzelknotens, ausgedrückt
      durch
      &lt;q&gt;
       &lt;code&gt;/&lt;/code&gt;
      &lt;/q&gt;
      . Er liefert für jedes XML-Dokument den
      Wurzelknoten.
      &lt;br /&gt;
      &lt;em&gt;Achtung!&lt;/em&gt;
      : Der Wurzelknoten ist nicht das Wurzelelement
      eines XML-Dokuments, sondern entspricht dem
      Document Information Item des Information Sets.
      Das Wurzelelement als erstes benanntes Element
      des Dokuments wird durch ein Element Information
      Item dargestellt.
     &lt;/li&gt;
     &lt;li&gt;
      Die Navigation zu den einzelnen Elementknoten,
      oder Knotenmengen, wird durch einen Pfadausdruck
      realisiert.
     &lt;/li&gt;
     &lt;li&gt;
      Die
      &lt;em&gt;explizite Navigation&lt;/em&gt;
      erlaubt die Angabe aller zu traversierenden
      Knoten bis hin zu den zu extrahierenden. Hierzu
      werden die Knoten, von der Wurzel absteigend
      durch
      &lt;q&gt;
       &lt;code&gt;/&lt;/code&gt;
      &lt;/q&gt;
      -Symbole separiert, notiert. Der XPath-Ausdruck
      von links nach rechts gelesen spiegelt auch die
      Schritte -- ausgehend vom Wurzelelement des
      Dokuments -- zur Lokalisierung der gesuchten
      Knotenmenge wieder.
     &lt;/li&gt;
    &lt;/ul&gt;

   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein erstes Beispiel&lt;/title&gt;
    &lt;p&gt;
     Grundlage für das erste Beispiel zu XPath ist eine
     erweiterte Version der Projektverwaltung.
    &lt;/p&gt;
    &lt;listing src="erweiterte_projektverwaltung.xml"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das folgende Beispiel zeigt eine solche
      Pfaddefinition am Beispiel der
      Projektverwaltung. Er werden alle
      &lt;code&gt;Vorname&lt;/code&gt;
      n selektiert, die als Kindelemente von
      &lt;code&gt;Person&lt;/code&gt;
      in
      &lt;code&gt;ProjektVerwaltung&lt;/code&gt;
      vorkommen.
     &lt;/li&gt;
     &lt;li&gt;Der XPath Ausdruck&lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-1.xml"
      line="2"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      liefert folgendes Ergebnis
      &lt;listing
       src="xpath-beispiel-1.xml"
       line="3-6"&gt;
      &lt;/listing&gt;
      &lt;em&gt;Anmerkung&lt;/em&gt;
      : Das Resultat ist in XML-Notation dargestellt,
      obwohl genaugenommen eine Knotenmenge des
      Information Sets als Resultat zurückgeliefert
      wird. Die gewählte XML-Darstellung ist hierbei
      nur eine der möglichen Varianten zur
      Ergebnispräsentation.
     &lt;/li&gt;
     &lt;li&gt;
      Die Einzelknoten werden entsprechend ihrer
      Auftrittsreihenfolge im Quelldokument (sog.
      &lt;em&gt;document order&lt;/em&gt;
      ) zurückgegeben.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Freie Lokalisierungsschritte (1/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die expliziten Pfadausdrücke lassen sich in
      beliebiger Länge fortsetzen, jedoch zeigen sie
      fundamentale Schwächen in Puncto Flexibilität.
     &lt;/li&gt;
     &lt;li&gt;
      Wie im Beispiel der XHTML-Verwendung innerhalb
      eines eigenen XML-Dokuments gesehen, kann
      Information desselben Typs (d.h. umschlossen
      durch denselben Tag) verschiedene Elternknoten
      besitzen.
     &lt;/li&gt;
     &lt;li&gt;
      So auch in unserem Beispiel, dort ist die
      &lt;code&gt;Qualifikation&lt;/code&gt;
      auf derselben Baumstufe sowohl unterhalb des
      Elternelements
      &lt;code&gt;em&lt;/code&gt;
      als auch
      &lt;code&gt;u&lt;/code&gt;
      anzutreffen.
     &lt;/li&gt;
     &lt;li&gt;
      Als Lösung erlaubt XPath die Nutzung von
      Platzhaltern statt der expliziten Elementnamen
      innerhalb eines Lokalisierungsschrittes. So
      entstehen freie Lokalisierungsschritte, die alle
      Kindknoten einer im direkt vorhergehenden
      Lokalisierungsschritt selektierten Knotenmenge
      adressieren.
     &lt;/li&gt;
     &lt;li&gt;
      Der nachfolgende XPath-Ausdruck zeigt dies am
      Beispiel des Qualifikationsprofils. Der XPath
      Ausdruck
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-2.xml"
      line="2"&gt;
     &lt;/listing&gt;
     &lt;li&gt;liefert folgendes Ergebnis&lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-2.xml"
      line="3-4"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Der Pfadausdruck liefert die beiden Kindelemente
      &lt;code&gt;Qualifikation&lt;/code&gt;
      -- unabhängig von der Benennung des
      Elternknotens -- die direkt unterhalb des
      Knotens
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      angeordnet sind.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Freie Lokalisierungsschritte (2/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die Ausgabe des letzten Beispiels enthält nicht
      alle Knoten des Typs
      &lt;code&gt;Qualifikation&lt;/code&gt;
      . Der gegebene Pfadausdruck gestattet lediglich
      das Überspringen
      &lt;em&gt;einer&lt;/em&gt;
      Hierarchieebene. Daher wird der hierarchisch
      tieferstehende Qualifikations-Knoten mit Inhalt
      Entwickler nicht lokalisiert.
     &lt;/li&gt;
     &lt;li&gt;
      Die (zunächst naheliegende) Lösung den
      Pfadausdruck zu
      &lt;code&gt;
       /ProjektVerwaltung/Person/Qualifikationsprofil/*/*/Qualifikation
      &lt;/code&gt;
      zu erweitern, liefert jedoch auch nicht das
      gewünschte Resultat aller
      &lt;code&gt;Qualifikation&lt;/code&gt;
      s-Knoten, sondern ausschließlich den zuvor nicht
      lokalisierbaren, da der neue Ausdruck nun
      zwingend
      &lt;em&gt;zwei&lt;/em&gt;
      freie Lokalisierungsschritte vorsieht.
     &lt;/li&gt;
     &lt;li&gt;
      Zur Variierung der Tiefe der freien Schritte
      sieht XPath die Schreibweise
      &lt;q&gt;
       &lt;code&gt;//&lt;/code&gt;
      &lt;/q&gt;
      vor. Sie erlaubt die Lokalisierung der
      Kindknoten auf einer beliebigen Hierarchiestufe.
     &lt;/li&gt;
     &lt;li&gt;
      Das Beispiel zeigt die korrekte
      XPath-Formulierung zur Lokation aller
      Qualifikations-Knoten:
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-3.xml"
      line="2"&gt;
     &lt;/listing&gt;
     &lt;li&gt;liefert folgendes Ergebnis&lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-3.xml"
      line="3-5"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Definition Lokalisierungsschritt&lt;/title&gt;
    &lt;p class="definition"&gt;
     Ein
     &lt;em&gt;Lokalisierungsschritt&lt;/em&gt;
     setzt sich aus dem Namen der
     &lt;code&gt;Achse&lt;/code&gt;
     gefolgt von zwei Doppelpunkten und einem
     &lt;em&gt;Knotentest&lt;/em&gt;
     , optional ergänzt um ein auszuwertendes
     &lt;em&gt;Prädikat&lt;/em&gt;
     , zusammen.
     &lt;br /&gt;
     Wird keine Achse spezifiziert, so gilt vorgabegemäß
     die Achse
     &lt;code&gt;child&lt;/code&gt;
     .
     &lt;br /&gt;
     Ein Knotentest ist syntaktisch ein
     &lt;code&gt;QName&lt;/code&gt;
     , der genau dann erfüllt ist, wenn der Knotenname
     mit dem Namen des Knotentests übereinstimmt.
     &lt;br /&gt;
     Das
     &lt;em&gt;Prädikat&lt;/em&gt;
     filtert die Ergebnismenge hinsichtlich verschiedener
     Charakteristika wie Existenz von Kindknoten oder
     Attributen, Position in der Ergebnismenge, etc.
    &lt;/p&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Achsen in XPath (1/2)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      XPath bietet das Konzept sog.
      &lt;em&gt;Achsen&lt;/em&gt;
      an, um relativ zum aktuellen Knoten beliebige
      Teilbäume zu lokalisieren. Im folgenden werden
      die einzelnen durch Achsen zugänglichen
      Knotenmengen anhand eines
      &lt;a href="xpathEx.xml"&gt;Beispieldokuments&lt;/a&gt;
      gezeigt.
     &lt;/li&gt;
     &lt;li&gt;
      Für die weitere Betrachtung sei
      &lt;em&gt;Knoten 8&lt;/em&gt;
      der aktuelle Knoten, an dem wir uns befinden.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;img
     src="xppartition.gif"
     style="margin : 4%"&gt;
    &lt;/img&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ein XML-Dokument wird grob in die fünf Achsen
      &lt;code&gt;ancestor&lt;/code&gt;
      ,
      &lt;code&gt;descendant&lt;/code&gt;
      ,
      &lt;code&gt;following&lt;/code&gt;
      ,
      &lt;code&gt;preceding&lt;/code&gt;
      und
      &lt;code&gt;self&lt;/code&gt;
      partitioniert (unter Auslassung der Attribut-
      und Namensraumknoten). Diese Knotenmengen
      überschneiden sich nicht und enthalten alle
      Elementknoten des Dokuments.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Achsen in XPath (2/2)&lt;/title&gt;
    &lt;p&gt;
     Für die einzelnen Achsen existieren darüber hinaus
     auch noch Feineinstufungen.
     &lt;br /&gt;
     Die folgende Tabelle listet alle durch die
     Verwendung von Achsen zugänglichen Knotenmengen
     relativ zum aktuellen Knoten (Knoten 8). In der
     letzten Spalte ist die Knotenmenge jeweils graphisch
     dargestellt. der aktuelle Knoten ist jeweils rot
     markiert.
    &lt;/p&gt;
    &lt;table
     border="1"
     width="90%"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th
        style="font-size : small ; line-height : 120%;"&gt;
        Achse
       &lt;/th&gt;
       &lt;th
        style="font-size : small ; line-height : 120%;"&gt;
        Semantik
       &lt;/th&gt;
       &lt;th
        style="font-size : small ; line-height : 120%;"&gt;
        Im Beispiel selektierte Knoten
       &lt;/th&gt;
       &lt;th
        style="font-size : small ; line-height : 120%;"&gt;
        Graphik
       &lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;self&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert den aktuellen Knoten. Als
        abkürzende Schreibweise kann der Punkt
        &lt;q&gt;
         &lt;code&gt;.&lt;/code&gt;
        &lt;/q&gt;
        verwendet werden.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/self::node8
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{8}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpself.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;child&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert die (direkten) Kindknoten
        des aktuellen Knotens.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;/node1/node3/node8/child::*&lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{12, 13, 14}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpchild.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;descendant&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert transitiv alle Kindknoten
        des aktuellen Knotens, außer Attribut-
        und Namensraumknoten.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/descendant::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{12, 13, 14, 15, 16}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpdescendant.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;

      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;descendant-or-self&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert transitiv alle Kindknoten
        des aktuellen Knotens (außer Attribut-
        und Namensraumknoten), sowie den Knoten
        selbst.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/descendant-or-self::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{8, 12, 13, 14, 15, 16}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpdescendantself.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;parent&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert den Elternknoten des
        aktuellen Knotes, falls existent.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/parent::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{3}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpparent.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;ancestor&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert transitiv alle Elternknoten
        des aktuellen Knotes.
        &lt;br /&gt;
        Die
        &lt;code&gt;ancestor&lt;/code&gt;
        -Achse enthält daher immer den
        Wurzelknoten, außer der aktuelle Knoten
        ist es selbst; in diesem Falle liefert
        die Achse die leere Menge.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/ancestor::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{1, 3}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpancestor.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;ancestor-or-self&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert transitiv alle Elternknoten
        des aktuellen Knotes, sowie den
        aktuellen Knoten.
        &lt;br /&gt;
        Diese Achse enthält immer den
        Wurzelknoten des Dokuments.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/ancestor-or-self::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{1, 3, 8}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpancestorself.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;preceding&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert alle dem aktuellen Knoten
        vorausgehenden Knoten, ohne seine
        Vorfahren sowie Attribut- und
        Namensraumknoten.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/preceding::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{2, 5, 6, 7}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xppreceding.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;preceding-sibling&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert die im Dokument vor dem
        aktuellen Knoten auftretenden
        Geschwisterknoten.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/preceding-sibling::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{7}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpprecedingsibling.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;following&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert alle dem aktuellen Knoten
        nachfolgenden Knoten ohne dessen Kind-,
        Attribut und Namensraumknoten.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/following::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{9, 4, 10, 11}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpfollowing.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;following-sibling&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert alle nachfolgenden
        „Geschwister“ des aktuellen Knotens,
        d.h. Knoten auf derselben
        Hierarchieebene.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/following-sibling::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{9}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpfollowingsibling.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;attribute&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert Attribut(e) eines Knotens.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/attribute::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;{Att1}&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpattribute.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;code&gt;namespace&lt;/code&gt;
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        Lokalisiert Namensraum-Attribute eines
        Knotens.
       &lt;/td&gt;
       &lt;td
        style="font-size : small ; line-height : 120%;"&gt;
        &lt;b&gt;XPath-Ausdruck:&lt;/b&gt;
        &lt;br /&gt;
        &lt;code&gt;
         /node1/node3/node8/namespace::*
        &lt;/code&gt;
        &lt;br /&gt;
        &lt;b&gt;Ergebnisknotenmenge&lt;/b&gt;
        :
        &lt;code&gt;
         {xmlns:xml="http://www.w3.org/XML/1998/namespace",
         xmlns:x="namespace:www.jeckle.de/vorlesung/xml"}
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        &lt;img
         src="xpnamespace.gif"
         style="margin : 4% ;"
         width="100%"&gt;
        &lt;/img&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Filtern mit Prädikaten&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es ist möglich, eine Knotenmenge, die mit Hilfe
      eines XPath ermittelt wird, durch Angabe eines
      Prädikats noch weiter einzugrenzen.
     &lt;/li&gt;
     &lt;li&gt;
      Ein Prädikat wird in eckigen Klammern notiert
      und kann bei jedem Lokalisierungsschritt
      angegeben werden. Auf diese Weise können die
      Ergebnismengen stark gefiltert werden.
     &lt;/li&gt;
     &lt;li&gt;
      Das Prädikat kann selbst ein gültiger
      XPath-Ausdruck sein. Ferner können einige
      vordefinierte Funktionen verwendet werden.
     &lt;/li&gt;
     &lt;li&gt;Vorgehen&lt;/li&gt;
     &lt;ol&gt;
      &lt;li&gt;
       Ermittlung der zur Anfrage passenden
       Knotenmenge
      &lt;/li&gt;
      &lt;li&gt;
       Reduzierung der Ergebnismenge um diejenigen
       Knoten, für die das Prädikat nicht zutrifft,
       also
       &lt;code&gt;false&lt;/code&gt;
       liefert.
      &lt;/li&gt;
      &lt;li&gt;
       Befinden sich rechts vom aktuell
       bearbeiteten Lokalisierungsschritt weitere
       Ausdrücke, so wird die Resultatmenge als
       Eingabe eines weiteren Schritts (1)
       übergeben.
      &lt;/li&gt;
     &lt;/ol&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Filtern mit Prädikaten - ein erstes Beispiel
    &lt;/title&gt;
    &lt;p&gt;
     Wird der folgende XPath-Ausdruck auf unser Beispiel
     der Projektverwaltung angewendet...
    &lt;/p&gt;
    &lt;listing
     src="xpath-beispiel-4.xml"
     line="2"&gt;
    &lt;/listing&gt;
    &lt;p&gt;... so erhält man folgendes Ergebnis:&lt;/p&gt;
    &lt;listing
     src="xpath-beispiel-4.xml"
     line="3"&gt;
    &lt;/listing&gt;
    &lt;p&gt;Die einzelnen Schritte im Überblick:&lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Der Ausdruck wählt zunächst alle Knoten des Typs
      &lt;code&gt;Person&lt;/code&gt;
      an beliebiger Stelle des Dokuments („//“) aus.
     &lt;/li&gt;
     &lt;li&gt;
      Diese Knotenmenge wird dann um diejenigen
      Personen vermindert, zu denen kein
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      angelegt ist. Positiv formuliert: es werden nur
      diejenigen Knoten ausgewählt, die über einen
      Kindknoten des Typs
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      verfügen.
     &lt;/li&gt;
     &lt;li&gt;
      Von dieser (reduzierten) Knotenmenge (Achtung:
      des Typs
      &lt;code&gt;Person&lt;/code&gt;
      !) werden dann im zweiten Lokalisierungsschritt
      die Kindknoten des Typs
      &lt;code&gt;Nachname&lt;/code&gt;
      ausgewählt.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     &lt;em&gt;Anmerkung&lt;/em&gt;
     : Das Beispiel nutzt im Prädikat die abkürzende
     Schreibweise zur Angabe der Vorgabeachse
     &lt;code&gt;child&lt;/code&gt;
     . Die ausführliche Schreibweise des XPath-Ausdruckes
     lautet:
     &lt;code&gt;
      //Person[child::Qualifikationsprofil]/Nachname
     &lt;/code&gt;
    &lt;/p&gt;
    &lt;!-- TODO: Dies als Beispiel - Overheadfolie - zum genau nachvollziehen --&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Filtern mit Prädikaten - erweitertes Beispiel
    &lt;/title&gt;
    &lt;p&gt;
     Das folgende Beispiel zeigt die Verwendung von
     Prädikaten bei mehreren Lokalisierungsschritten.
     Folgende Aufgabe soll gelöst werden:
     &lt;br /&gt;
     Auswählen aller
     &lt;code&gt;Vorname&lt;/code&gt;
     n als Kinder von
     &lt;code&gt;Person&lt;/code&gt;
     en-Knoten, deren
     &lt;code&gt;Nachname&lt;/code&gt;
     mit dem Buchstaben
     &lt;code&gt;O&lt;/code&gt;
     beginnt. Weitere Einschränkung: die
     &lt;code&gt;Person&lt;/code&gt;
     en-Knoten müssen ihrerseits Kinder von Knoten des
     Typs
     &lt;code&gt;Projektverwaltung&lt;/code&gt;
     sein.
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Auswählen aller Knoten des Typs
      &lt;code&gt;Person&lt;/code&gt;
      an beliebiger Stelle des Dokuments.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="3"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="4-6"&gt;
     &lt;/listing&gt;

     &lt;li&gt;
      Einschränken der Knotenmenge auf nur diejenigen
      Personen, die Kindelemente von
      &lt;code&gt;Projektverwaltung&lt;/code&gt;
      sind.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="7"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="8-10"&gt;
     &lt;/listing&gt;

     &lt;li&gt;
      Auswählen aller
      &lt;code&gt;Vorname&lt;/code&gt;
      n, die Kindelemente von
      &lt;code&gt;Person&lt;/code&gt;
      sind.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="11"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="12-15"&gt;
     &lt;/listing&gt;

     &lt;li&gt;
      Einschränken der Knotenmenge auf nur diejenigen
      Vornamen, auf die im Dokument ein
      Geschwisterelement
      &lt;code&gt;Nachname&lt;/code&gt;
      folgt.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="16"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="17-20"&gt;
     &lt;/listing&gt;

     &lt;li&gt;
      Verwendung der vordefinierten Funktion
      &lt;code&gt;starts-with&lt;/code&gt;
      zur zusätzlichen Formulierung der Einschränkung,
      daß der Nachname mit dem Buchstaben
      &lt;code&gt;O&lt;/code&gt;
      beginnen muß.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="21"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-5.xml"
      line="22-23"&gt;
     &lt;/listing&gt;

    &lt;/ol&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;In XPath vordefinierte Funktionen (1/5)&lt;/title&gt;
    &lt;p&gt;XPath-Funktionen für Knotenmengen (node-sets)&lt;/p&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Funktionsprototyp&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         last()
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Größe der aktuellen
        Knotenmenge; damit den Index des letzten
        Elements.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         position()
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Position des aktuellen
        Knotens innerhalb der Knotenmenge. Der
        erste Knoten trägt die Positionsnummer
        1.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         count(
         &lt;em&gt;node-set&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Gibt die Anzahl der Elemente der
        übergebenen Knotenmenge zurück.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;node-set&lt;/em&gt;
         id(
         &lt;em&gt;object&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert denjenigen Knoten, dessen
        ID-typisiertes Attribut den Argumentwert
        aufweist.
        &lt;br /&gt;
        Anmerkung: Zur Nutzung dieser Funktion
        muß zwingend eine Dokument-Grammatik
        (DTD oder Schema) zum Eingangsdokument
        vorliegen.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         local-name (
         &lt;em&gt;node-set?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert den lokalen Namen (oder die
        Menge der Namen) der übergebenen
        Knotenmenge. Wird keine Knotenmenge
        übergeben, dann wird der aktuelle Knoten
        als Argument genutzt.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         namespace-uri (
         &lt;em&gt;node-set?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Gibt die Namensraum-URI der übergebenen
        Knotenmenge zurück. Wird keine
        Knotenmenge übergeben, dann wird der
        aktuelle Knoten als Argument genutzt.
        &lt;br /&gt;
        Anmerkung: Handelt es sich nicht um
        einen Element- oder Attributknoten, so
        ist die zurückgegebene Zeichenkette
        leer.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         name (
         &lt;em&gt;node-set?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die qualifizierten Namen
        (gebildet aus Namensraumkürzel und
        lokalem Namen) der übergebenen
        Knotenmenge, oder des aktuellen Knotens
        bei leerer Knotenmenge.
        &lt;br /&gt;
        Anmerkung: Nur für Element- und
        Attributknoten liefert
        &lt;code&gt;name&lt;/code&gt;
        andere Resultate als
        &lt;code&gt;local-name&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;In XPath vordefinierte Funktionen (2/5)&lt;/title&gt;
    &lt;p&gt;XPath-Funktionen für Zeichenketten&lt;/p&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Funktionsprototyp&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         string (
         &lt;em&gt;object?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert Zeichenkettenrepräsentation
        einer Knotenmenge. Dabei wird der
        Zeichenkettenwert des ersten Knotens in
        der Dokumentreihenfolge zurückgegeben,
        andernfalls die leere Zeichenkette.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         concat (
         &lt;em&gt;string&lt;/em&gt;
         ,
         &lt;em&gt;string&lt;/em&gt;
         ,
         &lt;em&gt;string*&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Verkettet mindestens zwei Zeichenketten.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         starts-with (
         &lt;em&gt;string1&lt;/em&gt;
         ,
         &lt;em&gt;string2&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert
        &lt;code&gt;true&lt;/code&gt;
        , falls
        &lt;code&gt;string1&lt;/code&gt;
        das zweite Argument
        &lt;code&gt;string2&lt;/code&gt;
        als Präfix enthält; andernfalls
        &lt;code&gt;false&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         contains (
         &lt;em&gt;string1&lt;/em&gt;
         ,
         &lt;em&gt;string2&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert
        &lt;code&gt;true&lt;/code&gt;
        falls
        &lt;code&gt;string1&lt;/code&gt;
        die Zeichenkette aus
        &lt;code&gt;string2&lt;/code&gt;
        enthält; andernfalls
        &lt;code&gt;false&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         substring-before (
         &lt;em&gt;string1&lt;/em&gt;
         ,
         &lt;em&gt;string2&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert denjenigen Teil der Zeichenkette
        &lt;code&gt;string1&lt;/code&gt;
        , der sich vor dem ersten Auftreten der
        Zeichenkette
        &lt;code&gt;string2&lt;/code&gt;
        befindet.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         substring-after (
         &lt;em&gt;string1&lt;/em&gt;
         ,
         &lt;em&gt;string2&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert denjenigen Teil der Zeichenkette
        &lt;code&gt;string1&lt;/code&gt;
        , der sich nach dem ersten Auftreten der
        Zeichenkette
        &lt;code&gt;string2&lt;/code&gt;
        befindet.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         substring (
         &lt;em&gt;string&lt;/em&gt;
         ,
         &lt;em&gt;number1&lt;/em&gt;
         ,
         &lt;em&gt;number2?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert eine Zeichenkette der Länge
        &lt;code&gt;number2&lt;/code&gt;
        aus
        &lt;code&gt;string&lt;/code&gt;
        , beginnend mit der Position
        &lt;code&gt;number1&lt;/code&gt;
        . Fehlt das dritte Argument, so wird der
        Teilstring bis zum Ende der Zeichenkette
        &lt;code&gt;string&lt;/code&gt;
        zurückgegeben.
        &lt;br /&gt;
        Anmerkung: Das erste Zeichen trägt die
        Indexnummer 1, nicht 0 wie in Java und C
        üblich.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         string-length(
         &lt;em&gt;string?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Länge der übergebenen
        Zeichenkette. Wird kein Argument
        übergeben, so wird die Länge des zuvor
        in eine Zeichenkette konvertierten
        aktuellen Knotens zurückgegeben.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         normalize-space (
         &lt;em&gt;string?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die übergebene Zeichenkette
        unter Entfernung führender, schließender
        und mehrfacher Leerzeichen zurück.
        Ferner werden noch evtl. in der
        Argumentzeichenkette enthaltenen
        Entitätsreferenzen aufgelöst.
        &lt;br /&gt;
        Anmerkung: Der Normalisierungsvorgang
        entspricht damit der
        Attributwertenormalisierung nach
        &lt;a
         href="http://www.w3.org/TR/REC-xml#AVNormalize"&gt;
         Abschnitt 3.3.3 der
         XML-Spezifikation
        &lt;/a&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;string&lt;/em&gt;
         translate (
         &lt;em&gt;string1&lt;/em&gt;
         ,
         &lt;em&gt;string2&lt;/em&gt;
         ,
         &lt;em&gt;string3&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Zeichenkette
        &lt;code&gt;string1&lt;/code&gt;
        , wobei jedes Zeichen aus
        &lt;code&gt;string2&lt;/code&gt;
        durch das Zeichen an derselben Position
        aus
        &lt;code&gt;string3&lt;/code&gt;
        ersetzt wurde.
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;In XPath vordefinierte Funktionen (3/5)&lt;/title&gt;
    &lt;p&gt;Boole'sche XPath-Funktionen&lt;/p&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Funktionsprototyp&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         boolean (
         &lt;em&gt;object&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Boole'sche Repräsentation
        des übergebenen Arguments.
        &lt;br /&gt;
        Hierbei gilt:
        &lt;br /&gt;
        &lt;ul&gt;
         &lt;li&gt;
          Eine Zahl wird genau dann nach
          &lt;code&gt;true&lt;/code&gt;
          konvertiert, wenn sie weder Null
          (unbeachtlich ihres Vorzeichens)
          noch eine nicht darstellbare
          Zahl (
          &lt;code&gt;NaN&lt;/code&gt;
          ) ist.
         &lt;/li&gt;
         &lt;li&gt;
          Eine Knotenmenge ergibt
          &lt;code&gt;true&lt;/code&gt;
          , wenn sie nicht leer ist.
         &lt;/li&gt;
         &lt;li&gt;
          Eine Zeichenkette ergibt
          &lt;code&gt;true&lt;/code&gt;
          , wenn sie nicht leer (d.h.
          Länge größer Null) ist.
         &lt;/li&gt;
         &lt;li&gt;
          Die Konvertierung anderer Typen
          ist typabhängig, und nicht durch
          den Standard festgelegt.
         &lt;/li&gt;
        &lt;/ul&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         not (
         &lt;em&gt;boolean&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;Negiert das übergebene Argument.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         true()
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert statisch den Wert
        &lt;code&gt;true&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         false()
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert statisch den Wert
        &lt;code&gt;false&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;boolean&lt;/em&gt;
         lang (
         &lt;em&gt;string&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert
        &lt;code&gt;true&lt;/code&gt;
        , wenn der aktuelle Knoten ein
        &lt;code&gt;xml:lang&lt;/code&gt;
        -Attribut gemäß der als Argument
        übergebenen Sprache besitzt.
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;In XPath vordefinierte Funktionen (4/5)&lt;/title&gt;
    &lt;p&gt;Zahlenorientierte XPath-Funktionen&lt;/p&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Funktionsprototyp&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         number (
         &lt;em&gt;object?&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Konvertiert ein Objekt in eine Zahl
        gemäß folgender Regeln:
        &lt;br /&gt;
        &lt;ul&gt;
         &lt;li&gt;
          Eine Zeichenkette wird in eine
          Fließkommazahl gemäß IEEE 754
          konvertiert, wenn sie aus einem
          optionalen Leerzeichen, gefolgt
          durch ein optionales
          Minuszeichen, gefolgt von einem
          optionalen Leerzeichen und einer
          Ziffernfolge besteht.
         &lt;/li&gt;
         &lt;li&gt;
          Der Boole'sche Wert
          &lt;code&gt;true&lt;/code&gt;
          wird zu
          &lt;code&gt;1&lt;/code&gt;
          , der Wert
          &lt;code&gt;false&lt;/code&gt;
          zu
          &lt;code&gt;0&lt;/code&gt;
          konvertiert.
         &lt;/li&gt;
         &lt;li&gt;
          Eine Knotenmenge wird zunächst
          in eine Zeichenkette übersetzt,
          und dann gemäß der oben
          definierten Regeln umgesetzt.
         &lt;/li&gt;
         &lt;li&gt;
          Die Konvertierung anderer Typen
          erfolgt typabhängig, und ist
          nicht durch den Standard
          geregelt.
         &lt;/li&gt;
        &lt;/ul&gt;
        Wird kein Argument übergeben, so wird
        stattdessen der aktuelle Knoten als
        einziges Element einer Knotenmenge
        interpretiert.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         sum (
         &lt;em&gt;node-set&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die Summe aller Elemente der
        übergebenen Knotenmenge, die zuvor in
        eine Zahl konvertiert werden.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         floor (
         &lt;em&gt;number&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die größte ganze Zahl, die nicht
        größer als das Argument ist.
        &lt;br /&gt;
        Beispiele:
        &lt;code&gt;floor(7.4)=7&lt;/code&gt;
        ,
        &lt;code&gt;floor(−5)=−5&lt;/code&gt;
        und
        &lt;code&gt;floor(−5.4)=−6&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         ceiling (
         &lt;em&gt;number1&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert die kleinste ganze Zahl, die
        nicht kleiner als das Argument ist.
        &lt;br /&gt;
        Beispiele:
        &lt;code&gt;ceiling(7.4)=8&lt;/code&gt;
        ,
        &lt;code&gt;ceiling(−5)=−5&lt;/code&gt;
        und
        &lt;code&gt;ceiling(−5.4)=−5&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;
         &lt;em&gt;number&lt;/em&gt;
         round (
         &lt;em&gt;number&lt;/em&gt;
         )
        &lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Liefert das Argument auf die nächste
        ganze Zahl gerundet. Gibt es zwei solche
        -- wie bei Nachkommastelle gleich
        &lt;code&gt;0.5&lt;/code&gt;
        immer der Fall -- so wird die größere
        zurückgeliefert.
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;In XPath vordefinierte Funktionen (5/5)&lt;/title&gt;
    &lt;p&gt;Mathematische Operatoren&lt;/p&gt;
    &lt;table border="1"&gt;
     &lt;thead&gt;
      &lt;tr&gt;
       &lt;th&gt;Funktionsprototyp&lt;/th&gt;
       &lt;th&gt;Funktionalität&lt;/th&gt;
      &lt;/tr&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;+&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;Addition&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;-&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Subtraktion
        &lt;br /&gt;
        Anmerkung: Weil XML in Elementnamen den
        Bindestrich erlaubt, muß dieser Operator
        in einem Ausdruck immer durch
        Leerzeichen von den Operanden getrennt
        werden, andernfalls wird der gesamte
        Ausdruck als Name gewertet.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;*&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Multiplikation
        &lt;br /&gt;
        Außer wenn innerhalb von
        XPath-Ausdrücken als Knotentest
        eingesetzt.
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;div&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Division
        &lt;br /&gt;
        Achtung: Das Symbol
        &lt;code&gt;/&lt;/code&gt;
        dient ausschließlich als Trennzeichen
        innerhalb Lokalisierungspfaden!
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;td&gt;
        &lt;code&gt;mod&lt;/code&gt;
       &lt;/td&gt;
       &lt;td&gt;
        Modulo
        &lt;br /&gt;
        Rest einer ganzzahligen Division.
        &lt;br /&gt;
        Beispiel:
        &lt;code&gt;5 mod 2&lt;/code&gt;
        ergibt
        &lt;code&gt;1&lt;/code&gt;
        und
        &lt;code&gt;-5 mod 2&lt;/code&gt;
        ergibt
        &lt;code&gt;-1&lt;/code&gt;
        .
       &lt;/td&gt;
      &lt;/tr&gt;
     &lt;/tbody&gt;
    &lt;/table&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein umfangreiches Beispiel&lt;/title&gt;
    &lt;p&gt;
     Für das nachfolgende umfangreichere Beispiel wird
     die folgende erweiterte Projektverwaltung
     betrachtet:
    &lt;/p&gt;
    &lt;listing src="projektverwaltung-erweitert.xml"&gt;&lt;/listing&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Ein umfangreiches Beispiel&lt;/title&gt;
    &lt;p&gt;
     Folgende Aufgabe soll gelöst werden:
     &lt;br /&gt;
     Welchen Knoten im Dokument lokalisiert folgender
     XPath-Ausdruck:
    &lt;/p&gt;
    &lt;listing
     src="xpath-beispiel-6.xml"
     line="2"&gt;
    &lt;/listing&gt;
    &lt;p&gt;
     Schrittweises Nachverfolgen der einzelnen
     Lokalisierungsschritte und Filterungen:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Auswahl aller
      &lt;code&gt;Person&lt;/code&gt;
      en an beliebiger Stelle des Dokuments:
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="3"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="4-6"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Reduzierung auf diejenigen
      &lt;code&gt;Person&lt;/code&gt;
      en, die genau einen Kindknoten
      &lt;code&gt;Vorname&lt;/code&gt;
      besitzen
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="7"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="8-9"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Navigieren zu den Kindknoten
      &lt;code&gt;Nachname&lt;/code&gt;
      jeder ausgewählten Person
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="10"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="11-12"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Einschränken der soeben ausgewählten Menge von
      &lt;code&gt;Nachname&lt;/code&gt;
      n auf diejenigen, die einen nachfolgenden
      Geschwisterknoten vom Typ
      &lt;code&gt;Geburtsname&lt;/code&gt;
      besitzen.
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="13"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="14"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Einschränken der Menge der
      &lt;code&gt;Nachname&lt;/code&gt;
      n auf diejenigen, die einen nachfolgenden
      Geschwisterknoten vom Typ
      &lt;code&gt;Geburtsname&lt;/code&gt;
      mit einem Attribut namens
      &lt;code&gt;value&lt;/code&gt;
      besitzt (Test auf Existenz!).
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="15"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="16"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Ausgehend vom jedem Knoten der Menge, navigiere
      zum Elternelement vom Typ
      &lt;code&gt;Person&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="17"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="18"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Für jeden Knoten vom Typ
      &lt;code&gt;Person&lt;/code&gt;
      der eben selektierten Menge, navigiere zum
      Attributknoten
      &lt;code&gt;mitarbeitInProjekt&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="19"&gt;
     &lt;/listing&gt;
     &lt;listing
      src="xpath-beispiel-6.xml"
      line="20"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Der XPath-Ausdruck lokalisiert den Attributknoten
     &lt;code&gt;mitarbeitInProjekt&lt;/code&gt;
     von Person 3 mit dem Wert
     &lt;code&gt;Prj02&lt;/code&gt;
     .
    &lt;/p&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XPath - Übungen&lt;/title&gt;
    &lt;p&gt;
     Welches Ergebnis liefern folgende XPath-Ausdrücke?
    &lt;/p&gt;
    &lt;listing
     src="xpath-uebungen.xml"
     line="2"&gt;
    &lt;/listing&gt;
    &lt;note&gt;
     &lt;listing
      src="xpath-uebungen.xml"
      line="3-5"&gt;
     &lt;/listing&gt;
    &lt;/note&gt;
    &lt;listing
     src="xpath-uebungen.xml"
     line="6"&gt;
    &lt;/listing&gt;
    &lt;note&gt;
     &lt;listing
      src="xpath-uebungen.xml"
      line="7"&gt;
     &lt;/listing&gt;
    &lt;/note&gt;
    &lt;listing
     src="xpath-uebungen.xml"
     line="8"&gt;
    &lt;/listing&gt;
    &lt;note&gt;
     &lt;listing
      src="xpath-uebungen.xml"
      line="9"&gt;
     &lt;/listing&gt;
    &lt;/note&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Anwendungsbeispiel: Integritätsbedingungen in
     XML-Schema (1/4)
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die bei der Diskussion des
      Referenzierungsmechanismus für DTDs
      &lt;a
       href="file:///F:/bsz/webseite/onlineversion/vorlesung/dtd.html#(16)"&gt;
       geäußerte Kritik
      &lt;/a&gt;
      gilt prinzipiell auch für die Verwendung von
      XML-Schema, da die Bedeutung der
      &lt;code&gt;ID&lt;/code&gt;
      und
      &lt;code&gt;IDREF&lt;/code&gt;
      ,
      &lt;code&gt;IDREFS&lt;/code&gt;
      -Konstrukte aus der DTD in Schema übernommen
      wurden (Gültigkeit von Referenzen auf das
      aktuelle Dokument beschränkt, damit sind
      dokumentweit eindeutige Bezeichner notwendig).
     &lt;/li&gt;
     &lt;li&gt;
      Allerdings bietet XML-Schema eine Möglichkeit,
      eindeutige Wertbelegungen zu definieren: das
      &lt;code&gt;unique&lt;/code&gt;
      -Element.
     &lt;/li&gt;
     &lt;li&gt;
      Dieser Mechanismus verwendet XPath-Ausdrücke zur
      Festlegung der Knotenmenge, auf die sich die
      Einschränkung bezieht (
      &lt;code&gt;selector&lt;/code&gt;
      ), und zur Angabe der eingeschränkten Knoten (
      &lt;code&gt;field&lt;/code&gt;
      ) selbst.
     &lt;/li&gt;
     &lt;listing
      src="schema-unique.xml"
      line="2-6"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Einschränkung für das
      &lt;code&gt;selector&lt;/code&gt;
      -Element: es sind hier nur Ausdrücke erlaubt,
      die Kindelemente des Knotens liefern, in dessen
      Kontext die Einschränkung mittels des
      &lt;code&gt;unique&lt;/code&gt;
      -Elements angegeben wird.
     &lt;/li&gt;
     &lt;li&gt;
      Die Lokationsausdrücke in den
      &lt;code&gt;field&lt;/code&gt;
      -Elementen werden relativ zum Pfad des
      &lt;code&gt;selector&lt;/code&gt;
      -Knotens interpretiert.
     &lt;/li&gt;
     &lt;li&gt;
      Hintereinandergesetzt muß der Pfad eines
      &lt;code&gt;selector&lt;/code&gt;
      -Elements, gefolgt von einem Pfad eines
      &lt;code&gt;field&lt;/code&gt;
      -Elements, einen gültigen Lokationsausdruck
      ergeben, der genau einen Knoten oder genau ein
      Attribut in der Ergebnismenge liefert.
     &lt;/li&gt;
     &lt;li&gt;
      Sind mehrere
      &lt;code&gt;field&lt;/code&gt;
      -Elemente zu einem
      &lt;code&gt;selector&lt;/code&gt;
      -Element gegeben, so werden diese als durch
      logisches und verknüpft interpretiert.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Anwendungsbeispiel XML-Schema: Unique-Einschränkung
     (2/4)
    &lt;/title&gt;
    &lt;p&gt;
     Im folgenden Beispiel wird das
     &lt;code&gt;unique&lt;/code&gt;
     -Element verwendet, um zu formulieren, daß das
     Attribut
     &lt;code&gt;PersID&lt;/code&gt;
     des Elements
     &lt;code&gt;Person&lt;/code&gt;
     eindeutig sein muß (dies entspricht -- noch -- der
     bisherigen ID-Typisierung).
    &lt;/p&gt;
    &lt;listing src="XSDUniqueness.xsd"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Der Pfad
      &lt;code&gt;/Person&lt;/code&gt;
      wählt zunächst alle Knoten des gleichnamigen
      Typs aus.
     &lt;/li&gt;
     &lt;li&gt;
      Das
      &lt;code&gt;field&lt;/code&gt;
      -Element wendet die Eindeutigkeitsbedingung auf
      alle Attribut-Kindnoten des Typs
      &lt;code&gt;PersID&lt;/code&gt;
      der Knoten in der selektierten Knotenmenge (
      &lt;code&gt;/Person&lt;/code&gt;
      ) an.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Anwendungsbeispiel XML-Schema: Zusammengesetzter
     Schlüssel innerhalb eines unique-Elements (3/4)
    &lt;/title&gt;
    &lt;p&gt;
     Das nächste Beispiel zeigt die Verwendung
     &lt;u&gt;mehrerer&lt;/u&gt;
     &lt;code&gt;field&lt;/code&gt;
     -
     &lt;u&gt;Elemente&lt;/u&gt;
     zur Realisierung zusammengesetzter Schlüssel.
    &lt;/p&gt;
    &lt;listing src="concatKey.xsd"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Die Kombination aus dem Inhalt des
      &lt;code&gt;Nachname&lt;/code&gt;
      n- und des
      &lt;code&gt;Vorname&lt;/code&gt;
      n-Elements zusammen wird als eindeutig
      deklariert.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Anwendungsbeispiel XML-Schema: Referenzierung,
     Einschränkung der Referenzmenge (4/4)
    &lt;/title&gt;
    &lt;p&gt;
     Mit Hilfe der XML-Schema-Elemente
     &lt;code&gt;key&lt;/code&gt;
     und
     &lt;code&gt;keyref&lt;/code&gt;
     ist es möglich, Referenzen auf bestimmte
     Referenzmengen einzuschränken. Hiermit kann
     sichergestellt werden, daß als Werte eines Attributs
     &lt;code&gt;mitarbeitInProjekt&lt;/code&gt;
     auch wirklich nur auf Schlüssel verwiesen werden
     kann, die für ein Projekt definiert wurden. Damit
     ist es im Gegensatz zu DTDs nicht mehr möglich, an
     dieser Stelle auf IDs von Personen zu verweisen.
    &lt;/p&gt;
    &lt;listing src="keybasedRef.xml"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Der mit
      &lt;code&gt;projectKey&lt;/code&gt;
      benannte Schlüssel (
      &lt;code&gt;key&lt;/code&gt;
      ) definiert die Referenzmenge als das Ergebnis
      der XPath-Ausdruckes
      &lt;code&gt;Projekt/@ID&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Hierauf nimmt die Referenz namens
      &lt;code&gt;projectReference&lt;/code&gt;
      mittels
      &lt;code&gt;refer="projectKey"&lt;/code&gt;
      Bezug. In einer durch
      &lt;code&gt;keyref&lt;/code&gt;
      lokalisierten Knotenmenge dürfen ausschließlich
      Elemente der Referenzmenge enthalten sein.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Vorteile gegenüber
     &lt;code&gt;ID/IDREF&lt;/code&gt;
    &lt;/title&gt;
    &lt;p&gt;
     Zusammenfassend lassen sich folgende Vorteile
     gegenüber dem
     &lt;code&gt;ID/IDREF&lt;/code&gt;
     -Mechanismus festhalten:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;Zusammengesetzte Schlüssel möglich.&lt;/li&gt;
     &lt;li&gt;
      Neben Attributen können auch Elemente und ihre
      Inhalte Beschränkungen unterworfen werden.
     &lt;/li&gt;
     &lt;li&gt;
      Eindeutigkeitsbeschränkungen sind auf
      Gültigkeitsbereich des definierenden Elements
      beschränkt.
     &lt;/li&gt;
     &lt;li&gt;
      Schlüsselbestandteile müssen im XML-Dokument
      zwingend mit Werten (ungleich nil) belegt sein.
     &lt;/li&gt;
     &lt;li&gt;Einschränkung der Referenzmenge möglich.&lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!-- Ende XPath --&gt;

 &lt;!-- Uebungsaufgaben zu XPath --&gt;
 &lt;presentation id="uebungsaufgabenXPath"&gt;
  &lt;title short="uebungsaufgabenXPath"&gt;
   Übungsaufgaben zum Thema XPath.
  &lt;/title&gt;
  &lt;date&gt;2008-12-08&lt;/date&gt;
  &lt;toc id="resources" /&gt;
  &lt;toc id="abstract"&gt;Übungsaufgaben zum Thema XPath.&lt;/toc&gt;
  &lt;part&gt;
   &lt;title&gt;Übungsaufgaben zu XPath&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;XPath Übungsaufgabe 1: XMLBooks&lt;/title&gt;
    &lt;p&gt;
     Formulieren Sie zu untenstehendem XML-Dokument
     XPath-Anfragen, die die geforderten Knotenmengen aus
     dem Dokument extrahieren.
     &lt;br /&gt;
     Sie benötigen hierzu die XPath-Funktionen
     &lt;code&gt;boolean: contains(value,substring)&lt;/code&gt;
     und
     &lt;code&gt;number : count(nodeset)&lt;/code&gt;
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Geben Sie den XPath-Ausdruck an, der alle Bücher
      die im Vereinigten Königreich (UK) erschienen
      sind, lokalisiert.
     &lt;/li&gt;
     &lt;li&gt;
      Geben Sie einen XPath-Ausdruck an, der die Titel
      aller Bücher lokalisiert, die durch mehr als
      einen Autor geschrieben wurden.
     &lt;/li&gt;
     &lt;li&gt;
      Welche(n) Knoten lokalisiert der Ausdruck
      &lt;code&gt;
       /XMLBooks/book[(position() div 2) = 1]
      &lt;/code&gt;
      ?
     &lt;/li&gt;
     &lt;li&gt;
      Welche(n) Knoten lokalisiert der Ausdruck
      &lt;code&gt;
       //book[authors/author[.='W. Scott
       Means']]/title
      &lt;/code&gt;
      ?
     &lt;/li&gt;
    &lt;/ol&gt;
    &lt;listing src="XMLBooks.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;XPath Übungsaufgabe 2: Stammbaum&lt;/title&gt;
    &lt;p&gt;
     Formulieren Sie zu untenstehendem XML-Dokument
     XPath-Anfragen, die die geforderten Knotenmengen aus
     dem Dokument extrahieren.
     &lt;br /&gt;
     Sie benötigen hierzu die XPath-Funktionen
     &lt;code&gt;substring(string,start,end)&lt;/code&gt;
     .
     &lt;br /&gt;
     &lt;code&gt;string&lt;/code&gt;
     entspricht der zu verarbeitenden Zeichenkette,
     &lt;code&gt;start&lt;/code&gt;
     der Startposition und
     &lt;code&gt;end&lt;/code&gt;
     der Endposition.
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Lokalisieren Sie den Namen desjenigen
      Herrschers, der ab 1509 regierte.
     &lt;/li&gt;
     &lt;li&gt;
      Extrahieren Sie die Sterbejahre aller Herrscher
      namens Heinrich (verwenden Sie hierzu die
      &lt;code&gt;substring&lt;/code&gt;
      -Funktion).
     &lt;/li&gt;
     &lt;li&gt;
      Lokalisieren Sie den Personen-Knoten derjenigen
      Herrscher, die zwischen 1550 und 1640 gekrönt
      wurden und die gleichzeitig Nachfahren Heinrich
      VIII. sind.
     &lt;/li&gt;
    &lt;/ol&gt;
    &lt;listing src="Stammbaum.xml" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;XPath Übungsaufgabe 3: Stammbaum v2&lt;/title&gt;
    &lt;p&gt;
     Formulieren Sie zu untenstehendem XML-Dokument
     XPath-Anfragen, die die geforderten Knotenmengen aus
     dem Dokument extrahieren.
    &lt;/p&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Lokalisieren Sie die erfaßten Kinder von
      Friedrich Wilhelm I.
     &lt;/li&gt;
     &lt;li&gt;
      Extrahieren Sie die Namen der drei Herrscher des
      „Dreikaiserjahres“ 1888.
     &lt;/li&gt;
    &lt;/ol&gt;
    &lt;listing src="Stammbaum2.xml" /&gt;
   &lt;/slide&gt;
  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!--  Ende Übungen zu XPath--&gt;


 &lt;!-- Web Services --&gt;
 &lt;presentation id="soa-webservices"&gt;
  &lt;title short="soa-webservices"&gt;
   Web Services / Service-orientierte Architekturen
  &lt;/title&gt;
  &lt;date&gt;2008-12-22&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/2002/ws/"&gt;
    W3C Webseite zu Web Services
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Unter einem Web-Service versteht man zunächst eine
   Dienstleistung im klassischen Sinne (mit Merkmalen wie
   Immaterialität und damit nicht-Lagerfähigkeit,
   standortunabhängiger Produktion und der mangelnden
   Entkopplung von Erzeugung und Konsumption), die über das
   World Wide Web erbracht wird.
   &lt;br /&gt;
   Die einzigen hierbei verbindlich benötigten Standards sind
   die namensgebenden Web-Techniken. Hierzu gehören in erster
   Linie die physischen Hardwareinfrastrukturen sowie die
   benötigten Internet-Protokolle, z.B. TCP/IP.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract"&gt;&lt;/toc&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Einige Definitionsversuche&lt;/title&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;b&gt;IBM und Unisys&lt;/b&gt;
     &lt;br /&gt;
     Web Services are a new, standards-based approach to
     build integrated applications that run across an
     intranet, extranet, or the Internet. The approach
     represents a major evolution in how systems connect
     and interact with each other.
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;
      CWM Web Services Specification, OMG-Dokument
      ad/2001-10-07
     &lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;Frankfurter Allgemeine Zeitung&lt;/b&gt;
     &lt;br /&gt;
     Web Services sind Softwarebausteine, die Programme,
     die auf unterschiedlichen Netzwerkrechnern laufen,
     über das Internet zu einer Anwendung miteinenader
     verknüpfen.
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;F.A.Z. vom 14. Oktober 2003, S. 18&lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;Java Web Services&lt;/b&gt;
     &lt;br /&gt;
     A Web Service is a piece of business logic, located
     somewhere on the Internet, that is accessible
     through standard-based Internet protocols such as
     SMTP or HTTP.
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;
      &lt;a
       href="http://www.oreilly.com/catalog/javawebserv/"&gt;
       Java Web Services
      &lt;/a&gt;
      , S. 1
     &lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;
      Loosely Coupled - The Missing Pieces of Web
      Services
     &lt;/b&gt;
     &lt;br /&gt;
     A Web Service is nothing more than an application
     which other applications can communicate via a
     network, most often using XML.
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;
      &lt;a
       href="http://www.rds.com/books/looselyCoupled/index.html"&gt;
       Loosely Coupled
      &lt;/a&gt;
      , S. 26
     &lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;
      World Wide Web Consortium (Web Service
      Architecture Working Group)
     &lt;/b&gt;
     &lt;br /&gt;
     A Web service is a software system designed to
     support interoperable machine-to-machine interaction
     over a network. It has an interface described in a
     machine-processable format (specifically WSDL).
     Other systems interact with the Web service in a
     manner prescribed by its description using SOAP
     messages, typically conveyed using HTTP with an XML
     serialization in conjunction with other Web-related
     standards.
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;
      &lt;a
       href="http://www.w3.org/TR/2004/NOTE-ws-arch-20040211/"&gt;
       Web Services Architecture (W3C Working Group
       Note, 11 February 2004)
      &lt;/a&gt;
     &lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;Wrox Press: Professional Web Services&lt;/b&gt;
     &lt;br /&gt;
     Web Services are modular, self-describing
     applications that can be published, located and
     invoked from just about anywhere on the Web or a
     local network. The provider and the consumer of the
     XML Web service do not have to worry about operating
     system, language, environment, or component model
     used to create or access the XML Web service, as
     they are based on ubiquitous and open Internet
     standards, such as XML, HTTP, and SMTP.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;IBM&lt;/b&gt;
     &lt;br /&gt;
     Web services are technologies that allow
     applications to communicate with each other in a
     platform- and programming language-independent
     manner. A Web service is a software interface that
     describes a collection of operations that can be
     accessed over the network through standardized XML
     messaging. It uses protocols based on the XML
     language to describe an operation to execute or data
     to exchange with another Web service. A group of Web
     services interacting together in this manner defines
     a particular Web service application in a
     Service-Oriented Architecture (SOA).
     &lt;br /&gt;
     Quelle:
     &lt;em&gt;
      &lt;a
       href="http://www.alphaworks.ibm.com/webservices/newto"&gt;
       New to SOA and Web services
      &lt;/a&gt;
     &lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;SUN&lt;/b&gt;
     &lt;br /&gt;
     A Web service is, simply put, application
     functionality made available on the World Wide Web.
     A Web service consists of a network-accessible
     service, plus a formal description of how to connect
     to and use the service. The language for formal
     description of a Web service is an application of
     XML. A Web service description defines a contract
     for how another system can access the service for
     data, or in order to get something done. Development
     tools, or even autonomous software agents, can
     automatically discover and bind existing Web
     services into new applications, based on the
     description of the service.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;b&gt;Microsoft&lt;/b&gt;
     &lt;br /&gt;
     A Web Service is a unit of application logic
     providing data and services to other applications.
     Applications access Web Services via ubiquitous Web
     protocols and data formats such as HTTP, XML, and
     SOAP, with no need to worry about how each Web
     Service is implemented. Web Services combine the
     best aspects of component-based development and the
     Web, and are a cornerstone of the Microsoft .NET
     programming model.
    &lt;/li&gt;

    &lt;li&gt;
     &lt;b&gt;Gartner Group&lt;/b&gt;
     &lt;br /&gt;
     Web services are loosely coupled software components
     delivered over Internet standard technologies. A Web
     service represents a business function or a business
     service and can be accessed by another application -
     e.g., a client, a server or another Web service -
     over public networks using generally available
     protocols and transport, i.e., SOAP over HTTP. It
     can also be accessed directly by a user through a
     client interface. This business service can be
     implemented as a stand-alone application or as a
     series of applications linked together by an
     application integration infrastructure. From the
     point of view of the calling application, the Web
     service is a modular entity that delivers services
     on demand through a well-defined programmatic
     interface. In effect, Web services comprise the
     overall capability of finding and running programs
     across the Internet - much in the way that software
     programs run on a PC. As such, Web services will
     eventually act as a quasi-Internet "operating
     system" and use protocols to link and manage an
     array of Internet-connected servers, PCs, appliances
     and wireless devices. The underlying business goal
     of Web services is to enable enterprises to focus on
     their core competencies while outsourcing all other
     functions. Web services would be the "tap" to turn
     on to access, deploy and manage such essential
     outsourced functions as credit authorization,
     just-in-time productivity applications and
     quality-of-service monitoring. Recent e-business
     trends have included a movement toward outsourcing
     applications and hosting systems through service
     providers. Web services allow the delivery of core
     business competencies in the form of software
     processes accessible in a given value chain. This
     allows each member of the chain to produce and
     consume business services without the need for an
     intermediary such as an application service provider
     (ASP). In essence, each enterprises takes on the
     task of being both a service consumer and a service
     producer. Through 2004, the primary competitive
     value derived from Web services will be the delivery
     of core business competencies directly into trading
     communities rather than through an intermediate
     service provider (0.7 probability).
    &lt;/li&gt;


   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;Was ist ein Web-Service?&lt;/title&gt;
   &lt;img
    style="margin : 4% ; width : 40% ; "
    src="WsDef.gif" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;em&gt;über das Web erbrachte Dienstleistungen&lt;/em&gt;
     &lt;br /&gt;
     Ein Webservice ist eine Dienstleistung im
     klassischen Sinne (Immateriell, nicht lagerfähig,
     standortunabhängige Produktion), die über das World
     Wide Web erbracht wird.
     &lt;br /&gt;
     Web-Techniken sind hierbei verbindlich benötigte
     Standards (z.B. TCP/IP).
    &lt;/li&gt;
    &lt;li&gt;
     Darauf aufsetzende Stufen erhöhen Schritt für
     Schritt die Interoperabilität Hiermit wird
     Austauschbarkeit eines Dienstes für den Verbraucher
     hergestellt.
    &lt;/li&gt;
    &lt;li&gt;
     XML ermöglicht interoperable, vereinheitlichte
     Darstellung
     &lt;ul&gt;
      &lt;li&gt;des Inhalts einer Dienstleistung&lt;/li&gt;
      &lt;li&gt;
       der Formulierung einer Dienstanforderung
      &lt;/li&gt;
      &lt;li&gt;der Rückübermittlung eines Ergebnisses&lt;/li&gt;
     &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;
      Abgestimmte Inhalte in einem abgestimmten Format
     &lt;/em&gt;
     &lt;br /&gt;
     Eine vereinheitlichte Inhaltsdarstellungen ist auch
     mit anderen Formaten, wie etwa ASN.1 oder EDI (siehe
     Graphik) erreichbar. Allerdings liegt der
     XML-Einsatz von XML nahe, da es weit verbreitet ist
     und damit durch Werkzeuge und Tools breit
     unterstützt wird.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;Standardisierte Kommunikationsmechanismen&lt;/em&gt;
     &lt;br /&gt;
     Zusätzlich zu den Inhalten liegt es nahe, daß auch
     der Kommunikationsprozesses, also der Ablauf der
     daran beteiligten Interaktionen, standardisiert
     wird. Eine Möglichkeit hierzu sind die bekannten
     Remote Procedure Calls (RPC). Wird XML als
     Inhaltsformat gewählt, liegen Ansätze wie XML-RPC
     und dessen Weiterentwicklung, SOAP, auf der Hand.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;
      Beschreibung der Natur der angebotenen Leistung
     &lt;/em&gt;
     &lt;br /&gt;
     Beschreibungssprachen wie die Web Service
     Description Language (WSDL) helfen hier ab. Damit
     wird es Nutzern ermöglicht, sich über das Angebot
     von Diensten und ihrer Abwicklungsmodalitäten wie
     etwa Aufrufkonventionen oder zu übergebende
     Parameter zu informieren.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;Auffinden von interessanten Diensten&lt;/em&gt;
     &lt;br /&gt;
     Universal Service Description, Discovery, and
     Integration (UDDI) stellt einen Verzeichnisdienst
     zur Verfügung, mit dem Nutzer für sie interessante
     Dienste finden könnnen. In Anlehnung an die Gelben
     Seiten werden Dienste klassifiziert und durch
     verschiedene Zugriffsroutinen angeboten..
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;img
    style="margin : 4% ; width : 40% ; "
    src="WSArch.gif" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Definition&lt;/title&gt;
   &lt;p class="definition"&gt;
    Ein Web-Service ist eine über das Web erbrachte
    Dienstleistung, die abgestimmte Inhalte in einem
    abgestimmten Format über standardisierte
    Kommunikationsmechanismen zur Verfügung stellt. Er ist
    über ein offenes, im Internet verwendetes Protokoll
    zugreifbar.
    &lt;br /&gt;
    Darüber hinaus existieren Beschreibungen über die Natur
    der angebotenen Leistung, seine Schnittstelle ist
    &lt;em&gt;veröffentlicht&lt;/em&gt;
    .
    &lt;br /&gt;
    Optional existieren Verzeichnisse, die das Auffinden von
    für einen Verbraucher interessanten Diensten
    ermöglichen.
    &lt;br /&gt;
    In der technischen Umsetzung einer
    Web-Service-Architektur sind nicht alle Protokolle,
    Sprach- und Beschreibungsebenen zwingend zu realisieren.
   &lt;/p&gt;
   &lt;img
    style="margin : 4% ; width : 40% ; "
    src="Triangle.png" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;SOAP am Beispiel&lt;/title&gt;
   &lt;p&gt;
    Das hier vorgestellte Beispiel wurde für die SOAP
    Infrastruktur Apache Axis (in Apache Tomcat) entwickelt.
    Als Einstiegsbeispiel soll hier ein Zahlenaddier-Dienst
    dienen, der die hochkomplexe Aufgabe hat, zwei Zahlen
    miteinander zu addieren ;). Die Serverkomponente dieses
    Beispiels führt die Rechenoperation durch, die
    Clientkomponente greift darauf zu.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     &lt;b&gt;Serverkomponente&lt;/b&gt;
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;listing src="Add.java" /&gt;
   &lt;p&gt;
    &lt;em&gt;
     &lt;b&gt;
      Einbinden der Serverkomponente in einen
      Application Server, hier: Tomcat
     &lt;/b&gt;
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;p&gt;
    Nach dem Compilieren muß die resultierende Java Klasse (
    &lt;code&gt;Add.class&lt;/code&gt;
    ) innerhalb des Tomcat Verzeichnisbaumes in ein
    bestimmtes Unterverzeichnis des Tomcat Verzeichnisbaumes
    kopiert werden (z.B.
    &lt;code&gt;webapps/axis/WEB-INF/classes/&lt;/code&gt;
    ).
    &lt;br /&gt;
    Zusätzlich dazu benötigt man für jeden Service einen
    Deployment Descriptor, der als Datei vorliegt. Für unser
    Beispiel ist dies die Datei
    &lt;code&gt;DeploymentDescriptor.wsdd&lt;/code&gt;
    mit folgendem Inhalt:
   &lt;/p&gt;
   &lt;listing src="DeploymentDescriptor.wsdd" /&gt;
   &lt;p&gt;
    Mit dem Parameter
    &lt;code&gt;allowedMethods&lt;/code&gt;
    kann der Zugriff auf Methoden gesteuert werden, *
    bedeutet, daß der Zugriff auf alle Methoden der Klasse
    erlaubt ist.
   &lt;/p&gt;
   &lt;p&gt;
    Abschließend muß mit folgendem Befehl der Service in
    Tomcat eingebunden werden:
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;
     java org.apache.axis.client.AdminClient
     DeploymentDescriptor.wsdd
    &lt;/code&gt;
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     &lt;b&gt;Clientkomponente&lt;/b&gt;
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;listing src="AddClient.java" /&gt;
   &lt;p&gt;
    Nach dem Kompilieren kann man die Clientkomponente mit
    folgendem Befehl zum Aufruf der Serverkomponente
    benutzen:
   &lt;/p&gt;
   &lt;p&gt;
    &lt;code&gt;
     java AddClient 3 29
     http://localhost/axis/services/NumberAdder
    &lt;/code&gt;
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     &lt;b&gt;Netzverkehr&lt;/b&gt;
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;p&gt;
    Und so sieht der SOAP Aufruf aus, der bei obigem
    Beispiel zwischen Client und Server übertragen wird:
   &lt;/p&gt;
   &lt;listing src="ExampleSoapCall.txt" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Beispiel einer WSDL-Beschreibung&lt;/title&gt;

   &lt;p&gt;
    Zur SOAP-Anfrage des vorhergehenden Beispiels soll hier
    eine diesen Dienst beschreibende WSDL-Datei vorgestellt
    werden.
   &lt;/p&gt;
   &lt;listing
    src="ExampleSoapCall.txt"
    line="11-22" /&gt;
   &lt;listing src="ExampleSoapCall.wsdl" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Beispiel UDDI&lt;/title&gt;
   &lt;p&gt;
    &lt;a href="http://uddi.xml.org/specification"&gt;
     Universal Description, Discovery, and Integration
     (UDDI)
    &lt;/a&gt;
    ist eine Spezifikation, der einen Verzeichnisdienst für
    Web Services zur Verfügung stellt und verschiedene
    XML-Vokabulare zur Kommunikation zwischen Verbrauchern
    und einem UDDI-Server zur Verfügung stellt.
   &lt;/p&gt;
   &lt;p&gt;
    Nachfolgendes Beispiel zeigt eine typische Anfrage, die
    nach Firmen sucht, die WSDL-Basierte Web Services für
    beliebige Transportgüter zur Verfügung stellt (Suche
    nach
    &lt;em&gt;
     &lt;a href="http://www.unspsc.org/"&gt;
      United Nations Standard Products &amp;amp; Services
      Code
     &lt;/a&gt;
    &lt;/em&gt;
    mit der ID
    &lt;code&gt;78NNNNNN&lt;/code&gt;
    , Transportation and Storage and Mail Services). Die
    Firmen, die gefunden werden, sollen dann absteigend
    sortiert zurückgeliefert werden.
    &lt;br /&gt;
    (UDDI unterstützt neben der Suche nach
    &lt;code&gt;UNSPSC&lt;/code&gt;
    Codes noch weitere (international und national)
    standardisierte numerische Kategorien:
    &lt;code&gt;NAICS&lt;/code&gt;
    ,
    &lt;code&gt;D-U-N-S&lt;/code&gt;
    ,
    &lt;code&gt;ISO 3166&lt;/code&gt;
    und
    &lt;code&gt;SIC&lt;/code&gt;
    )
   &lt;/p&gt;
   &lt;listing src="UddiFindBusiness.xml" /&gt;
   &lt;p&gt;
    Ein mögliches Ergebnis einer solchen Anfrage könnte etwa
    lauten:
   &lt;/p&gt;
   &lt;listing src="UddiBusinessEntity.xml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Web-Services - Orchestrierung&lt;/title&gt;
   &lt;img
    style="margin : 4% ; width : 40% ; "
    src="WSExample.gif" /&gt;
   &lt;p&gt;
    Das Beispiel zeigt verschiedene Web-Services, die
    zusammen den Dienst der wechselseitigen Umrechnung von
    Geldbeträgen des europäischen Währungsraumes erbringen.
    Die Verwendungsbeziehungen sind als gerichtete Kanten
    ausgehend vom nutzenden Dienst hin zum benutzten
    dargestellt. Die Dienste sind auch eigenständig nutzbar.
   &lt;/p&gt;
   &lt;p&gt;
    Insgesamt wird das durch die Europäische Zentralbank
    vorgegebene Verfahren der Berechnung, die
    &lt;q&gt;Zwischen-Nutzung&lt;/q&gt;
    des Euros (sog. Triangulation), benutzt. Dabei wird
    zunächst die Ursprungslandeswährung in das
    Euro-Äquivalent überführt, welches dann in die
    gewünschte Zielwährung umgerechnet wird.
   &lt;/p&gt;
   &lt;p&gt;Die Verteilung der Aufgaben ist hierbei wie folgt:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;ExchangeRates&lt;/code&gt;
     liefert auf Anfrage mit dem amtlichen Währungskürzel
     den entsprechenden, durch die Europäische
     Zentralbank festgelegten, Umrechnungskurs.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;EuroConverter&lt;/code&gt;
     rechnet einen Betrag der Landeswährung in die
     Eurosumme um, bzw. umgekehrt. Zur Berechnung wird
     der durch ExchangeRates bereitgestellte Wechselkurs
     benötigt.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;CurrencyConvert&lt;/code&gt;
     erlaubt die Umrechnung zwischen allen Währungen des
     europäischen Währungsraumes. Gemäß der Festlegung
     durch die Europäische Zentralbank darf dieser
     Vorgang ausschließlich durch Umrechnung in Euro
     ausgeführt werden (Triangulation). Daher muß
     zunächst der Ursprungsbetrag nach Euro, anschließend
     dieser Wert in die Zielwährung konvertiert werden.
     Zur Realisierung nutzt
     &lt;code&gt;CurrencyConvert&lt;/code&gt;
     die durch
     &lt;code&gt;EuroConverter&lt;/code&gt;
     angebotenen Funktionen.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

 &lt;/presentation&gt;
 &lt;!-- Ende Web Services --&gt;


 &lt;!-- RDF und RSS --&gt;
 &lt;presentation id="rdf-rss"&gt;
  &lt;title short="rdf-rss"&gt;RDF und RSS&lt;/title&gt;
  &lt;date&gt;2008-12-22&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/RDF/index.html"&gt;
    W3C Webseite zu RDF
   &lt;/a&gt;
   ,
   &lt;a href="http://www.rssboard.org/"&gt;
    Webseite des RSS Advisory Board
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   RDF (Resource Description Framework) bietet ein
   leichtgewichtiges System an Ontologien, um den Austausch von
   Wissen über das Web zu ermöglichen.
   &lt;br /&gt;
   RSS (Really Simple Syndication) ist XML-Format, das der
   Syndikatisierung von Inhalten des WWW dient.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract"&gt;&lt;/toc&gt;
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;part&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF&lt;/title&gt;
    &lt;p class="definition"&gt;
     Das
     &lt;em&gt;Resource Description Framework (RDF)&lt;/em&gt;
     dient dazu, beispielsweise Informationen aus
     Büchereikatalogen und anderen Verzeichnissen zu
     &lt;em&gt;syndikatisieren&lt;/em&gt;
     und Nachrichten, Software sowie anderen Inhalt zu
     persönlichen Sammlungen wie beispielsweise Musik,
     Photos und anderen Ereignissen zu versammeln /
     aggregieren. Dabei dient XML als Austauschformat.
     RDF selbst bietet ein leichtgewichtiges System an
     Ontologien, um den Austausch von Wissen über das Web
     zu ermöglichen.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     Begriff
     &lt;em&gt;Ontologie&lt;/em&gt;
    &lt;/title&gt;
    &lt;p class="definition"&gt;
     Unter einer
     &lt;em&gt;Ontologie&lt;/em&gt;
     versteht man die
     &lt;em&gt;
      &lt;q&gt;Lehre vom Sein, vom Seienden&lt;/q&gt;
     &lt;/em&gt;
     (Duden, Deutsches Universalwörterbuch, 4. Auflage,
     2001), bzw. die
     &lt;em&gt;
      &lt;q&gt;
       Lehre von den Ordnungs-, Begriffs- und
       Wesensbestimmungen des Seienden
      &lt;/q&gt;
     &lt;/em&gt;
     (Duden, Das große Fremdwörterbuch, 2. Auflage,
     2000).
    &lt;/p&gt;
    &lt;li&gt;&lt;/li&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Verwendung von RDF&lt;/title&gt;
    &lt;p&gt;
     RDF beschreibt Information über Ressourcen im World
     Wide Web. Insbesondere werden dadurch Metadaten über
     Ressourcen ausgedrückt, wie z.B.:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;Titel einer Webseite&lt;/li&gt;
     &lt;li&gt;Autor&lt;/li&gt;
     &lt;li&gt;letzte Änderungsdatum&lt;/li&gt;
     &lt;li&gt;Copyright-Informationen&lt;/li&gt;
     &lt;li&gt;Lizensierungsbedingungen&lt;/li&gt;
     &lt;li&gt;zeitliche Verfügbarkeit einer Ressource&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     RDF wird jedoch auch dafür verwendet, Information
     über Dinge auszudrücken, die nicht direkt über das
     Web zugreifbar sind, sondern ausschließlich mit
     Hilfe von Web-Techniken identifizierbar sind (URIs):
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Informationen über Ware von Online-Märkten (
      Beschreibung, Preise, Verfügbarkeit)
     &lt;/li&gt;
     &lt;li&gt;
      Beschreibung von Nutzervorlieben (Art und Weise
      der Informationsnutzung)
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     RDF wird hierbei vor allem dann verwendet, wenn
     diese Informationen durch Softwaresysteme
     verarbeitet werden sollen. Es erlaubt den Austausch
     dieser Information zwischen Applikationen, ohne daß
     Information dabei verloren geht. Für Benutzer /
     Programmiere ist es vorteilhaft, daß Frameworks
     (Tools, Parser, Prozessoren) verfügbar sind und
     verwendet werden können.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF - Identifizierung von Ressourcen&lt;/title&gt;
    &lt;p&gt;
     RDF identifiziert Dinge mit Hilfe von UDIs und
     beschreibt Ressourcen durch einfache Eigenschaften
     und Eigenschaftswerte. Auf diese Weise können
     einfache Aussagen über Ressourcen getätigt werden.
     Abstrakt entspricht dies einem Graphen aus Knoten
     und Kanten, der die Ressourcen selbst sowie ihre
     Eigenschaften und Werte darstellt.
    &lt;/p&gt;
    &lt;img
     style="margin : 4% ; width : 60% ;"
     src="RDFGraph.png" /&gt;
    &lt;p&gt;
     Obige Grafik (Quelle:
     &lt;a
      href="http://www.w3.org/TR/rdf-primer/index.html"&gt;
      RDF Primer
     &lt;/a&gt;
     ) erläutert dies am Beispiel von folgenden
     Informationen über eine Person:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es gibt eine Person, die durch die URI
      &lt;code&gt;
       http://www.w3.org/People/EM/contact#me
      &lt;/code&gt;
      identifiziert wird.
     &lt;/li&gt;
     &lt;li&gt;Der Name dieser Person ist Eric Miller.&lt;/li&gt;
     &lt;li&gt;
      Die E-Mail-Adresse von Herrn Miller ist
      &lt;code&gt;em@w3.org&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Sein akademischer Titel ist
      &lt;code&gt;Dr.&lt;/code&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF: Identifizierung mit URIs&lt;/title&gt;
    &lt;img
     style="margin : 4% ; width : 60% ; "
     src="RDFGraph.png" /&gt;
    &lt;p&gt;
     Im vorherigen Beispiel identifiziert RDF folgende
     Dinge
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Individuen, z.B. Eric Miller (
      &lt;code&gt;
       http://www.w3.org/People/EM/contact#me
      &lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Klassen von Dingen, z.B. Personen (
      &lt;code&gt;
       http://www.w3.org/2000/10/swap/pim/contact#Person
      &lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Eigenschaften dieser Dinge, z.B. Mailbox (
      &lt;code&gt;
       http://www.w3.org/2000/10/swap/pim/contact#mailbox
      &lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Werte dieser Eigenschaften, z.B.
      &lt;code&gt;mailto:em@w3.org&lt;/code&gt;
      als Wert der Mailbox-Eigenschaft (RDF nutzt
      hierbei auch Zeichenketten wie bspw. "Eric
      Miller", und Werte anderer Datentypen wie z.B.
      Integer)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF XML-Syntax&lt;/title&gt;
    &lt;p&gt;
     Zum Austausch dieser Graphen bietet RDF eine
     XML-basierte Syntax namens
     &lt;em&gt;RDF/XML&lt;/em&gt;
     . Die im Beispiel dargestellte Information
     entspricht der folgenden XML-Darstellung:
    &lt;/p&gt;
    &lt;listing src="RDFExample.xml" /&gt;
    &lt;p&gt;
     Auch hier sind die URIs, ebenso wie die
     Eigenschaften wie
     &lt;code&gt;mailbox&lt;/code&gt;
     und
     &lt;code&gt;fullName&lt;/code&gt;
     sowie deren Werte wie
     &lt;code&gt;em@w3.org&lt;/code&gt;
     und
     &lt;code&gt;Eric Miller&lt;/code&gt;
     enthalten.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF Eigenschaften&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wie HTML ist RDF/XML automatisch durch Software
      verarbeitbar.
     &lt;/li&gt;
     &lt;li&gt;
      Durch die Verwendung von URIs können
      Informationen im Web miteinander verbunden
      werden.
     &lt;/li&gt;
     &lt;li&gt;
      URIs werden analog ihrer XML-Verwendung als
      Möglichkeit zur Identifizierung verwendet.
      Hiermit können auch Dinge identifiziert werden,
      die nicht direkt im Web Zugreifbar sind (wie
      etwa die Person aus dem Beispiel).
     &lt;/li&gt;
     &lt;li&gt;
      RDF kann damit nicht nur Webseiten beschreiben,
      sondern auch Autos, Firmen, Menschen,
      Nachrichten, Ereignisse, Veranstaltungen, etc.
     &lt;/li&gt;
     &lt;li&gt;
      Überdies können RDF Eigenschaften selbst URIs
      haben, damit können die Beziehungen zwischen den
      einzelnen Dingen eindeutig identifiziert werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF - Grundlegende Konzepte&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mit RDF können
      &lt;em&gt;Aussagen&lt;/em&gt;
      über Dinge gemacht werden.
     &lt;/li&gt;
     &lt;li&gt;
      Demnach muß es möglich sein, folgende Dinge zu
      benennen oder zu identifizieren:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Das Ding, über das die Aussage getroffen
       wird.
      &lt;/li&gt;
      &lt;li&gt;
       Eine bestimmte Eigenschaft dieses Dinges (zu
       Beisiel der Ersteller einer Webseite).
      &lt;/li&gt;
      &lt;li&gt;
       Den Wert dieser Eigenschaft (z.B: den Namen
       des Webseitenerstellers)
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Beispiel: In der Aussage
      &lt;br /&gt;
      &lt;q&gt;
       http://www.barbara-zengler.de/ hat einen
       Ersteller, dessen Wert Barbara Zengler ist.
      &lt;/q&gt;
      &lt;br /&gt;
      dient die URL der Identifikation der Webseite.
      Zusätzlich dazu identifiziert das Wort
      &lt;q&gt;Ersteller&lt;/q&gt;
      die Eigenschaft sowie die zwei Wörter
      &lt;q&gt;Barbara Zengler&lt;/q&gt;
      den Wert dieser Eigenschaft.
     &lt;/li&gt;
     &lt;li&gt;
      RDF verwendet zur Bezeichning dieser Dinge eine
      Begriffswelt, die sich an der Begriffswelt der
      Grammatiken orientiert:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der Gegenstand der Betrachtung wird
       &lt;em&gt;Subjekt&lt;/em&gt;
       genannt.
      &lt;/li&gt;
      &lt;li&gt;
       Die Eigenschaft des Subjekts, die Gegenstand
       der Aussage ist, wird als
       &lt;em&gt;Prädikat&lt;/em&gt;
       bezeichnet.
      &lt;/li&gt;
      &lt;li&gt;
       Der Wert der Eigenschaft stellt entsprechend
       das
       &lt;em&gt;Objekt&lt;/em&gt;
       dar.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Angewendet auf obiges Beispiel:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Das Subjekt entspricht der URL
       &lt;code&gt;http://www.barbara-zengler.de/&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Das Wort
       &lt;q&gt;Ersteller&lt;/q&gt;
       stellt das Prädikat dar.
      &lt;/li&gt;
      &lt;li&gt;
       Das Objekt wird durch den Ausdruck
       &lt;q&gt;Barbara Zengler&lt;/q&gt;
       gebildet.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Das RDF-Modell&lt;/title&gt;
    &lt;p&gt;
     Wenn man das Konzept der Verwendung von URIS auf das
     Beispiel anwendet, dann könnte eine RDF-Aussage zu
     obigem Beispiel in etwa folgende Anteile besitzen:
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Ein Subjekt
      &lt;code&gt;http://www.barbara-zengler.de/&lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Ein Prädikat
      &lt;code&gt;
       http://purl.org/dc/elements/1.1/creator
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Ein Objekt
      &lt;code&gt;
       http://www.example.org/mitarbeiterID/12345
      &lt;/code&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Das RDF-Modell stellt diese Information als Knoten
     und Kanten in einem Graphen dar. Entsprechend würde
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;Ein Knoten für das Subjekt,&lt;/li&gt;
     &lt;li&gt;ein Knoten für das Objekt und&lt;/li&gt;
     &lt;li&gt;
      eine gerichtete kante vom Subjekt hin zum Objekt
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;modelliert.&lt;/p&gt;
    &lt;img
     style="margin : 4% ; width : 60% ; "
     src="RDFModel.png" /&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF - Gruppierung&lt;/title&gt;
    &lt;p&gt;
     Werden mehrere Aussagen über ein Subjekt oder Objekt
     getroffen, so werden diese bei den entsprechenden
     Knoten gruppiert. Beispielsweise würden die
     folgenden zwei zusätzlichen Aussagen ....
    &lt;/p&gt;
    &lt;listing
     src="RDFStatements.txt"
     line="1-2" /&gt;
    &lt;p&gt;
     ..., die über das Subjekt unseres Beispiels
     getroffen werden, zu folgendem RDF-Modell führen:
    &lt;/p&gt;
    &lt;img
     style="margin : 4% ; width : 60% ; "
     src="RDFModel2.png" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Objekte in RDF können durch URIs (dargestellt in
      Ellipsen) oder Literale (dargestellt in
      Vierecken) bezeichnet werden.
     &lt;/li&gt;
     &lt;li&gt;
      Subjekte und Prädikate können hingegen nicht
      durch Literale bezeichnet werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RDF - Darstellung in Textform als Tripel&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Alternative Form der Darstellung: Textform&lt;/li&gt;
     &lt;li&gt;
      Subjekt, Prädikat und Objekt werden durch
      Leerzeichen getrennt als
      &lt;em&gt;Tripel&lt;/em&gt;
      hintereinander in dieser Reihenfolge notiert.
     &lt;/li&gt;
     &lt;li&gt;
      Jedes Tripel entspricht einem Kanten des Graphs,
      mit Start- und Endknoten.
     &lt;/li&gt;
     &lt;li&gt;
      Wichtig in RDF ist das Modell des Graphen. Seine
      Repräsentation, sei es grafisch, im XML-Format
      oder in Textform, ist weniger wichtig.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Die Information aus unserem Beispiel als Tripel
     notiert:
    &lt;/p&gt;
    &lt;listing
     src="RDFStatements.txt"
     line="4-6" /&gt;
    &lt;p&gt;
     Achtung: es handelt sich hierbei um KEINE
     XML-Notation!
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es besteht die Möglichkeit zur Abkürzung durch
      die Verwendung der aus den XML-Namensräumen
      bekannten
      &lt;em&gt;Präfix-Notation&lt;/em&gt;
     &lt;/li&gt;
     &lt;listing
      src="RDFStatements.txt"
      line="8-13" /&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     RDF - Darstellungsweisen in der Zusammenschau
    &lt;/title&gt;
    &lt;img
     style="margin : 4% ; width : 60% ; "
     src="RDFModel2.png" /&gt;
    &lt;listing
     src="RDFStatements.txt"
     line="4-6" /&gt;
    &lt;listing
     src="RDFStatements.txt"
     line="16-26" /&gt;
    &lt;p&gt;
     Die oben gezeigte XML-Darstellung ist eine Abkürzung
     für folgende Schreibweise:
    &lt;/p&gt;
    &lt;listing
     src="RDFStatements.txt"
     line="31-49" /&gt;
    &lt;p&gt;
     Die RDF-Information in beiden XML-Dokumenten ist
     dieselbe.
    &lt;/p&gt;
   &lt;/slide&gt;
  &lt;/part&gt;

  &lt;part&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS&lt;/title&gt;
    &lt;p class="definition"&gt;
     &lt;em&gt;Really Simple Syndication (RSS)&lt;/em&gt;
     ist XML-Format, das der Syndikatisierung
     (Verbreitung) von Inhalten des WWW dient. Ziel ist
     die einfache Weiterveröffentlichung der so
     beschriebenen Inhalte auf anderen Seiten und / oder
     die periodische Aktualisierung und Darstellung der
     Inhalte für den Verbraucher.
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS - Geschichte&lt;/title&gt;
    &lt;img
     style="margin : 4% ; width : 60% ; "
     src="RDFModel2.png" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      RSS wurde ursprünglich von
      &lt;em&gt;Netscape&lt;/em&gt;
      entwickelt, am 15. März 1999 wurde die
      Spezifikation
      &lt;em&gt;RDF Site Summary (RSS)&lt;/em&gt;
      0.90 veröffentlicht.
     &lt;/li&gt;
     &lt;li&gt;
      Direkt nach der Veröffentlichung dieser ersten
      Version divergierte die Weiterentwicklung des
      Standards in zwei Richtungen:
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Im Juli 1999 veröffentlichte Netscape die
       RDF Site Summary (RSS) Version 0.91
      &lt;/li&gt;
      &lt;li&gt;
       Im Juni 2000 veröffentlichte
       &lt;a href="http://www.userland.com/"&gt;
        UserLand Software
       &lt;/a&gt;
       die RSS Version 0.91
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Hauptunterschied dieser Versionen: Konformität
      zu RDF durch die RSS-Variante von Netscape. RDF
      Site Summary wurde im Jahr 2000 in der
      &lt;a href="http://web.resource.org/rss/1.0/"&gt;
       Version 1.0
      &lt;/a&gt;
      veröffentlicht, seither wird daran jedoch nicht
      mehr weiterentwickelt.
     &lt;/li&gt;
     &lt;li&gt;
      Im weiteren Verlauf wurde die Variante von
      UserLand kontinuierlich weiterentwickelt,
      wohingegen Netscape die Entwicklung an der
      eigenen RSS Variante einstellte.
     &lt;/li&gt;
     &lt;li&gt;
      Die Spezifikation wird heute vom sog.
      &lt;em&gt;RSS Advisory Board&lt;/em&gt;
      gepflegt.
     &lt;/li&gt;
     &lt;li&gt;
      Netscape übergabe seine Spezifikation
      schließlich am an das RSS Advisory Board, das
      heute als einzige Quelle für RSS gilt.
     &lt;/li&gt;
     &lt;li&gt;
      Derzeit aktuelle Version:
      &lt;a
       href="http://www.rssboard.org/rss-specification"&gt;
       RSS 2.0 (version 2.0.10)
      &lt;/a&gt;
      vom 15. Oktober 2007.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS - Verwendung&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;RSS findet heute sehr breite Verwendung.&lt;/li&gt;
     &lt;li&gt;
      Eine Google-Suche nach RSS findet derzeit etwa
      3.790.000.000 Treffer für den Suchbegriff RSS.
     &lt;/li&gt;
     &lt;li&gt;
      Der Einsatz von sogenannten RSS-Feeds erfolgt
      hauptsächlich auf Webseiten, die
      Nachrichteninhalte zur Verfügung stellen, sowie
      auf Blogs.
     &lt;/li&gt;
     &lt;li&gt;
      RSS ist auch Grundlage für die sog.
      &lt;em&gt;Podcasts&lt;/em&gt;
      , also das Anbieten von einer Reihe von
      Mediendateien wie MP3 in einer Sammlung (
      &lt;em&gt;Feed&lt;/em&gt;
      ) über das Internet.
     &lt;/li&gt;
     &lt;li&gt;
      Eine Übersicht über eine Vielzahl in Deutschlang
      angebotener RSS-
      &lt;em&gt;Feeds&lt;/em&gt;
      findet sich auf der Webseite
      &lt;a href="http://www.rss-verzeichnis.de/"&gt;
       RSS-Verzeichnis.de
      &lt;/a&gt;
      oder
      &lt;a href="http://www.rss-nachrichten.de/"&gt;
       RSS-Nachrichten.de
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Für das Format existiert eine Vielzahl von
      &lt;em&gt;Readern&lt;/em&gt;
      , eine Übersicht ist etwa auf der dortigen
      &lt;a
       href="http://www.rss-verzeichnis.de/rss-reader.php"&gt;
       RSS-Reader Webseite
      &lt;/a&gt;
      zusammengestellt.
     &lt;/li&gt;
     &lt;li&gt;
      Auch aktuelle Browser (wie z.B. der
      &lt;a href="http://www.lunascape.tv/"&gt;Lunascape&lt;/a&gt;
      Web Browser) bringen umfangreiche Unterstützung
      für das Format mit.
     &lt;/li&gt;
     &lt;li&gt;
      Das RSS Advisory Board bietet einen
      &lt;a
       href="http://www.rssboard.org/rss-validator"&gt;
       Validator-Service
      &lt;/a&gt;
      für RSS-Dateien an.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS - ein Beispiel&lt;/title&gt;
    &lt;listing src="RSS-Example.xml" /&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Alle in RSS definierten Elemente müssen reinen
      Text als Inhalt haben und dürfen nicht mehr
      weiter strukturiert sein (keine Kindelement!).
      &lt;br /&gt;
      Einzige Ausnahme: das Element
      &lt;code&gt;description&lt;/code&gt;
      , das aus HTML-Inhalt bestehen kann.
     &lt;/li&gt;
     &lt;li&gt;
      Die einzelnen Einträge des Feeds werden in Form
      von
      &lt;code&gt;item&lt;/code&gt;
      -Elementen verwaltet.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS - Beispiel&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine RSS-Datei hat einen festen Aufbau. Die
      gesamte Information ist im Wurzelelement
      &lt;code&gt;rss&lt;/code&gt;
      versammelt. Das Wurzelelement beinhaltet als
      Attribut die verwendete RSS-Version. Es muß
      genau ein Kindelement
      &lt;code&gt;channel&lt;/code&gt;
      besitzen.
     &lt;/li&gt;
     &lt;listing
      src="RSS-tagesschau.xml"
      line="3-14" /&gt;
     &lt;li&gt;
      Das
      &lt;code&gt;channel&lt;/code&gt;
      Element muß mindestens aus folgenden drei
      Kindelementen bestehen:
      &lt;ul&gt;
       &lt;li&gt;
        &lt;code&gt;title&lt;/code&gt;
        : Der Name des angebotenen Channels.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;link&lt;/code&gt;
        : Eine URL, die auf die zum Channel
        gehörende Webseite verweist.
       &lt;/li&gt;
       &lt;li&gt;
        &lt;code&gt;description&lt;/code&gt;
        : Beschreibung des Channels.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;listing
       src="RSS-tagesschau.xml"
       line="1-17" /&gt;
      Des weiteren kann es
      &lt;a
       href="http://www.rssboard.org/rss-specification#optionalChannelElements"&gt;
       weitere optionale Elemente
      &lt;/a&gt;
      beinhalten, die weitere Informationen zum
      angebotenen Feed beherbergen.
      &lt;listing
       src="RSS-tagesschau.xml"
       line="18-21" /&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Ein
      &lt;code&gt;item&lt;/code&gt;
      -Eintrag entspricht etwa einer Nachricht /
      Schlagzeile einer Zeitung. Seine Beschreibung (
      &lt;code&gt;description&lt;/code&gt;
      ist eine Zusammenfassung des Geschehnisses oder
      der komplette Text in HTML. Das Kindelement
      &lt;code&gt;link&lt;/code&gt;
      verweist auf eine ausführliche Beschreibung.
      &lt;br /&gt;
      Alle Kindelemente von
      &lt;code&gt;item&lt;/code&gt;
      sind optional. Mindestens Titel oder
      Beschreibung müssen jedoch vorhanden sein.
      &lt;br /&gt;
      Weitere mögliche Kindelemente:
      &lt;code&gt;author&lt;/code&gt;
      (E-Mail-Adresse),
      &lt;code&gt;category&lt;/code&gt;
      ,
      &lt;code&gt;comments&lt;/code&gt;
      ,
      &lt;code&gt;enclosure&lt;/code&gt;
      (verbundenes Medienobjekt),
      &lt;code&gt;guid&lt;/code&gt;
      (Eindeutiger Bezeichner),
      &lt;code&gt;pubDate&lt;/code&gt;
      , und
      &lt;code&gt;source&lt;/code&gt;
      (Quell-RSS-Channel).
      &lt;listing
       src="RSS-tagesschau.xml"
       line="22-44" /&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;RSS - komplettes "Tagesschau"-Beispiel&lt;/title&gt;
    &lt;listing src="RSS-Tagesschau.xml" /&gt;
   &lt;/slide&gt;
  &lt;/part&gt;

 &lt;/presentation&gt;
 &lt;!--  Ende RDF und RSS --&gt;

 &lt;!--  XSLT --&gt;
 &lt;presentation id="xslt"&gt;
  &lt;title short="XSLT"&gt;
   Transformation von XML-Dokumenten: XSL Transformations
  &lt;/title&gt;
  &lt;date&gt;2009-01-12&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a href="http://www.w3.org/Style/XSL/"&gt;
    W3C Webseite zu XSL
   &lt;/a&gt;
   ,
   &lt;a href="http://www.w3.org/TR/xslt20/"&gt;
    XSLT Spezifikation
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Weil eine XML-Sprache ein bestimmtes Vokabular
   repräsentiert, kommt oft der Wunsch auf, verschiedene
   Vokabulare in etwas anderes zu transformieren. Dies kann
   entweder ein anderes XML-Vokabular sein (zum Beispiel beim
   Datenaustausch), oder beispielsweise auch HTML (zum
   Publizieren von Daten im Web). Mit
   &lt;em&gt;XSL Transformations (XSLT)&lt;/em&gt;
   können solche Abbildungen leicht erstellt werden. XSLT macht
   sich die Mächtigkeit von XPath zunutze und setzt es in der
   recht einfach zu verwendenden Programmiersprache ein. Die
   Programme in XSLT werden oft auch
   &lt;em&gt;Stylesheets&lt;/em&gt;
   genannt. Einfache Aufgaben können mit XSLT ohne viel
   Programmierarbeit erledigt werden. Es wird ausschließlich
   spezifiziert, wie die Bestandteile einer Ausgangssprache in
   die Bestandteile einer Zielsprache abgebildet werden sollen.
   Dennoch stellt XSLT eine Turing-vollständige
   Programmiersprache dar.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract"&gt;&lt;/toc&gt;
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;part&gt;
   &lt;title&gt;XSLT&lt;/title&gt;
   &lt;slide&gt;
    &lt;title&gt;XSLT - eine Übersicht&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      XSLT ist eine funktionale Programmiersprache.
     &lt;/li&gt;
     &lt;li&gt;XSLT verwendet XML Syntax.&lt;/li&gt;
     &lt;li&gt;XSLT ist eine schwach typisierte Sprache.&lt;/li&gt;
     &lt;li&gt;
      XSLT wurde nicht dafür entworfen, große
      Programmieraufgaben damit durchzuführen.
     &lt;/li&gt;
     &lt;li&gt;
      XSLT ist
      &lt;em&gt;die&lt;/em&gt;
      Sprache, um XML in XML zu transformieren.
     &lt;/li&gt;
     &lt;li&gt;XSLT ist ziemlich einfach.&lt;/li&gt;
    &lt;/ul&gt;

   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     XSLT - eine funktionale Programmiersprache
    &lt;/title&gt;
    &lt;p&gt;
     Man unterscheidet üblicherweise zwei
     Programmierparadigmen.
    &lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Imperative Programmierung: Ein Computerprogramm
      besitzt / befindet sich in einem bestimmten
      &lt;em&gt;Zustand&lt;/em&gt;
      , der sich aus der Belegung von Variablen
      (Speicherbereich) und einem Programmzähler
      zusammensetzt. Dieser Zustand wird durch
      &lt;em&gt;Befehle&lt;/em&gt;
      verändert. Die Reihenfolge der Befehle steuert
      die zeitliche Abfolge des Programms.
     &lt;/li&gt;
     &lt;li&gt;
      Deklarative Programmierung: Basis für die
      deklarative Programmierung sind mathematische
      Theorien und Konzepte. Eine Lösung wird
      ausschließlich beschrieben. Es wird keine Angabe
      darüber gemacht, wie die Lösung berechnet werden
      soll.
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
     Die
     &lt;em&gt;objektorientierte Programmierung&lt;/em&gt;
     läßt sich nicht in diese Klassifizierung einordnen,
     sie ist hierzu orthogonal (vgl.
     &lt;a
      href="https://www.informatik.uni-stuttgart.de/fmi/szs/teaching/ws0506/info3/einfuehrung-2x2.pdf"&gt;
      Einführung in die Informatik von Barbara König
     &lt;/a&gt;
     ). Es gibt sowohl imperative objektorientierte
     Sprachen (z.B. Java, C++) als auch deklarative
     objektorientierte Sprachen (z.B. OCaml).
    &lt;/p&gt;
    &lt;p&gt;
     Die
     &lt;em&gt;funktionale Programmierung&lt;/em&gt;
     ist der deklarativen Programmierung zuzuordnen.
     &lt;br /&gt;
     Als Grundlage dient der Begriff der
     &lt;em&gt;Funktion&lt;/em&gt;
     , der stark auf dem Funktionsbegriff der Mathematik
     basiert. Eine Funktion besitzt einen
     Definitionsbereich, einen Wertebereich, sowie eine
     Abbildungsvorschrift (Aufzählung von Wertepaaren
     oder Funktionsgleichung). Eine Funktionsgleichung
     besitzt auf der linken Seite Variablen, die mit
     Werten aus dem Definitionsbereich belegt werden
     können. Auf der rechten Seite steht ein Ausdruck mit
     Konstanten (z.B. e, Pi) und Funktionen. Beispiel:
     &lt;code&gt;
      K(r) = pi * r
      &lt;sup&gt;2&lt;/sup&gt;
     &lt;/code&gt;
     . In einer funktionalen Programmiersprache kann
     diese Funktion auf die gleiche Art und Weise
     definiert und benutzt werden wie in der Mathematik.
     (Quelle: Martin Erwig: Grundlagen funktionaler
     Programmierung, Oldenbourg Verlag, ISBN
     3-486-25100-7)
    &lt;/p&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;
     XSLT - eine funktionale Programmiersprache
    &lt;/title&gt;
    &lt;p&gt;Eigenschaften funktionaler Programmiersprachen&lt;/p&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es gilt die
      &lt;em&gt;referenzielle Transparenz&lt;/em&gt;
      : Ein und dieselbe Variable bezeichnet (an
      verschiedenen Stellen ihres Geltungsbereichs)
      immer den gleichen Wert.
     &lt;/li&gt;
     &lt;li&gt;
      In imperativen Programmiersprachen ist dieses
      Prinzip verletzt.
      &lt;br /&gt;
      Beispiel:
      &lt;code&gt;i=i+1&lt;/code&gt;
      . Mathematisch eine nicht erfüllbare Aussage,
      steht in imperativen Programmiersprachen das
      &lt;code&gt;i&lt;/code&gt;
      links des Gleichheitszeichens etwa für eine
      &lt;code&gt;8&lt;/code&gt;
      , das
      &lt;code&gt;i&lt;/code&gt;
      rechts des Gleichheitszeichens hingegen für eine
      &lt;code&gt;7&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      In funktionalen Programmiersprachen gibt es
      keine Zuweisungen an Variablen.
     &lt;/li&gt;
     &lt;li&gt;
      Funktionale Programme bestehen aus Werte- und
      Funktionsdefinitionen.
     &lt;/li&gt;
     &lt;li&gt;
      Es gibt in funktionalen Programmiersprachen
      keine Schleifen wie
      &lt;code&gt;while&lt;/code&gt;
      oder
      &lt;code&gt;for&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Dafür gibt es
      &lt;code&gt;if-then-else&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Das wichtigste Kontrollinstrument ist die
      Rekursion.
     &lt;/li&gt;
     &lt;li&gt;
      Nebeneffekte / Seiteneffekte kommen in
      funktionalen Programmiersprachen nicht vor.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XSLT - Verarbeitungsmodell&lt;/title&gt;
    &lt;img
     style="margin : 4% ; width : 90% ; "
     src="xslt-model.png"&gt;
    &lt;/img&gt;
    &lt;p&gt;
     Quelle:
     &lt;a href="http://dret.net/lectures/xml-fall07/"&gt;
      XML-Vorlesung
     &lt;/a&gt;
     von
     &lt;a href="http://dret.net/netdret/"&gt;Erik Wilde&lt;/a&gt;
    &lt;/p&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein erstes XSLT-Programm&lt;/title&gt;
    &lt;listing src="first-xslt.xml"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;Beobachtungen&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Es handelt sich zweifelsfrei um ein
       XML-Dokument.
      &lt;/li&gt;
      &lt;li&gt;
       Der
       &lt;a
        href="http://www.w3.org/TR/xslt20/#xslt-namespace"&gt;
        XSLT-Namensraum
       &lt;/a&gt;
       wird verwendet.
      &lt;/li&gt;
      &lt;li&gt;
       Es besteht ausschließlich aus dem
       Wurzelelement.
      &lt;/li&gt;
      &lt;li&gt;
       Es sind keine weiteren Anweisungen darin
       vorhanden.
      &lt;/li&gt;
      &lt;li&gt;
       Wenn es ausgeführt wird, liefert es ein
       Ergebnis [sic!].
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein erstes XSLT-Programm - Ausführen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Ausführen des Programms&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Benötigt wird ein XSLT Prozessor. Empfohlen
       wird
       &lt;a href="http://saxon.sourceforge.net/"&gt;
        Saxon-B
       &lt;/a&gt;
       (von
       &lt;a href="http://www.saxonica.com/"&gt;
        Michael Kay
       &lt;/a&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       Außerdem benötigen Sie eine Java-Umgebung
       (Der Saxon-Autor empfieht JDK 1.5).
      &lt;/li&gt;
      &lt;li&gt;
       Zur Transformation brauchen Sie noch ein
       XML-Quelldokument sowie ein Stylesheet
       (beispielsweise unser eben erarbeitetes XSLT
       Stylesheet).
      &lt;/li&gt;
      &lt;li&gt;
       Saxon kann auf verschiedene Art und Weise
       gestartet werden, unter anderem von der
       Kommandozeile aus. Der Befehl hierfür lautet
       (für Saxon-B Version 8):
      &lt;/li&gt;
      &lt;listing
       src="saxon-command.txt"
       line="1"&gt;
      &lt;/listing&gt;
      &lt;li&gt;
       Möchte man das eben erarbeitete erste
       Stylesheetdokument auf unsere erweiterte
       Projektverwaltung anwenden, lautet der
       Befehl folgendermaßen:
      &lt;/li&gt;
      &lt;listing
       src="saxon-command.txt"
       line="2"&gt;
      &lt;/listing&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein erstes XSLT-Programm - Das Ergebnis&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Nach Anwendung des Stylesheets erhalten wir ein
      Ergebnis. (
      &lt;a href="transformationsergebnis.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Der
      &lt;q&gt;Text&lt;/q&gt;
      des Dokuments erscheint im Ergebnisdokument.
     &lt;/li&gt;
     &lt;li&gt;
      Wie funktioniert das, wo doch im
      Beispiel-Stylesheet keinerlei
      Transformationsregeln angegeben sind?
     &lt;/li&gt;
     &lt;li&gt;
      XSLT hat eingebaute
      &lt;q&gt;
       &lt;a
        href="http://www.w3.org/TR/xslt20/#built-in-rule"&gt;
        Vorgaberegeln
       &lt;/a&gt;
      &lt;/q&gt;
      .
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;Es traversiert den Dokumentbaum.&lt;/li&gt;
      &lt;li&gt;Dabei kopiert es alle Textknoten.&lt;/li&gt;
      &lt;li&gt;
       Der Dokumentbaum wird rekursiv
       durchschritten.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Es ist möglich, komplexe Transformationen für
      ein Eingabedokument durchzuführen, indem diese
      Vorgaben überschrieben und eigene Regeln
      definiert werden.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XSLT - Transformationsschablonen&lt;/title&gt;
    &lt;img
     style="margin : 4%"
     src="xsltTemplate.gif"&gt;
    &lt;/img&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Üblicherweise besteht ein XSLT-Programm aus
      verschiedenen Transformationsschablonen.
     &lt;/li&gt;
     &lt;li&gt;
      Eine solche Schablone besteht aus einem
      &lt;em&gt;Lokalisierungspfad&lt;/em&gt;
      und einem
      &lt;em&gt;Ersetzungsmuster&lt;/em&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Der Lokalisierungspfad wird durch eine
      eingeschränkte Variante von XPath gebildet.
      Ergebnis ist eine Knotenmenge.
     &lt;/li&gt;
     &lt;li&gt;
      Im Rumpf der Schablone legt das Ersetzungsmuster
      diejenige Zeichenfolge fest, die statt jedem
      Element der gefundenen Knotenmenge ausgegeben
      werden soll.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein zweites XSLT-Programm&lt;/title&gt;
    &lt;listing src="zweites-xslt.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Der XSLT-Prozesor durchläuft den Dokumentbaum
      rekursiv und
      &lt;q&gt;findet&lt;/q&gt;
      automatisch die richtigen Knoten. Die Ausführung
      des Codes wird durch den XSLT-Prozessor
      kontrolliert, er wendet die
      &lt;q&gt;Regeln&lt;/q&gt;
      an.
     &lt;/li&gt;
     &lt;li&gt;
      Ausgabe von Text statt XML-Strukturen (
      &lt;code&gt;xsl:text&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Wendet man dieses Stylesheet auf das
      Projektverwaltungsbeispiel an, so erhält man
      dreimal die Ausgabe
      &lt;code&gt;Person gefunden!&lt;/code&gt;
      ; für jedes Auftreten des Knotens Person in der
      Eingabe. (
      &lt;a href="transformationsergebnis.2-txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;listing src="transformationsergebnis-2.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XSLT - Anweisungen&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      XSLT hat eine übersichtliche Anzahl von
      Anweisungen (vgl.
      &lt;a
       href="http://www.w3.org/TR/xslt20/#element-syntax-summary"&gt;
       Zusammenfassung aller XSLT-Anweisungen
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Es wurde für einen bestimmten Zweck entwickelt.
     &lt;/li&gt;
     &lt;li&gt;
      XPath zeichet für einen Großteil der Mächtigkeit
      von XSLT verantwortlich.
     &lt;/li&gt;
     &lt;li&gt;
      XSLT kann über Knotenmengen iterieren, andere
      Probleme müssen rekursiv gelöst werden.
     &lt;/li&gt;
     &lt;li&gt;
      XSLT hat auch konditionale Anweisungen (
      &lt;code&gt;xsl:if&lt;/code&gt;
      und
      &lt;code&gt;xsl:choose&lt;/code&gt;
      ). Diese sollten jedoch nur für einfache
      Bedingungen verwendet werden. Tiefe
      Schachtelungen und lange Bedingungen werden
      schnell zum Problem (Lesbarkeit, Performance).
     &lt;/li&gt;
     &lt;li&gt;
      Alles in allem ist XSLT eine einfache
      Programmiersprache.
     &lt;/li&gt;
     &lt;li&gt;
      XPath ist esentiell und muß von einem
      XSLT-Programmierer beherrscht werden.
     &lt;/li&gt;
     &lt;li&gt;
      Wie in jeder anderen Programmiersprache gilt:
      Übung macht den Meister!
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Ein drittes XSLT-Programm&lt;/title&gt;
    &lt;listing src="drittes-xslt.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Verwenden des
      &lt;code&gt;xsl:stylesheet&lt;/code&gt;
      -Elements anstatt des
      &lt;code&gt;xsl:transform&lt;/code&gt;
      -Elements. Die beiden Elemente sind synonym -
      beiden können gleichsinnig verwendet werden.
     &lt;/li&gt;
     &lt;li&gt;
      Wiederum Ausgabe von Text. (
      &lt;a href="transformationsergebnis-3.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;

     &lt;li&gt;Erste Schablone:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der Lokalisierungspfad trifft zum einen auf
       das Document-Element (
       &lt;code&gt;/&lt;/code&gt;
       ) zu, zum anderen auf beliebige Elemente
       innerhalb eines Dokuments (
       &lt;code&gt;*&lt;/code&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       Das Ersetzungsmuster gibt den Text
       &lt;code&gt;
        ( Element
        &lt;em&gt;Elementname&lt;/em&gt;
       &lt;/code&gt;
       ) aus. Anschließend wird der Prozessor
       veranlaßt, Attribute und Kindelemente zu
       verarbeiten.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Zweite Schablone:&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Der Lokalisierungspfad der zweiten Schablone
       trifft auf alle Attribute zu (
       &lt;code&gt;@*&lt;/code&gt;
       ).
      &lt;/li&gt;
      &lt;li&gt;
       Ausgegeben wird der Text
       &lt;code&gt;Attribute:&lt;/code&gt;
       gefolgt vom Namen des Attributs
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Das Durchlaufen des Quelldokumentbaumes ist
      leicht durch Rekursion (
      &lt;code&gt;xsl:apply-templates&lt;/code&gt;
      ) zu bewerkstelligen, die meiste Arbeit
      übernimmt der XSLT-Prozessor selbst.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Versuchen Sie nicht, dieses
       Verarbeitungsmuster mit Gewalt zu
       durchbrechen oder zu umgehen (XSLT gibt
       Ihnen die Mittel hierfür durchaus an die
       Hand)!
      &lt;/li&gt;
      &lt;li&gt;
       Dies rächt sich mit undurchschaubarem
       Spaghetticode.
      &lt;/li&gt;
      &lt;li&gt;Auch die Performanz leidet erheblich!&lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Transformationsergebnis:&lt;/li&gt;
     &lt;listing src="transformationsergebnis-3.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Eine Variante des dritten XSLT-Programms&lt;/title&gt;
    &lt;listing src="drittes-xslt-v2.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In diesem Beispiel sehen Sie eine alternative
      Möglichkeit zur Ausgabe von Text angewendet.
     &lt;/li&gt;
     &lt;li&gt;
      Text kann nicht nur durch das Element
      &lt;code&gt;xsl:text&lt;/code&gt;
      ausgegeben werden, sondern einfach dadurch, daß
      der gewünschte Text in die Elementschablone
      hineingeschrieben wird.
     &lt;/li&gt;
     &lt;li&gt;
      (
      &lt;a href="transformationsergebnis-3-v2.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;listing src="transformationsergebnis-3-v2.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XSLT - Erzeugen einer XML-Ausgabe&lt;/title&gt;
    &lt;listing src="viertes-xslt.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Im obigen Beispiel wird jedes Element des Typs
      &lt;code&gt;Person&lt;/code&gt;
      durch ein leeres
      &lt;code&gt;Mitarbeiter&lt;/code&gt;
      -Element ersetzt.
     &lt;/li&gt;
     &lt;li&gt;
      Üblicherweise werden in XSLT-Programmen alle
      XSLT-Elemente durch Namensraumpräfix
      qualifiziert. Würde der Vorgabenamensraum mit
      der Namensraum-URI der XSL-Transformations
      belegt, so befände sich auch jedes XML-Element
      und -Attribut innerhalb des Ersetzungsmusters in
      diesem Namensraum. Als Konsequenz würde der
      XSLT-Prozessor die Transformation wegen des
      Auftretens ungültiger (d.h. nicht in der
      XSLT-Sprache enthaltener) Elemente ablehnen.
     &lt;/li&gt;
     &lt;li&gt;
      Das Ergebnis der obigen Transformation ist
      dreifach das leere Element
      &lt;code&gt;Mitarbeiter&lt;/code&gt;
      anstelle der
      &lt;code&gt;Person&lt;/code&gt;
      en-Elemente der Eingabe. (
      &lt;a href="transformationsergebnis-4.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Achtung: Für das Ersetzungsmuster gilt lediglich
      die Regel, daß alle Elemente geschlossen werden
      müssen und eine korrekte Schachtelung der
      Elemente vorliegen muß. Das Ergebnisdokument im
      Beispiel ist
      &lt;em&gt;kein&lt;/em&gt;
      wohlgeformtes XML-Dokument, da ihm das
      Wurzelelement fehlt. Der Programmierer des
      Stylesheets trägt die Verantwortung dafür, für
      eine XML-Ausgabe wohlgeformte XML-Dokumente zu
      erzeugen.
     &lt;/li&gt;
     &lt;listing src="transformationsergebnis-4.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     XSLT - Übernehmen von textuellen Werten aus dem
     Quelldokument (
     &lt;code&gt;xsl:value-of&lt;/code&gt;
     )
    &lt;/title&gt;
    &lt;listing src="fuenftes-xslt.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Oft sollen bei einer Transformation textuelle
      Werte aus der Eingabe in die Ausgabe übernommen
      werden.
     &lt;/li&gt;
     &lt;li&gt;
      Die XSLT-Anweisung
      &lt;code&gt;xsl:value-of&lt;/code&gt;
      erlaubt dies.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Textknoten, die in die Ausgabe
       übernommen werden sollen, werden durch den
       XPath-Ausdruck des
       &lt;code&gt;select&lt;/code&gt;
       -Attributs ausgewählt.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Im Ergebnisdokument liegen alle
      &lt;b&gt;Textknoten&lt;/b&gt;
      vor, die innerhalb des durch den XPath
      ausgewählten Knotens vorkommen. Dies schließt
      auch Text aus dessen Kindelementen mit ein. (
      &lt;a href="transformationsergebnis-5.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
      )
     &lt;/li&gt;
     &lt;listing src="transformationsergebnis-5.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     XSLT - Übernehmen vollständiger Elemente aus dem
     Quelldokument (
     &lt;code&gt;xsl:copy-of&lt;/code&gt;
     )
    &lt;/title&gt;
    &lt;listing src="sechstes-xslt.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das obige Beispiel benennt aller Elemente des
      Types
      &lt;code&gt;Person&lt;/code&gt;
      in
      &lt;code&gt;Mitarbeiter&lt;/code&gt;
      um.
     &lt;/li&gt;
     &lt;li&gt;
      Im
      &lt;code&gt;select&lt;/code&gt;
      -Ausdruck der Schablone ist in diesem Beispiel
      die in XSLT optionale
      &lt;code&gt;descendant&lt;/code&gt;
      -Achse (
      &lt;code&gt;//&lt;/code&gt;
      ) mit angegeben.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;copy-of&lt;/code&gt;
      übernimmt ein vollständiges Element
      einschließlich der Auszeichnungssymbole
      unverändert in die Ausgabe.
     &lt;/li&gt;
     &lt;li&gt;
      Des weiteren wird im
      &lt;code&gt;select&lt;/code&gt;
      -Attribut des
      &lt;code&gt;copy-of&lt;/code&gt;
      -Elements die
      &lt;code&gt;child&lt;/code&gt;
      -Achse verwendet.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die Schablone erstellt eine Knotenmenge mit
       Personen-Knoten.
      &lt;/li&gt;
      &lt;li&gt;
       Würde die
       &lt;code&gt;child&lt;/code&gt;
       -Achse nicht angegeben und stattdessen die
       &lt;code&gt;self&lt;/code&gt;
       -Achse verwendet, würden auch die
       Personen-Knoten selbst in die Ausgabe
       übernommen werden.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      (
      &lt;a href="transformationsergebnis-6.txt"&gt;
       Download des Transformationsergebnisses)
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Wie funktionieren Abbildungen?&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Alle XSLT-Elemente (
      &lt;code&gt;xsl:......&lt;/code&gt;
      ) in der Schablone stellen Anweisungen dar.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Sie werden ausgeführt und haben ein
       bestimmtes Verhalten.
      &lt;/li&gt;
      &lt;li&gt;
       Ihre Ergebnisse werden in den Ergebnisbaum
       übernommen.
      &lt;/li&gt;
      &lt;li&gt;
       &lt;code&gt;apply-templates&lt;/code&gt;
       hat eine Sonderrolle - es wählt Knoten aus,
       die verarbeitet werden sollen.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Alle nicht-XSLT-Elemente werden als sogenannte
      &lt;em&gt;Literale Ergebniselemente&lt;/em&gt;
      betrachtet.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Sie werden als Elementknoten in den
       Ergebnisbaum übernommen.
      &lt;/li&gt;
      &lt;li&gt;
       Ihr Inhalt wird vom XSLT-Prozessor weiter
       verarbeitet.
      &lt;/li&gt;
      &lt;li&gt;
       Sie können XSLT-Elemente oder
       nicht-XSLT-Elemente beinhalten.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;
      Ein XSLT-Programm besteht aus mehreren
      Schablonen.
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Die einzelnen Schablonen bilden jeweils
       Teilbäume des Quelldokuments ab.
      &lt;/li&gt;
      &lt;li&gt;
       Das
       &lt;code&gt;match&lt;/code&gt;
       -Attribute definiert, welche Knoten des
       Quelldokuments durch ein Template bearbeitet
       werden. Für jeden Knoten, der so ausgewählt
       wird, wird die Schablone ausgeführt /
       angewendet. Der jeweils ausgewählte Knoten
       stellt den Kontext für die Ausführung der
       Schablone dar (d.h. XPath-Ausdrücke
       innerhalb der Schablone werden relativ zu
       diesem Knoten ausgewertet).
      &lt;/li&gt;
      &lt;li&gt;
       Der Abbildungsprozess wird im Prinzip durch
       das Quelldokument gesteuert.
      &lt;/li&gt;
      &lt;li&gt;
       Dies benötigt eine gewisse Einarbeitungszeit
       des Programmierers.
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Schablonenauswahl&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Schablonen können durch folgende Ausdrücke
      miteinander verbunden werden
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       &lt;code&gt;xsl:apply-templates&lt;/code&gt;
       wählt zunächst die Knoten aus, die
       verarbeitet werden sollen.
      &lt;/li&gt;
      &lt;li&gt;
       Der XSLT Prozessor wählt die
       &lt;q&gt;am besten geeignete&lt;/q&gt;
       Schablone und führt sie aus.
      &lt;/li&gt;
      &lt;li&gt;
       Wenn es keine explizite Schablone gibt wird
       stattdessen eine der vordefinierten
       Schablonen verwendet.
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        Für Elemente wird der
        zeichenketten-artige Elementinhalt als
        Text in die Ausgabe übernommen.
       &lt;/li&gt;
       &lt;li&gt;
        Für Attribute wird der normalisierte
        Attributwert als Text in die Ausgabe
        übernommen.
       &lt;/li&gt;
       &lt;li&gt;
        Textknoten werden als Text in die
        Ausgabe übernommen (vgl. erstes Beispiel
        zu XSLT).
       &lt;/li&gt;
       &lt;li&gt;
        Processing-Instructions, Kommentare und
        Namensraumknoten werden ignoriert.
       &lt;/li&gt;
      &lt;/ul&gt;
      &lt;li&gt;
       XSLT unterstützt inkrementelle Entwicklung.
      &lt;/li&gt;
      &lt;ul&gt;
       &lt;li&gt;
        Es ist immer möglich, dem Programm
        spezialisiertere Schablonen
        hinzuzufügen.
       &lt;/li&gt;
       &lt;li&gt;
        Die anderen Schablonen müssen dazu nicht
        geändert werden.
       &lt;/li&gt;
      &lt;/ul&gt;

     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Konfliktauflösung (1/5)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Konflikte zwischen den Schablonen sind
      Bestandteil der Sprache
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Jede anwenderdefinierte Schablone steht im
       Wettbewerb zu einer vordefinierten
       Schablone.
      &lt;/li&gt;
      &lt;li&gt;
       Konfliktauflösung ist ein grundlegendes
       Konzept in XSLT.
      &lt;/li&gt;
     &lt;/ul&gt;
     &lt;li&gt;Wenn mehrere Schablonen zutreffen...&lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       ... dann wird in vielen Fällen die
       &lt;q&gt;spezifischste&lt;/q&gt;
       Schablone ausgewählt. (Daumenregel)
      &lt;/li&gt;
      &lt;li&gt;Die Transformation&lt;/li&gt;
      &lt;listing src="siebtes-xslt.xsl"&gt;&lt;/listing&gt;
      &lt;li&gt;liefert folgendes Ergebnis:&lt;/li&gt;
      &lt;listing src="ergebnis-konfliktloesung.xml"&gt;&lt;/listing&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Konfliktauflösung (2/5)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Grundlage für diese Auswahl ist die Berechnung
      einer internen Priorität für jede Schablone.
     &lt;/li&gt;
     &lt;li&gt;
      Die Schablone mit der höchsten Priorität
      gewinnt.
     &lt;/li&gt;
     &lt;li&gt;
      Für die Berechnung der Priorität gelten unter
      anderem folgende
      &lt;a
       href="http://www.w3.org/TR/xslt20/#conflict"&gt;
       Regeln
      &lt;/a&gt;
      .
     &lt;/li&gt;
     &lt;ul&gt;
      &lt;li&gt;
       Mit
       &lt;code&gt;oder&lt;/code&gt;
       verknüpfte XPath-Ausdrücke im
       &lt;code&gt;match&lt;/code&gt;
       -Attribut werden als verschiedene
       unterschiedliche Schablonen behandelt.
      &lt;/li&gt;
      &lt;li&gt;
       Der Wildcard-Ausdrück
       &lt;code&gt;*&lt;/code&gt;
       erhält die Priorität
       &lt;code&gt;-0.5&lt;/code&gt;
      &lt;/li&gt;
      &lt;li&gt;
       Qualifizierte Namen und Processing
       Instructions erhalten die Priorität
       &lt;code&gt;0&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Schablonen mit XPath Ausdrücken, die nach
       Elementnamen und -typen auswählen, erhalten
       die Priorität
       &lt;code&gt;0.25&lt;/code&gt;
       .
      &lt;/li&gt;
      &lt;li&gt;
       Spezifischere Ausdrücke (z.B. Ausdrücke mit
       Prädikaten sowie Ausdrücke, die Vorfahren
       beinhalten) erhalten die Priorität
       &lt;code&gt;0.5&lt;/code&gt;
      &lt;/li&gt;
     &lt;/ul&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Konfliktauflösung (3/5)&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Desweiteren haben aus anderen Stylesheets
      importierte Schablonen einen niedrigere
      Priorität als die im aktuellen Stylesheet
      definierten.
     &lt;/li&gt;
     &lt;img
      src="xslt-import-precedence.png"
      style="margin : 4% ; width : 90% ; "&gt;
     &lt;/img&gt;
     &lt;p&gt;
      Quelle:
      &lt;a
       href="http://dret.net/lectures/xml-fall07/"&gt;
       XML-Vorlesung
      &lt;/a&gt;
      von
      &lt;a href="http://dret.net/netdret/"&gt;
       Erik Wilde
      &lt;/a&gt;
     &lt;/p&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Konfliktauflösung (4/5)- Beispiel&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;Gegeben sei folgendes Eingabedokument&lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="conflict-resolution.xml"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Wendet man hierauf die folgende Transformation
      an...
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing src="conflict-resolution.xsl"&gt;&lt;/listing&gt;
    &lt;ul&gt;
     &lt;li&gt;
      ...so erhält man vom XSLT-Prozessor folgende
      Fehlermeldung:
     &lt;/li&gt;
    &lt;/ul&gt;
    &lt;listing
     src="fehler-bei-konflikt.txt"
     line="3-7"&gt;
    &lt;/listing&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Konfliktauflösung (5/5)- manuelle Angabe von
     Prioritäten
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      In den seltenen Fällen, in denen der Prozessor
      Konflike nicht selbst auflösen kann, ist
      manuelles Eingreifen nötig.
     &lt;/li&gt;
     &lt;li&gt;
      Zu diesem Zweck können für Schablonen explizit
      Prioritäten angegeben werden.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;code&gt;
       &amp;lt;xsl:template match="..."
       priority="1"&amp;gt;
      &lt;/code&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Folgendes Listing ist leicht abgeändert zum
      vorherigen Beispiel. Es gibt auf der
      Kommandozeile (
      &lt;code&gt;xsl:message&lt;/code&gt;
      ) aus, welche Schablone für die Transformation
      verwendet wurde.
     &lt;/li&gt;
     &lt;listing src="conflict-resolution-priority.xsl"&gt;&lt;/listing&gt;
     &lt;li&gt;Der Aufruf des Templates...&lt;/li&gt;
     &lt;listing
      src="conflict-resolution-ausgabe-mit-message.xml"
      line="3"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      ...erzeugt folgende Ausgabe auf der
      Kommandozeile:
     &lt;/li&gt;
     &lt;listing
      src="conflict-resolution-ausgabe-mit-message.xml"
      line="4"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;
   &lt;slide&gt;
    &lt;title&gt;Tracing-Information&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Eine andere Möglichkeit, die einzelnen Schritte
      des XSLT Prozessors Saxon nachzuverfolgen, ist
      es, mit dem Schalter
      &lt;code&gt;-T&lt;/code&gt;
      die Ausgabe von Tracing-Information zu
      aktivieren.
     &lt;/li&gt;
     &lt;li&gt;Der Aufruf...&lt;/li&gt;
     &lt;listing
      src="conflict-resolution-trace.xml"
      line="2-3"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      ...erzeugt folgende Ausgabe auf der
      Kommandozeile:
     &lt;/li&gt;
     &lt;listing
      src="conflict-resolution-trace.xml"
      line="4-15"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     &lt;em&gt;shallow copy&lt;/em&gt;
     von Elementen
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Folgendes Beispiel erweitert die letzten
      Transformation der Projektverwaltung um zwei
      weitere Schablonen.
     &lt;/li&gt;
     &lt;listing src="achtes-xslt.xsl"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Eine Schablone für alle
      &lt;code&gt;Qualifikationsprofil&lt;/code&gt;
      -Knoten, ohne Ersetzungsmuster. In der
      Konsequenz wird dieses Element sowie der
      Teilbaum darunter nicht in die Ausgabe
      übernommen.
     &lt;/li&gt;
     &lt;li&gt;
      Eine Schablone für alle anderen Knoten. Sie
      trifft auf alle Knoten außer dem Wurzelknoten zu
      (
      &lt;code&gt;node()&lt;/code&gt;
      -Funktion) sowie auf alle Attributeknoten (
      &lt;code&gt;attribute::*&lt;/code&gt;
      ).
     &lt;/li&gt;
     &lt;li&gt;
      Die zweite Schablone verwendet das Element
      &lt;code&gt;xsl:copy&lt;/code&gt;
      . Es übernimmt das aktuelle Element in das
      Ergebnis und läßt dabei eventuelle Kindelemente
      außer acht. Dies wird auch als
      &lt;em&gt;shallow copy&lt;/em&gt;
      bezeichnet
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Steuerung der Transformationsreihenfolge durch
     &lt;code&gt;apply-templates&lt;/code&gt;
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Standardmäßig durchläuft ein XSLT-Prozessor den
      aus dem Eingabedokument erzeugten Baum ausgehend
      vom Wurzelknoten in
      &lt;em&gt;preorder&lt;/em&gt;
      Reihenfolge und sucht die geeigneten Schablonen
      aus.
     &lt;/li&gt;
     &lt;li&gt;
      Es ist möglich, mit Hilfe des Befehls
      &lt;code&gt;xsl:apply-templates&lt;/code&gt;
      darauf Einfluß zu nehmen.
     &lt;/li&gt;
     &lt;li&gt;
      Trifft der Prozessor auf diesen Befehl, versucht
      er, weitere passende Schablonen zu den
      angegebenen XPath-Ausdrüken zu finden. Diese
      werden an der gegebenen Stelle ausgewertet
      (=Substitution).
     &lt;/li&gt;
     &lt;listing src="achtes-xslt.xsl"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Nachdem ein
      &lt;code&gt;Person&lt;/code&gt;
      en-Knoten in der Eingabe gefunden wurde und das
      öffnende Tag
      &lt;code&gt;Mitarbeiter&lt;/code&gt;
      ausgegeben wurde, wird nach weiteren Knoten im
      Eingabedokument gesucht, auf die Schablonen im
      XSLT-Programm zutreffen.
     &lt;/li&gt;
     &lt;li&gt;
      Dies ist für alle Attribute und Kindknoten von
      Person der Fall, da sie durch den
      Lokalisierungspfad
      &lt;code&gt;attribute::*|node()&lt;/code&gt;
      zugänglich sind.
     &lt;/li&gt;
     &lt;li&gt;
      So wird innerhalb des neu erzeugten Elements
      Mitarbeiter des Ausgabestroms das
      Ersetzungsmuster ausgeführt, das die Elemente
      und Attribute mit ihren Inhalten unverändert
      übernimmt.
     &lt;/li&gt;
     &lt;li&gt;
      Als Besonderheit nutzt das
      &lt;code&gt;apply-templates&lt;/code&gt;
      -Element im „allgemeinen“ (dritten) Template das
      Attribut
      &lt;code&gt;select&lt;/code&gt;
      . Es erlaubt dem Programmierer, die Knoten
      auszuwählen, für die nach weiteren passenden
      Schablonen gesucht werden soll.
     &lt;/li&gt;
     &lt;li&gt;
      &lt;a href="transformationsergebnis-8.txt"&gt;
       Download des Transformationsergebnisses
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;listing src="transformationsergebnis-8.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Benannte Ersetzungsschablonen und Parameterübergabe
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Es ist in XSLT auch möglich, benannte Schablonen
      ohne
      &lt;code&gt;match&lt;/code&gt;
      -Attribut zu definieren.
     &lt;/li&gt;
     &lt;li&gt;
      Diese werden vom Prozessor nicht automatisch
      aufgerufen, sondern müssen explizit durch den
      Befehl
      &lt;code&gt;xsl:call-template&lt;/code&gt;
      aufgerufen werden.
     &lt;/li&gt;
     &lt;li&gt;
      Dies entspricht Funktionsaufrufen in anderen
      Programmiersprachen.
     &lt;/li&gt;
     &lt;li&gt;
      Die Definition benannter Schablonen beinhaltet
      statt des
      &lt;code&gt;match&lt;/code&gt;
      -Attributs einen eindeutigen Namen.
     &lt;/li&gt;
     &lt;listing
      src="benannte-schablonen.xsl"
      line="3-4"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Des weiteren können Parameter an (benannte und
      unbenannte) Schablonen übergeben werden.
     &lt;/li&gt;
     &lt;li&gt;
      Als Parameter können beliebige
      Dokumentbestandteile als Knotenmenge, Ergebnisse
      von Funktionsausdrücken oder Konstanten
      übergeben werden.
     &lt;/li&gt;
     &lt;li&gt;
      Eine Parameterrückgabe ist nicht möglich, sie
      wird durch den Anteil der Schablone an der
      Ausgabe realisiert.
     &lt;/li&gt;
     &lt;listing
      src="benannte-schablonen.xsl"
      line="8-10"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;Beispiel Parameterübergabe&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das folgende Beispiel definiert eine Schablone
      für einen numerierten Block. Der Parameter gibt
      das Format der Numerierung an.
     &lt;/li&gt;
     &lt;listing
      src="benannte-schablonen.xsl"
      line="12-24"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Der Elementinhalt
      &lt;code&gt;1.&lt;/code&gt;
      des Elements
      &lt;code&gt;xsl:param&lt;/code&gt;
      innerhalb der Schablone namens
      &lt;code&gt;numbered-block&lt;/code&gt;
      dient als
      &lt;em&gt;Vorgabewert&lt;/em&gt;
      für den
      &lt;code&gt;format&lt;/code&gt;
      -Parameter. Wird in der Parameterübergabe kein
      Wert definiert, dann wird dieser Vorgabewert
      verwendet.
     &lt;/li&gt;
     &lt;li&gt;
      In unserem Fall wird in der ersten Schablone
      jedoch der Wert
      &lt;code&gt;a.&lt;/code&gt;
      übergeben, als Inhalt des
      &lt;code&gt;format&lt;/code&gt;
      -Parameters
      &lt;code&gt;xsl:with-param&lt;/code&gt;
      . Der übergebene Wert
      &lt;q&gt;sticht&lt;/q&gt;
      den vorgegebenen Wert.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Bedingte Verarbeitung (1/2) -
     &lt;code&gt;xsl:if&lt;/code&gt;
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mit Hilfe der
      &lt;code&gt;xsl:if&lt;/code&gt;
      -Anweisung ist es möglich, bedingte Anweisungen
      in XSLT-Programmen zu nutzen.
     &lt;/li&gt;
     &lt;li&gt;
      Der Inhalt der
      &lt;code&gt;xsl:if&lt;/code&gt;
      -Anweisung wird nur dann vom Prozessor
      bearbeitet, wenn die im
      &lt;code&gt;test&lt;/code&gt;
      -Attribut formulierte Boole'sche Bedingung wahr
      ist
     &lt;/li&gt;
     &lt;li&gt;Die Syntax ist wie folgt:&lt;/li&gt;
     &lt;listing
      src="xsl-if.xsl"
      line="3"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Nachfolgendes Beispiel zeigt, wie die Anweisung
      angewendet werden kann. Für
      &lt;code&gt;Person&lt;/code&gt;
      en, die mehr als einen
      &lt;code&gt;Vorname&lt;/code&gt;
      n haben, wird auf der Kommandozeile der
      angegebene Text (unter Auswertung des Inhalts
      von
      &lt;code&gt;Nachname&lt;/code&gt;
      ) ausgegeben.
      &lt;br /&gt;
      Besonderheit: Der Vergleichs-Operator
      &lt;code&gt;&amp;gt;&lt;/code&gt;
      wird durch die Zeichenfolge
      &lt;code&gt;&amp;amp;gt;&lt;/code&gt;
      ersetzt, da Auszeichnunssymbole in
      Attributwerten in XML bekanntermaßen nicht
      erlaubt sind.
     &lt;/li&gt;
     &lt;listing src="xsl-if-2.xsl"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Die Ausgabe auf der Kommandozeile ist wie folgt:
     &lt;/li&gt;
     &lt;listing
      src="ergebnis-xsl-if-2-kommandozeile.txt"
      line="3-4"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Angewendet auf die Projektverwaltung erhält man
      folgendes Ergebnis (unverändert zum
      &lt;a href="xslt.html#(27)"&gt;vorherigen Beispiel&lt;/a&gt;
      ):
     &lt;/li&gt;
     &lt;listing src="ergebnis-xsl-if-2.txt"&gt;&lt;/listing&gt;
    &lt;/ul&gt;


   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Bedingte Verarbeitung (2/2) -
     &lt;code&gt;xsl:choose&lt;/code&gt;
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Mit Hilfe der
      &lt;code&gt;xsl:choose&lt;/code&gt;
      -Anweisung wird Mehrfachselektion möglich.
     &lt;/li&gt;
     &lt;li&gt;
      Außerdem kann damit eine einfache
      &lt;code&gt;if-then-else&lt;/code&gt;
      -Struktur abgebildet werden.
     &lt;/li&gt;
     &lt;li&gt;Die Syntax ist wie folgt:&lt;/li&gt;
     &lt;listing
      src="xsl-choose.xsl"
      line="3-11"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Ein Beispiel: Gegeben sei folgendes
      Quelldokument, das die Bevölkerungszahl der
      europäischen Länder in Millionen Einwohner
      versammelt:
     &lt;/li&gt;
     &lt;listing src="europe-nations.xml"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Folgende Transformation verwendet die
      &lt;code&gt;xsl:choose&lt;/code&gt;
      -Anweisung um abhängig von der Bevölkerungszahl
      des jeweiligen Landes den Namen des Landes
      auszugeben oder den Text
      &lt;code&gt;(-- zu klein --)&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;listing src="europe-nations.xsl"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Die Transformation liefert folgendes Ergebnis:
     &lt;/li&gt;
     &lt;listing src="ergebnis-nations.txt"&gt;&lt;/listing&gt;
     &lt;li&gt;
      Quelle:
      &lt;a
       href="http://europa.eu/abc/keyfigures/sizeandpopulation/howmany/index_de.htm"&gt;
       Webseite der Europäischen Union
      &lt;/a&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Beispiel angelehnt an
      &lt;a
       href="http://www.oreilly.com/catalog/learnxslt/"&gt;
       &lt;em&gt;Fitzgerald, Michael&lt;/em&gt;
       : Learning XSLT, A Hands-On Introduction to
       XSLT and XPath, O-Reilly-Verlag, 2004, S.
       212ff.
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Ein umfangreiches Beispiel - Erzeugen eines
     XHTML-Reports aus der erweiterten Projektverwaltung
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Das Beispiel wird nachfolgend Schritt für
      Schritt aufgebaut und erklärt.
     &lt;/li&gt;
     &lt;li&gt;
      Als erstes wird der XHTML-Dokumentrahmen bei
      Auftreten des Dokumentknotens (Suchmuster
      &lt;code&gt;/&lt;/code&gt;
      ) erzeugt.
     &lt;/li&gt;
     &lt;li&gt;
      Nach dem öffnenden XHTML-Rumpfelement
      &lt;code&gt;body&lt;/code&gt;
      werden innerhalb des Quelldokuments beliebige
      weitere Knoten gesucht, die auf eines der
      angegebenen Suchmuster passen (
      &lt;code&gt;xsl:apply-templates&lt;/code&gt;
      ).
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="1-16"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Die nächste Schablone erzeugt beim Auftreten des
      Knotens
      &lt;code&gt;ProjektVerwaltung&lt;/code&gt;
      ein paar Überschriftszeilen und der Kopf einer
      XHTML-Tabelle.
     &lt;/li&gt;
     &lt;li&gt;
      Die Tabelle besteht aus den Elementen
      &lt;code&gt;table&lt;/code&gt;
      und der Kopfzeile (eingeschlossen durch
      &lt;code&gt;tr&lt;/code&gt;
      )
     &lt;/li&gt;
     &lt;li&gt;
      Den Rumpf der Tabelle schreibt ein anderes
      Template. Dieses wird jedoch nicht direkt
      aufgerufen, sondern der Prozeß der Ermittlung
      neuer „passender“ Knoten neu initiiert; jedoch
      auf Knoten vom Typ
      &lt;code&gt;Projekt&lt;/code&gt;
      beschränkt (
      &lt;code&gt;select&lt;/code&gt;
      -Attribut des
      &lt;code&gt;apply-templates&lt;/code&gt;
      -Elements).
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="18-28"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Die Schablone für
      &lt;code&gt;Projekt&lt;/code&gt;
      speichert zunächst den Inhalt des Attributs
      &lt;code&gt;Projektleiter&lt;/code&gt;
      in einer Variable namens
      &lt;code&gt;prjLeiter&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Anschließend wird die in der
      &lt;code&gt;Projektverwaltung&lt;/code&gt;
      geöffnete Tabelle befüllt.
     &lt;/li&gt;
     &lt;li&gt;
      Hierzu wird in die erste Spalte der Tabelle (mit
      dem Titel
      &lt;code&gt;Projektnummer&lt;/code&gt;
      ) die
      &lt;code&gt;ID&lt;/code&gt;
      des jeweiligen Projektes geschrieben. Sie wird
      in einen Anker (
      &lt;code&gt;a&lt;/code&gt;
      ) eingebettet, dessen
      &lt;code&gt;name&lt;/code&gt;
      -Attribut ebenfalls die
      &lt;code&gt;ID&lt;/code&gt;
      des Projektes als Wert erhält. Dies dient einer
      späteren Verlinkung.
     &lt;/li&gt;
     &lt;li&gt;
      In die zweite Spalte der Tabelle (mit dem Titel
      &lt;code&gt;Projektleiter&lt;/code&gt;
      ) wird der
      &lt;code&gt;Nachname&lt;/code&gt;
      derjenigen
      &lt;code&gt;Person&lt;/code&gt;
      geschrieben, deren ID (Wert des Attributs
      &lt;code&gt;PersID&lt;/code&gt;
      ) mit dem Wert der zuvor angelegten Variablen
      &lt;code&gt;prjLeiter&lt;/code&gt;
      übereinstimmt.
     &lt;/li&gt;
     &lt;li&gt;
      Dies ist in einen Hyperlink eingebettet,
      seinSprungziel ist ein aus dem Nachnamen durch
      die Funktion
      &lt;code&gt;generate-id()&lt;/code&gt;
      generierter eindeutiger ID-Wert.
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="40-56"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Der zweite Teil der Schablone der
      &lt;code&gt;ProjektVerwaltung&lt;/code&gt;
      erzeugt eine Tabelle für die Personen der
      Projektverwaltung.
     &lt;/li&gt;
     &lt;li&gt;
      Nach einer weiteren Überschrift wieder wieder
      der Kopf einer Tabelle erzeugt.
     &lt;/li&gt;
     &lt;li&gt;
      Der Rumpf wird wie oben durch ein anderes
      Template befüllt, diesmal auf Knoten vom Typ
      &lt;code&gt;Person&lt;/code&gt;
      beschränkt.
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="30-37"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Die Ersetzungsregel für
      &lt;code&gt;Person&lt;/code&gt;
      speichert zunächst den Inhalt des Attributs
      &lt;code&gt;PersID&lt;/code&gt;
      in einer Variable.
     &lt;/li&gt;
     &lt;li&gt;
      Dann wird wieder die in der
      &lt;code&gt;Projektverwaltung&lt;/code&gt;
      geöffnete Tabelle befüllt.
     &lt;/li&gt;
     &lt;li&gt;
      Hierzu werden für die erste Spalte der Tabelle
      nacheinander die Schablonen für Knoten des Typs
      &lt;code&gt;Vorname&lt;/code&gt;
      bzw.
      &lt;code&gt;Nachname&lt;/code&gt;
      aktiviert.
     &lt;/li&gt;
     &lt;li&gt;
      Die zweite Spalte der Tabelle enthält einen
      XHTML-Hyperlink zu den durch den Mitarbeiter
      bearbeiteten
      &lt;code&gt;Projekt&lt;/code&gt;
      en. Als Sprungziel wird hierbei der Inhalt des
      Attributs
      &lt;code&gt;mitarbeitInProjekt&lt;/code&gt;
      eingetragen.
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="58-70"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Die Schablonen für die Knoten
      &lt;code&gt;Vorname&lt;/code&gt;
      und
      &lt;code&gt;Nachname&lt;/code&gt;
      geben im Wesentlichen den Wert des Knotens aus,
      der zweite Vorname fügt ein Leerzeichen vor der
      Textausgabe ein. Für
      &lt;code&gt;Nachname&lt;/code&gt;
      wird ein Anker mit der automatisch generierten
      ID für den Wert des Knotens generiert (das
      Sprungziel des in der Schablone für
      &lt;code&gt;Projekt&lt;/code&gt;
      generierten Hyperlinks).
     &lt;/li&gt;
     &lt;listing
      src="projektverwaltung_v2.xsl"
      line="72-85"&gt;
     &lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;
     Ein umfangreiches Beispiel - komplettes Listing
    &lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Nachfolgend sind das komplette XSLT-Programm und
      das Ergebnis aufgeführt.
     &lt;/li&gt;
     &lt;listing src="projektverwaltung_v2.xsl"&gt;&lt;/listing&gt;
     &lt;listing src="projektverwaltung.htm"&gt;&lt;/listing&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;

   &lt;slide&gt;
    &lt;title&gt;XSLT und XSL-FO&lt;/title&gt;
    &lt;ul&gt;
     &lt;li&gt;
      XSLT ist eine XML-basierte Programmiersprache,
      um beliebiges XML in beliebiges XML zu
      transformieren.
     &lt;/li&gt;
     &lt;li&gt;
      XSL-FO ist eine XML-Sprache, die Formatierungen
      für Dokumente beschreibt.
     &lt;/li&gt;
     &lt;li&gt;Gehen wir von folgendem XML-Dokument aus&lt;/li&gt;
     &lt;listing
      src="xslt-and-xslfo.xml"
      line="2-13"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      Gewünscht ist nun eine Transformation nach
      XSL-FO. Dies wird mit Hilfe von XSLT
      bewerkstelligt. Ein Auszug aus einem
      entsprechenden XSLT-Programm könnte so aussehen:
     &lt;/li&gt;
     &lt;listing
      src="xslt-and-xslfo.xml"
      line="15-28"&gt;
     &lt;/listing&gt;
     &lt;li&gt;
      (Quelle:
      &lt;a
       href="http://www.w3.org/Style/XSL/WhatIsXSL.html"&gt;
       What is XSL
      &lt;/a&gt;
      -Webseite des W3C)
     &lt;/li&gt;
     &lt;li&gt;
      XSL-FO ist also ein mögliches
      &lt;b&gt;Ausgabeformat&lt;/b&gt;
      , das mit Hilfe von XSLT erzeugt werden kann.
     &lt;/li&gt;
     &lt;li&gt;
      Ein weiteres mögliches Ausgabeformat wäre XHTML.
     &lt;/li&gt;
     &lt;li&gt;
      Es sind aber beliebige XML-Vokabulare mit XSLT
      erzeugbar.
     &lt;/li&gt;
     &lt;li&gt;
      Das nachfolgende Bild verdeutlicht nochmals den
      Zusammenhang.
     &lt;/li&gt;
     &lt;img
      src="xslt-und-xslfo.png"
      style="margin : 4% ; width : 90% ; "&gt;
     &lt;/img&gt;
    &lt;/ul&gt;
   &lt;/slide&gt;


  &lt;/part&gt;
 &lt;/presentation&gt;
 &lt;!-- XSLT --&gt;



 &lt;!-- XFORMS --&gt;
 &lt;presentation id="xforms"&gt;
  &lt;title short="xforms"&gt;XForms&lt;/title&gt;
  &lt;date&gt;2009-01-12&lt;/date&gt;
  &lt;toc id="resources"&gt;
   &lt;a
    href="file:///C:/downloads/w3.org/www.w3.org/TR/2006/REC-xforms-20060314/index.html"&gt;
    W3C XForms Spezifikation
   &lt;/a&gt;
   &lt;a href="https://addons.mozilla.org/de/firefox/addon/824"&gt;
    XForms Plugin für Firefox
   &lt;/a&gt;
  &lt;/toc&gt;
  &lt;toc id="abstract"&gt;
   Mit XForms entwickelt das W3C die nächste Generation von
   Web-Formularen. Ziel dabei ist es, die Komplexität
   beherrschbar zu machen, die notwendige Dynamik zu
   unterstützen, multimodale Interaktion zu unterstützen und
   Geräteunabhängigkeit zu garantieren.
  &lt;/toc&gt;
  &lt;slide&gt;
   &lt;title&gt;Abstract&lt;/title&gt;
   &lt;p class="abstract"&gt;
    &lt;toc id="abstract"&gt;&lt;/toc&gt;
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms&lt;/title&gt;
   &lt;p class="definition"&gt;
    Formulare im Web werden hinsichtlich der immer weiter
    getriebenen Entwicklung von interaktiven
    Web-Applikationen immer wichtiger.
    &lt;br /&gt;
    &lt;em&gt;XForms&lt;/em&gt;
    sind eine Weiterentwicklung der für HTML definierten
    Formulare, sie basieren auf XML. Der Begriff
    &lt;em&gt;XForms&lt;/em&gt;
    versammelt zunächst zwei Teilbereiche unter sich,
    nämlich das
    &lt;em&gt;XForms-Modell&lt;/em&gt;
    sowie das
    &lt;em&gt;XForms User Interface&lt;/em&gt;
    . Dadurch wird, im Gegensatz zu den hergebrachten HTML
    Web-Formularen, die Trennung von Inhalt und Präsentation
    des Formulars ermöglicht. Modell und User-Interface
    gehen dabei Hand in Hand.
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    XForms - Zusammenspiel mit verschiedenen
    Benutzerschnittstellen
   &lt;/title&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-arch-1.png" /&gt;

   &lt;p&gt;
    Ein Formularmodell, das durch ein
    &lt;em&gt;XForms Modell&lt;/em&gt;
    beschrieben ist, kann mit unterschiedlichen
    Benutzerschnittstellen zusammenarbeiten.
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;em&gt;XForms User Interface&lt;/em&gt;
     :
     &lt;br /&gt;
     eine Menge von Kontrollelementen, die direkt in
     XHTML- und andere XML-Dokumente (z.B: SVG)
     eingebunden werden können. Sie sollen die
     hergebrachten XHTML Formularkontrollelemente
     ersetzen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;XHTML Formularelemente&lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;em&gt;WML-Formularelemente&lt;/em&gt;
     :
     &lt;br /&gt;
     analog zur HTML existieren Formularelemente auch in
     der sogenannten
     &lt;em&gt;Wireless Markup Language&lt;/em&gt;
     , einer Auszeichnungssprache, die auf die
     Darstellung von Web-Inhalten auf mobilen Endgeräten
     abzielt.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - Datenhaltung&lt;/title&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-arch-2.png" /&gt;

   &lt;p&gt;
    Ein XForms-Formular sammelt in erster Linie Daten. Diese
    Daten werden in Form von XML gehalten (sog.
    &lt;em&gt;Instanzdaten&lt;/em&gt;
    ). Die Struktur dieser Daten wird durch das
    XForms-Modell beschrieben.
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;Strukturierter Datenaustausch&lt;/li&gt;
    &lt;li&gt;
     Unterstützung von (vordefinierten) Arbeitsabläufen
    &lt;/li&gt;
    &lt;li&gt;Automatische Vervollständigung von Daten&lt;/li&gt;
    &lt;li&gt;Vorbefüllung von Formularfeldern&lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Datenaustausch der Instanzdaten zum und vom
    XForms-Prozessor über
    &lt;em&gt;XForms Submit Protocol&lt;/em&gt;
    : definiert, wie XForms Daten senden und empfangen.
    &lt;br /&gt;
    Vervollständigung eines Formulars kann angehalten und
    wieder aufgenommen werden.
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - Motivation&lt;/title&gt;
   &lt;p&gt;
    Die Entwicklung von
    &lt;em&gt;XForms&lt;/em&gt;
    als Weiterentwicklung der HTML Formulare versuchte
    mehrere Defizite der HTML-Formulare zu beheben:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Wiederverwendung von Formularen: Trennung der im
     Formular gesammelten Daten von den
     Kontrollelementen, die diese Daten sammeln. Das
     Formular ist nicht länger untrennbar mit der Seite,
     in der es verwendet wird, verbunden.
    &lt;/li&gt;
    &lt;li&gt;
     Unabhängigkeit in der Verwendung: XForms nicht
     ausschließlich an (X)HTML gebunden, sondern auch in
     anderen Sprachen verwendbar.
    &lt;/li&gt;
    &lt;li&gt;
     Starke Typisierung: Die in den Formularen
     übertragenene Daten sind stark typisiert und können
     somit bereits bei der Eingabe auf Clientseite leicht
     geprüft werden, sie müssen zur Validierung nicht
     erst zum Server übertragen werden.
    &lt;/li&gt;
    &lt;li&gt;
     Übertragung in Form von XML: Daten können direkt vom
     Server an die Backend-Applikationen weitergereicht
     werden, ein evtl. Zeischenformat zur Übertragung an
     die Applikation kann entfallen.
    &lt;/li&gt;
    &lt;li&gt;
     Verbesserte Zugreifbarkeit: separierte
     Kontrollelemente kapseln alle wichtigen Metadaten
     wie Formular
     &lt;q&gt;labels&lt;/q&gt;
     . Die Realisierung verschiedener
     Eingabemöglichkeiten wird hiermit erleichtert.
    &lt;/li&gt;
    &lt;li&gt;
     Unterstützung vielfältiger Endgeräte: Beschreibung
     der Kontrollelemente auf hoher Abstraktionsebene
     erleichtert Benutzung der Formulare auf
     verschiedenenen Endgeräten (z.B. Spracheingabe).
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - ein Beispiel (1/5)&lt;/title&gt;
   &lt;p&gt;
    XForms-Formulare bestehen zunächst aus einem Teil, der
    das Formular selbst beschreibt: das XForms-Modell. In
    einem anderen Teil wird beschrieben, wie das Formular
    dargestellt wird.
   &lt;/p&gt;
   &lt;p&gt;
    Wir wollen uns anhand eines einfachen
    e-Commerce-Formulars den Aufbau erarbeiten. Das Formular
    soll ermitteln, ob per Vorkasse oder mit Kreditkarte
    bezahlt werden soll. Falls mit Kreditkarte bezahlt wird,
    soll die Kreditkartennummer und das Gültigkeitsdatum
    eingegeben werden.
   &lt;/p&gt;
   &lt;p&gt;
    Ein derartiges Formular könnte etwa wie folgt in einem
    XForms
    &lt;code&gt;model&lt;/code&gt;
    Element modelliert werden:
   &lt;/p&gt;
   &lt;listing src="xforms-example1.xml" /&gt;
   &lt;p&gt;
    Aussage: Im Formular werden drei Informationen
    gesammelt. Diese Informationen werden an die URL, die
    als Wert des
    &lt;code&gt;action&lt;/code&gt;
    -Attributs angegeben ist, übermittelt.
   &lt;/p&gt;
   &lt;p&gt;
    Achtung: Über die Datentypen im Formular wurden noch
    keine Aussagen getroffen!
   &lt;/p&gt;
   &lt;p&gt;
    Hinweis: in XHTML findet sich
    &lt;code&gt;model&lt;/code&gt;
    -Information zumeist innerhalb des
    &lt;code&gt;head&lt;/code&gt;
    -Elements.
   &lt;/p&gt;
   &lt;p&gt;
    Hinweis: Der Großteil der hier
    besprochenen Beispiele entstammt
    der 
    &lt;a href="http://www.w3.org/TR/2006/REC-xforms-20060314/index.html"&gt;XForms Spezifikation des W3C&lt;/a&gt;.
   &lt;/p&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - ein Beispiel (2/5)&lt;/title&gt;
   &lt;p&gt;
    In einem zweiten Schritt werden die Kontrollelemente im
    Formular vorgesehen und mit dem Modell verbunden. Die
    Verknüpfung mit dem Modell geschieht über den
    sogenannten
    &lt;em&gt;Bindemechanismus&lt;/em&gt;
    . In diesem einfachen Fall wird mit Hilfe des
    &lt;code&gt;ref&lt;/code&gt;
    -Attributs der Kontrollelemente auf die jeweilige
    Modellelemente referenziert.
   &lt;/p&gt;
   &lt;listing src="xforms-example2.xml" /&gt;
   &lt;p&gt;
    Die in XForms definierten Kontrollelemente zeichnen sich
    durch ihre Geräte- und Plattformunabhängigeit aus.
   &lt;/p&gt;
   &lt;p&gt;
    Hinweis: in XHTML findet sich diese Information
    innerhalb des
    &lt;code&gt;body&lt;/code&gt;
    -Elements.
   &lt;/p&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XForms - ein Beispiel (3/5)&lt;/title&gt;
   &lt;p&gt;Eigenschaften dieses Formularentwurfs:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     In der Benutzerschnittstelle werden nicht
     zwingenderweise
     &lt;em&gt;Radio Buttons&lt;/em&gt;
     verwendet. Andere Geräte (wie z.B. sprachbasierte
     Browser) können selbst entscheiden, wie sie das
     Konzept
     &lt;q&gt;select one&lt;/q&gt;
     darstellen.
    &lt;/li&gt;
    &lt;li&gt;
     Kontrollelemente haben immer
     &lt;q&gt;Labels&lt;/q&gt;
     als Kindelemente. So wird die Zugreifbarkeit
     verbessert.
    &lt;/li&gt;
    &lt;li&gt;
     Im Gegensatz zur HTML gibt es keine Notwendigkeit,
     Formulare in
     &lt;code&gt;form&lt;/code&gt;
     -Elemente einzubetten.
    &lt;/li&gt;
    &lt;li&gt;
     Im Vergleich zur HTML wurde das Markup für
     Kontrollfelder deutlich vereinfacht.
    &lt;/li&gt;
    &lt;li&gt;
     Die Art und Weise der Bindung von Kontrollfeldern an
     das Modell vereinfacht die Integration von XForms in
     andere Sprachen.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XForms - ein Beispiel (4/5)&lt;/title&gt;
   &lt;p&gt;
    Dargestellt in einem Web Browser, könnte das soeben
    modellierte Formular folgendermaßen aussehen:
   &lt;/p&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-arch-3.png" /&gt;

   &lt;p&gt;
    Für Firefox existiert ein Plugin, mit dem
    XForms-Formulare angezeigt werden können:
    &lt;a
     href="https://addons.mozilla.org/de/firefox/addon/824"&gt;
     Mozilla XForms Plugin
    &lt;/a&gt;
   &lt;/p&gt;

   &lt;p&gt;
    Wenn Sie dieses Plugin installiert haben, können Sie auf
    der hier verlinkten Seite sehen, wie das Formular in
    Firefox dargestellt wird:
    &lt;a href="xforms-example.xhtml"&gt;
     XHTML-Beispielseite mit einfachem XForms-Formular
    &lt;/a&gt;
   &lt;/p&gt;

  &lt;/slide&gt;
  &lt;slide&gt;
   &lt;title&gt;XForms - ein Beispiel (5/5)&lt;/title&gt;
   &lt;p&gt;
    Nehmen wir an, das soeben modellierte Formular ist
    Bestandteil einer Webseite und wurde von einem Benutzer
    ausgefüllt.
    &lt;br /&gt;
    Das zugehörige Instanzdokument, das dann vom
    XForms-Prozessor übertragen wird, kann folgendermaßen
    aussehen:
   &lt;/p&gt;
   &lt;listing src="xforms-example3.xml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    XForms - Statusinformation des Instanzdokuments
   &lt;/title&gt;
   &lt;p&gt;
    Mit Hilfe der Instanzdaten verfolgt ein XForms Prozessor
    den Zustand des Formulars, während es befüllt wird. Das
    Element
    &lt;code&gt;instance&lt;/code&gt;
    beinhaltet dabei im Wesentlichen ein
    &lt;q&gt;Skelettdokument&lt;/q&gt;
    , das aktualisiert wird, während der Benutzer das
    Formular ausfüllt. Wenn das Formular übermittelt wird,
    werden die Instanzdaten als XML-Dokument geschrieben
    (serialisiert).
   &lt;/p&gt;
   &lt;p&gt;Eine leichte Abwandlung des vorherigen Beispiels:&lt;/p&gt;
   &lt;listing src="xforms-example4.xml" /&gt;
   &lt;p&gt;könnte folgendermaßen übertragen werden:&lt;/p&gt;
   &lt;listing src="xforms-example5.xml" /&gt;
   &lt;p&gt;Folgende Eigenschaften fallen auf:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Die leeren Elemente
     &lt;code&gt;number&lt;/code&gt;
     und
     &lt;code&gt;expiry&lt;/code&gt;
     dienen als
     &lt;q&gt;Platzhalter&lt;/q&gt;
     in der XML Struktur. Sie werden mit den Daten, die
     der Benutzer im Formular angibt, befüllt.
    &lt;/li&gt;
    &lt;li&gt;
     In den Instanzdokumenten können sämtliche
     Strukturierungselemente der XML verwendet werden,
     inkl. Attribute und Namensräume.
    &lt;/li&gt;
    &lt;li&gt;
     Der Wert
     &lt;q&gt;cc&lt;/q&gt;
     wird mit Hilfe des Attributs
     &lt;code&gt;method&lt;/code&gt;
     in den Instanzdaten vorbefüllt. Wenn der Benutzer
     den Wert im Formular ändert, wird dieser Vorgabewert
     im übermittelten XML-Dokument durch den angegebenen
     Wert ersetzt.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Die Verknüpfung dieser Instanzdaten mit den
    Kontrollelementen erfolgt wieder mit Hilfe der
    sogenannten
    &lt;em&gt;Binding Expressions&lt;/em&gt;
    , die auf XPath basieren (vgl. Verwendung des
    &lt;code&gt;@&lt;/code&gt;
    -Zeichens zum Zugriff auf Attribute).
   &lt;/p&gt;
   &lt;listing src="xforms-example6.xml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    XForms - komplettes Beispiel mit vorbefüllten Werten
   &lt;/title&gt;
   &lt;listing src="xforms-example-2.xhtml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - Werte begrenzen&lt;/title&gt;
   &lt;p&gt;
    Mit XForms können Daten bereits auf Gültigkeit geprüft
    werden, sobald sie in das Formular eingegeben werden.
   &lt;/p&gt;
   &lt;p&gt;
    Wenn keine Information über die Datentypen im Formular
    vorliegen, wird für alle Felder der Datentyp
    &lt;em&gt;String&lt;/em&gt;
    angenommen.
   &lt;/p&gt;
   &lt;p&gt;
    Es ist jedoch möglich, den Werten in den Instanzdaten
    Typen zuzuweisen.
   &lt;/p&gt;
   &lt;p&gt;
    Im folgenden Beispiel sollen folgende Bechränkungen für
    unser Beispielformular implementiert werden:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Die Kontrollelemente für die Kreditkarten sind nur
     dann relevant, wenn im Formular diese Zahlweise
     ausgewählt wurde. Dann sind sie aber zwingend
     auszufüllen.
    &lt;/li&gt;
    &lt;li&gt;
     In
     &lt;code&gt;number&lt;/code&gt;
     sollen nur nur Zahlen als Eingabe erlaubt sein,
     diese dürfen zwischen 14 und 18 Ziffern lang sein.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;expiry&lt;/code&gt;
     soll nur gültige Kombinationen aus Monat und Datum
     enthalten
    &lt;/li&gt;
   &lt;/ul&gt;

   &lt;p&gt;
    &lt;em&gt;Model Item Properties&lt;/em&gt;
    erlauben es dem Autor eines Formulars, solche
    beschreibende Information, mit deren Hilfe die
    Gültigkeit eines Wertes bestimmt werden kann, anzugeben:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Information aus XML-Schema (Fragment), das in das
     Formular eingebettet ist oder extern verfügbar sein
     kann
    &lt;/li&gt;
    &lt;li&gt;
     XForms-Spezifische Eigenschaften für
     &lt;code&gt;bind&lt;/code&gt;
     -Elemente, wie z.B.
     &lt;code&gt;relevant&lt;/code&gt;
     .
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing src="xforms-example-7.xml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    XForms - komplettes Beispiel mit Wertebegrenzung und
    -überprüfung
   &lt;/title&gt;
   &lt;listing src="xforms-example-3.xhtml" /&gt;
  &lt;/slide&gt;


  &lt;slide&gt;
   &lt;title&gt;
    XForms - Verwendung mehrerer Formulare in einem Dokument
   &lt;/title&gt;
   &lt;p&gt;
    In einem Dokument kann eine uneingeschränkte Anzahl von
    einzelnen Formularen nebeneinander definiert sein.
   &lt;/p&gt;
   &lt;p&gt;
    Jedes dieser Formulare benötigt lediglich ein eigenes
    &lt;code&gt;model&lt;/code&gt;
    -Element mit einem
    &lt;code&gt;id&lt;/code&gt;
    -Attribut. So kann es von jeder Stelle des Dokuments aus
    referenziert werden.
   &lt;/p&gt;
   &lt;p&gt;
    Die Kontrollelemente müssen zusätzlich Information
    enthalten, welches
    &lt;code&gt;model&lt;/code&gt;
    -Element die Instanzdaten beinhaltet, mit denen das
    Kontrollelement verknüpft wird. Hierfür existiert ein
    &lt;code&gt;model&lt;/code&gt;
    - Attribut für das
    &lt;code&gt;binding&lt;/code&gt;
    -Element.
    &lt;br /&gt;
    Ist kein
    &lt;code&gt;model&lt;/code&gt;
    -Attribut angegeben, so wird das Modell verwendet, das
    bei einem (dem nächstgelegenen) Vorfahr im Dokument
    angegeben ist, andernfalls das erste Modell des gesamten
    Dokuments.
   &lt;/p&gt;

   &lt;p&gt;
    Für unser Beispielformular soll nun zusätzlich ein
    Formular angegeben werden, das eine Meinungsumfrage
    beinhaltet. Dazu wird das Modell des Formulars zunächst
    folgendermaßen erweitert:
   &lt;/p&gt;
   &lt;listing src="xforms-example-8.xml" /&gt;
   &lt;p&gt;Außerdem werden folgende Kontrollelemente benötigt:&lt;/p&gt;
   &lt;listing src="xforms-example-9.xml" /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Verwendung des
     &lt;code&gt;model&lt;/code&gt;
     -Attributs zur Referenzierung auf das
     Formularmodell, mit dem die Kontrollelemente
     verknüpft sind
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - XHTML-Seite mit mehreren Formularen&lt;/title&gt;
   &lt;listing src="xforms-example-4.xhtml" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms - Dokumentstruktur&lt;/title&gt;
   &lt;p&gt;Allgemeine Bedingungen für XForms-Dokumente&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     Alle XForms-Elemente eines Dokuments müssen sich im
     Namensraum
     &lt;code&gt;http://www.w3.org/2002/xforms&lt;/code&gt;
     befinden.
    &lt;/li&gt;
    &lt;li&gt;
     Verlinkung mit entfernten Ressourcen erfolgt mit
     Hilfe des
     &lt;code&gt;src&lt;/code&gt;
     -Attributs. Es wird angenommen, daß die so
     angegebenen Ressourcen zugreifbar sind.
    &lt;/li&gt;
    &lt;li&gt;
     Verknüpfungen werden mit Hilfe der Attribute
     &lt;code&gt;ref&lt;/code&gt;
     (XPath-Ausdruck),
     &lt;code&gt;model&lt;/code&gt;
     (ID eines Modells) und
     &lt;code&gt;bind&lt;/code&gt;
     (Verweis auf ein
     &lt;code&gt;bind&lt;/code&gt;
     -Element) ausgedrückt.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Ein XForms-Formular besteht aus folgenden
    Strukturelementen:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;model&lt;/code&gt;
     : kann die Kindelemente
     &lt;code&gt;instance&lt;/code&gt;
     ,
     &lt;code&gt;schema&lt;/code&gt;
     ,
     &lt;code&gt;submission&lt;/code&gt;
     ,
     &lt;code&gt;bind&lt;/code&gt;
     sowie Kindelemente der Elementmenge
     &lt;em&gt;Action&lt;/em&gt;
     enthalten
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;instance&lt;/code&gt;
     mit beliebigen Kindelementen
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;submission&lt;/code&gt;
     mit Kindelementen aus
     &lt;em&gt;Action&lt;/em&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;bind&lt;/code&gt;
     mit beliebigen Kindelementen
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Das
    &lt;code&gt;model&lt;/code&gt;
    -Element
   &lt;/title&gt;
   &lt;p&gt;
    &lt;code&gt;model&lt;/code&gt;
    entspricht einer Formulardefinition. Innerhalb dieses
    Elements werden die Elemente aufgezählt, die das
    XForms-Modell definieren. Es können beliebig viele
    &lt;code&gt;model&lt;/code&gt;
    -Elemente in einem Dokument enthalten sein.
   &lt;/p&gt;
   &lt;p&gt;Erlaubte Attribute:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;ID&lt;/code&gt;
     : ID des Modells zur Referenzierung
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;schema&lt;/code&gt;
     : Link auf XML-Schema-Dokumente, die sich außerhalb
     des aktuellen
     &lt;code&gt;model&lt;/code&gt;
     -Elements befinden.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-example-4.xhtml"
    line="16-63" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Das
    &lt;code&gt;instance&lt;/code&gt;
    -Element
   &lt;/title&gt;
   &lt;p&gt;
    Das Element enthält oder referenziert erste Instanzdaten
    des Formulars mit eventuellen Vorbefüllungen für
    Formularwerte. Wenn sowohl eine Referenz auf
    Instanzdaten existiert und gleichzeitig Instanzdaten als
    Kindelemente des Elements angegeben sind, so sind die
    referenzierten Daten höherprior und werden verwendet.
   &lt;/p&gt;
   &lt;p&gt;Erlaubte Attribute:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;src&lt;/code&gt;
     : referenziert eine XML-Datei mit Instanzdaten
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-example-5.xhtml"
    line="16-47" /&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;Der Submit-Prozess&lt;/title&gt;
   &lt;p&gt;
    Für die Übertragung eines Formular(teil)s darf immer nur
    genau ein Submit-Prozess aktiv sein. Bei einer
    Übertragung laufen folgende Schritte ab:
   &lt;/p&gt;
   &lt;ol&gt;
    &lt;li&gt;
     Ein Knoten aus den Instanzdaten, der übertragen
     werden soll (vgl.
     &lt;code&gt;&lt;/code&gt;
     , wird ausgewählt. Er und all seine Nachkommen sind
     für den nachfolgenden Prozess relevant.
    &lt;/li&gt;
    &lt;li&gt;
     Die relevanten Knoten werden auf Gültigkeit
     überprüft (Schema, evtl vorhandene Constraints)
     Leere und ungültige Knoten halten den
     Übertragungsprozess an und werfen ein
     Fehler-Ereignis.
    &lt;/li&gt;
    &lt;li&gt;Die gewählten Instanzdaten werden serialisiert.&lt;/li&gt;
    &lt;li&gt;
     Die serialisierten Instanzdaten werden übertragen.
    &lt;/li&gt;
    &lt;li&gt;
     Die Antwort wird entgegengenommen und wie folgt
     verarbeitet:
    &lt;/li&gt;
    &lt;ul&gt;
     &lt;li&gt;
      Bei einer erfolgreichen Übertragung und Erhalt
      einer Antwort mit einem Dokument-
      &lt;code&gt;body&lt;/code&gt;
      wird der gesamte Dokumentinhalt durch den
      erhaltenen
      &lt;code&gt;body&lt;/code&gt;
      ersetzt. Voraussetzung: das
      &lt;code&gt;replace&lt;/code&gt;
      -Attribut des
      &lt;code&gt;submission&lt;/code&gt;
      -Elements hat den Wert
      &lt;code&gt;all&lt;/code&gt;
      .
     &lt;/li&gt;
     &lt;li&gt;
      Bei einer erfolgreichen Übertragung und Erhalt
      einer Antwort mit einem
      &lt;code&gt;body&lt;/code&gt;
      eines XML-Medientyps wird die Antwort als XML
      geparst. Voraussetzung: Das
      &lt;code&gt;replace&lt;/code&gt;
      -Attributs des Elements
      &lt;code&gt;submission&lt;/code&gt;
      hat den Wert
      &lt;code&gt;instance&lt;/code&gt;
      . Die Instanzdaten werden durch die
      Ergebnisdaten ersetzt.
     &lt;/li&gt;
     &lt;li&gt;
      Bei einer erfolgreichen Übertragung und Erhalt
      eines
      &lt;code&gt;body&lt;/code&gt;
      eines nicht auf XML basierenden Medientypen wird
      nichts ersetzt.
     &lt;/li&gt;
     &lt;li&gt;
      Bei einer erfolgreichen Übertragung und Erhalt
      eines Body wird nichts ersetzt, wenn der Wert
      des
      &lt;code&gt;replace&lt;/code&gt;
      -Attributs
      &lt;code&gt;none&lt;/code&gt;
      beträgt.
     &lt;/li&gt;
     &lt;li&gt;
      Bei einer erfolgreichen Übertragung und einem
      Ergebnis, das keinen Body enthält, wird nichts
      ersetzt.
     &lt;/li&gt;
     &lt;li&gt;
      Andere Attributwerte von
      &lt;code&gt;replace&lt;/code&gt;
      sind nicht definiert.
     &lt;/li&gt;
     &lt;li&gt;
      Bei einer fehlerhaften Übertragung wird nichts
      im Dokument ersetzt.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/ol&gt;
  &lt;/slide&gt;


  &lt;slide&gt;
   &lt;title&gt;
    Das
    &lt;code&gt;submission&lt;/code&gt;
    -Element
   &lt;/title&gt;
   &lt;p&gt;
    Das Element enthält beschreibende Informationen darüber,
    was wie übertragen werden soll.
   &lt;/p&gt;
   &lt;p&gt;Erlaubte Attribute:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;bind&lt;/code&gt;
     : optional, Verweis auf ein
     &lt;code&gt;bind&lt;/code&gt;
     -Rlement. Die Referenz, die durch dieses Attribut
     definiert ist, ist höherprior als eine evtl.
     Referenz durch ein
     &lt;code&gt;ref&lt;/code&gt;
     -Attribut.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;ref&lt;/code&gt;
     : optional, ermöglicht die Auswahl einer Teilmenge
     der Instanzdaten. Der ausgewählte Knoten wird samt
     seiner Nachfolger für die Übertragung ausgewählt.
     Der Vorgabewert ist
     &lt;q&gt;/&lt;/q&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;action&lt;/code&gt;
     : zwingend anzugeben, enthält die URI, an die die
     Instanzdaten übermittelt werden. Das angegebene
     URI-Schema hat Einfluß auf das
     Übertragungsprotokoll.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;method&lt;/code&gt;
     : zwingend anzugeben, gibt indirekt die
     Serialisierung an an, mit der die Instanzdaten
     übertragen werden. Zulässige Werte sind:
     &lt;code&gt;post&lt;/code&gt;
     ,
     &lt;code&gt;get&lt;/code&gt;
     ,
     &lt;code&gt;put&lt;/code&gt;
     ,
     &lt;code&gt;multipart-post&lt;/code&gt;
     ,
     &lt;code&gt;form-data-post&lt;/code&gt;
     ,
     &lt;code&gt;urlencoded-post&lt;/code&gt;
     (veraltet),
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;version&lt;/code&gt;
     : optional, gibt die XML-Version an, die für die
     Serialisierung des Dokuments verwendet werden soll.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;indent&lt;/code&gt;
     : optional, gibt an, ob während des
     Serialisierungsprozesses zusätzliche Leerzeichen in
     das Dokument eingefügt werden sollen, um die
     Lesbarkeit zu erhöhen.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;mediatype&lt;/code&gt;
     : optional, gibt den Medientyp für die
     Serialisierung der Instanzdaten an. Der angegebene
     Typ sollte mit
     &lt;code&gt;application/xml&lt;/code&gt;
     kompatibel sein.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;encoding&lt;/code&gt;
     : optional, gibt die Kodierung für die
     Serialisierung an.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;omit-xml-declaration&lt;/code&gt;
     : optional, gibt an, ob die XML-Deklaration
     serialisiert werden soll oder nicht.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;standalone&lt;/code&gt;
     : optional, gibt an, ob eine Standalone-Deklaration
     in das Ergebnisdokument eingefügt werden soll.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;replace&lt;/code&gt;
     : optional, gibt an wie die erhaltene Antwort auf
     das Instanzdokument angewendet wird. Fehlt das
     Attribut, gilt der Vorgabewert
     &lt;code&gt;all&lt;/code&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;instance&lt;/code&gt;
     : optional, gibt die Instanz an, die ersetzt werden
     soll, wenn der Wert des
     &lt;code&gt;replace&lt;/code&gt;
     -Attributs mit
     &lt;code&gt;instance&lt;/code&gt;
     angegeben ist. Fehlt das Attribut, so wird als
     Vorgabe die Instanz angenommen, die die zu
     übertragenden Daten enthält.
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;separator&lt;/code&gt;
     : optional, gibt das Trennzeichen an, das bei der
     URL Codierung als Trennzeichen zwischen
     Name-Wert-Paaren verwendet wird. Vorgabewert ist
     &lt;q&gt;;&lt;/q&gt;
     .
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;includenamespaceprefixes&lt;/code&gt;
     : optional, erlaubt die Kontrolle über die
     Serialisierung der Namensräume. Fehlt das Attribut,
     werden alle Namensräume serialisiert, unabhängig
     davon, ob sie verwendet werden oder nicht. Ist das
     Attribut vorhanden und leer, so werden nur die
     verwendeten Namensräume serialisiert. Es kann eine
     Liste von Namensraumpräfixen angegeben werden, die
     zusätzlich zu den verwendeten Namensräumen
     serialisiert werden sollen.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Kompatibilitätsmatrix URI-Schema, Protokoll und
    Serialisierung
   &lt;/title&gt;
   &lt;p&gt;
    Die folgende Tabelle gibt eine Übersicht über die
    zulässigen Wertekombinationen
   &lt;/p&gt;
   &lt;table border="1"&gt;
    &lt;thead&gt;
     &lt;tr&gt;
      &lt;th&gt;URI Schema&lt;/th&gt;
      &lt;th&gt;
       &lt;code&gt;method&lt;/code&gt;
      &lt;/th&gt;
      &lt;th&gt;Serialisierung&lt;/th&gt;
      &lt;th&gt;Übertragungsprotokoll&lt;/th&gt;
     &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;mailto&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;post&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;application/xml&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP POST&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;file&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;get&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        application/x-www-form-urlencoded
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP GET&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;file&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;put&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;application/xml&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP PUT&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;mailto&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;multipart-post&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;multipart/related&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP POST&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;mailto&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;form-data-post&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;multipart/form-data&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP POST&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;
       &lt;code&gt;http&lt;/code&gt;
       ,
       &lt;code&gt;https&lt;/code&gt;
       ,
       &lt;code&gt;mailto&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;urlencoded-post&lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;
        application/x-www-form-urlencoded
       &lt;/code&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;code&gt;HTTP POST&lt;/code&gt;
       oder kompatibel
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;
    Das
    &lt;code&gt;bind&lt;/code&gt;
    -Element
   &lt;/title&gt;
   &lt;p&gt;
    Das Element wählt über das Attribute
    &lt;code&gt;nodeset&lt;/code&gt;
    eine Knotenmenge aus den Instanzdaten aus. Für diese
    Knotenmenge kann dann zum Beispiel mit dem Attribut
    &lt;code&gt;type&lt;/code&gt;
    ein Datentyp definiert werden. Allgemein gesprochen wird
    eine Modelleigenschaft
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;type&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;readonly&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;required&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;relevant&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;calculate&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;constraint&lt;/code&gt;
    &lt;/li&gt;
    &lt;li&gt;
     &lt;code&gt;p3ptype&lt;/code&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;auf die Knoten der Knotenmenge angewendet.&lt;/p&gt;
   &lt;p&gt;Weitere Attribute:&lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;nodeset&lt;/code&gt;
     : Auswahl der Knotenmenge, für die die angegebene
     Eigenschaft gelten soll.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/slide&gt;

  &lt;slide&gt;
   &lt;title&gt;XForms-Kontrollelemente&lt;/title&gt;
   &lt;p&gt;
    XForms definiert folgende Kontrollelemente für
    Formulare:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;input&lt;/code&gt;
     : freies Eingabefeld. Kann je nach Datentyp des
     Instanzknotens unterschiedlich angezeigt werden.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="1-8" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-input.png" /&gt;
   &lt;br /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-calendar-picker-closed.png" /&gt;
   &lt;br /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-calendar-picker-open.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;secret&lt;/code&gt;
     : Die Eingabe ist geheim und soll für dritte
     Personen verborgen bleiben (z.B. Paßwort)
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="9-12" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-secret-with-hint.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;textarea&lt;/code&gt;
     : Freie Eingabe in Form von mehrzeiligem Inhalt,
     z.B. Inhalt einer E-Mail.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="13-16" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-textarea.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;output&lt;/code&gt;
     : Zeigt einen Wert aus den Instanzdaten an, bietet
     keine Möglichkeit zur Dateneingabe.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="17-19" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-output.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;upload&lt;/code&gt;
     : Mit diesem Kontrollelement kann eine Datei des
     lokalen Dateisystems auf einen Server geladen
     werden. Ebenso kann hiermit die Dateneingabe über
     verschiedene Eingabegeräte wie Mikrophone, Stifte
     und Digitalkameras ermötlicht werden.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="20-24" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-upload.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;range&lt;/code&gt;
     : Auswahl von Werten aus einem Wertebereich
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="25-27" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-range.png" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;trigger&lt;/code&gt;
     : Ähnlich zu einem Button. Erlaubt Aktionen, die
     durch den Benutzer initiiert werden.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="28-30" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;submit&lt;/code&gt;
     : Stößt die Übertragung der Instanzdaten an, mit
     denen es verknüpft wurde.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="31-33" /&gt;
   &lt;br /&gt;
   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;select&lt;/code&gt;
     : Ermöglicht Mehrfachauswahl aus einer
     Menge vorgegebener Werte.
     Steuerung der Darstellung durch
     CSS oder Attribut &lt;code&gt;appearance&lt;/code&gt; 
     (zulässige Werte: &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;compact&lt;/code&gt; 
     und &lt;code&gt;minimal&lt;/code&gt;)
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="34-50" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-selectMany-checkbox.png" /&gt;
    &lt;br/&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-selectMany-listbox.png" /&gt;
    &lt;br/&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-menu.png" /&gt;
    &lt;br/&gt;

   &lt;ul&gt;
    &lt;li&gt;
     &lt;code&gt;select1&lt;/code&gt;
     : Ermöglicht Einfachauswahl aus einer
     Menge vorgegebener Werte.
     Steuerung der Darstellung durch
     CSS oder Attribut &lt;code&gt;appearance&lt;/code&gt; 
     (zulässige Werte: &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;compact&lt;/code&gt; 
     und &lt;code&gt;minimal&lt;/code&gt;)
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;listing
    src="xforms-kontrollelemente.xml"
    line="51-65" /&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-selectOne-radio.png" /&gt;
    &lt;br/&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-selectOne-listbox.png" /&gt;
    &lt;br/&gt;
   &lt;img
    style="margin : 4% ; width : 30% ; "
    src="xforms-selectOne-pulldown.png" /&gt;
    &lt;br/&gt;
  &lt;/slide&gt;
  
  &lt;slide&gt;
   &lt;title&gt;XForms - weiterführende Konzepte&lt;/title&gt;
   &lt;p&gt;
    XForms verfügt des weiteren über weiterführende Konzepte
    wie hierarchische Gruppierungen von Formularelementen, 
    die Möglichkeit zu konditionaler Anzeige mit 
    &lt;code&gt;switch&lt;/code&gt; - &lt;code&gt;case&lt;/code&gt;-Anweisungen sowie
    die Möglichkeit zur einfachen Erstellung sich
    wiederholender Strukturen (man denke an Preislisten, etc.).
    Einsatzmöglichkeiten dieser Elemente sind nachzulesen in
    &lt;a href="http://www.w3.org/TR/2006/REC-xforms-20060314/slice9.html"&gt;
    Kapitel 9 der XForms-Spezifikation
    &lt;/a&gt;. Sie werden in dieser
    Vorlesung nicht weiter besprochen.
   &lt;/p&gt;
   &lt;p&gt;
    Auch auf die zahlreichen Events und die damit verbundenen
     Elemente wird hier nicht weiter eingegangen.
   &lt;/p&gt;
  &lt;/slide&gt;
  
  &lt;slide&gt;
   &lt;title&gt;XForms - abschließendes Beispiel (mit Flußkontrolle)&lt;/title&gt;
   &lt;listing src="xforms-final-example.xhtml"/&gt;
  &lt;/slide&gt;

 &lt;/presentation&gt;
 &lt;!-- Ende XForms --&gt;

&lt;/xslidy&gt;
</pre></a></li><li>
					Die Ausführung liefert eine textuelle Ausgabe, deren
					Ereignisreihenfolge der der folgenden Abbildung
					entspricht
				<a class="img" href="../pics/saxEvents.gif" title="View Image"><img src="../pics/saxEvents.gif" /></a></li></ul></div><div class="slide" id="d1e14052"><h1>Einfache Transformationen</h1><ul><li>
					Bedingt durch die sequentielle Aktivierung der
					verschiedenen Ereignisbehandlungsroutinen lassen
					sich mit SAX sehr komfortabel einfache
					Dokumenttransformationen, wie z.B. die Umbenennung
					von Elementen, realisieren.
				</li><li>
					Der Code aus untenstehendem Beispiel zeigt die
					Umbenennung eines Elements von
					<code>foo</code>
					nach
					<code>bar</code>
					. Alle anderen Elemente, Attribute und
					Zeichenketten-artigen Elementinhalte werden
					unverändert kopiert.
					<br />
					Hinweis: Das Beispiel berücksichtigt dabei jedoch
					weder Namensräume noch Processing Instructions.
				</li><li>
					Zur Realisierung komplexer Transformationen,
					insbesondere solcher, die die Zwischenspeicherung
					von Dokumentinformationen erfordern sind jedoch
					Ansätze mit expliziter Abbildung in
					Hauptspeicherstrukturen wie DOM oder XSLT besser
					geeignet.
				<a href="SAXExample9.java" title="SAXExample9.java"><pre class="listing">import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;

public class SAXExample9 extends DefaultHandler {
    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        if (qName == "foo") {
            System.out.print("&lt;bar");
        } //if
        else
            System.out.print("&lt;" + qName);

        for (int i = 0; i &lt; atts.getLength(); i++) {
            System.out.print(" " + atts.getQName(i) + "=\"" + atts.getValue(i) + "\"");
        } //for
        System.out.println("&gt;");
    } //startElement()

    public void endElement(String namespaceURI, String localName, String qName) {
        if (qName == "foo") {
            System.out.println("&lt;/bar&gt;");
        } //if
        else
            System.out.println("&lt;/" + qName + "&gt;");
    } //endElement()

    public void characters(char[] ch, int start, int length) {
        for (int i = start; i &lt; start + length; i++)
            System.out.print(ch[i]);
    } //characters()

    public static void main(String args[]) throws Exception {
        XMLReader xr = XMLReaderFactory.createXMLReader();
        SAXExample9 handler = new SAXExample9();
     xr.setContentHandler(handler);
     xr.setErrorHandler(handler);
     FileReader r = new FileReader(args[0]);
     xr.parse(new InputSource(r));     
    } //main()
}//class SAXExample9</pre></a></li><li>Angewendet auf folgendes Eingabedokument...<a href="SAXExample9-input.xml" title="SAXExample9-input.xml"><pre class="listing">&lt;?xml version="1.0"?&gt;
&lt;?myPI this is a test?&gt;
   &lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg"&gt;
   &lt;head&gt;
      &lt;title&gt;Testpage&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;p&gt;This is a &lt;a href="http://www.jeckle.de"&gt;link&lt;/a&gt;
  &lt;foo&gt;
   sfdgsfdgsfg
  &lt;/foo&gt;
      &lt;/p&gt;
   &lt;/body&gt;
&lt;/html&gt;</pre></a></li><li>...ergibt sich folgende Ausgabe:<a href="SAXExample9.output" title="SAXExample9.output"><pre class="listing">&lt;html&gt;

   &lt;head&gt;

      &lt;title&gt;
Testpage&lt;/title&gt;

   &lt;/head&gt;

   &lt;body&gt;

      &lt;p&gt;
This is a &lt;a href="http://www.jeckle.de"&gt;
link&lt;/a&gt;

  &lt;bar&gt;

   sfdgsfdgsfg
  &lt;/bar&gt;

      &lt;/p&gt;

   &lt;/body&gt;

&lt;/html&gt;
</pre></a></li></ul></div><div class="slide" id="d1e14087"><h1>Einbindung von SAX in Applikationsprogramme</h1><ul><li>
					Untenstehendes Beispiel zeigt die Einbindung eines
					SAX-Parsers in ein Applikationsprogramm. Die
					Anwendung überführt beliebige XML-Eingabedokumente
					in eine Java-SWING-konforme Baumdarstellung.
				<a href="TreeViewer.java" title="TreeViewer.java"><pre class="listing">import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import java.io.FileReader;
import org.xml.sax.InputSource;
import java.awt.BorderLayout;
import java.awt.HeadlessException;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;

public class TreeViewer extends JFrame {

    public static void main(String argv[]) {
        JFrame frame = new TreeViewer(argv[0]);
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });
        frame.pack();
        frame.setVisible(true);
    } //main()

    public TreeViewer(String XMLFile) {
        super("SAX-based XML Viewer");
        try {
            DefaultMutableTreeNode root = new DefaultMutableTreeNode("DOCUMENT: " + XMLFile);
            JTree tree = new JTree(root);
            JScrollPane treeView = new JScrollPane(tree);
            getContentPane().add(new JScrollPane(treeView), BorderLayout.CENTER);

            //add elements to root
            XMLReader xr = XMLReaderFactory.createXMLReader();
            xr.setFeature("http://xml.org/sax/features/namespaces", true);    
            xr.setFeature("http://xml.org/sax/features/namespace-prefixes", true);

            Consumer handler = new Consumer(root);
         xr.setContentHandler(handler);
         xr.setErrorHandler(handler);

         FileReader r = new FileReader(XMLFile);
         xr.parse(new InputSource(r));     
                      
        } catch (HeadlessException e) {
            System.out.println("EXCEPTION CAUGHT: " + e.getClass().getName());
            e.printStackTrace();
        } catch (FactoryConfigurationError factoryConfigurationError) {
            System.out.println("EXCEPTION CAUGHT: " + factoryConfigurationError.getClass().getName());
            factoryConfigurationError.printStackTrace();
        } catch (SAXException e) {
            System.out.println("EXCEPTION CAUGHT: " + e.getClass().getName());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("EXCEPTION CAUGHT: " + e.getClass().getName());
            e.printStackTrace();
        }
    }
} //class TreeViewer

class Consumer extends DefaultHandler {
    private DefaultMutableTreeNode current;

    public Consumer(DefaultMutableTreeNode root) {
        current = root;
    }

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) {
        for (int i = 0; i &lt; atts.getLength(); i++) {
            current.add(new DefaultMutableTreeNode("ATTRIBUTE: " + atts.getQName(i) + "=" + atts.getValue(i)));
        }

        DefaultMutableTreeNode newNode = new DefaultMutableTreeNode("ELEMENT: " + localName);
        current.add(newNode);
        current = newNode;
    }

    public void endElement(String namespaceURI, String localName, String qName) {
        current = (DefaultMutableTreeNode) current.getParent();
    }

    public void processingInstruction(String target, String data) {
        current.add(new DefaultMutableTreeNode("PROCESSING INSTRUCTION: " + target));
    }

    public void characters(char[] ch, int start, int length) {
        current.add(new DefaultMutableTreeNode("CHARACTERS: " + new String(ch, start, length)));
    }
    
} //class Consumer</pre></a></li><li>
					Der Code zeigt die sukzessive Konstruktion der
					Baumansicht entlang der beim Lesevorgang
					eintretenden SAX-Ereignisse.
				</li><li>
					Hervorzuheben ist hierbei die Erzeugung je eines
					Baumknotens innerhalb der
					Ereignisbehandlungsroutinen
					<code>startElement</code>
					,
					<code>processingInstruction</code>
					und
					<code>characters</code>
					. All diese Methoden fügen einen neuen Kindknoten
					zum aktuell bearbeiteten Baumknoten zu. Zusätzlich
					wird innerhalb der Behandlung des
					<code>startElement</code>
					-Ereignisses der neu erzeugte Kindknoten für die
					weitere Verarbeitung als Aktueller definiert und
					damit eine zusätzliche Baumstufe eröffnet.
				</li><li>
					Das rekursive Aufsteigen im Baum findet beim
					Verlassen eines Elements (Ereignis:
					<code>endElement</code>
					) statt.
				</li><li>
					Untenstehende Abbildung zeigt die durch Verarbeitung
					des Dokuments
					<a class="outlink" href="namespace15-noBOM.xml" title="namespace15-noBOM.xml">
						namespace15-noBOM.xml
					</a>
					erzeugte Bildschirmansicht. Die vermeintlich
					„leeren“ CHARACTER-Elemente entstehen durch die
					nichtdruckbaren Zeichen wie Zeilenumbrüche und
					Wagenrückläufe.
				<a class="img" href="../pics/TreeViewer.gif" title="View Image"><img src="../pics/TreeViewer.gif" /></a></li></ul></div><div class="slide" id="d1e14130"><h1>Abschlußbemerkungen und Einsatzempfehlungen</h1><ul><li>
					SAX offenbart sich als leicht einzusetzende und
					trotzdem für geeignete Anwendungsfälle sehr mächtige
					Schnittstelle. Insbesondere ist der serielle
					Verarbeitungsansatz, der nur geringe
					Hauptspeicheranforderungen stellt, sehr gut für
					große XML-Dokumente geeignet. Gleichzeitig skalieren
					SAX-basierte Anwendungen vergleichsweise gut, da das
					Eingabedokument nur einmal durchlaufen wird.
				</li><li>
					Als gravierende Nachteile offenbaren sich jedoch die
					fehlenden Navigationsmöglichkeiten, die der
					Applikation die Reihenfolge der Elemente im Dokument
					als Verarbeitungsreihenfolge aufzwingen.
					Festzuhalten bleibt, daß es sich bei SAX lediglich
					um eine Schnittstelle handelt, auf der Parser
					realisiert werden können. SAX selbst ist jedoch kein
					solcher.
				</li></ul></div></body></html>

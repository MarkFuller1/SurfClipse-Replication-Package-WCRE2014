
# HG changeset patch
# User yan
# Date 1253607651 25200
# Node ID 986ec552383f2fddd8f154ead91b59eac41c4724
# Parent 317ac0bf2285152b94bc519baa2a467f8c629c67# Parent f09a2bfba691b89be11c3d26a7dd391735fbf7d7
Merge

--- a/.hgignore	Tue Sep 15 16:15:36 2009 +0400
+++ b/.hgignore	Tue Sep 22 01:20:51 2009 -0700
@@ -1,3 +1,6 @@
 ^build/
 ^dist/
 ^nbproject/private/
+^make/netbeans/.*/nbproject/private/
+^make/netbeans/.*/build/
+^make/netbeans/.*/dist/
--- a/.hgtags	Tue Sep 15 16:15:36 2009 +0400
+++ b/.hgtags	Tue Sep 22 01:20:51 2009 -0700
@@ -45,3 +45,5 @@ b23d905cb5d3b382295240d28ab0bfb266b4503c
 b23d905cb5d3b382295240d28ab0bfb266b4503c jdk7-b68
 226b20019b1f020c09ea97d137d98e011ce65d76 jdk7-b69
 893bcca951b747ddcf6986362b877f0e1dbb835b jdk7-b70
+b3f3240135f0c10b9f2481c174b81b7fcf0daa60 jdk7-b71
+460639b036f327282832a4fe52b7aa45688afd50 jdk7-b72
--- a/README	Tue Sep 15 16:15:36 2009 +0400
+++ b/README	Tue Sep 22 01:20:51 2009 -0700
@@ -9,35 +9,25 @@ Simple Build Instructions:
      http://java.sun.com/javase/downloads/index.jsp
      Set the environment variable ALT_BOOTDIR to the location of this JDK 6.
 
-  2. Download and install the JIBX libraries, version 1.1.5 from
-     http://sourceforge.net/project/showfiles.php?group_id=69358&package_id=68290
-     You'll need the following four JAR files:
-         bcel.jar
-         jibx-bind.jar
-         jibx-run.jar
-         xpp3.jar
-     Set the environment variable ALT_JIBX_LIBS_PATH to the location of
-     these JAR files.
-     
-  3. Download and install the Binary Plugs for the most recent JDK7 from
+  2. Download and install the Binary Plugs for the most recent JDK7 from
      http://download.java.net/openjdk/jdk7/
      Set the environment variable ALT_BINARY_PLUGS_PATH to the location of
      these binary plugs.
      
-  4. Either download and install the latest JDK7 from
+  3. Either download and install the latest JDK7 from
      http://download.java.net/openjdk/jdk7/, or build your own complete
      OpenJDK7 by using the top level Makefile in the OpenJDK Mercurial forest.
      Set the environment variable ALT_JDK_IMPORT_PATH to the location of
      this latest JDK7 or OpenJDK7 build.
      
-  5. Check the sanity of doing a build with the current machine:
+  4. Check the sanity of doing a build with the current machine:
        cd make && gnumake sanity
      See README-builds.html if you run into problems.
   
-  6. Do a partial build of the jdk:
+  5. Do a partial build of the jdk:
        cd make && gnumake all
   
-  7. Construct the images:
+  6. Construct the images:
        cd make && gnumake images
      The resulting JDK image should be found in build/*/j2sdk-image
 
--- a/make/com/sun/java/pack/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/com/sun/java/pack/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -67,15 +67,14 @@ ifeq ($(STANDALONE),true)
 	     $(ZIPOBJDIR)/deflate.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/trees.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/zadler32.$(OBJECT_SUFFIX) \
+	     $(ZIPOBJDIR)/compress.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/zutil.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/inflate.$(OBJECT_SUFFIX) \
-	     $(ZIPOBJDIR)/infblock.$(OBJECT_SUFFIX) \
-	     $(ZIPOBJDIR)/infcodes.$(OBJECT_SUFFIX) \
+	     $(ZIPOBJDIR)/infback.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/inftrees.$(OBJECT_SUFFIX) \
-	     $(ZIPOBJDIR)/infutil.$(OBJECT_SUFFIX) \
 	     $(ZIPOBJDIR)/inffast.$(OBJECT_SUFFIX)
 
-  ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+  ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
   OTHER_CXXFLAGS += $(ZINCLUDE)
   LDDFLAGS += $(ZIPOBJS)
 else
--- a/make/common/Defs.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/Defs.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -241,6 +241,12 @@ DEVTOOLS_FT_DIR_EXISTS = $(shell \
     endif
   endif
 endif
+
+#
+# zlib version
+#
+ZLIB_VERSION = 1.2.3
+
 
 #
 # Localizations for the different parts of the product beyond English
--- a/make/common/Sanity.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/Sanity.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -93,8 +93,7 @@ sanity-all:: sanity-base \
     sane-alt_bootdir \
     sane-bootdir \
     sane-local-bootdir \
-    sane-alsa-headers \
-    sane-jibx
+    sane-alsa-headers
 
 ifdef OPENJDK
 sanity-all:: sane-freetype 
--- a/make/common/shared/Defs-java.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/shared/Defs-java.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -201,7 +201,10 @@ ifeq ($(JAVAC_WARNINGS_FATAL), true)
 ifeq ($(JAVAC_WARNINGS_FATAL), true)
   BOOT_JAVACFLAGS  += -Werror
 endif
-BOOT_JAVACFLAGS  += -encoding ascii
+
+BOOT_SOURCE_LANGUAGE_VERSION = 6
+BOOT_TARGET_CLASS_VERSION = 6
+BOOT_JAVACFLAGS  += -encoding ascii -source $(BOOT_SOURCE_LANGUAGE_VERSION) -target $(BOOT_TARGET_CLASS_VERSION)
 BOOT_JAR_JFLAGS += $(JAR_JFLAGS)
 
 BOOT_JAVACFLAGS  += $(NO_PROPRIETARY_API_WARNINGS)
--- a/make/common/shared/Defs.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/shared/Defs.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -536,15 +536,6 @@ endif
 #   NOTE: ISA_DIR is usually empty, on Solaris it might be /sparcv9 or /amd64
 BINDIR      = $(OUTPUTDIR)/bin$(ISA_DIR)
   
-# JIBX_LIBS_PATH: path to JIBX libraries, needed for NimbusLookAndFeel
-ifdef ALT_JIBX_LIBS_PATH
-  JIBX_LIBS_PATH:=$(call FullPath,$(ALT_JIBX_LIBS_PATH))
-  JIBX_LIBS_PATH:=$(call AltCheckSpaces,JIBX_LIBS_PATH)
-  JIBX_LIBS_PATH:=$(call AltCheckValue,JIBX_LIBS_PATH)
-else
-  JIBX_LIBS_PATH=$(JDK_DEVTOOLS_DIR)/share/jibx/lib
-endif
-
 # MOZILLA_HEADERS_PATH: path to mozilla header files for plugin
 ifdef ALT_MOZILLA_HEADERS_PATH
   MOZILLA_HEADERS_PATH :=$(call FullPath,$(ALT_MOZILLA_HEADERS_PATH))
--- a/make/common/shared/Sanity-Settings.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/shared/Sanity-Settings.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -233,7 +233,6 @@ ifeq ($(PLATFORM),windows)
   endif
 endif
 ALL_SETTINGS+=$(call addAltSetting,CACERTS_FILE)
-ALL_SETTINGS+=$(call addAltSetting,JIBX_LIBS_PATH)
 ifndef OPENJDK
   ALL_SETTINGS+=$(call addAltSetting,MOZILLA_HEADERS_PATH)
 endif
--- a/make/common/shared/Sanity.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/common/shared/Sanity.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -214,7 +214,6 @@ include $(JDK_MAKE_SHARED_DIR)/Sanity-Se
 	sane-link \
 	sane-cacerts \
 	sane-alsa-headers \
-	sane-jibx \
 	sane-ant_version \
 	sane-zip_version \
 	sane-unzip_version \
@@ -1517,22 +1516,6 @@ endif
 
 
 ######################################################
-# JIBX_LIBS_PATH must be valid
-######################################################
-sane-jibx:
-ifdef DISABLE_NIMBUS	
-	$(call SanityWarning,Disabling Nimbus will remove public API in javax.swing.plaf.nimbus.)
-else
-	@if [ ! -r $(subst \,/,$(JIBX_LIBS_PATH))/jibx-run.jar ]; then \
-	  $(ECHO) "ERROR: You do not have access to valid JIBX library files. \n" \
-	    "      Please check your access to \n" \
-	    "          $(subst \,/,$(JIBX_LIBS_PATH))/jibx-run.jar \n" \
-	    "      and/or check your value of ALT_JDK_DEVTOOLS_DIR, ALT_JIBX_LIBS_PATH \n" \
-	    "" >> $(ERROR_FILE) ; \
-	fi
-endif
-
-######################################################
 # MOZILLA_HEADERS_PATH must be valid
 ######################################################
 sane-mozilla:
--- a/make/java/jli/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/jli/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -44,7 +44,6 @@ MS_RUNTIME_STATIC = true
 
 include $(BUILDDIR)/common/Defs.gmk
 
-ZLIB_VERSION = 1.1.3
 ZIP_SRC = $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 LAUNCHER_SHARE_SRC = $(SHARE_SRC)/bin
 LAUNCHER_PLATFORM_SRC = $(PLATFORM_SRC)/bin
@@ -68,12 +67,10 @@ FILES_c = \
 	wildcard.c \
 	jli_util.c \
 	inflate.c \
-	infblock.c \
 	inftrees.c \
-	infcodes.c \
 	inffast.c \
-	infutil.c \
 	zadler32.c \
+	zcrc32.c \
 	zutil.c
 
 ifneq ($(PLATFORM), windows)
--- a/make/java/nio/FILES_java.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/nio/FILES_java.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -160,7 +160,6 @@ FILES_src = \
 	\
 	sun/nio/ByteBuffered.java \
 	\
-	sun/nio/ch/AbstractFuture.java \
         sun/nio/ch/AbstractPollArrayWrapper.java \
 	sun/nio/ch/AllocatedNativeObject.java \
 	sun/nio/ch/AsynchronousChannelGroupImpl.java \
--- a/make/java/zip/FILES_c.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/zip/FILES_c.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -29,15 +29,16 @@ FILES_c = \
 	Deflater.c \
 	Inflater.c \
 	ZipFile.c \
+	zip_util.c \
+	compress.c \
+	deflate.c \
+	gzio.c \
+	infback.c \
+	inffast.c \
+	inflate.c \
+	inftrees.c \
+	trees.c \
+	uncompr.c \
 	zadler32.c \
 	zcrc32.c \
-	deflate.c \
-	trees.c \
-	zutil.c \
-	inflate.c \
-	infblock.c \
-	inftrees.c \
-	infcodes.c \
-	infutil.c \
-	inffast.c \
-	zip_util.c
+	zutil.c 
--- a/make/java/zip/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/zip/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -30,7 +30,9 @@ PRODUCT = sun
 PRODUCT = sun
 include $(BUILDDIR)/common/Defs.gmk
 
-ZLIB_VERSION = 1.1.3
+#
+# ZLIB_VERSION is defined in make/common/Defs.gmk
+#
 
 #
 # Files to compile.
--- a/make/java/zip/reorder-i586	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/zip/reorder-i586	Tue Sep 22 01:20:51 2009 -0700
@@ -32,38 +32,17 @@ text: .text%Java_java_util_zip_Inflater_
 text: .text%Java_java_util_zip_Inflater_init;
 text: .text%inflateInit2_;
 text: .text%zcalloc;
-text: .text%inflate_blocks_new;
-text: .text%inflate_blocks_reset;
 text: .text%inflateReset;
 text: .text%Java_java_util_zip_Inflater_inflateBytes;
 text: .text%inflate;
-text: .text%inflate_blocks;
-text: .text%inflate_flush;
 text: .text%Java_java_util_zip_ZipFile_read;
 text: .text%ZIP_Read;
-text: .text%inflate_trees_bits;
 text: .text%huft_build: OUTPUTDIR/tmp/sun/java.util.zip/zip/obj/inftrees.o;
 text: .text%zcfree;
-text: .text%inflate_trees_dynamic;
-text: .text%inflate_codes_new;
-text: .text%inflate_codes;
-text: .text%inflate_fast;
-text: .text%inflate_codes_free;
-text: .text%inflate_trees_fixed;
-# Test Exit
-# Test Hello
-# Test Sleep
-# Test IntToString
-# Test LoadToolkit
 text: .text%Java_java_util_jar_JarFile_getMetaInfEntryNames;
 text: .text%ZIP_ReadEntry;
 text: .text%InflateFully;
 text: .text%inflateEnd;
-text: .text%inflate_blocks_free;
-# Test LoadFrame
-# Test LoadJFrame
-# Test JHello
-# SwingSet
 text: .text%Java_java_util_zip_Inflater_reset;
 text: .text%Java_java_util_zip_ZipFile_close;
 text: .text%ZIP_Close;
--- a/make/java/zip/reorder-sparc	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/zip/reorder-sparc	Tue Sep 22 01:20:51 2009 -0700
@@ -31,37 +31,13 @@ text: .text%Java_java_util_zip_Inflater_
 text: .text%Java_java_util_zip_Inflater_init;
 text: .text%inflateInit2_;
 text: .text%zcalloc;
-text: .text%inflate_blocks_new;
-text: .text%inflate_blocks_reset;
-text: .text%inflateReset;
 text: .text%Java_java_util_zip_Inflater_inflateBytes;
-text: .text%inflate;
-text: .text%inflate_blocks;
-text: .text%inflate_flush;
 text: .text%Java_java_util_zip_ZipFile_read;
 text: .text%ZIP_Read;
-text: .text%inflate_trees_bits;
-text: .text%huft_build: OUTPUTDIR/tmp/sun/java.util.zip/zip/obj/inftrees.o;
 text: .text%zcfree;
-text: .text%inflate_trees_dynamic;
-text: .text%inflate_codes_new;
-text: .text%inflate_codes;
-text: .text%inflate_fast;
-text: .text%inflate_codes_free;
-text: .text%inflate_trees_fixed;
-# Test Exit
-# Test Hello
-# Test Sleep
-# Test IntToString
-# Test LoadToolkit
 text: .text%Java_java_util_jar_JarFile_getMetaInfEntryNames;
-# Test LoadFrame
-# Test LoadJFrame
-# Test JHello
-# SwingSet
 text: .text%Java_java_util_zip_Inflater_reset;
 text: .text%Java_java_util_zip_Inflater_end;
 text: .text%inflateEnd;
-text: .text%inflate_blocks_free;
 text: .text%Java_java_util_zip_ZipFile_close;
 text: .text%ZIP_Close;
--- a/make/java/zip/reorder-sparcv9	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/java/zip/reorder-sparcv9	Tue Sep 22 01:20:51 2009 -0700
@@ -1,6 +1,5 @@ data = R0x2000;
 data = R0x2000;
 text = LOAD ?RXO;
-# Test Null
 text: .text%ZIP_Open;
 text: .text%ZIP_Open_Generic;
 text: .text%InitializeZip;
@@ -32,38 +31,17 @@ text: .text%Java_java_util_zip_Inflater_
 text: .text%Java_java_util_zip_Inflater_init;
 text: .text%inflateInit2_;
 text: .text%zcalloc;
-text: .text%inflate_blocks_new;
-text: .text%inflate_blocks_reset;
 text: .text%inflateReset;
 text: .text%Java_java_util_zip_Inflater_inflateBytes;
 text: .text%inflate;
-text: .text%inflate_blocks;
-text: .text%inflate_flush;
 text: .text%Java_java_util_zip_ZipFile_read;
 text: .text%ZIP_Read;
-text: .text%inflate_trees_bits;
 text: .text%huft_build: OUTPUTDIR/tmp/sun/java.util.zip/zip/obj64/inftrees.o;
 text: .text%zcfree;
-text: .text%inflate_trees_dynamic;
-text: .text%inflate_codes_new;
-text: .text%inflate_codes;
-text: .text%inflate_fast;
-text: .text%inflate_codes_free;
-text: .text%inflate_trees_fixed;
-# Test Exit
-# Test Hello
-# Test Sleep
-# Test IntToString
-# Test LoadToolkit
 text: .text%Java_java_util_jar_JarFile_getMetaInfEntryNames;
 text: .text%ZIP_ReadEntry;
 text: .text%InflateFully;
 text: .text%inflateEnd;
-text: .text%inflate_blocks_free;
-# Test LoadFrame
-# Test LoadJFrame
-# Test JHello
-# SwingSet
 text: .text%Java_java_util_zip_Inflater_reset;
 text: .text%Java_java_util_zip_ZipFile_close;
 text: .text%ZIP_Close;
--- a/make/javax/swing/plaf/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/javax/swing/plaf/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -34,16 +34,14 @@ include $(BUILDDIR)/common/Defs.gmk
 #
 include FILES.gmk
 AUTO_FILES_JAVA_DIRS = javax/swing/plaf sun/swing com/sun/java/swing/plaf
-ifndef DISABLE_NIMBUS
-  SUBDIRS = nimbus
-endif
-
-# Nimbus is handled in its own directory
-AUTO_JAVA_PRUNE = nimbus
 
 ifeq ($(PLATFORM), windows)
     # Don't build GTK L&F on Windows
-    AUTO_JAVA_PRUNE += gtk
+    AUTO_JAVA_PRUNE = gtk
+endif
+
+ifdef DISABLE_NIMBUS
+    AUTO_JAVA_PRUNE += nimbus
 endif
 
 MISC_FILES = $(MISC_SWING_FILES)
@@ -51,6 +49,10 @@ ifneq ($(PLATFORM), windows)
     # Only include GTK icons on Solaris/Linux
     MISC_FILES += $(MISC_SWING_FILES_UNIX)
 endif
+
+NIMBUS_GENSRC_DIR = $(GENSRCDIR)/javax/swing/plaf/nimbus
+NIMBUS_SKIN_FILE = $(SWING_SRC)/plaf/nimbus/skin.laf
+NIMBUS_GENERATOR_JAR = $(BUILDTOOLJARDIR)/generatenimbus.jar
 
 FILES_java = $(FILES_SWING_java)
 
@@ -75,14 +77,25 @@ endif
 # Process LOGO_ICONS and Motif Icons first.
 #
 build: $(LOGO_ICONS) $(MISC_SWING_FILES_MOTIF_GIF) $(MISC_SWING_FILES_MOTIF_PNG) other_files
-	$(SUBDIRS-loop)
 
-clean clobber::
-	$(SUBDIRS-loop)
+$(NIMBUS_GENSRC_DIR): $(NIMBUS_SKIN_FILE) $(NIMBUS_GENERATOR_JAR)
+	@$(ECHO) "Generating Nimbus source files:"
+	$(RM) -r $(NIMBUS_GENSRC_DIR)
+	$(BOOT_JAVA_CMD) -jar $(NIMBUS_GENERATOR_JAR) \
+	    -skinFile $(NIMBUS_SKIN_FILE) -buildDir $(GENSRCDIR) \
+	    -packagePrefix $(PACKAGE).nimbus -lafName Nimbus
+	@$(ECHO) "Finished generating Nimbus source files"
+
+clean:: classes.clean
+	$(RM) -r $(NIMBUS_GENSRC_DIR)
 
 #
 # Include
 #
+ifndef DISABLE_NIMBUS
+    CLASSES_INIT = $(NIMBUS_GENSRC_DIR)
+endif
+
 include $(BUILDDIR)/common/Classes.gmk
 
 ifndef OPENJDK
--- a/make/sun/javazic/tzdata/VERSION	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/VERSION	Tue Sep 22 01:20:51 2009 -0700
@@ -21,4 +21,4 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
-tzdata2009g
+tzdata2009l
--- a/make/sun/javazic/tzdata/africa	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/africa	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -263,18 +265,18 @@ Rule	Egypt	2007	only	-	Sep	Thu>=1	23:00s
 # The following appeared in Red Hat bugzilla[1] (edited):
 #
 # > $ zdump -v /usr/share/zoneinfo/Africa/Cairo | grep 2009
-# > /usr/share/zoneinfo/Africa/Cairo  Thu Apr 23 21:59:59 2009 UTC =3D Thu =
+# > /usr/share/zoneinfo/Africa/Cairo  Thu Apr 23 21:59:59 2009 UTC = Thu =
 # Apr 23
-# > 23:59:59 2009 EET isdst=3D0 gmtoff=3D7200
-# > /usr/share/zoneinfo/Africa/Cairo  Thu Apr 23 22:00:00 2009 UTC =3D Fri =
+# > 23:59:59 2009 EET isdst=0 gmtoff=7200
+# > /usr/share/zoneinfo/Africa/Cairo  Thu Apr 23 22:00:00 2009 UTC = Fri =
 # Apr 24
-# > 01:00:00 2009 EEST isdst=3D1 gmtoff=3D10800
-# > /usr/share/zoneinfo/Africa/Cairo  Thu Aug 27 20:59:59 2009 UTC =3D Thu =
+# > 01:00:00 2009 EEST isdst=1 gmtoff=10800
+# > /usr/share/zoneinfo/Africa/Cairo  Thu Aug 27 20:59:59 2009 UTC = Thu =
 # Aug 27
-# > 23:59:59 2009 EEST isdst=3D1 gmtoff=3D10800
-# > /usr/share/zoneinfo/Africa/Cairo  Thu Aug 27 21:00:00 2009 UTC =3D Thu =
+# > 23:59:59 2009 EEST isdst=1 gmtoff=10800
+# > /usr/share/zoneinfo/Africa/Cairo  Thu Aug 27 21:00:00 2009 UTC = Thu =
 # Aug 27
-# > 23:00:00 2009 EET isdst=3D0 gmtoff=3D7200
+# > 23:00:00 2009 EET isdst=0 gmtoff=7200
 #
 # > end date should be Thu Sep 24 2009 (Last Thursday in September at 23:59=
 # :59)
@@ -282,11 +284,11 @@ Rule	Egypt	2007	only	-	Sep	Thu>=1	23:00s
 #
 # timeanddate[2] and another site I've found[3] also support that.
 #
-# [1] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=3D492263">
-# https://bugzilla.redhat.com/show_bug.cgi?id=3D492263
-# </a>
-# [2] <a href="http://www.timeanddate.com/worldclock/clockchange.html?n=3D53">
-# http://www.timeanddate.com/worldclock/clockchange.html?n=3D53
+# [1] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=492263">
+# https://bugzilla.redhat.com/show_bug.cgi?id=492263
+# </a>
+# [2] <a href="http://www.timeanddate.com/worldclock/clockchange.html?n=53">
+# http://www.timeanddate.com/worldclock/clockchange.html?n=53
 # </a>
 # [3] <a href="http://wwp.greenwichmeantime.com/time-zone/africa/egypt/">
 # http://wwp.greenwichmeantime.com/time-zone/africa/egypt/
@@ -296,8 +298,27 @@ Rule	Egypt	2007	only	-	Sep	Thu>=1	23:00s
 # In 2009 (and for the next several years), Ramadan ends before the fourth
 # Thursday in September; Egypt is expected to revert to the last Thursday
 # in September.
+
+# From Steffen Thorsen (2009-08-11):
+# We have been able to confirm the August change with the Egyptian Cabinet 
+# Information and Decision Support Center:
+# <a href="http://www.timeanddate.com/news/time/egypt-dst-ends-2009.html">
+# http://www.timeanddate.com/news/time/egypt-dst-ends-2009.html
+# </a>
+# 
+# The Middle East News Agency
+# <a href="http://www.mena.org.eg/index.aspx">
+# http://www.mena.org.eg/index.aspx
+# </a>
+# also reports "Egypt starts winter time on August 21"
+# today in article numbered "71, 11/08/2009 12:25 GMT." 
+# Only the title above is available without a subscription to their service,
+# and can be found by searching for "winter" in their search engine
+# (at least today).
+
 Rule	Egypt	2008	only	-	Aug	lastThu	23:00s	0	-
-Rule	Egypt	2009	max	-	Sep	lastThu	23:00s	0	-
+Rule	Egypt	2009	only	-	Aug	20	23:00s	0	-
+Rule	Egypt	2010	max	-	Sep	lastThu	23:00s	0	-
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Cairo	2:05:00 -	LMT	1900 Oct
@@ -499,8 +520,8 @@ Zone Africa/Nouakchott	-1:03:48 -	LMT	19
 
 # From Riad M. Hossen Ally (2008-08-03):
 # The Government of Mauritius weblink
-# <a href="http://www.gov.mu/portal/site/pmosite/menuitem.4ca0efdee47462e7440a600248a521ca/?content_id=3D4728ca68b2a5b110VgnVCM1000000a04a8c0RCRD">
-# http://www.gov.mu/portal/site/pmosite/menuitem.4ca0efdee47462e7440a600248a521ca/?content_id=3D4728ca68b2a5b110VgnVCM1000000a04a8c0RCRD
+# <a href="http://www.gov.mu/portal/site/pmosite/menuitem.4ca0efdee47462e7440a600248a521ca/?content_id=4728ca68b2a5b110VgnVCM1000000a04a8c0RCRD">
+# http://www.gov.mu/portal/site/pmosite/menuitem.4ca0efdee47462e7440a600248a521ca/?content_id=4728ca68b2a5b110VgnVCM1000000a04a8c0RCRD
 # </a>
 # Cabinet Decision of July 18th, 2008 states as follows:
 #
@@ -522,11 +543,33 @@ Zone Africa/Nouakchott	-1:03:48 -	LMT	19
 # http://www.gov.mu/portal/goc/assemblysite/file/bill2708.pdf
 # </a>
 
+# From Steffen Thorsen (2009-06-05):
+# According to several sources, Mauritius will not continue to observe
+# DST the coming summer...
+#
+# Some sources, in French:
+# <a href="http://www.defimedia.info/news/946/Rashid-Beebeejaun-:-%C2%AB-L%E2%80%99heure-d%E2%80%99%C3%A9t%C3%A9-ne-sera-pas-appliqu%C3%A9e-cette-ann%C3%A9e-%C2%BB">
+# http://www.defimedia.info/news/946/Rashid-Beebeejaun-:-%C2%AB-L%E2%80%99heure-d%E2%80%99%C3%A9t%C3%A9-ne-sera-pas-appliqu%C3%A9e-cette-ann%C3%A9e-%C2%BB
+# </a>
+# <a href="http://lexpress.mu/Story/3398~Beebeejaun---Les-objectifs-d-%C3%A9conomie-d-%C3%A9nergie-de-l-heure-d-%C3%A9t%C3%A9-ont-%C3%A9t%C3%A9-atteints-">
+# http://lexpress.mu/Story/3398~Beebeejaun---Les-objectifs-d-%C3%A9conomie-d-%C3%A9nergie-de-l-heure-d-%C3%A9t%C3%A9-ont-%C3%A9t%C3%A9-atteints-
+# </a>
+#
+# Our wrap-up:
+# <a href="http://www.timeanddate.com/news/time/mauritius-dst-will-not-repeat.html">
+# http://www.timeanddate.com/news/time/mauritius-dst-will-not-repeat.html
+# </a>
+
+# From Arthur David Olson (2009-07-11):
+# The "mauritius-dst-will-not-repeat" wrapup includes this: 
+# "The trial ended on March 29, 2009, when the clocks moved back by one hour
+# at 2am (or 02:00) local time..."
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule Mauritius	1982	only	-	Oct	10	0:00	1:00	S
 Rule Mauritius	1983	only	-	Mar	21	0:00	0	-
-Rule Mauritius	2008	max	-	Oct	lastSun	2:00s	1:00	S
-Rule Mauritius	2009	max	-	Mar	lastSun	2:00s	0	-
+Rule Mauritius	2008	only	-	Oct	lastSun	2:00	1:00	S
+Rule Mauritius	2009	only	-	Mar	lastSun	2:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Indian/Mauritius	3:50:00 -	LMT	1907		# Port Louis
 			4:00 Mauritius	MU%sT	# Mauritius Time
--- a/make/sun/javazic/tzdata/antarctica	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/antarctica	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # From Paul Eggert (1999-11-15):
 # To keep things manageable, we list only locations occupied year-round; see
--- a/make/sun/javazic/tzdata/asia	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/asia	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -147,6 +149,57 @@ Zone	Asia/Bahrain	3:22:20 -	LMT	1920		# 
 			3:00	-	AST
 
 # Bangladesh
+# From Alexander Krivenyshev (2009-05-13):
+# According to newspaper Asian Tribune (May 6, 2009) Bangladesh may introduce
+# Daylight Saving Time from June 16 to Sept 30
+#
+# Bangladesh to introduce daylight saving time likely from June 16
+# <a href="http://www.asiantribune.com/?q=node/17288">
+# http://www.asiantribune.com/?q=node/17288
+# </a>
+# or
+# <a href="http://www.worldtimezone.com/dst_news/dst_news_bangladesh02.html">
+# http://www.worldtimezone.com/dst_news/dst_news_bangladesh02.html
+# </a>
+#
+# "... Bangladesh government has decided to switch daylight saving time from
+# June
+# 16 till September 30 in a bid to ensure maximum use of daylight to cope with
+# crippling power crisis. "
+#
+# The switch will remain in effect from June 16 to Sept 30 (2009) but if
+# implemented the next year, it will come in force from April 1, 2010
+
+# From Steffen Thorsen (2009-06-02):
+# They have finally decided now, but changed the start date to midnight between
+# the 19th and 20th, and they have not set the end date yet.
+#
+# Some sources:
+# <a href="http://in.reuters.com/article/southAsiaNews/idINIndia-40017620090601">
+# http://in.reuters.com/article/southAsiaNews/idINIndia-40017620090601
+# </a>
+# <a href="http://bdnews24.com/details.php?id=85889&cid=2">
+# http://bdnews24.com/details.php?id=85889&cid=2
+# </a>
+#
+# Our wrap-up:
+# <a href="http://www.timeanddate.com/news/time/bangladesh-daylight-saving-2009.html">
+# http://www.timeanddate.com/news/time/bangladesh-daylight-saving-2009.html
+# </a>
+
+# From A. N. M. Kamrus Saadat (2009-06-15):
+# Finally we've got the official mail regarding DST start time where DST start 
+# time is mentioned as Jun 19 2009, 23:00 from BTRC (Bangladesh 
+# Telecommunication Regulatory Commission). 
+#
+# No DST end date has been announced yet.
+
+# From Arthur David Olson (2009-07-11):
+# Arbitrarily end DST at the end of 2009 so that a POSIX-sytle time zone string
+# can appear in the Dhaka binary file and for the benefit of old glibc
+# reimplementations of the time zone software that mishandle permanent DST.
+# A change will be required once the end date is known.
+
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Dhaka	6:01:40 -	LMT	1890
 			5:53:20	-	HMT	1941 Oct    # Howrah Mean Time?
@@ -154,7 +207,9 @@ Zone	Asia/Dhaka	6:01:40 -	LMT	1890
 			5:30	-	IST	1942 Sep
 			6:30	-	BURT	1951 Sep 30
 			6:00	-	DACT	1971 Mar 26 # Dacca Time
-			6:00	-	BDT	# Bangladesh Time
+			6:00	-	BDT	2009 Jun 19 23:00 # Bangladesh Time
+			6:00	1:00	BDST	2010
+			6:00	-	BDT
 
 # Bhutan
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -1129,7 +1184,7 @@ Rule	Jordan	1999	only	-	Jul	 1	0:00s	1:0
 Rule	Jordan	1999	only	-	Jul	 1	0:00s	1:00	S
 Rule	Jordan	1999	2002	-	Sep	lastFri	0:00s	0	-
 Rule	Jordan	2000	2001	-	Mar	lastThu	0:00s	1:00	S
-Rule	Jordan	2002	max	-	Mar	lastFri	0:00s	1:00	S
+Rule	Jordan	2002	max	-	Mar	lastThu	24:00	1:00	S
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
--- a/make/sun/javazic/tzdata/australasia	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/australasia	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This file also includes Pacific islands.
 
@@ -447,6 +449,22 @@ Zone Pacific/Pago_Pago	 12:37:12 -	LMT	1
 			-11:00	-	SST			# S=Samoa
 
 # Samoa
+
+# From Alexander Krivenyshev (2008-12-06):
+# The Samoa government (Western Samoa) may implement DST on the first Sunday of 
+# October 2009 (October 4, 2009) until the last Sunday of March 2010 (March 28, 
+# 2010). 
+# 
+# "Selected Committee reports to Cabinet on Daylight Saving Time",
+# Government of Samoa:
+# <a href="http://www.govt.ws/pr_article.cfm?pr_id=560">
+# http://www.govt.ws/pr_article.cfm?pr_id=560
+# </a>
+# or
+# <a href="http://www.worldtimezone.com/dst_news/dst_news_samoa01.html">
+# http://www.worldtimezone.com/dst_news/dst_news_samoa01.html
+# </a>
+
 Zone Pacific/Apia	 12:33:04 -	LMT	1879 Jul  5
 			-11:26:56 -	LMT	1911
 			-11:30	-	SAMT	1950		# Samoa Time
@@ -1141,6 +1159,27 @@ Zone	Pacific/Wallis	12:15:20 -	LMT	1901
 # From Paul Eggert (2007-07-23):
 # See "southeast Australia" above for 2008 and later.
 
+# From Steffen Thorsen (2009-04-28):
+# According to the official press release, South Australia's extended daylight 
+# saving period will continue with the same rules as used during the 2008-2009 
+# summer (southern hemisphere).
+# 
+# From
+# <a href="http://www.safework.sa.gov.au/uploaded_files/DaylightDatesSet.pdf">
+# http://www.safework.sa.gov.au/uploaded_files/DaylightDatesSet.pdf
+# </a>
+# The extended daylight saving period that South Australia has been trialling 
+# for over the last year is now set to be ongoing.
+# Daylight saving will continue to start on the first Sunday in October each 
+# year and finish on the first Sunday in April the following year.
+# Industrial Relations Minister, Paul Caica, says this provides South Australia 
+# with a consistent half hour time difference with NSW, Victoria, Tasmania and 
+# the ACT for all 52 weeks of the year...
+# 
+# We have a wrap-up here:
+# <a href="http://www.timeanddate.com/news/time/south-australia-extends-dst.html">
+# http://www.timeanddate.com/news/time/south-australia-extends-dst.html
+# </a>
 ###############################################################################
 
 # New Zealand
--- a/make/sun/javazic/tzdata/backward	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/backward	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This file provides links between current names for time zones
 # and their old names.  Many names changed in late 1993.
--- a/make/sun/javazic/tzdata/etcetera	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/etcetera	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # These entries are mostly present for historical reasons, so that
 # people in areas not otherwise covered by the tz files could "zic -l"
--- a/make/sun/javazic/tzdata/europe	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/europe	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -479,7 +481,7 @@ Rule	EU	1981	max	-	Mar	lastSun	 1:00u	1:
 Rule	EU	1981	max	-	Mar	lastSun	 1:00u	1:00	S
 Rule	EU	1996	max	-	Oct	lastSun	 1:00u	0	-
 # The most recent directive covers the years starting in 2002.  See:
-# <a href="http://europa.eu.int/eur-lex/en/lif/dat/2000/en_300L0084.html">
+# <a="http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:32000L0084:EN:NOT">
 # Directive 2000/84/EC of the European Parliament and of the Council
 # of 19 January 2001 on summer-time arrangements.
 # </a>
--- a/make/sun/javazic/tzdata/factory	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/factory	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # For companies who don't want to put time zone specification in
 # their installation procedures.  When users run date, they'll get the message.
--- a/make/sun/javazic/tzdata/iso3166.tab	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/iso3166.tab	Tue Sep 22 01:20:51 2009 -0700
@@ -21,8 +21,10 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 # ISO 3166 alpha-2 country codes
-#
 #
 # From Paul Eggert (2006-09-27):
 #
--- a/make/sun/javazic/tzdata/leapseconds	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/leapseconds	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # Allowance for leapseconds added to each timezone file.
 
@@ -75,13 +78,13 @@ Leap	2008	Dec	31	23:59:60	+	S
 # SERVICE DE LA ROTATION TERRESTRE
 # OBSERVATOIRE DE PARIS
 # 61, Av. de l'Observatoire 75014 PARIS (France)
-# Tel.      : 33 (0) 1 40 51 22 29
+# Tel.      : 33 (0) 1 40 51 22 26
 # FAX       : 33 (0) 1 40 51 22 91
 # Internet  : services.iers@obspm.fr
 #
-# Paris, 15 January 2009
+# Paris, 4 July 2009
 #
-# Bulletin C 37
+# Bulletin C 38
 #
 # To authorities responsible
 # for the measurement and
@@ -89,7 +92,7 @@ Leap	2008	Dec	31	23:59:60	+	S
 #
 # INFORMATION ON UTC - TAI
 #
-# NO positive leap second will be introduced at the end of June 2009.
+# NO positive leap second will be introduced at the end of December 2009.
 # The difference between Coordinated Universal Time UTC and the
 # International Atomic Time TAI is :		
 #
@@ -101,6 +104,6 @@ Leap	2008	Dec	31	23:59:60	+	S
 # will be no time step at the next possible date.
 #
 # Daniel GAMBIS
-# Head			
-# Earth Orientation Center of the IERS
+# Director			
+# Earth Orientation Center of IERS
 # Observatoire de Paris, France
--- a/make/sun/javazic/tzdata/northamerica	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/northamerica	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # also includes Central America and the Caribbean
 
--- a/make/sun/javazic/tzdata/pacificnew	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/pacificnew	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # From Arthur David Olson (1989-04-05):
 # On 1989-04-05, the U. S. House of Representatives passed (238-154) a bill
--- a/make/sun/javazic/tzdata/solar87	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/solar87	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # So much for footnotes about Saudi Arabia.
 # Apparent noon times below are for Riyadh; your mileage will vary.
--- a/make/sun/javazic/tzdata/solar88	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/solar88	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # Apparent noon times below are for Riyadh; they're a bit off for other places.
 # Times were computed using formulas in the U.S. Naval Observatory's
--- a/make/sun/javazic/tzdata/solar89	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/solar89	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # Apparent noon times below are for Riyadh; they're a bit off for other places.
 # Times were computed using a formula provided by the U. S. Naval Observatory:
--- a/make/sun/javazic/tzdata/southamerica	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/southamerica	Tue Sep 22 01:20:51 2009 -0700
@@ -22,6 +22,8 @@
 # have any questions.
 #
 # <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -696,8 +698,8 @@ Zone	America/La_Paz	-4:32:36 -	LMT	1890
 
 # From Rodrigo Severo (2008-06-24):
 # Just correcting the URL:
-# <a href="https://www.in.gov.br/imprensa/visualiza/index.jsp?jornal=3Ddo&secao=3D1&pagina=3D1&data=3D25/04/2008">
-# https://www.in.gov.br/imprensa/visualiza/index.jsp?jornal=3Ddo&secao=3D1&pagina=3D1&data=3D25/04/2008
+# <a href="https://www.in.gov.br/imprensa/visualiza/index.jsp?jornal=do&secao=1&pagina=1&data=25/04/2008">
+# https://www.in.gov.br/imprensa/visualiza/index.jsp?jornal=do&secao=1&pagina=1&data=25/04/2008
 # </a>
 #
 # As a result of the above Decree I believe the America/Rio_Branco
--- a/make/sun/javazic/tzdata/systemv	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/systemv	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 
 # Old rules, should the need arise.
 # No attempt is made to handle Newfoundland, since it cannot be expressed
--- a/make/sun/javazic/tzdata/zone.tab	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/javazic/tzdata/zone.tab	Tue Sep 22 01:20:51 2009 -0700
@@ -21,6 +21,9 @@
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
 #
+# <pre>
+# This file is in the public domain, so clarified as of
+# 2009-05-17 by Arthur David Olson.
 #
 # TZ zone descriptions
 #
@@ -123,7 +126,7 @@ BR	-0958-06748	America/Rio_Branco	Acre
 BR	-0958-06748	America/Rio_Branco	Acre
 BS	+2505-07721	America/Nassau
 BT	+2728+08939	Asia/Thimphu
-BW	-2545+02555	Africa/Gaborone
+BW	-2439+02555	Africa/Gaborone
 BY	+5354+02734	Europe/Minsk
 BZ	+1730-08812	America/Belize
 CA	+4734-05243	America/St_Johns	Newfoundland Time, including SE Labrador
@@ -307,7 +310,7 @@ MY	+0133+11020	Asia/Kuching	Sabah & Sara
 MY	+0133+11020	Asia/Kuching	Sabah & Sarawak
 MZ	-2558+03235	Africa/Maputo
 NA	-2234+01706	Africa/Windhoek
-NC	-2216+16530	Pacific/Noumea
+NC	-2216+16627	Pacific/Noumea
 NE	+1331+00207	Africa/Niamey
 NF	-2903+16758	Pacific/Norfolk
 NG	+0627+00324	Africa/Lagos
@@ -387,7 +390,7 @@ TL	-0833+12535	Asia/Dili
 TL	-0833+12535	Asia/Dili
 TM	+3757+05823	Asia/Ashgabat
 TN	+3648+01011	Africa/Tunis
-TO	-2110+17510	Pacific/Tongatapu
+TO	-2110-17510	Pacific/Tongatapu
 TR	+4101+02858	Europe/Istanbul
 TT	+1039-06131	America/Port_of_Spain
 TV	-0831+17913	Pacific/Funafuti
@@ -431,7 +434,7 @@ UY	-3453-05611	America/Montevideo
 UY	-3453-05611	America/Montevideo
 UZ	+3940+06648	Asia/Samarkand	west Uzbekistan
 UZ	+4120+06918	Asia/Tashkent	east Uzbekistan
-VA	+4154+01227	Europe/Vatican
+VA	+415408+0122711	Europe/Vatican
 VC	+1309-06114	America/St_Vincent
 VE	+1030-06656	America/Caracas
 VG	+1827-06437	America/Tortola
--- a/make/sun/splashscreen/FILES_c.gmk	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/splashscreen/FILES_c.gmk	Tue Sep 22 01:20:51 2009 -0700
@@ -52,12 +52,10 @@ FILES_c = \
 	compress.c \
 	deflate.c \
 	gzio.c \
-	infblock.c \
-	infcodes.c \
+	infback.c \
 	inffast.c \
 	inflate.c \
 	inftrees.c \
-	infutil.c \
 	trees.c \
 	uncompr.c \
 	zadler32.c \
--- a/make/sun/splashscreen/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/sun/splashscreen/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -77,13 +77,13 @@ vpath %.c   $(SHARE_SRC)/native/$(PKGDIR
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/splashscreen
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/giflib
-vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/libpng
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen
 
 CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
-CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 
 # Shun the less than portable MMX assembly code in pnggccrd.c,
 # and use alternative implementations in C.
--- a/make/tools/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -54,7 +54,7 @@ SUBDIRS =                   \
   CharsetMapping
 
 ifndef DISABLE_NIMBUS
-  SUBDIRS += swing-nimbus
+  SUBDIRS += generate_nimbus
 endif
 
 all build clean clobber::
--- a/make/tools/freetypecheck/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/freetypecheck/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -28,16 +28,21 @@ include $(BUILDDIR)/common/Defs.gmk
 include $(BUILDDIR)/common/Defs.gmk
 
 # Default name
-FT_TEST = $(BUILDTOOLBINDIR)/freetype_versioncheck$(EXE_SUFFIX)
+PROGRAM = freetype_versioncheck
+FT_OBJ = $(BUILDTOOLBINDIR)/$(PROGRAM).$(OBJECT_SUFFIX)
+FT_TEST = $(BUILDTOOLBINDIR)/$(PROGRAM)$(EXE_SUFFIX)
 
 # Used on openjdk only
 ifeq ($(OPENJDK),true)
 
 # Start with CFLAGS (which gets us the required -xarch setting on solaris)
 ifeq ($(PLATFORM), windows)
-  FT_OPTIONS  = /nologo $(CC_OBJECT_OUTPUT_FLAG)$(TEMPDIR)
+  FT_OPTIONS  = /nologo /c
   FREETYPE_DLL = $(FREETYPE_LIB_PATH)/freetype.dll
   FT_LD_OPTIONS  = $(FREETYPE_LIB_PATH)/freetype.lib
+ifdef MT
+  FT_LD_OPTIONS += /manifest
+endif
 else
   FT_OPTIONS  = $(CFLAGS)
   FT_LD_OPTIONS = -L$(FREETYPE_LIB_PATH)
@@ -55,15 +60,22 @@ FT_LD_OPTIONS += $(LFLAGS_$(COMPILER_VER
 
 # Create test program
 all: $(FT_TEST)
-	@$(FT_TEST)
+	$(FT_TEST)
 
 # On windows we need to copy dll to test dir to ensure it will be found
 #   at runtime
 $(FT_TEST): freetypecheck.c
-	@$(prep-target)
+	$(prep-target)
+ifeq ($(PLATFORM), windows)
+	$(CC) $(FT_OPTIONS) $(CC_OBJECT_OUTPUT_FLAG)$(FT_OBJ) $<
+	$(LINK) $(FT_LD_OPTIONS) /OUT:$(FT_TEST) $(FT_OBJ)
+	$(CP) $(FREETYPE_DLL) $(@D)/
+ifdef MT
+	$(CP) $(MSVCRNN_DLL_PATH)/$(MSVCRNN_DLL) $(@D)/
+	$(MT) /manifest $(FT_TEST).manifest /outputresource:$(FT_TEST);#1
+endif
+else
 	@$(CC) $(FT_OPTIONS) $(CC_PROGRAM_OUTPUT_FLAG)$@ $< $(FT_LD_OPTIONS)
-ifeq ($(PLATFORM), windows)
-	@$(CP) $(FREETYPE_DLL) `dirname $@`
 endif
 
 else
--- a/make/tools/freetypecheck/freetypecheck.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/freetypecheck/freetypecheck.c	Tue Sep 22 01:20:51 2009 -0700
@@ -32,6 +32,45 @@
 #include "ft2build.h"
 #include FT_FREETYPE_H
 
+#ifdef _MSC_VER
+#if _MSC_VER > 1400
+
+/*
+ * When building for Microsoft Windows, your program has a dependency
+ * on msvcr??.dll.
+ *
+ * When using Visual Studio 2005 or later, that must be recorded in
+ * the <program>.exe.manifest file.
+ *
+ * Reference:
+ *     C:/Program Files/Microsoft SDKs/Windows/v6.1/include/crtdefs.h
+ */
+#include <crtassem.h>
+#ifdef _M_IX86
+
+#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
+        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT' "              \
+        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
+        "processorArchitecture='x86' "                                  \
+        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
+
+#endif /* _M_IX86 */
+
+//This may not be necessary yet for the Windows 64-bit build, but it
+//will be when that build environment is updated.  Need to test to see
+//if it is harmless:
+#ifdef _M_AMD64
+
+#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
+        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT' "              \
+        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
+        "processorArchitecture='amd64' "                                \
+        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
+
+#endif  /* _M_AMD64 */
+#endif  /* _MSC_VER > 1400 */
+#endif  /* _MSC_VER */
+
 #define QUOTEMACRO(x) QUOTEME(x)
 #define QUOTEME(x) #x
 
--- a/make/tools/src/build/tools/jdwpgen/AbstractNamedNode.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/AbstractNamedNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,7 +30,7 @@ import java.io.*;
 
 abstract class AbstractNamedNode extends Node {
 
-    NameNode nameNode;
+    NameNode nameNode = null;
     String name;
 
     public String name() {
--- a/make/tools/src/build/tools/jdwpgen/AltNode.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/AltNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,7 +30,7 @@ import java.io.*;
 
 class AltNode extends AbstractGroupNode implements TypeNode {
 
-    SelectNode select;
+    SelectNode select = null;
 
     void constrain(Context ctx) {
         super.constrain(ctx);
--- a/make/tools/src/build/tools/jdwpgen/ConstantSetNode.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/ConstantSetNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -33,13 +33,7 @@ class ConstantSetNode extends AbstractNa
     /**
      * The mapping between a constant and its value.
      */
-    protected static Map<String, String> constantMap;
-
-    ConstantSetNode(){
-        if (constantMap == null) {
-            constantMap = new HashMap<String, String>();
-        }
-    }
+    protected static final Map<String, String> constantMap = new HashMap<String, String>();
 
     void prune() {
         List<Node> addons = new ArrayList<Node>();
@@ -95,9 +89,6 @@ class ConstantSetNode extends AbstractNa
     }
 
     public static String getConstant(String key){
-        if (constantMap == null) {
-            return "";
-        }
         String com = constantMap.get(key);
         if(com == null){
             return "";
--- a/make/tools/src/build/tools/jdwpgen/Main.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/Main.java	Tue Sep 22 01:20:51 2009 -0700
@@ -25,13 +25,11 @@
 
 package build.tools.jdwpgen;
 
-import java.util.*;
 import java.io.*;
 
 class Main {
 
     static String specSource;
-    static Map nameMap = new HashMap();
     static boolean genDebug = true;
 
     static void usage() {
@@ -43,7 +41,6 @@ class Main {
         System.err.println("-doc <doc_output>");
         System.err.println("-jdi <java_output>");
         System.err.println("-include <include_file_output>");
-        System.exit(1);
     }
 
     public static void main(String args[]) throws IOException {
@@ -66,6 +63,7 @@ class Main {
                 } else {
                     System.err.println("Invalid option: " + arg);
                     usage();
+                    return;
                 }
             } else {
                 specSource = arg;
@@ -75,6 +73,7 @@ class Main {
         if (reader == null) {
             System.err.println("<spec_input> must be specified");
             usage();
+            return;
         }
 
         Parse parse = new Parse(reader);
--- a/make/tools/src/build/tools/jdwpgen/Node.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/Node.java	Tue Sep 22 01:20:51 2009 -0700
@@ -36,7 +36,7 @@ abstract class Node {
     int lineno;
     List<String> commentList = new ArrayList<String>();
     Node parent = null;
-    Context context;
+    Context context = null;
 
     static final int maxStructIndent = 5;
     static int structIndent = 0; // horrible hack
@@ -82,7 +82,7 @@ abstract class Node {
     }
 
     void indent(PrintWriter writer, int depth) {
-        for (int i = depth; i > 0; --i) {
+        for (int i = 0; i < depth; i++) {
             writer.print("    ");
         }
     }
@@ -195,6 +195,6 @@ abstract class Node {
         System.err.println(Main.specSource + ":" + lineno + ": " +
                            kind + " - " + errmsg);
         System.err.println();
-        System.exit(1);
+        throw new RuntimeException("Error: " + errmsg);
     }
 }
--- a/make/tools/src/build/tools/jdwpgen/Parse.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/Parse.java	Tue Sep 22 01:20:51 2009 -0700
@@ -146,8 +146,12 @@ class Parse {
                             Node node = (Node)proto.getClass().newInstance();
                             node.set(kind, list, izer.lineno());
                             return node;
-                        } catch (Exception exc) {
+                        } catch (InstantiationException exc) {
                             error(exc.toString());
+                            return null;
+                        } catch (IllegalAccessException exc) {
+                            error(exc.toString());
+                            return null;
                         }
                     }
                 } else {
@@ -166,6 +170,6 @@ class Parse {
     void error(String errmsg) {
         System.err.println(Main.specSource + ":" + izer.lineno() +
                            ": " + errmsg);
-        System.exit(1);
+        throw new RuntimeException("Error: " + errmsg);
     }
 }
--- a/make/tools/src/build/tools/jdwpgen/RepeatNode.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/RepeatNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,7 +30,7 @@ import java.io.*;
 
 class RepeatNode extends AbstractTypeNode {
 
-    Node member;
+    Node member = null;
 
     void constrain(Context ctx) {
         super.constrain(ctx);
--- a/make/tools/src/build/tools/jdwpgen/SelectNode.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/make/tools/src/build/tools/jdwpgen/SelectNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,7 +30,7 @@ import java.io.*;
 
 class SelectNode extends AbstractGroupNode implements TypeNode {
 
-    AbstractSimpleTypeNode typeNode;
+    AbstractSimpleTypeNode typeNode = null;
 
     void prune() {
         super.prune();
--- a/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -52,8 +52,14 @@ public final class BeanInfoFinder
     }
 
     @Override
-    protected BeanInfo instantiate(Class<?> type, String name) {
-        BeanInfo info = super.instantiate(type, name);
+    protected BeanInfo instantiate(Class<?> type, String prefix, String name) {
+        // this optimization will only use the BeanInfo search path
+        // if is has changed from the original
+        // or trying to get the ComponentBeanInfo
+        BeanInfo info = !DEFAULT.equals(prefix) || "ComponentBeanInfo".equals(name)
+                ? super.instantiate(type, prefix, name)
+                : null;
+
         if (info != null) {
             // make sure that the returned BeanInfo matches the class
             BeanDescriptor bd = info.getBeanDescriptor();
@@ -89,14 +95,4 @@ public final class BeanInfoFinder
         }
         return null;
     }
-
-    @Override
-    protected BeanInfo instantiate(Class<?> type, String prefix, String name) {
-        // this optimization will only use the BeanInfo search path
-        // if is has changed from the original
-        // or trying to get the ComponentBeanInfo
-        return !DEFAULT.equals(prefix) || "ComponentBeanInfo".equals(name)
-                ? super.instantiate(type, prefix, name)
-                : null;
-    }
 }
--- a/src/share/classes/com/sun/java/swing/plaf/windows/DesktopProperty.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/java/swing/plaf/windows/DesktopProperty.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 2001-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2001-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,7 +49,7 @@ public class DesktopProperty implements 
     /**
      * ReferenceQueue of unreferenced WeakPCLs.
      */
-    private static ReferenceQueue<DesktopProperty> queue;
+    private static final ReferenceQueue<DesktopProperty> queue = new ReferenceQueue<DesktopProperty>();
 
     /**
      * PropertyChangeListener attached to the Toolkit.
@@ -58,7 +58,7 @@ public class DesktopProperty implements 
     /**
      * Key used to lookup value from desktop.
      */
-    private String key;
+    private final String key;
     /**
      * Value to return.
      */
@@ -66,17 +66,8 @@ public class DesktopProperty implements 
     /**
      * Fallback value in case we get null from desktop.
      */
-    private Object fallback;
-
-    /**
-     * Toolkit.
-     */
-    private Toolkit toolkit;
-
-
-    static {
-        queue = new ReferenceQueue<DesktopProperty>();
-    }
+    private final Object fallback;
+
 
     /**
      * Cleans up any lingering state held by unrefeernced
@@ -138,13 +129,10 @@ public class DesktopProperty implements 
      *
      * @param key Key used in looking up desktop value.
      * @param fallback Value used if desktop property is null.
-     * @param toolkit Toolkit used to fetch property from, can be null
-     *        in which default will be used.
-     */
-    public DesktopProperty(String key, Object fallback, Toolkit toolkit) {
+     */
+    public DesktopProperty(String key, Object fallback) {
         this.key = key;
         this.fallback = fallback;
-        this.toolkit = toolkit;
         // The only sure fire way to clear our references is to create a
         // Thread and wait for a reference to be added to the queue.
         // Because it is so rare that you will actually change the look
@@ -175,13 +163,14 @@ public class DesktopProperty implements 
      * Returns the value from the desktop.
      */
     protected Object getValueFromDesktop() {
-        if (this.toolkit == null) {
-            this.toolkit = Toolkit.getDefaultToolkit();
-        }
-        Object value = toolkit.getDesktopProperty(getKey());
-        pcl = new WeakPCL(this, toolkit, getKey(), UIManager.getLookAndFeel());
-        toolkit.addPropertyChangeListener(getKey(), pcl);
-        return value;
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+
+        if (pcl == null) {
+            pcl = new WeakPCL(this, getKey(), UIManager.getLookAndFeel());
+            toolkit.addPropertyChangeListener(getKey(), pcl);
+        }
+
+        return toolkit.getDesktopProperty(getKey());
     }
 
     /**
@@ -205,12 +194,7 @@ public class DesktopProperty implements 
      * <code>createValue</code> will ask for the property again.
      */
     public void invalidate() {
-        if (pcl != null) {
-            toolkit.removePropertyChangeListener(getKey(), pcl);
-            toolkit = null;
-            pcl = null;
-            value = null;
-        }
+        value = null;
     }
 
     /**
@@ -271,13 +255,11 @@ public class DesktopProperty implements 
      */
     private static class WeakPCL extends WeakReference<DesktopProperty>
                                implements PropertyChangeListener {
-        private Toolkit kit;
         private String key;
         private LookAndFeel laf;
 
-        WeakPCL(DesktopProperty target, Toolkit kit, String key, LookAndFeel laf) {
+        WeakPCL(DesktopProperty target, String key, LookAndFeel laf) {
             super(target, queue);
-            this.kit = kit;
             this.key = key;
             this.laf = laf;
         }
@@ -297,7 +279,7 @@ public class DesktopProperty implements 
         }
 
         void dispose() {
-            kit.removePropertyChangeListener(key, this);
+            Toolkit.getDefaultToolkit().removePropertyChangeListener(key, this);
         }
     }
 }
--- a/src/share/classes/com/sun/java/swing/plaf/windows/WindowsFileChooserUI.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/java/swing/plaf/windows/WindowsFileChooserUI.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 1997-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1997-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,7 +43,6 @@ import java.security.PrivilegedAction;
 import java.security.PrivilegedAction;
 
 import sun.awt.shell.ShellFolder;
-import sun.awt.OSInfo;
 import sun.swing.*;
 
 import javax.accessibility.*;
@@ -58,8 +57,6 @@ public class WindowsFileChooserUI extend
     // The following are private because the implementation of the
     // Windows FileChooser L&F is not complete yet.
 
-    private static final OSInfo.WindowsVersion OS_VERSION = OSInfo.getWindowsVersion();
-
     private JPanel centerPanel;
 
     private JLabel lookInLabel;
@@ -118,17 +115,8 @@ public class WindowsFileChooserUI extend
     private String upFolderToolTipText = null;
     private String upFolderAccessibleName = null;
 
-    private String homeFolderToolTipText = null;
-    private String homeFolderAccessibleName = null;
-
     private String newFolderToolTipText = null;
     private String newFolderAccessibleName = null;
-
-    private String listViewButtonToolTipText = null;
-    private String listViewButtonAccessibleName = null;
-
-    private String detailsViewButtonToolTipText = null;
-    private String detailsViewButtonAccessibleName = null;
 
     private String viewMenuButtonToolTipText = null;
     private String viewMenuButtonAccessibleName = null;
@@ -231,9 +219,7 @@ public class WindowsFileChooserUI extend
         // Directory manipulation buttons
         JToolBar topPanel = new JToolBar();
         topPanel.setFloatable(false);
-        if (OS_VERSION.compareTo(OSInfo.WINDOWS_ME) >= 0) {
-            topPanel.putClientProperty("JToolBar.isRollover", Boolean.TRUE);
-        }
+        topPanel.putClientProperty("JToolBar.isRollover", Boolean.TRUE);
 
         // Add the top panel to the fileChooser
         fc.add(topPanel, BorderLayout.NORTH);
@@ -287,218 +273,103 @@ public class WindowsFileChooserUI extend
         topPanel.add(Box.createRigidArea(hstrut10));
 
         // Up Button
-        JButton upFolderButton = new JButton(getChangeToParentDirectoryAction());
-        upFolderButton.setText(null);
-        upFolderButton.setIcon(upFolderIcon);
-        upFolderButton.setToolTipText(upFolderToolTipText);
-        upFolderButton.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY,
-                                         upFolderAccessibleName);
-        upFolderButton.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY,
-                                         Boolean.TRUE);
-        upFolderButton.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-        upFolderButton.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-        upFolderButton.setMargin(shrinkwrap);
-        upFolderButton.setFocusPainted(false);
+        JButton upFolderButton = createToolButton(getChangeToParentDirectoryAction(), upFolderIcon,
+            upFolderToolTipText, upFolderAccessibleName);
         topPanel.add(upFolderButton);
-        if (OS_VERSION.compareTo(OSInfo.WINDOWS_ME) < 0) {
-            topPanel.add(Box.createRigidArea(hstrut10));
-        }
-
-        JButton b;
-
-        if (OS_VERSION == OSInfo.WINDOWS_98) {
-            // Desktop Button
-            File homeDir = fsv.getHomeDirectory();
-            String toolTipText = homeFolderToolTipText;
-            if (fsv.isRoot(homeDir)) {
-                toolTipText = getFileView(fc).getName(homeDir); // Probably "Desktop".
-            }
-            b = new JButton(getFileView(fc).getIcon(homeDir));
-            b.setToolTipText(toolTipText);
-            b.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY,
-                                toolTipText);
-            b.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-            b.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-            b.setMargin(shrinkwrap);
-            b.setFocusPainted(false);
-            b.addActionListener(getGoHomeAction());
-            topPanel.add(b);
-            topPanel.add(Box.createRigidArea(hstrut10));
-        }
 
         // New Directory Button
         if (!UIManager.getBoolean("FileChooser.readOnly")) {
-            b = new JButton(filePane.getNewFolderAction());
-            b.setText(null);
-            b.setIcon(newFolderIcon);
-            b.setToolTipText(newFolderToolTipText);
-            b.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY,
-                                newFolderAccessibleName);
-            b.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY,
-                                Boolean.TRUE);
-            b.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-            b.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-            b.setMargin(shrinkwrap);
-            b.setFocusPainted(false);
-            topPanel.add(b);
-        }
-        if (OS_VERSION.compareTo(OSInfo.WINDOWS_ME) < 0) {
-            topPanel.add(Box.createRigidArea(hstrut10));
-
-            // View button group
-            ButtonGroup viewButtonGroup = new ButtonGroup();
-
-            // List Button
-            final JToggleButton listViewButton = new JToggleButton(listViewIcon);
-            listViewButton.setToolTipText(listViewButtonToolTipText);
-            listViewButton.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY,
-                    listViewButtonAccessibleName);
-            listViewButton.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY,
-                    Boolean.TRUE);
-            listViewButton.setFocusPainted(false);
-            listViewButton.setSelected(true);
-            listViewButton.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-            listViewButton.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-            listViewButton.setMargin(shrinkwrap);
-            listViewButton.addActionListener(filePane.getViewTypeAction(FilePane.VIEWTYPE_LIST));
-            topPanel.add(listViewButton);
-            viewButtonGroup.add(listViewButton);
-
-            // Details Button
-            final JToggleButton detailsViewButton = new JToggleButton(detailsViewIcon);
-            detailsViewButton.setToolTipText(detailsViewButtonToolTipText);
-            detailsViewButton.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY,
-                    detailsViewButtonAccessibleName);
-            detailsViewButton.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY,
-                    Boolean.TRUE);
-            detailsViewButton.setFocusPainted(false);
-            detailsViewButton.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-            detailsViewButton.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-            detailsViewButton.setMargin(shrinkwrap);
-            detailsViewButton.addActionListener(filePane.getViewTypeAction(FilePane.VIEWTYPE_DETAILS));
-            topPanel.add(detailsViewButton);
-            viewButtonGroup.add(detailsViewButton);
-
-            topPanel.add(Box.createRigidArea(new Dimension(60, 0)));
-
-            filePane.addPropertyChangeListener(new PropertyChangeListener() {
-                public void propertyChange(PropertyChangeEvent e) {
-                    if ("viewType".equals(e.getPropertyName())) {
-                        int viewType = filePane.getViewType();
-
-                        switch (viewType) {
-                            case FilePane.VIEWTYPE_LIST:
-                                listViewButton.setSelected(true);
-                                break;
-
-                            case FilePane.VIEWTYPE_DETAILS:
-                                detailsViewButton.setSelected(true);
-                                break;
-                        }
+            JButton newFolderButton = createToolButton(filePane.getNewFolderAction(), newFolderIcon,
+                newFolderToolTipText, newFolderAccessibleName);
+            topPanel.add(newFolderButton);
+        }
+
+        // View button group
+        ButtonGroup viewButtonGroup = new ButtonGroup();
+
+        // Popup Menu
+        final JPopupMenu viewTypePopupMenu = new JPopupMenu();
+
+        final JRadioButtonMenuItem listViewMenuItem = new JRadioButtonMenuItem(
+                filePane.getViewTypeAction(FilePane.VIEWTYPE_LIST));
+        listViewMenuItem.setSelected(filePane.getViewType() == FilePane.VIEWTYPE_LIST);
+        viewTypePopupMenu.add(listViewMenuItem);
+        viewButtonGroup.add(listViewMenuItem);
+
+        final JRadioButtonMenuItem detailsViewMenuItem = new JRadioButtonMenuItem(
+                filePane.getViewTypeAction(FilePane.VIEWTYPE_DETAILS));
+        detailsViewMenuItem.setSelected(filePane.getViewType() == FilePane.VIEWTYPE_DETAILS);
+        viewTypePopupMenu.add(detailsViewMenuItem);
+        viewButtonGroup.add(detailsViewMenuItem);
+
+        // Create icon for viewMenuButton
+        BufferedImage image = new BufferedImage(viewMenuIcon.getIconWidth() + 7, viewMenuIcon.getIconHeight(),
+                BufferedImage.TYPE_INT_ARGB);
+        Graphics graphics = image.getGraphics();
+        viewMenuIcon.paintIcon(filePane, graphics, 0, 0);
+        int x = image.getWidth() - 5;
+        int y = image.getHeight() / 2 - 1;
+        graphics.setColor(Color.BLACK);
+        graphics.fillPolygon(new int[]{x, x + 5, x + 2}, new int[]{y, y, y + 3}, 3);
+
+        // Details Button
+        final JButton viewMenuButton = createToolButton(null, new ImageIcon(image), viewMenuButtonToolTipText,
+                viewMenuButtonAccessibleName);
+
+        viewMenuButton.addMouseListener(new MouseAdapter() {
+            public void mousePressed(MouseEvent e) {
+                if (SwingUtilities.isLeftMouseButton(e) && !viewMenuButton.isSelected()) {
+                    viewMenuButton.setSelected(true);
+
+                    viewTypePopupMenu.show(viewMenuButton, 0, viewMenuButton.getHeight());
+                }
+            }
+        });
+        viewMenuButton.addKeyListener(new KeyAdapter() {
+            public void keyPressed(KeyEvent e) {
+                // Forbid keyboard actions if the button is not in rollover state
+                if (e.getKeyCode() == KeyEvent.VK_SPACE && viewMenuButton.getModel().isRollover()) {
+                    viewMenuButton.setSelected(true);
+
+                    viewTypePopupMenu.show(viewMenuButton, 0, viewMenuButton.getHeight());
+                }
+            }
+        });
+        viewTypePopupMenu.addPopupMenuListener(new PopupMenuListener() {
+            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
+            }
+
+            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
+                SwingUtilities.invokeLater(new Runnable() {
+                    public void run() {
+                        viewMenuButton.setSelected(false);
                     }
-                }
-            });
-        } else { // After Windows Me
-            // View button group
-            ButtonGroup viewButtonGroup = new ButtonGroup();
-
-            // Popup Menu
-            final JPopupMenu viewTypePopupMenu = new JPopupMenu();
-
-            final JRadioButtonMenuItem listViewMenuItem = new JRadioButtonMenuItem(
-                    filePane.getViewTypeAction(FilePane.VIEWTYPE_LIST));
-            listViewMenuItem.setSelected(filePane.getViewType() == FilePane.VIEWTYPE_LIST);
-            viewTypePopupMenu.add(listViewMenuItem);
-            viewButtonGroup.add(listViewMenuItem);
-
-            final JRadioButtonMenuItem detailsViewMenuItem = new JRadioButtonMenuItem(
-                    filePane.getViewTypeAction(FilePane.VIEWTYPE_DETAILS));
-            detailsViewMenuItem.setSelected(filePane.getViewType() == FilePane.VIEWTYPE_DETAILS);
-            viewTypePopupMenu.add(detailsViewMenuItem);
-            viewButtonGroup.add(detailsViewMenuItem);
-
-            // Create icon for viewMenuButton
-            BufferedImage image = new BufferedImage(viewMenuIcon.getIconWidth() + 7, viewMenuIcon.getIconHeight(),
-                    BufferedImage.TYPE_INT_ARGB);
-            Graphics graphics = image.getGraphics();
-            viewMenuIcon.paintIcon(filePane, graphics, 0, 0);
-            int x = image.getWidth() - 5;
-            int y = image.getHeight() / 2 - 1;
-            graphics.setColor(Color.BLACK);
-            graphics.fillPolygon(new int[]{x, x + 5, x + 2}, new int[]{y, y, y + 3}, 3);
-
-            // Details Button
-            final JButton viewMenuButton = new JButton(new ImageIcon(image));
-            viewMenuButton.setToolTipText(viewMenuButtonToolTipText);
-            viewMenuButton.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, viewMenuButtonAccessibleName);
-            viewMenuButton.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY, Boolean.TRUE);
-            viewMenuButton.setFocusable(false);
-            viewMenuButton.setAlignmentX(JComponent.LEFT_ALIGNMENT);
-            viewMenuButton.setAlignmentY(JComponent.CENTER_ALIGNMENT);
-            viewMenuButton.setMargin(shrinkwrap);
-            viewMenuButton.setModel(new DefaultButtonModel() {
-                public void setPressed(boolean b) {
-                }
-
-                public void setArmed(boolean b) {
-                }
-
-                public void setSelected(boolean b) {
-                    super.setSelected(b);
-
-                    if (b) {
-                        stateMask |= PRESSED | ARMED;
-                    } else {
-                        stateMask &= ~(PRESSED | ARMED);
+                });
+            }
+
+            public void popupMenuCanceled(PopupMenuEvent e) {
+            }
+        });
+
+        topPanel.add(viewMenuButton);
+
+        topPanel.add(Box.createRigidArea(new Dimension(80, 0)));
+
+        filePane.addPropertyChangeListener(new PropertyChangeListener() {
+            public void propertyChange(PropertyChangeEvent e) {
+                if ("viewType".equals(e.getPropertyName())) {
+                    switch (filePane.getViewType()) {
+                        case FilePane.VIEWTYPE_LIST:
+                            listViewMenuItem.setSelected(true);
+                            break;
+
+                        case FilePane.VIEWTYPE_DETAILS:
+                            detailsViewMenuItem.setSelected(true);
+                            break;
                     }
                 }
-            });
-            viewMenuButton.addMouseListener(new MouseAdapter() {
-                public void mousePressed(MouseEvent e) {
-                    if (SwingUtilities.isLeftMouseButton(e)) {
-                        viewMenuButton.setSelected(!viewMenuButton.isSelected());
-
-                        if (viewMenuButton.isSelected()) {
-                            viewTypePopupMenu.show(viewMenuButton, 0, viewMenuButton.getHeight());
-                        }
-                    }
-                }
-            });
-            viewTypePopupMenu.addPopupMenuListener(new PopupMenuListener() {
-                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
-                }
-
-                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
-                    SwingUtilities.invokeLater(new Runnable() {
-                        public void run() {
-                            viewMenuButton.setSelected(false);
-                        }
-                    });
-                }
-
-                public void popupMenuCanceled(PopupMenuEvent e) {
-                }
-            });
-            topPanel.add(viewMenuButton);
-
-            topPanel.add(Box.createRigidArea(new Dimension(80, 0)));
-
-            filePane.addPropertyChangeListener(new PropertyChangeListener() {
-                public void propertyChange(PropertyChangeEvent e) {
-                    if ("viewType".equals(e.getPropertyName())) {
-                        switch (filePane.getViewType()) {
-                            case FilePane.VIEWTYPE_LIST:
-                                listViewMenuItem.setSelected(true);
-                                break;
-
-                            case FilePane.VIEWTYPE_DETAILS:
-                                detailsViewMenuItem.setSelected(true);
-                                break;
-                        }
-                    }
-                }
-            });
-        }
+            }
+        });
 
         // ************************************** //
         // ******* Add the directory pane ******* //
@@ -622,19 +493,18 @@ public class WindowsFileChooserUI extend
         // Decide whether to use the ShellFolder class to populate shortcut
         // panel and combobox.
         JFileChooser fc = getFileChooser();
-        if (OS_VERSION.compareTo(OSInfo.WINDOWS_ME) >= 0) {
-            if (FilePane.usesShellFolder(fc)) {
-                if (placesBar == null && !UIManager.getBoolean("FileChooser.noPlacesBar")) {
-                    placesBar = new WindowsPlacesBar(fc, XPStyle.getXP() != null);
-                    fc.add(placesBar, BorderLayout.BEFORE_LINE_BEGINS);
-                    fc.addPropertyChangeListener(placesBar);
-                }
-            } else {
-                if (placesBar != null) {
-                    fc.remove(placesBar);
-                    fc.removePropertyChangeListener(placesBar);
-                    placesBar = null;
-                }
+
+        if (FilePane.usesShellFolder(fc)) {
+            if (placesBar == null && !UIManager.getBoolean("FileChooser.noPlacesBar")) {
+                placesBar = new WindowsPlacesBar(fc, XPStyle.getXP() != null);
+                fc.add(placesBar, BorderLayout.BEFORE_LINE_BEGINS);
+                fc.addPropertyChangeListener(placesBar);
+            }
+        } else {
+            if (placesBar != null) {
+                fc.remove(placesBar);
+                fc.removePropertyChangeListener(placesBar);
+                placesBar = null;
             }
         }
     }
@@ -673,17 +543,8 @@ public class WindowsFileChooserUI extend
         upFolderToolTipText =  UIManager.getString("FileChooser.upFolderToolTipText",l);
         upFolderAccessibleName = UIManager.getString("FileChooser.upFolderAccessibleName",l);
 
-        homeFolderToolTipText =  UIManager.getString("FileChooser.homeFolderToolTipText",l);
-        homeFolderAccessibleName = UIManager.getString("FileChooser.homeFolderAccessibleName",l);
-
         newFolderToolTipText = UIManager.getString("FileChooser.newFolderToolTipText",l);
         newFolderAccessibleName = UIManager.getString("FileChooser.newFolderAccessibleName",l);
-
-        listViewButtonToolTipText = UIManager.getString("FileChooser.listViewButtonToolTipText",l);
-        listViewButtonAccessibleName = UIManager.getString("FileChooser.listViewButtonAccessibleName",l);
-
-        detailsViewButtonToolTipText = UIManager.getString("FileChooser.detailsViewButtonToolTipText",l);
-        detailsViewButtonAccessibleName = UIManager.getString("FileChooser.detailsViewButtonAccessibleName",l);
 
         viewMenuButtonToolTipText = UIManager.getString("FileChooser.viewMenuButtonToolTipText",l);
         viewMenuButtonAccessibleName = UIManager.getString("FileChooser.viewMenuButtonAccessibleName",l);
@@ -1052,6 +913,65 @@ public class WindowsFileChooserUI extend
         return new DirectoryComboBoxRenderer();
     }
 
+    private static JButton createToolButton(Action a, Icon defaultIcon, String toolTipText, String accessibleName) {
+        final JButton result = new JButton(a);
+
+        result.setText(null);
+        result.setIcon(defaultIcon);
+        result.setToolTipText(toolTipText);
+        result.setRequestFocusEnabled(false);
+        result.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, accessibleName);
+        result.putClientProperty(WindowsLookAndFeel.HI_RES_DISABLED_ICON_CLIENT_KEY, Boolean.TRUE);
+        result.setAlignmentX(JComponent.LEFT_ALIGNMENT);
+        result.setAlignmentY(JComponent.CENTER_ALIGNMENT);
+        result.setMargin(shrinkwrap);
+        result.setFocusPainted(false);
+
+        result.setModel(new DefaultButtonModel() {
+            public void setPressed(boolean b) {
+                // Forbid keyboard actions if the button is not in rollover state
+                if (!b || isRollover()) {
+                    super.setPressed(b);
+                }
+            }
+
+            public void setRollover(boolean b) {
+                if (b && !isRollover()) {
+                    // Reset other buttons
+                    for (Component component : result.getParent().getComponents()) {
+                        if (component instanceof JButton && component != result) {
+                            ((JButton) component).getModel().setRollover(false);
+                        }
+                    }
+                }
+
+                super.setRollover(b);
+            }
+
+            public void setSelected(boolean b) {
+                super.setSelected(b);
+
+                if (b) {
+                    stateMask |= PRESSED | ARMED;
+                } else {
+                    stateMask &= ~(PRESSED | ARMED);
+                }
+            }
+        });
+
+        result.addFocusListener(new FocusAdapter() {
+            public void focusGained(FocusEvent e) {
+                result.getModel().setRollover(true);
+            }
+
+            public void focusLost(FocusEvent e) {
+                result.getModel().setRollover(false);
+            }
+        });
+
+        return result;
+    }
+
     //
     // Renderer for DirectoryComboBox
     //
--- a/src/share/classes/com/sun/java/swing/plaf/windows/WindowsLookAndFeel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/java/swing/plaf/windows/WindowsLookAndFeel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 1997-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1997-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -104,7 +104,6 @@ public class WindowsLookAndFeel extends 
         new StringUIClientPropertyKey(
             "WindowsLookAndFeel.generateHiResDisabledIcon");
 
-    private Toolkit toolkit;
     private boolean updatePending = false;
 
     private boolean useSystemFontSettings = true;
@@ -149,7 +148,6 @@ public class WindowsLookAndFeel extends 
 
     public void initialize() {
         super.initialize();
-        toolkit = Toolkit.getDefaultToolkit();
 
         // Set the flag which determines which version of Windows should
         // be rendered. This flag only need to be set once.
@@ -470,80 +468,61 @@ public class WindowsLookAndFeel extends 
 
         Object ControlBackgroundColor = new DesktopProperty(
                                                        "win.3d.backgroundColor",
-                                                        table.get("control"),
-                                                       toolkit);
+                                                        table.get("control"));
         Object ControlLightColor      = new DesktopProperty(
                                                        "win.3d.lightColor",
-                                                        table.get("controlHighlight"),
-                                                       toolkit);
+                                                        table.get("controlHighlight"));
         Object ControlHighlightColor  = new DesktopProperty(
                                                        "win.3d.highlightColor",
-                                                        table.get("controlLtHighlight"),
-                                                       toolkit);
+                                                        table.get("controlLtHighlight"));
         Object ControlShadowColor     = new DesktopProperty(
                                                        "win.3d.shadowColor",
-                                                        table.get("controlShadow"),
-                                                       toolkit);
+                                                        table.get("controlShadow"));
         Object ControlDarkShadowColor = new DesktopProperty(
                                                        "win.3d.darkShadowColor",
-                                                        table.get("controlDkShadow"),
-                                                       toolkit);
+                                                        table.get("controlDkShadow"));
         Object ControlTextColor       = new DesktopProperty(
                                                        "win.button.textColor",
-                                                        table.get("controlText"),
-                                                       toolkit);
+                                                        table.get("controlText"));
         Object MenuBackgroundColor    = new DesktopProperty(
                                                        "win.menu.backgroundColor",
-                                                        table.get("menu"),
-                                                       toolkit);
+                                                        table.get("menu"));
         Object MenuBarBackgroundColor = new DesktopProperty(
                                                        "win.menubar.backgroundColor",
-                                                        table.get("menu"),
-                                                       toolkit);
+                                                        table.get("menu"));
         Object MenuTextColor          = new DesktopProperty(
                                                        "win.menu.textColor",
-                                                        table.get("menuText"),
-                                                       toolkit);
+                                                        table.get("menuText"));
         Object SelectionBackgroundColor = new DesktopProperty(
                                                        "win.item.highlightColor",
-                                                        table.get("textHighlight"),
-                                                       toolkit);
+                                                        table.get("textHighlight"));
         Object SelectionTextColor     = new DesktopProperty(
                                                        "win.item.highlightTextColor",
-                                                        table.get("textHighlightText"),
-                                                       toolkit);
+                                                        table.get("textHighlightText"));
         Object WindowBackgroundColor  = new DesktopProperty(
                                                        "win.frame.backgroundColor",
-                                                        table.get("window"),
-                                                       toolkit);
+                                                        table.get("window"));
         Object WindowTextColor        = new DesktopProperty(
                                                        "win.frame.textColor",
-                                                        table.get("windowText"),
-                                                       toolkit);
+                                                        table.get("windowText"));
         Object WindowBorderWidth      = new DesktopProperty(
                                                        "win.frame.sizingBorderWidth",
-                                                       Integer.valueOf(1),
-                                                       toolkit);
+                                                       Integer.valueOf(1));
         Object TitlePaneHeight        = new DesktopProperty(
                                                        "win.frame.captionHeight",
-                                                       Integer.valueOf(18),
-                                                       toolkit);
+                                                       Integer.valueOf(18));
         Object TitleButtonWidth       = new DesktopProperty(
                                                        "win.frame.captionButtonWidth",
-                                                       Integer.valueOf(16),
-                                                       toolkit);
+                                                       Integer.valueOf(16));
         Object TitleButtonHeight      = new DesktopProperty(
                                                        "win.frame.captionButtonHeight",
-                                                       Integer.valueOf(16),
-                                                       toolkit);
+                                                       Integer.valueOf(16));
         Object InactiveTextColor      = new DesktopProperty(
                                                        "win.text.grayedTextColor",
-                                                        table.get("textInactiveText"),
-                                                       toolkit);
+                                                        table.get("textInactiveText"));
         Object ScrollbarBackgroundColor = new DesktopProperty(
                                                        "win.scrollbar.backgroundColor",
-                                                        table.get("scrollbar"),
-                                                       toolkit);
+                                                        table.get("scrollbar"));
 
         Object TextBackground         = new XPColorValue(Part.EP_EDIT, null, Prop.FILLCOLOR,
                                                          WindowBackgroundColor);
@@ -566,32 +545,22 @@ public class WindowsLookAndFeel extends 
         Object ToolTipFont = sansSerifPlain12;
         Object IconFont = ControlFont;
 
-        Object scrollBarWidth = new DesktopProperty("win.scrollbar.width",
-                                                    Integer.valueOf(16), toolkit);
-
-        Object menuBarHeight = new DesktopProperty("win.menu.height",
-                                                   null, toolkit);
-
-        Object hotTrackingOn = new DesktopProperty("win.item.hotTrackingOn",
-                                                   true, toolkit);
-
-        Object showMnemonics = new DesktopProperty("win.menu.keyboardCuesOn",
-                                                     Boolean.TRUE, toolkit);
+        Object scrollBarWidth = new DesktopProperty("win.scrollbar.width", Integer.valueOf(16));
+
+        Object menuBarHeight = new DesktopProperty("win.menu.height", null);
+
+        Object hotTrackingOn = new DesktopProperty("win.item.hotTrackingOn", true);
+
+        Object showMnemonics = new DesktopProperty("win.menu.keyboardCuesOn", Boolean.TRUE);
 
         if (useSystemFontSettings) {
-            MenuFont = getDesktopFontValue("win.menu.font", MenuFont, toolkit);
-            FixedControlFont = getDesktopFontValue("win.ansiFixed.font",
-                                                   FixedControlFont, toolkit);
-            ControlFont = getDesktopFontValue("win.defaultGUI.font",
-                                              ControlFont, toolkit);
-            MessageFont = getDesktopFontValue("win.messagebox.font",
-                                              MessageFont, toolkit);
-            WindowFont = getDesktopFontValue("win.frame.captionFont",
-                                             WindowFont, toolkit);
-            IconFont    = getDesktopFontValue("win.icon.font",
-                                              IconFont, toolkit);
-            ToolTipFont = getDesktopFontValue("win.tooltip.font", ToolTipFont,
-                                              toolkit);
+            MenuFont = getDesktopFontValue("win.menu.font", MenuFont);
+            FixedControlFont = getDesktopFontValue("win.ansiFixed.font", FixedControlFont);
+            ControlFont = getDesktopFontValue("win.defaultGUI.font", ControlFont);
+            MessageFont = getDesktopFontValue("win.messagebox.font", MessageFont);
+            WindowFont = getDesktopFontValue("win.frame.captionFont", WindowFont);
+            IconFont    = getDesktopFontValue("win.icon.font", IconFont);
+            ToolTipFont = getDesktopFontValue("win.tooltip.font", ToolTipFont);
 
             /* Put the desktop AA settings in the defaults.
              * JComponent.setUI() retrieves this and makes it available
@@ -605,26 +574,14 @@ public class WindowsLookAndFeel extends 
                 new FontDesktopProperty(SunToolkit.DESKTOPFONTHINTS);
         }
         if (useSystemFontSizeSettings) {
-            MenuFont = new WindowsFontSizeProperty("win.menu.font.height",
-                                  toolkit, Font.DIALOG, Font.PLAIN, 12);
-            FixedControlFont = new WindowsFontSizeProperty(
-                       "win.ansiFixed.font.height", toolkit, Font.MONOSPACED,
+            MenuFont = new WindowsFontSizeProperty("win.menu.font.height", Font.DIALOG, Font.PLAIN, 12);
+            FixedControlFont = new WindowsFontSizeProperty("win.ansiFixed.font.height", Font.MONOSPACED,
                        Font.PLAIN, 12);
-            ControlFont = new WindowsFontSizeProperty(
-                        "win.defaultGUI.font.height", toolkit, Font.DIALOG,
-                        Font.PLAIN, 12);
-            MessageFont = new WindowsFontSizeProperty(
-                              "win.messagebox.font.height",
-                              toolkit, Font.DIALOG, Font.PLAIN, 12);
-            WindowFont = new WindowsFontSizeProperty(
-                             "win.frame.captionFont.height", toolkit,
-                             Font.DIALOG, Font.BOLD, 12);
-            ToolTipFont = new WindowsFontSizeProperty(
-                              "win.tooltip.font.height", toolkit, Font.SANS_SERIF,
-                              Font.PLAIN, 12);
-            IconFont    = new WindowsFontSizeProperty(
-                              "win.icon.font.height", toolkit, Font.DIALOG,
-                              Font.PLAIN, 12);
+            ControlFont = new WindowsFontSizeProperty("win.defaultGUI.font.height", Font.DIALOG, Font.PLAIN, 12);
+            MessageFont = new WindowsFontSizeProperty("win.messagebox.font.height", Font.DIALOG, Font.PLAIN, 12);
+            WindowFont = new WindowsFontSizeProperty("win.frame.captionFont.height", Font.DIALOG, Font.BOLD, 12);
+            ToolTipFont = new WindowsFontSizeProperty("win.tooltip.font.height", Font.SANS_SERIF, Font.PLAIN, 12);
+            IconFont    = new WindowsFontSizeProperty("win.icon.font.height", Font.DIALOG, Font.PLAIN, 12);
         }
 
 
@@ -752,8 +709,7 @@ public class WindowsLookAndFeel extends 
             // DeskTop.
             "Desktop.background", new DesktopProperty(
                                                  "win.desktop.backgroundColor",
-                                                  table.get("desktop"),
-                                                 toolkit),
+                                                  table.get("desktop")),
             "Desktop.ancestorInputMap",
                new UIDefaults.LazyInputMap(new Object[] {
                    "ctrl F5", "restore",
@@ -819,7 +775,7 @@ public class WindowsLookAndFeel extends 
             "FileChooser.filesOfTypeLabelMnemonic", Integer.valueOf(KeyEvent.VK_T),
             "FileChooser.usesSingleFilePane", Boolean.TRUE,
             "FileChooser.noPlacesBar", new DesktopProperty("win.comdlg.noPlacesBar",
-                                                           Boolean.FALSE, toolkit),
+                                                           Boolean.FALSE),
             "FileChooser.ancestorInputMap",
                new UIDefaults.LazyInputMap(new Object[] {
                      "ESCAPE", "cancelSelection",
@@ -861,36 +817,28 @@ public class WindowsLookAndFeel extends 
             "InternalFrame.resizeIconShadow", ControlShadowColor,
             "InternalFrame.activeBorderColor", new DesktopProperty(
                                                        "win.frame.activeBorderColor",
-                                                       table.get("windowBorder"),
-                                                       toolkit),
+                                                       table.get("windowBorder")),
             "InternalFrame.inactiveBorderColor", new DesktopProperty(
                                                        "win.frame.inactiveBorderColor",
-                                                       table.get("windowBorder"),
-                                                       toolkit),
+                                                       table.get("windowBorder")),
             "InternalFrame.activeTitleBackground", new DesktopProperty(
                                                         "win.frame.activeCaptionColor",
-                                                         table.get("activeCaption"),
-                                                        toolkit),
+                                                         table.get("activeCaption")),
             "InternalFrame.activeTitleGradient", new DesktopProperty(
                                                         "win.frame.activeCaptionGradientColor",
-                                                         table.get("activeCaption"),
-                                                        toolkit),
+                                                         table.get("activeCaption")),
             "InternalFrame.activeTitleForeground", new DesktopProperty(
                                                         "win.frame.captionTextColor",
-                                                         table.get("activeCaptionText"),
-                                                        toolkit),
+                                                         table.get("activeCaptionText")),
             "InternalFrame.inactiveTitleBackground", new DesktopProperty(
                                                         "win.frame.inactiveCaptionColor",
-                                                         table.get("inactiveCaption"),
-                                                        toolkit),
+                                                         table.get("inactiveCaption")),
             "InternalFrame.inactiveTitleGradient", new DesktopProperty(
                                                         "win.frame.inactiveCaptionGradientColor",
-                                                         table.get("inactiveCaption"),
-                                                        toolkit),
+                                                         table.get("inactiveCaption")),
             "InternalFrame.inactiveTitleForeground", new DesktopProperty(
                                                         "win.frame.inactiveCaptionTextColor",
-                                                         table.get("inactiveCaptionText"),
-                                                        toolkit),
+                                                         table.get("inactiveCaptionText")),
 
             "InternalFrame.maximizeIcon",
                 WindowsIconFactory.createFrameMaximizeIcon(),
@@ -1529,12 +1477,8 @@ public class WindowsLookAndFeel extends 
 
             // *** ToolTip
             "ToolTip.font", ToolTipFont,
-            "ToolTip.background", new DesktopProperty(
-                                           "win.tooltip.backgroundColor",
-                                            table.get("info"), toolkit),
-            "ToolTip.foreground", new DesktopProperty(
-                                           "win.tooltip.textColor",
-                                            table.get("infoText"), toolkit),
+            "ToolTip.background", new DesktopProperty("win.tooltip.backgroundColor", table.get("info")),
+            "ToolTip.foreground", new DesktopProperty("win.tooltip.textColor", table.get("infoText")),
 
         // *** ToolTipManager
             "ToolTipManager.enableToolTipMode", "activeApplication",
@@ -1798,10 +1742,9 @@ public class WindowsLookAndFeel extends 
      * represented in the current encoding this will return null and
      * turn off the use of system fonts.
      */
-    private Object getDesktopFontValue(String fontName, Object backup,
-                                       Toolkit kit) {
+    private Object getDesktopFontValue(String fontName, Object backup) {
         if (useSystemFontSettings) {
-            return new WindowsFontProperty(fontName, backup, kit);
+            return new WindowsFontProperty(fontName, backup);
         }
         return null;
     }
@@ -1989,7 +1932,6 @@ public class WindowsLookAndFeel extends 
 
     public void uninitialize() {
         super.uninitialize();
-        toolkit = null;
 
         if (WindowsPopupMenuUI.mnemonicListener != null) {
             MenuSelectionManager.defaultManager().
@@ -2309,8 +2251,8 @@ public class WindowsLookAndFeel extends 
      * is returned, it is mapped to 'Microsoft Sans Serif'.
      */
     private static class WindowsFontProperty extends DesktopProperty {
-        WindowsFontProperty(String key, Object backup, Toolkit kit) {
-            super(key, backup, kit);
+        WindowsFontProperty(String key, Object backup) {
+            super(key, backup);
         }
 
         public void invalidate(LookAndFeel laf) {
@@ -2372,9 +2314,9 @@ public class WindowsLookAndFeel extends 
         private int fontSize;
         private int fontStyle;
 
-        WindowsFontSizeProperty(String key, Toolkit toolkit, String fontName,
+        WindowsFontSizeProperty(String key, String fontName,
                                 int fontStyle, int fontSize) {
-            super(key, null, toolkit);
+            super(key, null);
             this.fontName = fontName;
             this.fontSize = fontSize;
             this.fontStyle = fontStyle;
@@ -2508,7 +2450,7 @@ public class WindowsLookAndFeel extends 
 
     private class TriggerDesktopProperty extends DesktopProperty {
         TriggerDesktopProperty(String key) {
-            super(key, null, toolkit);
+            super(key, null);
             // This call adds a property change listener for the property,
             // which triggers a call to updateUI(). The value returned
             // is not interesting here.
--- a/src/share/classes/com/sun/security/auth/callback/TextCallbackHandler.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/security/auth/callback/TextCallbackHandler.java	Tue Sep 22 01:20:51 2009 -0700
@@ -129,7 +129,7 @@ public class TextCallbackHandler impleme
                 System.err.print(pc.getPrompt());
                 System.err.flush();
 
-                pc.setPassword(Password.readPassword(System.in));
+                pc.setPassword(Password.readPassword(System.in, pc.isEchoOn()));
 
             } else if (callbacks[i] instanceof ConfirmationCallback) {
                 confirmation = (ConfirmationCallback) callbacks[i];
--- a/src/share/classes/com/sun/security/sasl/Provider.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/com/sun/security/sasl/Provider.java	Tue Sep 22 01:20:51 2009 -0700
@@ -51,7 +51,7 @@ public final class Provider extends java
         " server mechanisms for: DIGEST-MD5, GSSAPI, CRAM-MD5)";
 
     public Provider() {
-        super("SunSASL", 1.5, info);
+        super("SunSASL", 1.7d, info);
 
         AccessController.doPrivileged(new PrivilegedAction<Void>() {
             public Void run() {
--- a/src/share/classes/java/awt/Cursor.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/awt/Cursor.java	Tue Sep 22 01:20:51 2009 -0700
@@ -119,7 +119,7 @@ public class Cursor implements java.io.S
     public static final int     MOVE_CURSOR                     = 13;
 
     /**
-      * @deprecated As of JDK version 1.7, the {@link #getPredefinedCursor()}
+      * @deprecated As of JDK version 1.7, the {@link #getPredefinedCursor(int)}
       * method should be used instead.
       */
     @Deprecated
--- a/src/share/classes/java/awt/Window.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/awt/Window.java	Tue Sep 22 01:20:51 2009 -0700
@@ -3347,7 +3347,7 @@ public class Window extends Container im
      *
      * @return the opacity of the window
      *
-     * @see Window#setOpacity
+     * @see Window#setOpacity(float)
      * @see GraphicsDevice.WindowTranslucency
      *
      * @since 1.7
@@ -3366,7 +3366,7 @@ public class Window extends Container im
      * window. This is a platform-dependent behavior.
      * <p>
      * In order for this method to enable the translucency effect, the {@link
-     * GraphicsDevice#isWindowTranslucencySupported()} method must indicate that
+     * GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)} method must indicate that
      * the {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
      * translucency is supported.
      * <p>
@@ -3375,8 +3375,8 @@ public class Window extends Container im
      * IllegalComponentStateException} is thrown.
      * <p>
      * The translucency levels of individual pixels may also be effected by the
-     * alpha component of their color (see {@link setBackground()}) and the
-     * current shape of this window (see {@link setShape()}).
+     * alpha component of their color (see {@link Window#setBackground(Color)}) and the
+     * current shape of this window (see {@link #setShape(Shape)}).
      *
      * @param opacity the opacity level to set to the window
      *
@@ -3389,10 +3389,10 @@ public class Window extends Container im
      *     translucency kind is not supported and the opacity is less than 1.0f
      *
      * @see Window#getOpacity
-     * @see Window#setBackground()
-     * @see Window#setShape()
+     * @see Window#setBackground(Color)
+     * @see Window#setShape(Shape)
      * @see GraphicsDevice.WindowTranslucency
-     * @see GraphicsDevice#isWindowTranslucencySupported()
+     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
      *
      * @since 1.7
      */
@@ -3434,7 +3434,7 @@ public class Window extends Container im
      * @return the shape of the window or {@code null} if no
      *     shape is specified for the window
      *
-     * @see Window#setShape
+     * @see Window#setShape(Shape)
      * @see GraphicsDevice.WindowTranslucency
      *
      * @since 1.7
@@ -3458,19 +3458,19 @@ public class Window extends Container im
      * <ul>
      * <li>The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
      * PERPIXEL_TRANSPARENT} translucency kind must be supported by the
-     * underlying system (see {@link })
+     * underlying system
      * <i>and</i>
      * <li>The window must not be in the full-screen mode (see
-     * {@link GraphicsDevice#setFullScreenWindow()})
+     * {@link GraphicsDevice#setFullScreenWindow(Window)})
      * </ul>
      * If a certain condition is not met, either the {@code
      * UnsupportedOperationException} or {@code IllegalComponentStateException}
      * is thrown.
      * <p>
      * The tranlucency levels of individual pixels may also be effected by the
-     * alpha component of their color (see {@link setBackground()}) and the
-     * opacity value (see {@link setOpacity()}). See {@link
-     * GraphicsDevice#WindowTranslucency} for more details.
+     * alpha component of their color (see {@link Window#setBackground(Color)}) and the
+     * opacity value (see {@link #setOpacity(float)}). See {@link
+     * GraphicsDevice.WindowTranslucency} for more details.
      *
      * @param shape the shape to set to the window
      *
@@ -3481,10 +3481,10 @@ public class Window extends Container im
      *     PERPIXEL_TRANSPARENT} translucency is not supported
      *
      * @see Window#getShape()
-     * @see Window#setBackgound()
-     * @see Window#setOpacity()
+     * @see Window#setBackground(Color)
+     * @see Window#setOpacity(float)
      * @see GraphicsDevice.WindowTranslucency
-     * @see GraphicsDevice#isWindowTranslucencySupported()
+     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
      *
      * @since 1.7
      */
@@ -3520,7 +3520,7 @@ public class Window extends Container im
      *
      * @return this component's background color
      *
-     * @see Window#setBackground
+     * @see Window#setBackground(Color)
      * @see Window#isOpaque
      * @see GraphicsDevice.WindowTranslucency
      */
@@ -3544,7 +3544,7 @@ public class Window extends Container im
      * PERPIXEL_TRANSLUCENT} translucency must be supported
      * by the graphics device where this window is located <i>and</i>
      * <li>The window must not be in the full-screen mode (see {@link
-     * GraphicsDevice#setFullScreenWindow()})
+     * GraphicsDevice#setFullScreenWindow(Window)})
      * </ul>
      * If a certain condition is not met at the time of calling this method,
      * the alpha component of the given background color will not effect the
@@ -3561,8 +3561,8 @@ public class Window extends Container im
      * method is equal to zero.)
      * <p>
      * The actual level of translucency of a given pixel also depends on window
-     * opacity (see {@link setOpacity()}), as well as the current shape of
-     * this window (see {@link setShape()}).
+     * opacity (see {@link #setOpacity(float)}), as well as the current shape of
+     * this window (see {@link #setShape(Shape)}).
      * <p>
      * Note that painting a pixel with the alpha value of 0 may or may not
      * disable the mouse event handling on this pixel. This is a
@@ -3585,10 +3585,10 @@ public class Window extends Container im
      *
      * @see Window#getBackground
      * @see Window#isOpaque
-     * @see Window#setOpacity()
-     * @see Window#setShape()
+     * @see Window#setOpacity(float)
+     * @see Window#setShape(Shape)
      * @see GraphicsDevice.WindowTranslucency
-     * @see GraphicsDevice#isWindowTranslucencySupported()
+     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
      * @see GraphicsConfiguration#isTranslucencyCapable()
      */
     @Override
@@ -3635,7 +3635,7 @@ public class Window extends Container im
      * @return {@code true} if the window is opaque, {@code false} otherwise
      *
      * @see Window#getBackground
-     * @see Window#setBackground
+     * @see Window#setBackground(Color)
      * @since 1.7
      */
     @Override
--- a/src/share/classes/java/awt/dnd/DragSourceContext.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/awt/dnd/DragSourceContext.java	Tue Sep 22 01:20:51 2009 -0700
@@ -275,7 +275,7 @@ public class DragSourceContext
      *
      * @param c     the initial {@code Cursor} for this drag operation,
      *                       or {@code null} for the default cursor handling;
-     *                       see {@linkplain #defaultCursor class
+     *                       see {@linkplain Cursor class
      *                       level documentation} for more details
      *                       on the cursor handling during drag and drop
      *
--- a/src/share/classes/java/lang/Character.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/Character.java	Tue Sep 22 01:20:51 2009 -0700
@@ -162,7 +162,7 @@ class Character extends Object implement
      *
      * @since   1.0.2
      */
-    public static final char   MAX_VALUE = '\uffff';
+    public static final char   MAX_VALUE = '\uFFFF';
 
     /**
      * The <code>Class</code> instance representing the primitive type
@@ -518,75 +518,91 @@ class Character extends Object implement
     public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT = 18;
 
     /**
-     * The minimum value of a Unicode high-surrogate code unit in the
-     * UTF-16 encoding. A high-surrogate is also known as a
-     * <i>leading-surrogate</i>.
+     * The minimum value of a
+     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
+     * Unicode high-surrogate code unit</a>
+     * in the UTF-16 encoding, constant <code>'&#92;uD800'</code>.
+     * A high-surrogate is also known as a <i>leading-surrogate</i>.
      *
      * @since 1.5
      */
     public static final char MIN_HIGH_SURROGATE = '\uD800';
 
     /**
-     * The maximum value of a Unicode high-surrogate code unit in the
-     * UTF-16 encoding. A high-surrogate is also known as a
-     * <i>leading-surrogate</i>.
+     * The maximum value of a
+     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
+     * Unicode high-surrogate code unit</a>
+     * in the UTF-16 encoding, constant <code>'&#92;uDBFF'</code>.
+     * A high-surrogate is also known as a <i>leading-surrogate</i>.
      *
      * @since 1.5
      */
     public static final char MAX_HIGH_SURROGATE = '\uDBFF';
 
     /**
-     * The minimum value of a Unicode low-surrogate code unit in the
-     * UTF-16 encoding. A low-surrogate is also known as a
-     * <i>trailing-surrogate</i>.
+     * The minimum value of a
+     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
+     * Unicode low-surrogate code unit</a>
+     * in the UTF-16 encoding, constant <code>'&#92;uDC00'</code>.
+     * A low-surrogate is also known as a <i>trailing-surrogate</i>.
      *
      * @since 1.5
      */
     public static final char MIN_LOW_SURROGATE  = '\uDC00';
 
     /**
-     * The maximum value of a Unicode low-surrogate code unit in the
-     * UTF-16 encoding. A low-surrogate is also known as a
-     * <i>trailing-surrogate</i>.
+     * The maximum value of a
+     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
+     * Unicode low-surrogate code unit</a>
+     * in the UTF-16 encoding, constant <code>'&#92;uDFFF'</code>.
+     * A low-surrogate is also known as a <i>trailing-surrogate</i>.
      *
      * @since 1.5
      */
     public static final char MAX_LOW_SURROGATE  = '\uDFFF';
 
     /**
-     * The minimum value of a Unicode surrogate code unit in the UTF-16 encoding.
+     * The minimum value of a Unicode surrogate code unit in the
+     * UTF-16 encoding, constant <code>'&#92;uD800'</code>.
      *
      * @since 1.5
      */
     public static final char MIN_SURROGATE = MIN_HIGH_SURROGATE;
 
     /**
-     * The maximum value of a Unicode surrogate code unit in the UTF-16 encoding.
+     * The maximum value of a Unicode surrogate code unit in the
+     * UTF-16 encoding, constant <code>'&#92;uDFFF'</code>.
      *
      * @since 1.5
      */
     public static final char MAX_SURROGATE = MAX_LOW_SURROGATE;
 
     /**
-     * The minimum value of a supplementary code point.
+     * The minimum value of a
+     * <a href="http://www.unicode.org/glossary/#supplementary_code_point">
+     * Unicode supplementary code point</a>, constant {@code U+10000}.
      *
      * @since 1.5
      */
     public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000;
 
     /**
-     * The minimum value of a Unicode code point.
+     * The minimum value of a
+     * <a href="http://www.unicode.org/glossary/#code_point">
+     * Unicode code point</a>, constant {@code U+0000}.
      *
      * @since 1.5
      */
     public static final int MIN_CODE_POINT = 0x000000;
 
     /**
-     * The maximum value of a Unicode code point.
+     * The maximum value of a
+     * <a href="http://www.unicode.org/glossary/#code_point">
+     * Unicode code point</a>, constant {@code U+10FFFF}.
      *
      * @since 1.5
      */
-    public static final int MAX_CODE_POINT = 0x10ffff;
+    public static final int MAX_CODE_POINT = 0X10FFFF;
 
 
     /**
@@ -2571,9 +2587,9 @@ class Character extends Object implement
      * significantly better space and time performance by caching
      * frequently requested values.
      *
-     * This method will always cache values in the range '&#92;u0000'
-     * to '&#92;u007f'", inclusive, and may cache other values outside
-     * of this range.
+     * This method will always cache values in the range {@code
+     * '\u005Cu0000'} to {@code '\u005Cu007f'}, inclusive, and may
+     * cache other values outside of this range.
      *
      * @param  c a char value.
      * @return a <tt>Character</tt> instance representing <tt>c</tt>.
@@ -2648,19 +2664,15 @@ class Character extends Object implement
     }
 
     /**
-     * Determines whether the specified code point is a valid Unicode
-     * code point value in the range of <code>0x0000</code> to
-     * <code>0x10FFFF</code> inclusive. This method is equivalent to
-     * the expression:
-     *
-     * <blockquote><pre>
-     * codePoint >= 0x0000 && codePoint <= 0x10FFFF
-     * </pre></blockquote>
+     * Determines whether the specified code point is a valid
+     * <a href="http://www.unicode.org/glossary/#code_point">
+     * Unicode code point value</a>.
      *
      * @param  codePoint the Unicode code point to be tested
-     * @return <code>true</code> if the specified code point value
-     * is a valid code point value;
-     * <code>false</code> otherwise.
+     * @return {@code true} if the specified code point value is between
+     *         {@link #MIN_CODE_POINT} and
+     *         {@link #MAX_CODE_POINT} inclusive;
+     *         {@code false} otherwise.
      * @since  1.5
      */
     public static boolean isValidCodePoint(int codePoint) {
@@ -2669,15 +2681,13 @@ class Character extends Object implement
 
     /**
      * Determines whether the specified character (Unicode code point)
-     * is in the supplementary character range. The method call is
-     * equivalent to the expression:
-     * <blockquote><pre>
-     * codePoint >= 0x10000 && codePoint <= 0x10FFFF
-     * </pre></blockquote>
+     * is in the <a href="#supplementary">supplementary character</a> range.
      *
      * @param  codePoint the character (Unicode code point) to be tested
-     * @return <code>true</code> if the specified character is in the Unicode
-     *         supplementary character range; <code>false</code> otherwise.
+     * @return {@code true} if the specified code point is between
+     *         {@link #MIN_SUPPLEMENTARY_CODE_POINT} and
+     *         {@link #MAX_CODE_POINT} inclusive;
+     *         {@code false} otherwise.
      * @since  1.5
      */
     public static boolean isSupplementaryCodePoint(int codePoint) {
@@ -2686,56 +2696,83 @@ class Character extends Object implement
     }
 
     /**
-     * Determines if the given <code>char</code> value is a
-     * high-surrogate code unit (also known as <i>leading-surrogate
-     * code unit</i>). Such values do not represent characters by
-     * themselves, but are used in the representation of <a
-     * href="#supplementary">supplementary characters</a> in the
-     * UTF-16 encoding.
-     *
-     * <p>This method returns <code>true</code> if and only if
-     * <blockquote><pre>ch >= '&#92;uD800' && ch <= '&#92;uDBFF'
-     * </pre></blockquote>
-     * is <code>true</code>.
-     *
-     * @param   ch   the <code>char</code> value to be tested.
-     * @return  <code>true</code> if the <code>char</code> value
-     *          is between '&#92;uD800' and '&#92;uDBFF' inclusive;
-     *          <code>false</code> otherwise.
-     * @see     java.lang.Character#isLowSurrogate(char)
-     * @see     Character.UnicodeBlock#of(int)
-     * @since   1.5
+     * Determines if the given {@code char} value is a
+     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
+     * Unicode high-surrogate code unit</a>
+     * (also known as <i>leading-surrogate code unit</i>).
+     *
+     * <p>Such values do not represent characters by themselves,
+     * but are used in the representation of
+     * <a href="#supplementary">supplementary characters</a>
+     * in the UTF-16 encoding.
+     *
+     * @param  ch the {@code char} value to be tested.
+     * @return {@code true} if the {@code char} value is between
+     *         {@link #MIN_HIGH_SURROGATE} and
+     *         {@link #MAX_HIGH_SURROGATE} inclusive;
+     *         {@code false} otherwise.
+     * @see    #isLowSurrogate(char)
+     * @see    Character.UnicodeBlock#of(int)
+     * @since  1.5
      */
     public static boolean isHighSurrogate(char ch) {
         return ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE;
     }
 
     /**
-     * Determines if the given <code>char</code> value is a
-     * low-surrogate code unit (also known as <i>trailing-surrogate code
-     * unit</i>). Such values do not represent characters by themselves,
-     * but are used in the representation of <a
-     * href="#supplementary">supplementary characters</a> in the UTF-16 encoding.
-     *
-     * <p> This method returns <code>true</code> if and only if
-     * <blockquote><pre>ch >= '&#92;uDC00' && ch <= '&#92;uDFFF'
-     * </pre></blockquote> is <code>true</code>.
-     *
-     * @param   ch   the <code>char</code> value to be tested.
-     * @return  <code>true</code> if the <code>char</code> value
-     *          is between '&#92;uDC00' and '&#92;uDFFF' inclusive;
-     *          <code>false</code> otherwise.
-     * @see java.lang.Character#isHighSurrogate(char)
-     * @since   1.5
+     * Determines if the given {@code char} value is a
+     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
+     * Unicode low-surrogate code unit</a>
+     * (also known as <i>trailing-surrogate code unit</i>).
+     *
+     * <p>Such values do not represent characters by themselves,
+     * but are used in the representation of
+     * <a href="#supplementary">supplementary characters</a>
+     * in the UTF-16 encoding.
+     *
+     * @param  ch the {@code char} value to be tested.
+     * @return {@code true} if the {@code char} value is between
+     *         {@link #MIN_LOW_SURROGATE} and
+     *         {@link #MAX_LOW_SURROGATE} inclusive;
+     *         {@code false} otherwise.
+     * @see    #isHighSurrogate(char)
+     * @since  1.5
      */
     public static boolean isLowSurrogate(char ch) {
         return ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE;
     }
 
     /**
+     * Determines if the given {@code char} value is a Unicode
+     * <i>surrogate code unit</i>.
+     *
+     * <p>Such values do not represent characters by themselves,
+     * but are used in the representation of
+     * <a href="#supplementary">supplementary characters</a>
+     * in the UTF-16 encoding.
+     *
+     * <p>A char value is a surrogate code unit if and only if it is either
+     * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or
+     * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.
+     *
+     * @param  ch the {@code char} value to be tested.
+     * @return {@code true} if the {@code char} value is between
+     *         {@link #MIN_SURROGATE} and
+     *         {@link #MAX_SURROGATE} inclusive;
+     *         {@code false} otherwise.
+     * @since  1.7
+     */
+    public static boolean isSurrogate(char ch) {
+        return ch >= MIN_SURROGATE && ch <= MAX_SURROGATE;
+    }
+
+    /**
      * Determines whether the specified pair of <code>char</code>
-     * values is a valid surrogate pair. This method is equivalent to
-     * the expression:
+     * values is a valid
+     * <a href="http://www.unicode.org/glossary/#surrogate_pair">
+     * Unicode surrogate pair</a>.
+
+     * <p>This method is equivalent to the expression:
      * <blockquote><pre>
      * isHighSurrogate(high) && isLowSurrogate(low)
      * </pre></blockquote>
@@ -4968,7 +5005,7 @@ class Character extends Object implement
 
     /**
      * The number of bits used to represent a <tt>char</tt> value in unsigned
-     * binary form.
+     * binary form, constant {@code 16}.
      *
      * @since 1.5
      */
--- a/src/share/classes/java/lang/EnumConstantNotPresentException.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/EnumConstantNotPresentException.java	Tue Sep 22 01:20:51 2009 -0700
@@ -28,8 +28,12 @@ package java.lang;
 /**
  * Thrown when an application tries to access an enum constant by name
  * and the enum type contains no constant with the specified name.
+ * This exception can be thrown by the {@linkplain
+ * java.lang.reflect.AnnotatedElement API used to read annotations
+ * reflectively}.
  *
  * @author  Josh Bloch
+ * @see     java.lang.reflect.AnnotatedElement
  * @since   1.5
  */
 public class EnumConstantNotPresentException extends RuntimeException {
--- a/src/share/classes/java/lang/String.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/String.java	Tue Sep 22 01:20:51 2009 -0700
@@ -2301,6 +2301,54 @@ public final class String
      * @spec JSR-51
      */
     public String[] split(String regex, int limit) {
+        /* fastpath if the regex is a
+           (1)one-char String and this character is not one of the
+              RegEx's meta characters ".$|()[{^?*+\\", or
+           (2)two-char String and the first char is the backslash and
+              the second is not the ascii digit or ascii letter.
+        */
+        char ch = 0;
+        if (((regex.count == 1 &&
+             ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) ||
+             (regex.length() == 2 &&
+              regex.charAt(0) == '\\' &&
+              (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&
+              ((ch-'a')|('z'-ch)) < 0 &&
+              ((ch-'A')|('Z'-ch)) < 0)) &&
+            (ch < Character.MIN_HIGH_SURROGATE ||
+             ch > Character.MAX_LOW_SURROGATE))
+        {
+            int off = 0;
+            int next = 0;
+            boolean limited = limit > 0;
+            ArrayList<String> list = new ArrayList<String>();
+            while ((next = indexOf(ch, off)) != -1) {
+                if (!limited || list.size() < limit - 1) {
+                    list.add(substring(off, next));
+                    off = next + 1;
+                } else {    // last one
+                    //assert (list.size() == limit - 1);
+                    list.add(substring(off, count));
+                    off = count;
+                    break;
+                }
+            }
+            // If no match was found, return this
+            if (off == 0)
+                return new String[] { this };
+
+            // Add remaining segment
+            if (!limited || list.size() < limit)
+                list.add(substring(off, count));
+
+            // Construct result
+            int resultSize = list.size();
+            if (limit == 0)
+                while (resultSize > 0 && list.get(resultSize-1).length() == 0)
+                    resultSize--;
+            String[] result = new String[resultSize];
+            return list.subList(0, resultSize).toArray(result);
+        }
         return Pattern.compile(regex).split(this, limit);
     }
 
--- a/src/share/classes/java/lang/TypeNotPresentException.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/TypeNotPresentException.java	Tue Sep 22 01:20:51 2009 -0700
@@ -35,8 +35,12 @@ package java.lang;
  * <p>Note that this exception may be used when undefined type variables
  * are accessed as well as when types (e.g., classes, interfaces or
  * annotation types) are loaded.
+ * In particular, this exception can be thrown by the {@linkplain
+ * java.lang.reflect.AnnotatedElement API used to read annotations
+ * reflectively}.
  *
  * @author  Josh Bloch
+ * @see     java.lang.reflect.AnnotatedElement
  * @since 1.5
  */
 public class TypeNotPresentException extends RuntimeException {
--- a/src/share/classes/java/lang/annotation/AnnotationFormatError.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/annotation/AnnotationFormatError.java	Tue Sep 22 01:20:51 2009 -0700
@@ -28,8 +28,12 @@ package java.lang.annotation;
 /**
  * Thrown when the annotation parser attempts to read an annotation
  * from a class file and determines that the annotation is malformed.
+ * This error can be thrown by the {@linkplain
+ * java.lang.reflect.AnnotatedElement API used to read annotations
+ * reflectively}.
  *
  * @author  Josh Bloch
+ * @see     java.lang.reflect.AnnotatedElement
  * @since   1.5
  */
 public class AnnotationFormatError extends Error {
--- a/src/share/classes/java/lang/annotation/AnnotationTypeMismatchException.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/annotation/AnnotationTypeMismatchException.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,8 +30,12 @@ import java.lang.reflect.Method;
  * Thrown to indicate that a program has attempted to access an element of
  * an annotation whose type has changed after the annotation was compiled
  * (or serialized).
+ * This exception can be thrown by the {@linkplain
+ * java.lang.reflect.AnnotatedElement API used to read annotations
+ * reflectively}.
  *
  * @author  Josh Bloch
+ * @see     java.lang.reflect.AnnotatedElement
  * @since 1.5
  */
 public class AnnotationTypeMismatchException extends RuntimeException {
--- a/src/share/classes/java/lang/annotation/IncompleteAnnotationException.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/annotation/IncompleteAnnotationException.java	Tue Sep 22 01:20:51 2009 -0700
@@ -30,8 +30,12 @@ package java.lang.annotation;
  * an annotation type that was added to the annotation type definition after
  * the annotation was compiled (or serialized).  This exception will not be
  * thrown if the new element has a default value.
+ * This exception can be thrown by the {@linkplain
+ * java.lang.reflect.AnnotatedElement API used to read annotations
+ * reflectively}.
  *
  * @author  Josh Bloch
+ * @see     java.lang.reflect.AnnotatedElement
  * @since 1.5
  */
 public class IncompleteAnnotationException extends RuntimeException {
--- a/src/share/classes/java/lang/reflect/AnnotatedElement.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/reflect/AnnotatedElement.java	Tue Sep 22 01:20:51 2009 -0700
@@ -50,6 +50,11 @@ import java.lang.annotation.Annotation;
  * java.lang.annotation.AnnotationTypeMismatchException} or an
  * {@link java.lang.annotation.IncompleteAnnotationException}.
  *
+ * @see java.lang.EnumConstantNotPresentException
+ * @see java.lang.TypeNotPresentException
+ * @see java.lang.annotation.AnnotationFormatError
+ * @see java.lang.annotation.AnnotationTypeMismatchException
+ * @see java.lang.annotation.IncompleteAnnotationException
  * @since 1.5
  * @author Josh Bloch
  */
--- a/src/share/classes/java/lang/reflect/Constructor.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/reflect/Constructor.java	Tue Sep 22 01:20:51 2009 -0700
@@ -81,10 +81,6 @@ public final
     // of permissions); we speed up the check in the common case by
     // remembering the last Class for which the check succeeded.
     private volatile Class securityCheckCache;
-
-    // Modifiers that can be applied to a constructor in source code
-    private static final int LANGUAGE_MODIFIERS =
-        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE;
 
     // Generics infrastructure
     // Accessor for factory
@@ -359,7 +355,7 @@ public final
     public String toString() {
         try {
             StringBuffer sb = new StringBuffer();
-            int mod = getModifiers() & LANGUAGE_MODIFIERS;
+            int mod = getModifiers() & Modifier.constructorModifiers();
             if (mod != 0) {
                 sb.append(Modifier.toString(mod) + " ");
             }
@@ -423,7 +419,7 @@ public final
     public String toGenericString() {
         try {
             StringBuilder sb = new StringBuilder();
-            int mod = getModifiers() & LANGUAGE_MODIFIERS;
+            int mod = getModifiers() & Modifier.constructorModifiers();
             if (mod != 0) {
                 sb.append(Modifier.toString(mod) + " ");
             }
--- a/src/share/classes/java/lang/reflect/Method.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/reflect/Method.java	Tue Sep 22 01:20:51 2009 -0700
@@ -88,12 +88,6 @@ public final
     private Class securityCheckCache;
     private Class securityCheckTargetClassCache;
 
-    // Modifiers that can be applied to a method in source code
-    private static final int LANGUAGE_MODIFIERS =
-        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
-        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
-        Modifier.SYNCHRONIZED   | Modifier.NATIVE;
-
    // Generics infrastructure
 
     private String getGenericSignature() {return signature;}
@@ -408,12 +402,12 @@ public final
      * {@code public}, {@code protected} or {@code private} first,
      * and then other modifiers in the following order:
      * {@code abstract}, {@code static}, {@code final},
-     * {@code synchronized}, {@code native}.
+     * {@code synchronized}, {@code native}, {@code strictfp}.
      */
     public String toString() {
         try {
             StringBuffer sb = new StringBuffer();
-            int mod = getModifiers() & LANGUAGE_MODIFIERS;
+            int mod = getModifiers() & Modifier.methodModifiers();
             if (mod != 0) {
                 sb.append(Modifier.toString(mod) + " ");
             }
@@ -473,7 +467,7 @@ public final
      * {@code public}, {@code protected} or {@code private} first,
      * and then other modifiers in the following order:
      * {@code abstract}, {@code static}, {@code final},
-     * {@code synchronized} {@code native}.
+     * {@code synchronized}, {@code native}, {@code strictfp}.
      *
      * @return a string describing this {@code Method},
      * include type parameters
@@ -483,7 +477,7 @@ public final
     public String toGenericString() {
         try {
             StringBuilder sb = new StringBuilder();
-            int mod = getModifiers() & LANGUAGE_MODIFIERS;
+            int mod = getModifiers() & Modifier.methodModifiers();
             if (mod != 0) {
                 sb.append(Modifier.toString(mod) + " ");
             }
--- a/src/share/classes/java/lang/reflect/Modifier.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/lang/reflect/Modifier.java	Tue Sep 22 01:20:51 2009 -0700
@@ -235,6 +235,11 @@ class Modifier {
      * possible validity of the combination of modifiers represented
      * by the input.
      *
+     * Note that to perform such checking for a known kind of entity,
+     * such as a constructor or method, first AND the argument of
+     * {@code toString} with the appropriate mask from a method like
+     * {@link #constructorModifiers} or {@link #methodModifiers}.
+     *
      * @param   mod a set of modifiers
      * @return  a string representation of the set of modifiers
      * represented by {@code mod}
@@ -353,4 +358,108 @@ class Modifier {
     static boolean isSynthetic(int mod) {
       return (mod & SYNTHETIC) != 0;
     }
+
+    /**
+     * See JLSv3 section 8.1.1.
+     */
+    private static final int CLASS_MODIFIERS =
+        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
+        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
+        Modifier.STRICT;
+
+    /**
+     * See JLSv3 section 9.1.1.
+     */
+    private static final int INTERFACE_MODIFIERS =
+        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
+        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.STRICT;
+
+
+    /**
+     * See JLSv3 section 8.8.3.
+     */
+    private static final int CONSTRUCTOR_MODIFIERS =
+        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE;
+
+    /**
+     * See JLSv3 section 8.4.3.
+     */
+    private static final int METHOD_MODIFIERS =
+        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
+        Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
+        Modifier.SYNCHRONIZED   | Modifier.NATIVE       | Modifier.STRICT;
+
+    /**
+     * See JLSv3 section 8.3.1.
+     */
+    private static final int FIELD_MODIFIERS =
+        Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
+        Modifier.STATIC         | Modifier.FINAL        | Modifier.TRANSIENT |
+        Modifier.VOLATILE;
+
+    /**
+     * Return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a class.
+     * @return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a class.
+     *
+     * @jls3 8.1.1 Class Modifiers
+     * @since 1.7
+     */
+    public static int classModifiers() {
+        return CLASS_MODIFIERS;
+    }
+
+    /**
+     * Return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to an interface.
+     * @return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to an inteface.
+     *
+     * @jls3 9.1.1 Interface Modifiers
+     * @since 1.7
+     */
+    public static int interfaceModifiers() {
+        return INTERFACE_MODIFIERS;
+    }
+
+    /**
+     * Return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a constructor.
+     * @return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a constructor.
+     *
+     * @jls3 8.8.3 Constructor Modifiers
+     * @since 1.7
+     */
+    public static int constructorModifiers() {
+        return CONSTRUCTOR_MODIFIERS;
+    }
+
+    /**
+     * Return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a method.
+     * @return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a method.
+     *
+     * @jls3 8.4.3 Method Modifiers
+     * @since 1.7
+     */
+    public static int methodModifiers() {
+        return METHOD_MODIFIERS;
+    }
+
+
+    /**
+     * Return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a field.
+     * @return an {@code int} value OR-ing together the source language
+     * modifiers that can be applied to a field.
+     *
+     * @jls3 8.3.1 Field Modifiers
+     * @since 1.7
+     */
+    public static int fieldModifiers() {
+        return FIELD_MODIFIERS;
+    }
 }
--- a/src/share/classes/java/math/BigDecimal.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/math/BigDecimal.java	Tue Sep 22 01:20:51 2009 -0700
@@ -315,6 +315,10 @@ public class BigDecimal extends Number i
         new BigDecimal(BigInteger.ZERO, 0, 15, 1),
     };
 
+    // Half of Long.MIN_VALUE & Long.MAX_VALUE.
+    private static final long HALF_LONG_MAX_VALUE = Long.MAX_VALUE / 2;
+    private static final long HALF_LONG_MIN_VALUE = Long.MIN_VALUE / 2;
+
     // Constants
     /**
      * The value 0, with a scale of 0.
@@ -1455,10 +1459,15 @@ public class BigDecimal extends Number i
             } else if (roundingMode == ROUND_FLOOR) {   // Towards -infinity
                 increment = (qsign < 0);
             } else {
-                if (isLongDivision || ldivisor != INFLATED)
-                    cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);
-                else
+                if (isLongDivision || ldivisor != INFLATED) {
+                    if (r <= HALF_LONG_MIN_VALUE || r > HALF_LONG_MAX_VALUE) {
+                        cmpFracHalf = 1;    // 2 * r can't fit into long
+                    } else {
+                        cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);
+                    }
+                } else {
                     cmpFracHalf = mr.compareHalf(mdivisor);
+                }
                 if (cmpFracHalf < 0)
                     increment = false;     // We're closer to higher digit
                 else if (cmpFracHalf > 0)  // We're closer to lower digit
--- a/src/share/classes/java/nio/channels/AsynchronousByteChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousByteChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -56,18 +56,18 @@ public interface AsynchronousByteChannel
     /**
      * Reads a sequence of bytes from this channel into the given buffer.
      *
-     * <p> This method initiates an operation to read a sequence of bytes from
-     * this channel into the given buffer. The method returns a {@link Future}
-     * representing the pending result of the operation. The result of the
-     * operation, obtained by invoking the {@code Future} 's {@link
-     * Future#get() get} method, is the number of bytes read or {@code -1} if
-     * all bytes have been read and the channel has reached end-of-stream.
-     *
-     * <p> This method initiates a read operation to read up to <i>r</i> bytes
-     * from the channel, where <i>r</i> is the number of bytes remaining in the
-     * buffer, that is, {@code dst.remaining()} at the time that the read is
-     * attempted. Where <i>r</i> is 0, the read operation completes immediately
-     * with a result of {@code 0} without initiating an I/O operation.
+     * <p> This method initiates an asynchronous read operation to read a
+     * sequence of bytes from this channel into the given buffer. The {@code
+     * handler} parameter is a completion handler that is invoked when the read
+     * operation completes (or fails). The result passed to the completion
+     * handler is the number of bytes read or {@code -1} if no bytes could be
+     * read because the channel has reached end-of-stream.
+     *
+     * <p> The read operation may read up to <i>r</i> bytes from the channel,
+     * where <i>r</i> is the number of bytes remaining in the buffer, that is,
+     * {@code dst.remaining()} at the time that the read is attempted. Where
+     * <i>r</i> is 0, the read operation completes immediately with a result of
+     * {@code 0} without initiating an I/O operation.
      *
      * <p> Suppose that a byte sequence of length <i>n</i> is read, where
      * <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
@@ -79,44 +79,46 @@ public interface AsynchronousByteChannel
      * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.
      *
      * <p> Buffers are not safe for use by multiple concurrent threads so care
-     * should be taken to not to access the buffer until the operaton has completed.
+     * should be taken to not access the buffer until the operation has
+     * completed.
      *
      * <p> This method may be invoked at any time. Some channel types may not
      * allow more than one read to be outstanding at any given time. If a thread
      * initiates a read operation before a previous read operation has
      * completed then a {@link ReadPendingException} will be thrown.
-     *
-     * <p> The <tt>handler</tt> parameter is used to specify a {@link
-     * CompletionHandler}. When the read operation completes the handler's
-     * {@link CompletionHandler#completed completed} method is executed.
-     *
      *
      * @param   dst
      *          The buffer into which bytes are to be transferred
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The completion handler object; can be {@code null}
-     *
-     * @return  A Future representing the result of the operation
+     *          The completion handler
      *
      * @throws  IllegalArgumentException
      *          If the buffer is read-only
      * @throws  ReadPendingException
      *          If the channel does not allow more than one read to be outstanding
      *          and a previous read has not completed
-     */
-    <A> Future<Integer> read(ByteBuffer dst,
-                             A attachment,
-                             CompletionHandler<Integer,? super A> handler);
+     * @throws  ShutdownChannelGroupException
+     *          If the channel is associated with a {@link AsynchronousChannelGroup
+     *          group} that has terminated
+     */
+    <A> void read(ByteBuffer dst,
+                  A attachment,
+                  CompletionHandler<Integer,? super A> handler);
 
     /**
      * Reads a sequence of bytes from this channel into the given buffer.
      *
-     * <p> An invocation of this method of the form <tt>c.read(dst)</tt>
-     * behaves in exactly the same manner as the invocation
-     * <blockquote><pre>
-     * c.read(dst, null, null);</pre></blockquote>
+     * <p> This method initiates an asynchronous read operation to read a
+     * sequence of bytes from this channel into the given buffer. The method
+     * behaves in exactly the same manner as the {@link
+     * #read(ByteBuffer,Object,CompletionHandler)
+     * read(ByteBuffer,Object,CompletionHandler)} method except that instead
+     * of specifying a completion handler, this method returns a {@code Future}
+     * representing the pending result. The {@code Future}'s {@link Future#get()
+     * get} method returns the number of bytes read or {@code -1} if no bytes
+     * could be read because the channel has reached end-of-stream.
      *
      * @param   dst
      *          The buffer into which bytes are to be transferred
@@ -134,17 +136,17 @@ public interface AsynchronousByteChannel
     /**
      * Writes a sequence of bytes to this channel from the given buffer.
      *
-     * <p> This method initiates an operation to write a sequence of bytes to
-     * this channel from the given buffer. This method returns a {@link
-     * Future} representing the pending result of the operation. The result
-     * of the operation, obtained by invoking the <tt>Future</tt>'s {@link
-     * Future#get() get} method, is the number of bytes written, possibly zero.
-     *
-     * <p> This method initiates a write operation to write up to <i>r</i> bytes
-     * to the channel, where <i>r</i> is the number of bytes remaining in the
-     * buffer, that is, {@code src.remaining()}  at the moment the write is
-     * attempted. Where <i>r</i> is 0, the write operation completes immediately
-     * with a result of {@code 0} without initiating an I/O operation.
+     * <p> This method initiates an asynchronous write operation to write a
+     * sequence of bytes to this channel from the given buffer. The {@code
+     * handler} parameter is a completion handler that is invoked when the write
+     * operation completes (or fails). The result passed to the completion
+     * handler is the number of bytes written.
+     *
+     * <p> The write operation may write up to <i>r</i> bytes to the channel,
+     * where <i>r</i> is the number of bytes remaining in the buffer, that is,
+     * {@code src.remaining()} at the time that the write is attempted. Where
+     * <i>r</i> is 0, the write operation completes immediately with a result of
+     * {@code 0} without initiating an I/O operation.
      *
      * <p> Suppose that a byte sequence of length <i>n</i> is written, where
      * <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
@@ -156,41 +158,43 @@ public interface AsynchronousByteChannel
      * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.
      *
      * <p> Buffers are not safe for use by multiple concurrent threads so care
-     * should be taken to not to access the buffer until the operaton has completed.
+     * should be taken to not access the buffer until the operation has
+     * completed.
      *
      * <p> This method may be invoked at any time. Some channel types may not
      * allow more than one write to be outstanding at any given time. If a thread
      * initiates a write operation before a previous write operation has
      * completed then a {@link WritePendingException} will be thrown.
-     *
-     * <p> The <tt>handler</tt> parameter is used to specify a {@link
-     * CompletionHandler}. When the write operation completes the handler's
-     * {@link CompletionHandler#completed completed} method is executed.
      *
      * @param   src
      *          The buffer from which bytes are to be retrieved
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The completion handler object; can be {@code null}
-     *
-     * @return  A Future representing the result of the operation
+     *          The completion handler object
      *
      * @throws  WritePendingException
      *          If the channel does not allow more than one write to be outstanding
      *          and a previous write has not completed
-     */
-    <A> Future<Integer> write(ByteBuffer src,
-                              A attachment,
-                              CompletionHandler<Integer,? super A> handler);
+     * @throws  ShutdownChannelGroupException
+     *          If the channel is associated with a {@link AsynchronousChannelGroup
+     *          group} that has terminated
+     */
+    <A> void write(ByteBuffer src,
+                   A attachment,
+                   CompletionHandler<Integer,? super A> handler);
 
     /**
      * Writes a sequence of bytes to this channel from the given buffer.
      *
-     * <p> An invocation of this method of the form <tt>c.write(src)</tt>
-     * behaves in exactly the same manner as the invocation
-     * <blockquote><pre>
-     * c.write(src, null, null);</pre></blockquote>
+     * <p> This method initiates an asynchronous write operation to write a
+     * sequence of bytes to this channel from the given buffer. The method
+     * behaves in exactly the same manner as the {@link
+     * #write(ByteBuffer,Object,CompletionHandler)
+     * write(ByteBuffer,Object,CompletionHandler)} method except that instead
+     * of specifying a completion handler, this method returns a {@code Future}
+     * representing the pending result. The {@code Future}'s {@link Future#get()
+     * get} method returns the number of bytes written.
      *
      * @param   src
      *          The buffer from which bytes are to be retrieved
--- a/src/share/classes/java/nio/channels/AsynchronousChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -34,7 +34,8 @@ import java.util.concurrent.Future;  // 
  *
  * <ol>
  * <li><pre>{@link Future}&lt;V&gt; <em>operation</em>(<em>...</em>)</pre></li>
- * <li><pre>Future&lt;V&gt; <em>operation</em>(<em>...</em> A attachment, {@link CompletionHandler}&lt;V,? super A&gt handler)</pre></li>
+ * <li><pre>void <em>operation</em>(<em>...</em> A attachment, {@link
+ *   CompletionHandler}&lt;V,? super A&gt; handler)</pre></li>
  * </ol>
  *
  * where <i>operation</i> is the name of the I/O operation (read or write for
@@ -48,7 +49,7 @@ import java.util.concurrent.Future;  // 
  * interface may be used to check if the operation has completed, wait for its
  * completion, and to retrieve the result. In the second form, a {@link
  * CompletionHandler} is invoked to consume the result of the I/O operation when
- * it completes, fails, or is cancelled.
+ * it completes or fails.
  *
  * <p> A channel that implements this interface is <em>asynchronously
  * closeable</em>: If an I/O operation is outstanding on the channel and the
@@ -63,33 +64,33 @@ import java.util.concurrent.Future;  // 
  * <h4>Cancellation</h4>
  *
  * <p> The {@code Future} interface defines the {@link Future#cancel cancel}
- * method to cancel execution of a task.
+ * method to cancel execution. This causes all threads waiting on the result of
+ * the I/O operation to throw {@link java.util.concurrent.CancellationException}.
+ * Whether the underlying I/O operation can be cancelled is highly implementation
+ * specific and therefore not specified. Where cancellation leaves the channel,
+ * or the entity to which it is connected, in an inconsistent state, then the
+ * channel is put into an implementation specific <em>error state</em> that
+ * prevents further attempts to initiate I/O operations that are <i>similar</i>
+ * to the operation that was cancelled. For example, if a read operation is
+ * cancelled but the implementation cannot guarantee that bytes have not been
+ * read from the channel then it puts the channel into an error state; further
+ * attempts to initiate a {@code read} operation cause an unspecified runtime
+ * exception to be thrown. Similarly, if a write operation is cancelled but the
+ * implementation cannot guarantee that bytes have not been written to the
+ * channel then subsequent attempts to initiate a {@code write} will fail with
+ * an unspecified runtime exception.
  *
- * <p> Where the {@code cancel} method is invoked with the {@code
+ * <p> Where the {@link Future#cancel cancel} method is invoked with the {@code
  * mayInterruptIfRunning} parameter set to {@code true} then the I/O operation
- * may be interrupted by closing the channel. This will cause any other I/O
- * operations outstanding on the channel to complete with the exception {@link
- * AsynchronousCloseException}.
- *
- * <p> If a {@code CompletionHandler} is specified when initiating an I/O
- * operation, and the {@code cancel} method is invoked to cancel the I/O
- * operation before it completes, then the {@code CompletionHandler}'s {@link
- * CompletionHandler#cancelled cancelled} method is invoked.
- *
- * <p> If an implementation of this interface supports a means to cancel I/O
- * operations, and where cancellation may leave the channel, or the entity to
- * which it is connected, in an inconsistent state, then the channel is put into
- * an implementation specific <em>error state</em> that prevents further
- * attempts to initiate I/O operations on the channel. For example, if a read
- * operation is cancelled but the implementation cannot guarantee that bytes
- * have not been read from the channel then it puts the channel into error state
- * state; further attempts to initiate a {@code read} operation causes an
- * unspecified runtime exception to be thrown.
+ * may be interrupted by closing the channel. In that case all threads waiting
+ * on the result of the I/O operation throw {@code CancellationException} and
+ * any other I/O operations outstanding on the channel complete with the
+ * exception {@link AsynchronousCloseException}.
  *
  * <p> Where the {@code cancel} method is invoked to cancel read or write
- * operations then it recommended that all buffers used in the I/O operations be
- * discarded or care taken to ensure that the buffers are not accessed while the
- * channel remains open.
+ * operations then it is recommended that all buffers used in the I/O operations
+ * be discarded or care taken to ensure that the buffers are not accessed while
+ * the channel remains open.
  *
  *  @since 1.7
  */
@@ -102,7 +103,7 @@ public interface AsynchronousChannel
      *
      * <p> Any outstanding asynchronous operations upon this channel will
      * complete with the exception {@link AsynchronousCloseException}. After a
-     * channel is closed then further attempts to initiate asynchronous I/O
+     * channel is closed, further attempts to initiate asynchronous I/O
      * operations complete immediately with cause {@link ClosedChannelException}.
      *
      * <p>  This method otherwise behaves exactly as specified by the {@link
--- a/src/share/classes/java/nio/channels/AsynchronousDatagramChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousDatagramChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -109,17 +109,11 @@ import java.nio.ByteBuffer;
  *  // print the source address of all packets that we receive
  *  dc.receive(buffer, buffer, new CompletionHandler&lt;SocketAddress,ByteBuffer&gt;() {
  *      public void completed(SocketAddress sa, ByteBuffer buffer) {
- *          try {
- *               System.out.println(sa);
- *
- *               buffer.clear();
- *               dc.receive(buffer, buffer, this);
- *           } catch (...) { ... }
+ *          System.out.println(sa);
+ *          buffer.clear();
+ *          dc.receive(buffer, buffer, this);
  *      }
  *      public void failed(Throwable exc, ByteBuffer buffer) {
- *          ...
- *      }
- *      public void cancelled(ByteBuffer buffer) {
  *          ...
  *      }
  *  });
@@ -314,10 +308,10 @@ public abstract class AsynchronousDatagr
     /**
      * Receives a datagram via this channel.
      *
-     * <p> This method initiates the receiving of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The {@code Future}'s {@link Future#get() get} method returns
-     * the source address of the datagram upon successful completion.
+     * <p> This method initiates the receiving of a datagram into the given
+     * buffer. The {@code handler} parameter is a completion handler that is
+     * invoked when the receive operation completes (or fails). The result
+     * passed to the completion handler is the datagram's source address.
      *
      * <p> The datagram is transferred into the given byte buffer starting at
      * its current position, as if by a regular {@link AsynchronousByteChannel#read
@@ -350,28 +344,26 @@ public abstract class AsynchronousDatagr
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the timeout is negative or the buffer is read-only
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<SocketAddress> receive(ByteBuffer dst,
-                                                      long timeout,
-                                                      TimeUnit unit,
-                                                      A attachment,
-                                                      CompletionHandler<SocketAddress,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void receive(ByteBuffer dst,
+                                     long timeout,
+                                     TimeUnit unit,
+                                     A attachment,
+                                     CompletionHandler<SocketAddress,? super A> handler);
 
     /**
      * Receives a datagram via this channel.
      *
-     * <p> This method initiates the receiving of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The {@code Future}'s {@link Future#get() get} method returns
-     * the source address of the datagram upon successful completion.
+     * <p> This method initiates the receiving of a datagram into the given
+     * buffer. The {@code handler} parameter is a completion handler that is
+     * invoked when the receive operation completes (or fails). The result
+     * passed to the completion handler is the datagram's source address.
      *
      * <p> This method is equivalent to invoking {@link
      * #receive(ByteBuffer,long,TimeUnit,Object,CompletionHandler)} with a
@@ -382,34 +374,30 @@ public abstract class AsynchronousDatagr
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the buffer is read-only
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public final <A> Future<SocketAddress> receive(ByteBuffer dst,
-                                                   A attachment,
-                                                   CompletionHandler<SocketAddress,? super A> handler)
+     *          If the channel group has terminated
+     */
+    public final <A> void receive(ByteBuffer dst,
+                                  A attachment,
+                                  CompletionHandler<SocketAddress,? super A> handler)
     {
-        return receive(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
+        receive(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
     }
 
     /**
      * Receives a datagram via this channel.
      *
-     * <p> This method initiates the receiving of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The {@code Future}'s {@link Future#get() get} method returns
-     * the source address of the datagram upon successful completion.
-     *
-     * <p> This method is equivalent to invoking {@link
-     * #receive(ByteBuffer,long,TimeUnit,Object,CompletionHandler)} with a
-     * timeout of {@code 0L}, and an attachment and completion handler
-     * of {@code null}.
+     * <p> This method initiates the receiving of a datagram into the given
+     * buffer. The method behaves in exactly the same manner as the {@link
+     * #receive(ByteBuffer,Object,CompletionHandler)
+     * receive(ByteBuffer,Object,CompletionHandler)} method except that instead
+     * of specifying a completion handler, this method returns a {@code Future}
+     * representing the pending result. The {@code Future}'s {@link Future#get()
+     * get} method returns the datagram's source address.
      *
      * @param   dst
      *          The buffer into which the datagram is to be transferred
@@ -419,84 +407,19 @@ public abstract class AsynchronousDatagr
      * @throws  IllegalArgumentException
      *          If the buffer is read-only
      */
-    public final <A> Future<SocketAddress> receive(ByteBuffer dst) {
-        return receive(dst, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
+    public abstract Future<SocketAddress> receive(ByteBuffer dst);
 
     /**
      * Sends a datagram via this channel.
      *
-     * <p> This method initiates sending of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The operation sends the remaining bytes in the given buffer as a single
-     * datagram to the given target address. The result of the operation, obtained
-     * by invoking the {@code Future}'s {@link Future#get() get}
-     * method, is the number of bytes sent.
-     *
-     * <p> The datagram is transferred from the byte buffer as if by a regular
-     * {@link AsynchronousByteChannel#write write} operation.
-     *
-     * <p> If a timeout is specified and the timeout elapses before the operation
-     * completes then the operation completes with the exception {@link
-     * InterruptedByTimeoutException}. When a timeout elapses then the state of
-     * the {@link ByteBuffer} is not defined. The buffers should be discarded or
-     * at least care must be taken to ensure that the buffer is not accessed
-     * while the channel remains open.
-     *
-     * <p> If there is a security manager installed and the channel is not
-     * connected then this method verifies that the target address and port number
-     * are permitted by the security manager's {@link SecurityManager#checkConnect
-     * checkConnect} method.  The overhead of this security check can be avoided
-     * by first connecting the socket via the {@link #connect connect} method.
-     *
-     * @param   src
-     *          The buffer containing the datagram to be sent
-     * @param   target
-     *          The address to which the datagram is to be sent
-     * @param   timeout
-     *          The timeout, or {@code 0L} for no timeout
-     * @param   unit
-     *          The time unit of the {@code timeout} argument
-     * @param   attachment
-     *          The object to attach to the I/O operation; can be {@code null}
-     * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
-     *
-     * @throws  UnresolvedAddressException
-     *          If the given remote address is not fully resolved
-     * @throws  UnsupportedAddressTypeException
-     *          If the type of the given remote address is not supported
-     * @throws  IllegalArgumentException
-     *          If the timeout is negative, or if the channel's socket is
-     *          connected to an address that is not equal to {@code target}
-     * @throws  SecurityException
-     *          If a security manager has been installed and it does not permit
-     *          datagrams to be sent to the given address
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Integer> send(ByteBuffer src,
-                                             SocketAddress target,
-                                             long timeout,
-                                             TimeUnit unit,
-                                             A attachment,
-                                             CompletionHandler<Integer,? super A> handler);
-
-    /**
-     * Sends a datagram via this channel.
-     *
-     * <p> This method initiates sending of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The operation sends the remaining bytes in the given buffer as a single
-     * datagram to the given target address. The result of the operation, obtained
-     * by invoking the {@code Future}'s {@link Future#get() get}
-     * method, is the number of bytes sent.
-     *
-     * <p> This method is equivalent to invoking {@link
-     * #send(ByteBuffer,SocketAddress,long,TimeUnit,Object,CompletionHandler)}
-     * with a timeout of {@code 0L}.
+     * <p> This method initiates sending of a datagram from the given buffer to
+     * the given address. The {@code handler} parameter is a completion handler
+     * that is invoked when the send completes (or fails). The result passed to
+     * the completion handler is the number of bytes sent.
+     *
+     * <p> Otherwise this method works in the same manner as the {@link
+     * AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}
+     * method.
      *
      * @param   src
      *          The buffer containing the datagram to be sent
@@ -505,9 +428,7 @@ public abstract class AsynchronousDatagr
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  UnresolvedAddressException
      *          If the given remote address is not fully resolved
@@ -520,30 +441,23 @@ public abstract class AsynchronousDatagr
      *          If a security manager has been installed and it does not permit
      *          datagrams to be sent to the given address
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public final <A> Future<Integer> send(ByteBuffer src,
-                                          SocketAddress target,
-                                          A attachment,
-                                          CompletionHandler<Integer,? super A> handler)
-    {
-        return send(src, target, 0L, TimeUnit.MILLISECONDS, attachment, handler);
-    }
+     *          If the channel group has terminated
+     */
+    public abstract <A> void send(ByteBuffer src,
+                                  SocketAddress target,
+                                  A attachment,
+                                  CompletionHandler<Integer,? super A> handler);
 
     /**
      * Sends a datagram via this channel.
      *
-     * <p> This method initiates sending of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The operation sends the remaining bytes in the given buffer as a single
-     * datagram to the given target address. The result of the operation, obtained
-     * by invoking the {@code Future}'s {@link Future#get() get}
-     * method, is the number of bytes sent.
-     *
-     * <p> This method is equivalent to invoking {@link
-     * #send(ByteBuffer,SocketAddress,long,TimeUnit,Object,CompletionHandler)}
-     * with a timeout of {@code 0L} and an attachment and completion handler
-     * of {@code null}.
+     * <p> This method initiates sending of a datagram from the given buffer to
+     * the given address. The method behaves in exactly the same manner as the
+     * {@link #send(ByteBuffer,SocketAddress,Object,CompletionHandler)
+     * send(ByteBuffer,SocketAddress,Object,CompletionHandler)} method except
+     * that instead of specifying a completion handler, this method returns a
+     * {@code Future} representing the pending result. The {@code Future}'s
+     * {@link Future#get() get} method returns the number of bytes sent.
      *
      * @param   src
      *          The buffer containing the datagram to be sent
@@ -563,17 +477,15 @@ public abstract class AsynchronousDatagr
      *          If a security manager has been installed and it does not permit
      *          datagrams to be sent to the given address
      */
-    public final Future<Integer> send(ByteBuffer src, SocketAddress target) {
-        return send(src, target, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
+    public abstract Future<Integer> send(ByteBuffer src, SocketAddress target);
 
     /**
      * Receives a datagram via this channel.
      *
-     * <p> This method initiates the receiving of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The {@code Future}'s {@link Future#get() get} method returns
-     * the number of bytes transferred upon successful completion.
+     * <p> This method initiates the receiving of a datagram into the given
+     * buffer. The {@code handler} parameter is a completion handler that is
+     * invoked when the receive operation completes (or fails). The result
+     * passed to the completion handler is number of bytes read.
      *
      * <p> This method may only be invoked if this channel is connected, and it
      * only accepts datagrams from the peer that the channel is connected too.
@@ -599,120 +511,62 @@ public abstract class AsynchronousDatagr
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the timeout is negative or buffer is read-only
      * @throws  NotYetConnectedException
      *          If this channel is not connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Integer> read(ByteBuffer dst,
-                                             long timeout,
-                                             TimeUnit unit,
-                                             A attachment,
-                                             CompletionHandler<Integer,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void read(ByteBuffer dst,
+                                  long timeout,
+                                  TimeUnit unit,
+                                  A attachment,
+                                  CompletionHandler<Integer,? super A> handler);
 
     /**
      * @throws  NotYetConnectedException
      *          If this channel is not connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    @Override
-    public final <A> Future<Integer> read(ByteBuffer dst,
-                                          A attachment,
-                                          CompletionHandler<Integer,? super A> handler)
+     *          If the channel group has terminated
+     */
+    @Override
+    public final <A> void read(ByteBuffer dst,
+                               A attachment,
+                               CompletionHandler<Integer,? super A> handler)
     {
-        return read(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
+        read(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
     }
 
     /**
      * @throws  NotYetConnectedException
      *          If this channel is not connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    @Override
-    public final Future<Integer> read(ByteBuffer dst) {
-        return read(dst, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
-
-    /**
-     * Writes a datagram to this channel.
-     *
-     * <p> This method initiates sending of a datagram, returning a
-     * {@code Future} representing the pending result of the operation.
-     * The operation sends the remaining bytes in the given buffer as a single
-     * datagram. The result of the operation, obtained by invoking the
-     * {@code Future}'s {@link Future#get() get} method, is the
-     * number of bytes sent.
-     *
-     * <p> The datagram is transferred from the byte buffer as if by a regular
-     * {@link AsynchronousByteChannel#write write} operation.
-     *
-     * <p> This method may only be invoked if this channel is connected,
-     * in which case it sends datagrams directly to the socket's peer.  Otherwise
-     * it behaves exactly as specified in the {@link
-     * AsynchronousByteChannel} interface.
-     *
-     * <p> If a timeout is specified and the timeout elapses before the operation
-     * completes then the operation completes with the exception {@link
-     * InterruptedByTimeoutException}. When a timeout elapses then the state of
-     * the {@link ByteBuffer} is not defined. The buffers should be discarded or
-     * at least care must be taken to ensure that the buffer is not accessed
-     * while the channel remains open.
-     *
-     * @param   src
-     *          The buffer containing the datagram to be sent
-     * @param   timeout
-     *          The timeout, or {@code 0L} for no timeout
-     * @param   unit
-     *          The time unit of the {@code timeout} argument
-     * @param   attachment
-     *          The object to attach to the I/O operation; can be {@code null}
-     * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
-     *
-     * @throws  IllegalArgumentException
-     *          If the timeout is negative
+     *          If the channel group has terminated
+     */
+    @Override
+    public abstract Future<Integer> read(ByteBuffer dst);
+
+    /**
      * @throws  NotYetConnectedException
      *          If this channel is not connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Integer> write(ByteBuffer src,
-                                              long timeout,
-                                              TimeUnit unit,
-                                              A attachment,
-                                              CompletionHandler<Integer,? super A> handler);
+     *          If the channel group has terminated
+     */
+    @Override
+    public abstract <A> void  write(ByteBuffer src,
+                                    A attachment,
+                                    CompletionHandler<Integer,? super A> handler);
+
+
     /**
      * @throws  NotYetConnectedException
      *          If this channel is not connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    @Override
-    public final <A> Future<Integer> write(ByteBuffer src,
-                                           A attachment,
-                                           CompletionHandler<Integer,? super A> handler)
-    {
-        return write(src, 0L, TimeUnit.MILLISECONDS, attachment, handler);
-    }
-
-    /**
-     * @throws  NotYetConnectedException
-     *          If this channel is not connected
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    @Override
-    public final Future<Integer> write(ByteBuffer src) {
-        return write(src, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
+     *          If the channel group has terminated
+     */
+    @Override
+    public abstract Future<Integer> write(ByteBuffer src);
 }
--- a/src/share/classes/java/nio/channels/AsynchronousFileChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousFileChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -48,7 +48,12 @@ import java.util.Collections;
  *
  * <p> An asynchronous file channel does not have a <i>current position</i>
  * within the file. Instead, the file position is specified to each read and
- * write operation.
+ * write methd that initiate asynchronous operations. A {@link CompletionHandler}
+ * is specified as a parameter and is invoked to consume the result of the I/O
+ * operation. This class also defines read and write methods that initiate
+ * asynchronous operations, returning a {@link Future} to represent the pending
+ * result of the operation. The {@code Future} may be used to check if the
+ * operation has completed, to wait for its completion.
  *
  * <p> In addition to read and write operations, this class defines the
  * following operations: </p>
@@ -59,17 +64,10 @@ import java.util.Collections;
  *   out</i>} to the underlying storage device, ensuring that data are not
  *   lost in the event of a system crash.  </p></li>
  *
- *   <li><p> A region of a file may be {@link FileLock <i>locked</i>}
- *   against access by other programs.  </p></li>
+ *   <li><p> A region of a file may be {@link #lock <i>locked</i>} against
+ *   access by other programs.  </p></li>
  *
  * </ul>
- *
- * <p> The {@link #read read}, {@link #write write}, and {@link #lock lock}
- * methods defined by this class are asynchronous  and return a {@link Future}
- * to represent the pending result of the operation. This may be used to check
- * if the operation has completed, to wait for its completion, and to retrieve
- * the result. These method may optionally specify a {@link CompletionHandler}
- * that is invoked to consume the result of the I/O operation when it completes.
  *
  * <p> An {@code AsynchronousFileChannel} is associated with a thread pool to
  * which tasks are submitted to handle I/O events and dispatch to completion
@@ -123,22 +121,6 @@ public abstract class AsynchronousFileCh
     }
 
     /**
-     * Closes this channel.
-     *
-     * <p> If this channel is associated with its own thread pool then closing
-     * the channel causes the thread pool to shutdown after all actively
-     * executing completion handlers have completed. No attempt is made to stop
-     * or interrupt actively completion handlers.
-     *
-     * <p> This method otherwise behaves exactly as specified by the {@link
-     * AsynchronousChannel} interface.
-     *
-     * @throws  IOException     {@inheritDoc}
-     */
-    @Override
-    public abstract void close() throws IOException;
-
-    /**
      * Opens or creates a file for reading and/or writing, returning an
      * asynchronous file channel to access the file.
      *
@@ -215,9 +197,8 @@ public abstract class AsynchronousFileCh
      * should be taken when configuring the {@code Executor}. Minimally it
      * should support an unbounded work queue and should not run tasks on the
      * caller thread of the {@link ExecutorService#execute execute} method.
-     * {@link #close Closing} the channel results in the orderly {@link
-     * ExecutorService#shutdown shutdown} of the executor service. Shutting down
-     * the executor service by other means results in unspecified behavior.
+     * Shutting down the executor service while the channel is open results in
+     * unspecified behavior.
      *
      * <p> The {@code attrs} parameter is an optional array of file {@link
      * FileAttribute file-attributes} to set atomically when creating the file.
@@ -276,7 +257,8 @@ public abstract class AsynchronousFileCh
      * <p> An invocation of this method behaves in exactly the same way as the
      * invocation
      * <pre>
-     *     ch.{@link #open(Path,Set,ExecutorService,FileAttribute[]) open}(file, opts, null, new FileAttribute&lt;?&gt;[0]);
+     *     ch.{@link #open(Path,Set,ExecutorService,FileAttribute[])
+     *       open}(file, opts, null, new FileAttribute&lt;?&gt;[0]);
      * </pre>
      * where {@code opts} is a {@code Set} containing the options specified to
      * this method.
@@ -405,10 +387,11 @@ public abstract class AsynchronousFileCh
     /**
      * Acquires a lock on the given region of this channel's file.
      *
-     * <p> This method initiates an operation to acquire a lock on the given region
-     * of this channel's file. The method returns a {@code Future} representing
-     * the pending result of the operation. Its {@link Future#get() get}
-     * method returns the {@link FileLock} on successful completion.
+     * <p> This method initiates an operation to acquire a lock on the given
+     * region of this channel's file. The {@code handler} parameter is a
+     * completion handler that is invoked when the lock is acquired (or the
+     * operation fails). The result passed to the completion handler is the
+     * resulting {@code FileLock}.
      *
      * <p> The region specified by the {@code position} and {@code size}
      * parameters need not be contained within, or even overlap, the actual
@@ -455,9 +438,7 @@ public abstract class AsynchronousFileCh
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  OverlappingFileLockException
      *          If a lock that overlaps the requested region is already held by
@@ -466,26 +447,24 @@ public abstract class AsynchronousFileCh
      * @throws  IllegalArgumentException
      *          If the preconditions on the parameters do not hold
      * @throws  NonReadableChannelException
-     *          If {@code shared} is true this channel but was not opened for reading
+     *          If {@code shared} is true but this channel was not opened for reading
      * @throws  NonWritableChannelException
      *          If {@code shared} is false but this channel was not opened for writing
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, the channel is closed, and the channel
-     *          was originally created with its own thread pool
-     */
-    public abstract <A> Future<FileLock> lock(long position,
-                                              long size,
-                                              boolean shared,
-                                              A attachment,
-                                              CompletionHandler<FileLock,? super A> handler);
+     */
+    public abstract <A> void lock(long position,
+                                  long size,
+                                  boolean shared,
+                                  A attachment,
+                                  CompletionHandler<FileLock,? super A> handler);
 
     /**
      * Acquires an exclusive lock on this channel's file.
      *
-     * <p> This method initiates an operation to acquire an exclusive lock on this
-     * channel's file. The method returns a {@code Future} representing
-     * the pending result of the operation. Its {@link Future#get() get}
-     * method returns the {@link FileLock} on successful completion.
+     * <p> This method initiates an operation to acquire a lock on the given
+     * region of this channel's file. The {@code handler} parameter is a
+     * completion handler that is invoked when the lock is acquired (or the
+     * operation fails). The result passed to the completion handler is the
+     * resulting {@code FileLock}.
      *
      * <p> An invocation of this method of the form {@code ch.lock(att,handler)}
      * behaves in exactly the same way as the invocation
@@ -496,40 +475,72 @@ public abstract class AsynchronousFileCh
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  a {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  OverlappingFileLockException
      *          If a lock is already held by this Java virtual machine, or there
      *          is already a pending attempt to lock a region
      * @throws  NonWritableChannelException
      *          If this channel was not opened for writing
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, the channel is closed, and the channel
-     *          was originally created with its own thread pool
-     */
-    public final <A> Future<FileLock> lock(A attachment,
-                                           CompletionHandler<FileLock,? super A> handler)
+     */
+    public final <A> void lock(A attachment,
+                               CompletionHandler<FileLock,? super A> handler)
     {
-        return lock(0L, Long.MAX_VALUE, false, attachment, handler);
+        lock(0L, Long.MAX_VALUE, false, attachment, handler);
     }
+
+    /**
+     * Acquires a lock on the given region of this channel's file.
+     *
+     * <p> This method initiates an operation to acquire a lock on the given
+     * region of this channel's file.  The method behaves in exactly the same
+     * manner as the {@link #lock(long, long, boolean, Object, CompletionHandler)}
+     * method except that instead of specifying a completion handler, this
+     * method returns a {@code Future} representing the pending result. The
+     * {@code Future}'s {@link Future#get() get} method returns the {@link
+     * FileLock} on successful completion.
+     *
+     * @param   position
+     *          The position at which the locked region is to start; must be
+     *          non-negative
+     * @param   size
+     *          The size of the locked region; must be non-negative, and the sum
+     *          {@code position}&nbsp;+&nbsp;{@code size} must be non-negative
+     * @param   shared
+     *          {@code true} to request a shared lock, in which case this
+     *          channel must be open for reading (and possibly writing);
+     *          {@code false} to request an exclusive lock, in which case this
+     *          channel must be open for writing (and possibly reading)
+     *
+     * @return  a {@code Future} object representing the pending result
+     *
+     * @throws  OverlappingFileLockException
+     *          If a lock is already held by this Java virtual machine, or there
+     *          is already a pending attempt to lock a region
+     * @throws  IllegalArgumentException
+     *          If the preconditions on the parameters do not hold
+     * @throws  NonReadableChannelException
+     *          If {@code shared} is true but this channel was not opened for reading
+     * @throws  NonWritableChannelException
+     *          If {@code shared} is false but this channel was not opened for writing
+     */
+    public abstract Future<FileLock> lock(long position, long size, boolean shared);
 
     /**
      * Acquires an exclusive lock on this channel's file.
      *
      * <p> This method initiates an operation to acquire an exclusive lock on this
      * channel's file. The method returns a {@code Future} representing the
-     * pending result of the operation. Its {@link Future#get() get} method
-     * returns the {@link FileLock} on successful completion.
+     * pending result of the operation. The {@code Future}'s {@link Future#get()
+     * get} method returns the {@link FileLock} on successful completion.
      *
      * <p> An invocation of this method behaves in exactly the same way as the
      * invocation
      * <pre>
-     *     ch.{@link #lock(long,long,boolean,Object,CompletionHandler) lock}(0L, Long.MAX_VALUE, false, null, null)
+     *     ch.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false)
      * </pre>
      *
-     * @return  A {@code Future} object representing the pending result
+     * @return  a {@code Future} object representing the pending result
      *
      * @throws  OverlappingFileLockException
      *          If a lock is already held by this Java virtual machine, or there
@@ -538,7 +549,7 @@ public abstract class AsynchronousFileCh
      *          If this channel was not opened for writing
      */
     public final Future<FileLock> lock() {
-        return lock(0L, Long.MAX_VALUE, false, null, null);
+        return lock(0L, Long.MAX_VALUE, false);
     }
 
     /**
@@ -576,7 +587,7 @@ public abstract class AsynchronousFileCh
      *          blocked in this method and is attempting to lock an overlapping
      *          region of the same file
      * @throws  NonReadableChannelException
-     *          If {@code shared} is true this channel but was not opened for reading
+     *          If {@code shared} is true but this channel was not opened for reading
      * @throws  NonWritableChannelException
      *          If {@code shared} is false but this channel was not opened for writing
      *
@@ -629,11 +640,10 @@ public abstract class AsynchronousFileCh
      * starting at the given file position.
      *
      * <p> This method initiates the reading of a sequence of bytes from this
-     * channel into the given buffer, starting at the given file position. This
-     * method returns a {@code Future} representing the pending result of the
-     * operation. The Future's {@link Future#get() get} method returns the
-     * number of bytes read or {@code -1} if the given position is greater than
-     * or equal to the file's size at the time that the read is attempted.
+     * channel into the given buffer, starting at the given file position. The
+     * result of the read is the number of bytes read or {@code -1} if the given
+     * position is greater than or equal to the file's size at the time that the
+     * read is attempted.
      *
      * <p> This method works in the same manner as the {@link
      * AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)}
@@ -649,22 +659,17 @@ public abstract class AsynchronousFileCh
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the position is negative or the buffer is read-only
      * @throws  NonReadableChannelException
      *          If this channel was not opened for reading
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, the channel is closed, and the channel
-     *          was originally created with its own thread pool
-     */
-    public abstract <A> Future<Integer> read(ByteBuffer dst,
-                                             long position,
-                                             A attachment,
-                                             CompletionHandler<Integer,? super A> handler);
+     */
+    public abstract <A> void read(ByteBuffer dst,
+                                  long position,
+                                  A attachment,
+                                  CompletionHandler<Integer,? super A> handler);
 
     /**
      * Reads a sequence of bytes from this channel into the given buffer,
@@ -673,13 +678,15 @@ public abstract class AsynchronousFileCh
      * <p> This method initiates the reading of a sequence of bytes from this
      * channel into the given buffer, starting at the given file position. This
      * method returns a {@code Future} representing the pending result of the
-     * operation. The Future's {@link Future#get() get} method returns the
-     * number of bytes read or {@code -1} if the given position is greater
+     * operation. The {@code Future}'s {@link Future#get() get} method returns
+     * the number of bytes read or {@code -1} if the given position is greater
      * than or equal to the file's size at the time that the read is attempted.
      *
-     * <p> This method is equivalent to invoking {@link
-     * #read(ByteBuffer,long,Object,CompletionHandler)} with the {@code attachment}
-     * and handler parameters set to {@code null}.
+     * <p> This method works in the same manner as the {@link
+     * AsynchronousByteChannel#read(ByteBuffer)} method, except that bytes are
+     * read starting at the given file position. If the given file position is
+     * greater than the file's size at the time that the read is attempted then
+     * no bytes are read.
      *
      * @param   dst
      *          The buffer into which bytes are to be transferred
@@ -694,19 +701,11 @@ public abstract class AsynchronousFileCh
      * @throws  NonReadableChannelException
      *          If this channel was not opened for reading
      */
-    public final Future<Integer> read(ByteBuffer dst, long position) {
-        return read(dst, position, null, null);
-    }
+    public abstract Future<Integer> read(ByteBuffer dst, long position);
 
     /**
      * Writes a sequence of bytes to this channel from the given buffer, starting
      * at the given file position.
-     *
-     * <p> This method initiates the writing of a sequence of bytes to this channel
-     * from the given buffer, starting at the given file position. The method
-     * returns a {@code Future} representing the pending result of the write
-     * operation. The Future's {@link Future#get() get} method returns the
-     * number of bytes written.
      *
      * <p> This method works in the same manner as the {@link
      * AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}
@@ -724,36 +723,35 @@ public abstract class AsynchronousFileCh
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the position is negative
      * @throws  NonWritableChannelException
      *          If this channel was not opened for writing
-     * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, the channel is closed, and the channel
-     *          was originally created with its own thread pool
-     */
-    public abstract <A> Future<Integer> write(ByteBuffer src,
-                                              long position,
-                                              A attachment,
-                                              CompletionHandler<Integer,? super A> handler);
+     */
+    public abstract <A> void write(ByteBuffer src,
+                                   long position,
+                                   A attachment,
+                                   CompletionHandler<Integer,? super A> handler);
 
     /**
      * Writes a sequence of bytes to this channel from the given buffer, starting
      * at the given file position.
      *
-     * <p> This method initiates the writing of a sequence of bytes to this channel
-     * from the given buffer, starting at the given file position. The method
-     * returns a {@code Future} representing the pending result of the write
-     * operation. The Future's {@link Future#get() get} method returns the
-     * number of bytes written.
-     *
-     * <p> This method is equivalent to invoking {@link
-     * #write(ByteBuffer,long,Object,CompletionHandler)} with the {@code attachment}
-     * and handler parameters set to {@code null}.
+     * <p> This method initiates the writing of a sequence of bytes to this
+     * channel from the given buffer, starting at the given file position. The
+     * method returns a {@code Future} representing the pending result of the
+     * write operation. The {@code Future}'s {@link Future#get() get} method
+     * returns the number of bytes written.
+     *
+     * <p> This method works in the same manner as the {@link
+     * AsynchronousByteChannel#write(ByteBuffer)} method, except that bytes are
+     * written starting at the given file position. If the given position is
+     * greater than the file's size, at the time that the write is attempted,
+     * then the file will be grown to accommodate the new bytes; the values of
+     * any bytes between the previous end-of-file and the newly-written bytes
+     * are unspecified.
      *
      * @param   src
      *          The buffer from which bytes are to be transferred
@@ -768,7 +766,5 @@ public abstract class AsynchronousFileCh
      * @throws  NonWritableChannelException
      *          If this channel was not opened for writing
      */
-    public final Future<Integer> write(ByteBuffer src, long position) {
-        return write(src, position, null, null);
-    }
+    public abstract Future<Integer> write(ByteBuffer src, long position);
 }
--- a/src/share/classes/java/nio/channels/AsynchronousServerSocketChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousServerSocketChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -85,9 +85,6 @@ import java.io.IOException;
  *      public void failed(Throwable exc, Void att) {
  *          ...
  *      }
- *      public void cancelled(Void att) {
- *          ...
- *      }
  *  });
  * </pre>
  *
@@ -240,11 +237,11 @@ public abstract class AsynchronousServer
     /**
      * Accepts a connection.
      *
-     * <p> This method initiates accepting a connection made to this channel's
-     * socket, returning a {@link Future} representing the pending result
-     * of the operation. The {@code Future}'s {@link Future#get() get}
-     * method will return the {@link AsynchronousSocketChannel} for the new
-     * connection on successful completion.
+     * <p> This method initiates an asynchronous operation to accept a
+     * connection made to this channel's socket. The {@code handler} parameter is
+     * a completion handler that is invoked when a connection is accepted (or
+     * the operation fails). The result passed to the completion handler is
+     * the {@link AsynchronousSocketChannel} to the new connection.
      *
      * <p> When a new connection is accepted then the resulting {@code
      * AsynchronousSocketChannel} will be bound to the same {@link
@@ -269,35 +266,35 @@ public abstract class AsynchronousServer
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  an <tt>Future</tt> object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  AcceptPendingException
      *          If an accept operation is already in progress on this channel
      * @throws  NotYetBoundException
      *          If this channel's socket has not yet been bound
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<AsynchronousSocketChannel>
-        accept(A attachment, CompletionHandler<AsynchronousSocketChannel,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void accept(A attachment,
+                                    CompletionHandler<AsynchronousSocketChannel,? super A> handler);
 
     /**
      * Accepts a connection.
      *
-     * <p> This method is equivalent to invoking {@link
-     * #accept(Object,CompletionHandler)} with the {@code attachment}
-     * and {@code handler} parameters set to {@code null}.
-     *
-     * @return  an <tt>Future</tt> object representing the pending result
+     * <p> This method initiates an asynchronous operation to accept a
+     * connection made to this channel's socket. The method behaves in exactly
+     * the same manner as the {@link #accept(Object, CompletionHandler)} method
+     * except that instead of specifying a completion handler, this method
+     * returns a {@code Future} representing the pending result. The {@code
+     * Future}'s {@link Future#get() get} method returns the {@link
+     * AsynchronousSocketChannel} to the new connection on successful completion.
+     *
+     * @return  a {@code Future} object representing the pending result
      *
      * @throws  AcceptPendingException
      *          If an accept operation is already in progress on this channel
      * @throws  NotYetBoundException
      *          If this channel's socket has not yet been bound
      */
-    public final Future<AsynchronousSocketChannel> accept() {
-        return accept(null, null);
-    }
+    public abstract Future<AsynchronousSocketChannel> accept();
 }
--- a/src/share/classes/java/nio/channels/AsynchronousSocketChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/AsynchronousSocketChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -274,14 +274,11 @@ public abstract class AsynchronousSocket
     /**
      * Connects this channel.
      *
-     * <p> This method initiates an operation to connect this channel, returning
-     * a {@code Future} representing the pending result of the operation. If
-     * the connection is successfully established then the {@code Future}'s
-     * {@link Future#get() get} method will return {@code null}. If the
-     * connection cannot be established then the channel is closed. In that case,
-     * invoking the {@code get} method throws {@link
-     * java.util.concurrent.ExecutionException} with an {@code IOException} as
-     * the cause.
+     * <p> This method initiates an operation to connect this channel. The
+     * {@code handler} parameter is a completion handler that is invoked when
+     * the connection is successfully established or connection cannot be
+     * established. If the connection cannot be established then the channel is
+     * closed.
      *
      * <p> This method performs exactly the same security checks as the {@link
      * java.net.Socket} class.  That is, if a security manager has been
@@ -294,9 +291,7 @@ public abstract class AsynchronousSocket
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  UnresolvedAddressException
      *          If the given remote address is not fully resolved
@@ -307,23 +302,26 @@ public abstract class AsynchronousSocket
      * @throws  ConnectionPendingException
      *          If a connection operation is already in progress on this channel
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
+     *          If the channel group has terminated
      * @throws  SecurityException
      *          If a security manager has been installed
      *          and it does not permit access to the given remote endpoint
      *
      * @see #getRemoteAddress
      */
-    public abstract <A> Future<Void> connect(SocketAddress remote,
-                                             A attachment,
-                                             CompletionHandler<Void,? super A> handler);
+    public abstract <A> void connect(SocketAddress remote,
+                                     A attachment,
+                                     CompletionHandler<Void,? super A> handler);
 
     /**
      * Connects this channel.
      *
-     * <p> This method is equivalent to invoking {@link
-     * #connect(SocketAddress,Object,CompletionHandler)} with the {@code attachment}
-     * and handler parameters set to {@code null}.
+     * <p> This method initiates an operation to connect this channel. This
+     * method behaves in exactly the same manner as the {@link
+     * #connect(SocketAddress, Object, CompletionHandler)} method except that
+     * instead of specifying a completion handler, this method returns a {@code
+     * Future} representing the pending result. The {@code Future}'s {@link
+     * Future#get() get} method returns {@code null} on successful completion.
      *
      * @param   remote
      *          The remote address to which this channel is to be connected
@@ -342,18 +340,17 @@ public abstract class AsynchronousSocket
      *          If a security manager has been installed
      *          and it does not permit access to the given remote endpoint
      */
-    public final Future<Void> connect(SocketAddress remote) {
-        return connect(remote, null, null);
-    }
+    public abstract Future<Void> connect(SocketAddress remote);
 
     /**
      * Reads a sequence of bytes from this channel into the given buffer.
      *
-     * <p> This method initiates the reading of a sequence of bytes from this
-     * channel into the given buffer, returning a {@code Future} representing
-     * the pending result of the operation. The {@code Future}'s {@link
-     * Future#get() get} method returns the number of bytes read or {@code -1}
-     * if all bytes have been read and channel has reached end-of-stream.
+     * <p> This method initiates an asynchronous read operation to read a
+     * sequence of bytes from this channel into the given buffer. The {@code
+     * handler} parameter is a completion handler that is invoked when the read
+     * operation completes (or fails). The result passed to the completion
+     * handler is the number of bytes read or {@code -1} if no bytes could be
+     * read because the channel has reached end-of-stream.
      *
      * <p> If a timeout is specified and the timeout elapses before the operation
      * completes then the operation completes with the exception {@link
@@ -376,9 +373,7 @@ public abstract class AsynchronousSocket
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the {@code timeout} parameter is negative or the buffer is
@@ -388,13 +383,13 @@ public abstract class AsynchronousSocket
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Integer> read(ByteBuffer dst,
-                                             long timeout,
-                                             TimeUnit unit,
-                                             A attachment,
-                                             CompletionHandler<Integer,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void read(ByteBuffer dst,
+                                  long timeout,
+                                  TimeUnit unit,
+                                  A attachment,
+                                  CompletionHandler<Integer,? super A> handler);
 
     /**
      * @throws  IllegalArgumentException        {@inheritDoc}
@@ -402,14 +397,14 @@ public abstract class AsynchronousSocket
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
+     *          If the channel group has terminated
      */
     @Override
-    public final <A> Future<Integer> read(ByteBuffer dst,
-                                          A attachment,
-                                          CompletionHandler<Integer,? super A> handler)
+    public final <A> void read(ByteBuffer dst,
+                               A attachment,
+                               CompletionHandler<Integer,? super A> handler)
     {
-        return read(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
+        read(dst, 0L, TimeUnit.MILLISECONDS, attachment, handler);
     }
 
     /**
@@ -419,16 +414,18 @@ public abstract class AsynchronousSocket
      *          If this channel is not yet connected
      */
     @Override
-    public final Future<Integer> read(ByteBuffer dst) {
-        return read(dst, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
+    public abstract Future<Integer> read(ByteBuffer dst);
 
     /**
      * Reads a sequence of bytes from this channel into a subsequence of the
      * given buffers. This operation, sometimes called a <em>scattering read</em>,
      * is often useful when implementing network protocols that group data into
      * segments consisting of one or more fixed-length headers followed by a
-     * variable-length body.
+     * variable-length body. The {@code handler} parameter is a completion
+     * handler that is invoked when the read operation completes (or fails). The
+     * result passed to the completion handler is the number of bytes read or
+     * {@code -1} if no bytes could be read because the channel has reached
+     * end-of-stream.
      *
      * <p> This method initiates a read of up to <i>r</i> bytes from this channel,
      * where <i>r</i> is the total number of bytes remaining in the specified
@@ -455,11 +452,6 @@ public abstract class AsynchronousSocket
      * number of buffers (with bytes remaining), exceeds this limit, then the
      * I/O operation is performed with the maximum number of buffers allowed by
      * the operating system.
-     *
-     * <p> The return value from this method is a {@code Future} representing
-     * the pending result of the operation. The {@code Future}'s {@link
-     * Future#get() get} method returns the number of bytes read or {@code -1L}
-     * if all bytes have been read and the channel has reached end-of-stream.
      *
      * <p> If a timeout is specified and the timeout elapses before the operation
      * completes then it completes with the exception {@link
@@ -485,9 +477,7 @@ public abstract class AsynchronousSocket
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IndexOutOfBoundsException
      *          If the pre-conditions for the {@code offset}  and {@code length}
@@ -500,23 +490,24 @@ public abstract class AsynchronousSocket
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Long> read(ByteBuffer[] dsts,
-                                          int offset,
-                                          int length,
-                                          long timeout,
-                                          TimeUnit unit,
-                                          A attachment,
-                                          CompletionHandler<Long,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void read(ByteBuffer[] dsts,
+                                  int offset,
+                                  int length,
+                                  long timeout,
+                                  TimeUnit unit,
+                                  A attachment,
+                                  CompletionHandler<Long,? super A> handler);
 
     /**
      * Writes a sequence of bytes to this channel from the given buffer.
      *
-     * <p> This method initiates the writing of a sequence of bytes to this channel
-     * from the given buffer, returning a {@code Future} representing the
-     * pending result of the operation. The {@code Future}'s {@link Future#get()
-     * get} method will return the number of bytes written.
+     * <p> This method initiates an asynchronous write operation to write a
+     * sequence of bytes to this channel from the given buffer. The {@code
+     * handler} parameter is a completion handler that is invoked when the write
+     * operation completes (or fails). The result passed to the completion
+     * handler is the number of bytes written.
      *
      * <p> If a timeout is specified and the timeout elapses before the operation
      * completes then it completes with the exception {@link
@@ -539,9 +530,7 @@ public abstract class AsynchronousSocket
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IllegalArgumentException
      *          If the {@code timeout} parameter is negative
@@ -550,28 +539,28 @@ public abstract class AsynchronousSocket
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Integer> write(ByteBuffer src,
-                                              long timeout,
-                                              TimeUnit unit,
-                                              A attachment,
-                                              CompletionHandler<Integer,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void write(ByteBuffer src,
+                                   long timeout,
+                                   TimeUnit unit,
+                                   A attachment,
+                                   CompletionHandler<Integer,? super A> handler);
 
     /**
      * @throws  WritePendingException          {@inheritDoc}
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
+     *          If the channel group has terminated
      */
     @Override
-    public final <A> Future<Integer> write(ByteBuffer src,
-                                           A attachment,
-                                           CompletionHandler<Integer,? super A> handler)
+    public final <A> void write(ByteBuffer src,
+                                A attachment,
+                                CompletionHandler<Integer,? super A> handler)
 
     {
-        return write(src, 0L, TimeUnit.MILLISECONDS, attachment, handler);
+        write(src, 0L, TimeUnit.MILLISECONDS, attachment, handler);
     }
 
     /**
@@ -580,16 +569,16 @@ public abstract class AsynchronousSocket
      *          If this channel is not yet connected
      */
     @Override
-    public final Future<Integer> write(ByteBuffer src) {
-        return write(src, 0L, TimeUnit.MILLISECONDS, null, null);
-    }
+    public abstract Future<Integer> write(ByteBuffer src);
 
     /**
      * Writes a sequence of bytes to this channel from a subsequence of the given
      * buffers. This operation, sometimes called a <em>gathering write</em>, is
      * often useful when implementing network protocols that group data into
      * segments consisting of one or more fixed-length headers followed by a
-     * variable-length body.
+     * variable-length body. The {@code handler} parameter is a completion
+     * handler that is invoked when the write operation completes (or fails).
+     * The result passed to the completion handler is the number of bytes written.
      *
      * <p> This method initiates a write of up to <i>r</i> bytes to this channel,
      * where <i>r</i> is the total number of bytes remaining in the specified
@@ -615,10 +604,6 @@ public abstract class AsynchronousSocket
      * used in an I/O operation. Where the number of buffers (with bytes
      * remaining), exceeds this limit, then the I/O operation is performed with
      * the maximum number of buffers allowed by the operating system.
-     *
-     * <p> The return value from this method is a {@code Future} representing
-     * the pending result of the operation. The {@code Future}'s {@link
-     * Future#get() get} method will return the number of bytes written.
      *
      * <p> If a timeout is specified and the timeout elapses before the operation
      * completes then it completes with the exception {@link
@@ -644,9 +629,7 @@ public abstract class AsynchronousSocket
      * @param   attachment
      *          The object to attach to the I/O operation; can be {@code null}
      * @param   handler
-     *          The handler for consuming the result; can be {@code null}
-     *
-     * @return  A {@code Future} object representing the pending result
+     *          The handler for consuming the result
      *
      * @throws  IndexOutOfBoundsException
      *          If the pre-conditions for the {@code offset}  and {@code length}
@@ -658,13 +641,13 @@ public abstract class AsynchronousSocket
      * @throws  NotYetConnectedException
      *          If this channel is not yet connected
      * @throws  ShutdownChannelGroupException
-     *          If a handler is specified, and the channel group is shutdown
-     */
-    public abstract <A> Future<Long> write(ByteBuffer[] srcs,
-                                           int offset,
-                                           int length,
-                                           long timeout,
-                                           TimeUnit unit,
-                                           A attachment,
-                                           CompletionHandler<Long,? super A> handler);
+     *          If the channel group has terminated
+     */
+    public abstract <A> void write(ByteBuffer[] srcs,
+                                   int offset,
+                                   int length,
+                                   long timeout,
+                                   TimeUnit unit,
+                                   A attachment,
+                                   CompletionHandler<Long,? super A> handler);
 }
--- a/src/share/classes/java/nio/channels/Channels.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/Channels.java	Tue Sep 22 01:20:51 2009 -0700
@@ -182,7 +182,6 @@ public final class Channels {
     }
 
     /**
-     * {@note new}
      * Constructs a stream that reads bytes from the given channel.
      *
      * <p> The stream will not be buffered, and it will not support the {@link
@@ -258,7 +257,6 @@ public final class Channels {
     }
 
     /**
-     * {@note new}
      * Constructs a stream that writes bytes to the given channel.
      *
      * <p> The stream will not be buffered. The stream will be safe for access
--- a/src/share/classes/java/nio/channels/CompletionHandler.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/CompletionHandler.java	Tue Sep 22 01:20:51 2009 -0700
@@ -32,11 +32,9 @@ package java.nio.channels;
  * handler to be specified to consume the result of an asynchronous operation.
  * The {@link #completed completed} method is invoked when the I/O operation
  * completes successfully. The {@link #failed failed} method is invoked if the
- * I/O operations fails. The {@link #cancelled cancelled} method is invoked when
- * the I/O operation is cancelled by invoking the {@link
- * java.util.concurrent.Future#cancel cancel} method. The implementations of
- * these methods should complete in a timely manner so as to avoid keeping the
- * invoking thread from dispatching to other completion handlers.
+ * I/O operations fails. The implementations of these methods should complete
+ * in a timely manner so as to avoid keeping the invoking thread from dispatching
+ * to other completion handlers.
  *
  * @param   <V>     The result type of the I/O operation
  * @param   <A>     The type of the object attached to the I/O operation
@@ -65,13 +63,4 @@ public interface CompletionHandler<V,A> 
      *          The object attached to the I/O operation when it was initiated.
      */
     void failed(Throwable exc, A attachment);
-
-    /**
-     * Invoked when an operation is cancelled by invoking the {@link
-     * java.util.concurrent.Future#cancel cancel} method.
-     *
-     * @param   attachment
-     *          The object attached to the I/O operation when it was initiated.
-     */
-    void cancelled(A attachment);
 }
--- a/src/share/classes/java/nio/channels/FileChannel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/FileChannel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -39,8 +39,7 @@ import java.util.Collections;
 /**
  * A channel for reading, writing, mapping, and manipulating a file.
  *
- * <p> {@note revised}
- * A file channel is a {@link SeekableByteChannel} that is connected to
+ * <p> A file channel is a {@link SeekableByteChannel} that is connected to
  * a file. It has a current <i>position</i> within its file which can
  * be both {@link #position() <i>queried</i>} and {@link #position(long)
  * <i>modified</i>}.  The file itself contains a variable-length sequence
@@ -151,7 +150,6 @@ import java.util.Collections;
  * @author Mike McCloskey
  * @author JSR-51 Expert Group
  * @since 1.4
- * @updated 1.7
  */
 
 public abstract class FileChannel
@@ -164,7 +162,6 @@ public abstract class FileChannel
     protected FileChannel() { }
 
     /**
-     * {@note new}
      * Opens or creates a file, returning a file channel to access the file.
      *
      * <p> The {@code options} parameter determines how the file is opened.
@@ -293,7 +290,6 @@ public abstract class FileChannel
     private static final FileAttribute<?>[] NO_ATTRIBUTES = new FileAttribute[0];
 
     /**
-     * {@note new}
      * Opens or creates a file, returning a file channel to access the file.
      *
      * <p> An invocation of this method behaves in exactly the same way as the
--- a/src/share/classes/java/nio/channels/FileLock.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/FileLock.java	Tue Sep 22 01:20:51 2009 -0700
@@ -114,7 +114,6 @@ import java.io.IOException;
  * @author Mark Reinhold
  * @author JSR-51 Expert Group
  * @since 1.4
- * @updated 1.7
  */
 
 public abstract class FileLock {
@@ -161,7 +160,7 @@ public abstract class FileLock {
     }
 
     /**
-     * {@note new} Initializes a new instance of this class.
+     * Initializes a new instance of this class.
      *
      * @param  channel
      *         The channel upon whose file this lock is held
@@ -199,7 +198,6 @@ public abstract class FileLock {
     }
 
     /**
-     * {@note revised}
      * Returns the file channel upon whose file this lock was acquired.
      *
      * <p> This method has been superseded by the {@link #acquiredBy acquiredBy}
@@ -213,7 +211,6 @@ public abstract class FileLock {
     }
 
     /**
-     * {@note new}
      * Returns the channel upon whose file this lock was acquired.
      *
      * @return  The channel upon whose file this lock was acquired.
--- a/src/share/classes/java/nio/channels/exceptions	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/exceptions	Tue Sep 22 01:20:51 2009 -0700
@@ -190,5 +190,5 @@ gen ShutdownChannelGroupException "
 gen ShutdownChannelGroupException "
  * Unchecked exception thrown when an attempt is made to construct a channel in 
  * a group that is shutdown or the completion handler for an I/O operation 
- * cannot be invoked because the channel group is shutdown." \
+ * cannot be invoked because the channel group has terminated." \
  -3903801676350154157L
--- a/src/share/classes/java/nio/channels/package-info.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/channels/package-info.java	Tue Sep 22 01:20:51 2009 -0700
@@ -285,7 +285,6 @@
  * java.lang.NullPointerException NullPointerException} to be thrown.
  *
  * @since 1.4
- * @updated 1.7
  * @author Mark Reinhold
  * @author JSR-51 Expert Group
  */
--- a/src/share/classes/java/nio/file/FileRef.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/file/FileRef.java	Tue Sep 22 01:20:51 2009 -0700
@@ -39,8 +39,6 @@ import java.io.IOException;
  * metadata or file attributes.
  *
  * @since 1.7
- * @see java.io.Inputs
- * @see java.io.Outputs
  * @see java.nio.file.attribute.Attributes
  * @see java.io.File#toPath
  */
--- a/src/share/classes/java/nio/file/Files.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/file/Files.java	Tue Sep 22 01:20:51 2009 -0700
@@ -133,10 +133,11 @@ public final class Files {
      * <p> This method walks a file tree rooted at a given starting file. The
      * file tree traversal is <em>depth-first</em> with the given {@link
      * FileVisitor} invoked for each file encountered. File tree traversal
-     * completes when all accessible files in the tree have been visited, a
-     * visitor returns a result of {@link FileVisitResult#TERMINATE TERMINATE},
-     * or the visitor terminates due to an uncaught {@code Error} or {@code
-     * RuntimeException}.
+     * completes when all accessible files in the tree have been visited, or a
+     * visit method returns a result of {@link FileVisitResult#TERMINATE
+     * TERMINATE}. Where a visit method terminates due an uncaught error or
+     * runtime exception then the traversal is terminated and the error or
+     * exception is propagated to the caller of this method.
      *
      * <p> For each file encountered this method attempts to gets its {@link
      * java.nio.file.attribute.BasicFileAttributes}. If the file is not a
--- a/src/share/classes/java/nio/file/SimpleFileVisitor.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/nio/file/SimpleFileVisitor.java	Tue Sep 22 01:20:51 2009 -0700
@@ -124,8 +124,8 @@ public class SimpleFileVisitor<T> implem
      * cause.
      *
      * @throws  IOError
-     *          if iteration of the directory completed prematurely due to an
-     *          I/O error
+     *          with the I/O exception thrown when iteration of the directory
+     *          completed prematurely due to an I/O error
      */
     @Override
     public FileVisitResult postVisitDirectory(T dir, IOException exc) {
--- a/src/share/classes/java/util/Properties.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/util/Properties.java	Tue Sep 22 01:20:51 2009 -0700
@@ -101,11 +101,11 @@ import java.io.BufferedWriter;
  *    &lt;!ATTLIST entry key CDATA #REQUIRED&gt;
  * </pre>
  *
+ * <p>This class is thread-safe: multiple threads can share a single
+ * <tt>Properties</tt> object without the need for external synchronization.
+ *
  * @see <a href="../../../technotes/tools/solaris/native2ascii.html">native2ascii tool for Solaris</a>
  * @see <a href="../../../technotes/tools/windows/native2ascii.html">native2ascii tool for Windows</a>
- *
- * <p>This class is thread-safe: multiple threads can share a single
- * <tt>Properties</tt> object without the need for external synchronization.
  *
  * @author  Arthur van Hoff
  * @author  Michael McCloskey
--- a/src/share/classes/java/util/Scanner.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/util/Scanner.java	Tue Sep 22 01:20:51 2009 -0700
@@ -674,7 +674,6 @@ public final class Scanner implements It
     }
 
     /**
-     * {@note new}
      * Constructs a new <code>Scanner</code> that produces values scanned
      * from the specified file. Bytes from the file are converted into
      * characters using the underlying platform's
@@ -694,7 +693,6 @@ public final class Scanner implements It
     }
 
     /**
-     * {@note new}
      * Constructs a new <code>Scanner</code> that produces values scanned
      * from the specified file. Bytes from the file are converted into
      * characters using the specified charset.
--- a/src/share/classes/java/util/SimpleTimeZone.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/util/SimpleTimeZone.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1372,7 +1372,7 @@ public class SimpleTimeZone extends Time
                 throw new IllegalArgumentException(
                         "Illegal start month " + startMonth);
             }
-            if (startTime < 0 || startTime >= millisPerDay) {
+            if (startTime < 0 || startTime > millisPerDay) {
                 throw new IllegalArgumentException(
                         "Illegal start time " + startTime);
             }
@@ -1419,7 +1419,7 @@ public class SimpleTimeZone extends Time
                 throw new IllegalArgumentException(
                         "Illegal end month " + endMonth);
             }
-            if (endTime < 0 || endTime >= millisPerDay) {
+            if (endTime < 0 || endTime > millisPerDay) {
                 throw new IllegalArgumentException(
                         "Illegal end time " + endTime);
             }
--- a/src/share/classes/java/util/concurrent/LinkedBlockingQueue.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/java/util/concurrent/LinkedBlockingQueue.java	Tue Sep 22 01:20:51 2009 -0700
@@ -766,19 +766,21 @@ public class LinkedBlockingQueue<E> exte
         }
 
         /**
-         * Unlike other traversal methods, iterators need to handle:
+         * Returns the next live successor of p, or null if no such.
+         *
+         * Unlike other traversal methods, iterators need to handle both:
          * - dequeued nodes (p.next == p)
-         * - interior removed nodes (p.item == null)
+         * - (possibly multiple) interior removed nodes (p.item == null)
          */
         private Node<E> nextNode(Node<E> p) {
-            Node<E> s = p.next;
-            if (p == s)
-                return head.next;
-            // Skip over removed nodes.
-            // May be necessary if multiple interior Nodes are removed.
-            while (s != null && s.item == null)
-                s = s.next;
-            return s;
+            for (;;) {
+                Node<E> s = p.next;
+                if (s == p)
+                    return head.next;
+                if (s == null || s.item != null)
+                    return s;
+                p = s;
+            }
         }
 
         public E next() {
--- a/src/share/classes/javax/swing/JEditorPane.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JEditorPane.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,6 +23,8 @@
  * have any questions.
  */
 package javax.swing;
+
+import sun.swing.SwingUtilities2;
 
 import java.awt.*;
 import java.awt.event.*;
@@ -1123,6 +1125,7 @@ public class JEditorPane extends JTextCo
      * @param content  the content to replace the selection with.  This
      *   value can be <code>null</code>
      */
+    @Override
     public void replaceSelection(String content) {
         if (! isEditable()) {
             UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);
@@ -1133,6 +1136,7 @@ public class JEditorPane extends JTextCo
             try {
                 Document doc = getDocument();
                 Caret caret = getCaret();
+                boolean composedTextSaved = saveComposedText(caret.getDot());
                 int p0 = Math.min(caret.getDot(), caret.getMark());
                 int p1 = Math.max(caret.getDot(), caret.getMark());
                 if (doc instanceof AbstractDocument) {
@@ -1147,6 +1151,9 @@ public class JEditorPane extends JTextCo
                         doc.insertString(p0, content, ((StyledEditorKit)kit).
                                          getInputAttributes());
                     }
+                }
+                if (composedTextSaved) {
+                    restoreComposedText();
                 }
             } catch (BadLocationException e) {
                 UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);
@@ -1323,8 +1330,8 @@ public class JEditorPane extends JTextCo
      */
     public Dimension getPreferredSize() {
         Dimension d = super.getPreferredSize();
-        if (getParent() instanceof JViewport) {
-            JViewport port = (JViewport)getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
             TextUI ui = getUI();
             int prefWidth = d.width;
             int prefHeight = d.height;
@@ -1445,8 +1452,8 @@ public class JEditorPane extends JTextCo
      * match its own, false otherwise
      */
     public boolean getScrollableTracksViewportWidth() {
-        if (getParent() instanceof JViewport) {
-            JViewport port = (JViewport)getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
             TextUI ui = getUI();
             int w = port.getWidth();
             Dimension min = ui.getMinimumSize(this);
@@ -1467,8 +1474,8 @@ public class JEditorPane extends JTextCo
      *          false otherwise
      */
     public boolean getScrollableTracksViewportHeight() {
-        if (getParent() instanceof JViewport) {
-            JViewport port = (JViewport)getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
             TextUI ui = getUI();
             int h = port.getHeight();
             Dimension min = ui.getMinimumSize(this);
--- a/src/share/classes/javax/swing/JLayer.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JLayer.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,6 +1,26 @@
 /*
- * Copyright 2009 Sun Microsystems, Inc. All rights reserved.
- * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
  */
 
 package javax.swing;
@@ -158,7 +178,7 @@ public final class JLayer<V extends Comp
      * @return the {@code JLayer}'s view component
      *         or {@code null} if none exists
      *
-     * @see #setView(V)
+     * @see #setView(Component)
      */
     public V getView() {
         return view;
@@ -259,7 +279,7 @@ public final class JLayer<V extends Comp
      * @throws UnsupportedOperationException this method is not supported
      *
      * @see #setView(Component)
-     * @see #setGlassPane(Component)
+     * @see #setGlassPane(JPanel)
      */
     protected void addImpl(Component comp, Object constraints, int index) {
         throw new UnsupportedOperationException(
@@ -319,7 +339,7 @@ public final class JLayer<V extends Comp
      * @return false if {@code JLayer}'s {@code glassPane} is visible
      */
     public boolean isOptimizedDrawingEnabled() {
-        return !glassPane.isVisible();
+        return glassPane == null || !glassPane.isVisible();
     }
 
     /**
@@ -388,7 +408,10 @@ public final class JLayer<V extends Comp
         if (layerEventMask != oldEventMask) {
             disableEvents(oldEventMask);
             enableEvents(eventMask);
-            eventController.updateAWTEventListener(this);
+            if (isDisplayable()) {
+                eventController.updateAWTEventListener(
+                        oldEventMask, layerEventMask);
+            }
         }
     }
 
@@ -475,9 +498,6 @@ public final class JLayer<V extends Comp
         if (getUI() != null) {
             return getUI().getScrollableTracksViewportHeight(this);
         }
-        if (getParent() instanceof JViewport) {
-            return ((getParent()).getHeight() > getPreferredSize().height);
-        }
         return false;
     }
 
@@ -497,9 +517,6 @@ public final class JLayer<V extends Comp
     public boolean getScrollableTracksViewportWidth() {
         if (getUI() != null) {
             return getUI().getScrollableTracksViewportWidth(this);
-        }
-        if (getParent() instanceof JViewport) {
-            return ((getParent()).getWidth() > getPreferredSize().width);
         }
         return false;
     }
@@ -535,20 +552,36 @@ public final class JLayer<V extends Comp
     private void readObject(ObjectInputStream s)
             throws IOException, ClassNotFoundException {
         s.defaultReadObject();
-        if (getUI() != null) {
-            setUI(getUI());
-        }
-        if (getLayerEventMask() != 0) {
-            eventController.updateAWTEventListener(this);
-        }
+        if (layerUI != null) {
+            setUI(layerUI);
+        }
+        if (eventMask != 0) {
+            eventController.updateAWTEventListener(0, eventMask);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void addNotify() {
+        super.addNotify();
+        eventController.updateAWTEventListener(0, eventMask);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void removeNotify() {
+        super.removeNotify();
+        eventController.updateAWTEventListener(eventMask, 0);
     }
 
     /**
      * static AWTEventListener to be shared with all AbstractLayerUIs
      */
     private static class LayerEventController implements AWTEventListener {
-        private ArrayList<WeakReference<JLayer>> layerList =
-                new ArrayList<WeakReference<JLayer>>();
+        private ArrayList<Long> layerMaskList =
+                new ArrayList<Long>();
 
         private long currentEventMask;
 
@@ -572,37 +605,24 @@ public final class JLayer<V extends Comp
             }
         }
 
-        private boolean layerListContains(JLayer l) {
-            for (WeakReference<JLayer> layerWeakReference : layerList) {
-                if (layerWeakReference.get() == l) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        private void updateAWTEventListener(JLayer layer) {
-            if (!layerListContains(layer) && layer.getLayerEventMask() != 0) {
-                layerList.add(new WeakReference<JLayer>(layer));
+        private void updateAWTEventListener(long oldEventMask, long newEventMask) {
+            if (oldEventMask != 0) {
+                layerMaskList.remove(oldEventMask);
+            }
+            if (newEventMask != 0) {
+                layerMaskList.add(newEventMask);
             }
             long combinedMask = 0;
-            Iterator<WeakReference<JLayer>> it = layerList.iterator();
-            while (it.hasNext()) {
-                WeakReference<JLayer> weakRef = it.next();
-                JLayer currLayer = weakRef.get();
-                if (currLayer == null) {
-                    it.remove();
-                } else {
-                    combinedMask |= currLayer.getLayerEventMask();
-                }
+            for (Long mask : layerMaskList) {
+                combinedMask |= mask;
             }
             if (combinedMask == 0) {
                 removeAWTEventListener();
-                layerList.clear();
             } else if (getCurrentEventMask() != combinedMask) {
                 removeAWTEventListener();
                 addAWTEventListener(combinedMask);
             }
+            currentEventMask = combinedMask;
         }
 
         private long getCurrentEventMask() {
@@ -617,7 +637,7 @@ public final class JLayer<V extends Comp
                     return null;
                 }
             });
-            currentEventMask = eventMask;
+
         }
 
         private void removeAWTEventListener() {
@@ -628,7 +648,6 @@ public final class JLayer<V extends Comp
                     return null;
                 }
             });
-            currentEventMask = 0;
         }
 
         private boolean isEventEnabled(long eventMask, int id) {
@@ -785,4 +804,4 @@ public final class JLayer<V extends Comp
         public void removeLayoutComponent(Component comp) {
         }
     }
-}
\ No newline at end of file
+}
--- a/src/share/classes/javax/swing/JList.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JList.java	Tue Sep 22 01:20:51 2009 -0700
@@ -2722,8 +2722,9 @@ public class JList extends JComponent im
                                       getVisibleRowCount() <= 0) {
             return true;
         }
-        if (getParent() instanceof JViewport) {
-            return (getParent().getWidth() > getPreferredSize().width);
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return port.getWidth() > getPreferredSize().width;
         }
         return false;
     }
@@ -2747,8 +2748,9 @@ public class JList extends JComponent im
                      getVisibleRowCount() <= 0) {
             return true;
         }
-        if (getParent() instanceof JViewport) {
-            return (getParent().getHeight() > getPreferredSize().height);
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return port.getHeight() > getPreferredSize().height;
         }
         return false;
     }
--- a/src/share/classes/javax/swing/JTable.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JTable.java	Tue Sep 22 01:20:51 2009 -0700
@@ -718,9 +718,9 @@ public class JTable extends JComponent i
      * @see #addNotify
      */
     protected void configureEnclosingScrollPane() {
-        Container p = getParent();
-        if (p instanceof JViewport) {
-            Container gp = p.getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            Container gp = port.getParent();
             if (gp instanceof JScrollPane) {
                 JScrollPane scrollPane = (JScrollPane)gp;
                 // Make certain we are the viewPort's view and not, for
@@ -750,9 +750,9 @@ public class JTable extends JComponent i
      * from configureEnclosingScrollPane() and updateUI() in a safe manor.
      */
     private void configureEnclosingScrollPaneUI() {
-        Container p = getParent();
-        if (p instanceof JViewport) {
-            Container gp = p.getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            Container gp = port.getParent();
             if (gp instanceof JScrollPane) {
                 JScrollPane scrollPane = (JScrollPane)gp;
                 // Make certain we are the viewPort's view and not, for
@@ -819,9 +819,9 @@ public class JTable extends JComponent i
      * @since 1.3
      */
     protected void unconfigureEnclosingScrollPane() {
-        Container p = getParent();
-        if (p instanceof JViewport) {
-            Container gp = p.getParent();
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            Container gp = port.getParent();
             if (gp instanceof JScrollPane) {
                 JScrollPane scrollPane = (JScrollPane)gp;
                 // Make certain we are the viewPort's view and not, for
@@ -5215,9 +5215,10 @@ public class JTable extends JComponent i
      * @see #getFillsViewportHeight
      */
     public boolean getScrollableTracksViewportHeight() {
+        JViewport port = SwingUtilities2.getViewport(this);
         return getFillsViewportHeight()
-               && getParent() instanceof JViewport
-               && (getParent().getHeight() > getPreferredSize().height);
+               && port != null
+               && port.getHeight() > getPreferredSize().height;
     }
 
     /**
--- a/src/share/classes/javax/swing/JTextField.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JTextField.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,6 +23,8 @@
  * have any questions.
  */
 package javax.swing;
+
+import sun.swing.SwingUtilities2;
 
 import java.awt.*;
 import java.awt.event.*;
@@ -288,11 +290,7 @@ public class JTextField extends JTextCom
      * @see JComponent#isValidateRoot
      */
     public boolean isValidateRoot() {
-        Component parent = getParent();
-        if (parent instanceof JViewport) {
-            return false;
-        }
-        return true;
+        return SwingUtilities2.getViewport(this) == null;
     }
 
 
--- a/src/share/classes/javax/swing/JTextPane.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JTextPane.java	Tue Sep 22 01:20:51 2009 -0700
@@ -170,6 +170,7 @@ public class JTextPane extends JEditorPa
      *
      * @param content  the content to replace the selection with
      */
+    @Override
     public void replaceSelection(String content) {
         replaceSelection(content, true);
     }
@@ -183,6 +184,7 @@ public class JTextPane extends JEditorPa
         if (doc != null) {
             try {
                 Caret caret = getCaret();
+                boolean composedTextSaved = saveComposedText(caret.getDot());
                 int p0 = Math.min(caret.getDot(), caret.getMark());
                 int p1 = Math.max(caret.getDot(), caret.getMark());
                 AttributeSet attr = getInputAttributes().copyAttributes();
@@ -196,6 +198,9 @@ public class JTextPane extends JEditorPa
                     if (content != null && content.length() > 0) {
                         doc.insertString(p0, content, attr);
                     }
+                }
+                if (composedTextSaved) {
+                    restoreComposedText();
                 }
             } catch (BadLocationException e) {
                 UIManager.getLookAndFeel().provideErrorFeedback(JTextPane.this);
--- a/src/share/classes/javax/swing/JTree.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/JTree.java	Tue Sep 22 01:20:51 2009 -0700
@@ -3498,8 +3498,9 @@ public class JTree extends JComponent im
      * @see Scrollable#getScrollableTracksViewportWidth
      */
     public boolean getScrollableTracksViewportWidth() {
-        if (getParent() instanceof JViewport) {
-            return getParent().getWidth() > getPreferredSize().width;
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return port.getWidth() > getPreferredSize().width;
         }
         return false;
     }
@@ -3514,8 +3515,9 @@ public class JTree extends JComponent im
      * @see Scrollable#getScrollableTracksViewportHeight
      */
     public boolean getScrollableTracksViewportHeight() {
-        if (getParent() instanceof JViewport) {
-            return getParent().getHeight() > getPreferredSize().height;
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return port.getHeight() > getPreferredSize().height;
         }
         return false;
     }
--- a/src/share/classes/javax/swing/SwingUtilities.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/SwingUtilities.java	Tue Sep 22 01:20:51 2009 -0700
@@ -999,24 +999,20 @@ public class SwingUtilities implements S
                 textR.height = (int) v.getPreferredSpan(View.Y_AXIS);
             } else {
                 textR.width = SwingUtilities2.stringWidth(c, fm, text);
-
-                // Take into account the left and right side bearings.
-                // This gives more space than it is actually needed,
-                // but there are two reasons:
-                // 1. If we set the width to the actual bounds,
-                //    all callers would have to account for the bearings
-                //    themselves. NOTE: all pref size calculations don't do it.
-                // 2. You can do a drawString at the returned location
-                //    and the text won't be clipped.
                 lsb = SwingUtilities2.getLeftSideBearing(c, fm, text);
                 if (lsb < 0) {
+                    // If lsb is negative, add it to the width and later
+                    // adjust the x location. This gives more space than is
+                    // actually needed.
+                    // This is done like this for two reasons:
+                    // 1. If we set the width to the actual bounds all
+                    //    callers would have to account for negative lsb
+                    //    (pref size calculations ONLY look at width of
+                    //    textR)
+                    // 2. You can do a drawString at the returned location
+                    //    and the text won't be clipped.
                     textR.width -= lsb;
                 }
-                rsb = SwingUtilities2.getRightSideBearing(c, fm, text);
-                if (rsb > 0) {
-                    textR.width += rsb;
-                }
-
                 if (textR.width > availTextWidth) {
                     text = SwingUtilities2.clipString(c, fm, text,
                                                       availTextWidth);
--- a/src/share/classes/javax/swing/plaf/LayerUI.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/LayerUI.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,6 +1,26 @@
 /*
- * Copyright 2009 Sun Microsystems, Inc. All rights reserved.
- * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
  */
 
 package javax.swing.plaf;
@@ -202,6 +222,7 @@ public class LayerUI<V extends Component
      * Returns an array of all the listeners which have been associated
      * with the named property.
      *
+     * @param propertyName  The name of the property being listened to
      * @return all of the {@code PropertyChangeListener}s associated with
      *         the named property; if no such listeners have been added or
      *         if {@code propertyName} is {@code null}, an empty
@@ -242,6 +263,7 @@ public class LayerUI<V extends Component
     /**
      * Returns the preferred size of the viewport for a view component.
      *
+     * @param l the {@code JLayer} component where this UI delegate is being installed
      * @return the preferred size of the viewport for a view component
      * @see Scrollable#getPreferredScrollableViewportSize()
      */
@@ -257,6 +279,10 @@ public class LayerUI<V extends Component
      * that display logical rows or columns in order to completely expose
      * one block of rows or columns, depending on the value of orientation.
      *
+     * @param l the {@code JLayer} component where this UI delegate is being installed
+     * @param visibleRect The view area visible within the viewport
+     * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
+     * @param direction Less than zero to scroll up/left, greater than zero for down/right.
      * @return the "block" increment for scrolling in the specified direction
      * @see Scrollable#getScrollableBlockIncrement(Rectangle, int, int)
      */
@@ -276,15 +302,13 @@ public class LayerUI<V extends Component
      * determine the height of the layer, unless the preferred height
      * of the layer is smaller than the height of the viewport.
      *
+     * @param l the {@code JLayer} component where this UI delegate is being installed
      * @return whether the layer should track the height of the viewport
      * @see Scrollable#getScrollableTracksViewportHeight()
      */
     public boolean getScrollableTracksViewportHeight(JLayer<? extends V> l) {
         if (l.getView() instanceof Scrollable) {
             return ((Scrollable)l.getView()).getScrollableTracksViewportHeight();
-        }
-        if (l.getParent() instanceof JViewport) {
-            return (((JViewport)l.getParent()).getHeight() > l.getPreferredSize().height);
         }
         return false;
     }
@@ -294,6 +318,7 @@ public class LayerUI<V extends Component
      * determine the width of the layer, unless the preferred width
      * of the layer is smaller than the width of the viewport.
      *
+     * @param l the {@code JLayer} component where this UI delegate is being installed
      * @return whether the layer should track the width of the viewport
      * @see Scrollable
      * @see LayerUI#getScrollableTracksViewportWidth(JLayer)
@@ -301,9 +326,6 @@ public class LayerUI<V extends Component
     public boolean getScrollableTracksViewportWidth(JLayer<? extends V> l) {
         if (l.getView() instanceof Scrollable) {
             return ((Scrollable)l.getView()).getScrollableTracksViewportWidth();
-        }
-        if (l.getParent() instanceof JViewport) {
-            return (((JViewport)l.getParent()).getWidth() > l.getPreferredSize().width);
         }
         return false;
     }
@@ -318,6 +340,10 @@ public class LayerUI<V extends Component
      * Scrolling containers, like JScrollPane, will use this method
      * each time the user requests a unit scroll.
      *
+     * @param l the {@code JLayer} component where this UI delegate is being installed
+     * @param visibleRect The view area visible within the viewport
+     * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
+     * @param direction Less than zero to scroll up/left, greater than zero for down/right.
      * @return The "unit" increment for scrolling in the specified direction.
      *         This value should always be positive.
      * @see Scrollable#getScrollableUnitIncrement(Rectangle, int, int)
@@ -367,4 +393,4 @@ public class LayerUI<V extends Component
         }
         return super.getBaselineResizeBehavior(c);
     }
-}
\ No newline at end of file
+}
--- a/src/share/classes/javax/swing/plaf/basic/BasicSliderUI.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/basic/BasicSliderUI.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1507,7 +1507,8 @@ public class BasicSliderUI extends Slide
                     propertyName == "paintTicks" ||
                     propertyName == "paintTrack" ||
                     propertyName == "font" ||
-                    propertyName == "paintLabels") {
+                    propertyName == "paintLabels" ||
+                    propertyName == "Slider.paintThumbArrowShape") {
                 checkedLabelBaselines = false;
                 calculateGeometry();
                 slider.repaint();
--- a/src/share/classes/javax/swing/plaf/metal/MetalFontDesktopProperty.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/metal/MetalFontDesktopProperty.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 2001 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2001-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,8 +25,6 @@ package javax.swing.plaf.metal;
 package javax.swing.plaf.metal;
 
 import java.awt.*;
-import java.beans.*;
-import javax.swing.*;
 
 /**
  * DesktopProperty that only uses font height in configuring font. This
@@ -60,7 +58,7 @@ class MetalFontDesktopProperty extends c
      * @param type MetalTheme font type.
      */
     MetalFontDesktopProperty(int type) {
-        this(propertyMapping[type], Toolkit.getDefaultToolkit(), type);
+        this(propertyMapping[type], type);
     }
 
     /**
@@ -72,8 +70,8 @@ class MetalFontDesktopProperty extends c
      * @param type Type of font being used, corresponds to MetalTheme font
      *        type.
      */
-    MetalFontDesktopProperty(String key, Toolkit kit, int type) {
-        super(key, null, kit);
+    MetalFontDesktopProperty(String key, int type) {
+        super(key, null);
         this.type = type;
     }
 
--- a/src/share/classes/javax/swing/plaf/metal/MetalLookAndFeel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/metal/MetalLookAndFeel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 1998-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1998-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1541,10 +1541,8 @@ public class MetalLookAndFeel extends Ba
         table.putDefaults(defaults);
 
         if (isWindows() && useSystemFonts() && theme.isSystemTheme()) {
-            Toolkit kit = Toolkit.getDefaultToolkit();
             Object messageFont = new MetalFontDesktopProperty(
-                              "win.messagebox.font.height", kit, MetalTheme.
-                              CONTROL_TEXT_FONT);
+                "win.messagebox.font.height", MetalTheme.CONTROL_TEXT_FONT);
 
             defaults = new Object[] {
                 "OptionPane.messageFont", messageFont,
--- a/src/share/classes/javax/swing/plaf/nimbus/Defaults.template	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/nimbus/Defaults.template	Tue Sep 22 01:20:51 2009 -0700
@@ -101,14 +101,7 @@ final class ${LAF_NAME}Defaults {
      */
     private FontUIResource defaultFont;
 
-    /**
-     * Map of lists of derived colors keyed by the DerivedColorKeys
-     */
-    private Map<DerivedColorKey, DerivedColor> derivedColorsMap =
-            new HashMap<DerivedColorKey, DerivedColor>();
-
-    /** Tempory key used for fetching from the derivedColorsMap */
-    private final DerivedColorKey tmpDCKey = new DerivedColorKey();
+    private ColorTree colorTree = new ColorTree();
 
     /** Listener for changes to user defaults table */
     private DefaultsListener defaultsListener = new DefaultsListener();
@@ -117,14 +110,14 @@ final class ${LAF_NAME}Defaults {
     void initialize() {
         // add listener for derived colors
         UIManager.addPropertyChangeListener(defaultsListener);
-        UIManager.getDefaults().addPropertyChangeListener(defaultsListener);
+        UIManager.getDefaults().addPropertyChangeListener(colorTree);
     }
 
     /** Called by UIManager when this look and feel is uninstalled. */
     void uninitialize() {
         // remove listener for derived colors
-        UIManager.getDefaults().removePropertyChangeListener(defaultsListener);
         UIManager.removePropertyChangeListener(defaultsListener);
+        UIManager.getDefaults().removePropertyChangeListener(colorTree);
     }
 
     /**
@@ -663,22 +656,23 @@ final class ${LAF_NAME}Defaults {
         }
     }
 
-    /**
-     * Get a derived color, derived colors are shared instances and will be
-     * updated when its parent UIDefault color changes.
-     *
-     * @param uiDefaultParentName The parent UIDefault key
-     * @param hOffset The hue offset
-     * @param sOffset The saturation offset
-     * @param bOffset The brightness offset
-     * @param aOffset The alpha offset
-     * @return The stored derived color
-     */
-    public DerivedColor getDerivedColor(String uiDefaultParentName,
-                                        float hOffset, float sOffset,
-                                        float bOffset, int aOffset){
-        return getDerivedColor(uiDefaultParentName, hOffset, sOffset,
-                               bOffset, aOffset, true);
+    private void addColor(UIDefaults d, String uin, int r, int g, int b, int a) {
+        Color color = new ColorUIResource(new Color(r, g, b, a));
+        colorTree.addColor(uin, color);
+        d.put(uin, color);
+    }
+
+    private void addColor(UIDefaults d, String uin, String parentUin,
+            float hOffset, float sOffset, float bOffset, int aOffset) {
+        addColor(d, uin, parentUin, hOffset, sOffset, bOffset, aOffset, true);
+    }
+
+    private void addColor(UIDefaults d, String uin, String parentUin,
+            float hOffset, float sOffset, float bOffset,
+            int aOffset, boolean uiResource) {
+        Color color = getDerivedColor(uin, parentUin,
+                hOffset, sOffset, bOffset, aOffset, uiResource);
+        d.put(uin, color);
     }
 
     /**
@@ -694,89 +688,110 @@ final class ${LAF_NAME}Defaults {
      *        false if it should not be a UIResource
      * @return The stored derived color
      */
-    public DerivedColor getDerivedColor(String uiDefaultParentName,
+    public DerivedColor getDerivedColor(String parentUin,
                                         float hOffset, float sOffset,
                                         float bOffset, int aOffset,
                                         boolean uiResource){
-        tmpDCKey.set(uiDefaultParentName, hOffset, sOffset, bOffset, aOffset,
-            uiResource);
-        DerivedColor color = derivedColorsMap.get(tmpDCKey);
-        if (color == null){
-            if (uiResource) {
-                color = new DerivedColor.UIResource(uiDefaultParentName,
-                        hOffset, sOffset, bOffset, aOffset);
-            } else {
-                color = new DerivedColor(uiDefaultParentName, hOffset, sOffset,
-                    bOffset, aOffset);
-            }
-            // calculate the initial value
-            color.rederiveColor();
-            // add the listener so that if the color changes we'll propogate it
-            color.addPropertyChangeListener(defaultsListener);
-            // add to the derived colors table
-            derivedColorsMap.put(new DerivedColorKey(uiDefaultParentName,
-                    hOffset, sOffset, bOffset, aOffset, uiResource),color);
-        }
-        return color;
-    }
-
-    /**
-     * Key class for derived colors
-     */
-    private class DerivedColorKey {
-        private String uiDefaultParentName;
-        private float hOffset, sOffset, bOffset;
-        private int aOffset;
-        private boolean uiResource;
-
-        DerivedColorKey(){}
-
-        DerivedColorKey(String uiDefaultParentName, float hOffset,
-                        float sOffset, float bOffset, int aOffset,
-                        boolean uiResource) {
-            set(uiDefaultParentName, hOffset, sOffset, bOffset, aOffset, uiResource);
-        }
-
-        void set (String uiDefaultParentName, float hOffset,
-                        float sOffset, float bOffset, int aOffset,
-                        boolean uiResource) {
-            this.uiDefaultParentName = uiDefaultParentName;
-            this.hOffset = hOffset;
-            this.sOffset = sOffset;
-            this.bOffset = bOffset;
-            this.aOffset = aOffset;
-            this.uiResource = uiResource;
+        return getDerivedColor(null, parentUin,
+                hOffset, sOffset, bOffset, aOffset, uiResource);
+    }
+
+    private DerivedColor getDerivedColor(String uin, String parentUin,
+                                        float hOffset, float sOffset,
+                                        float bOffset, int aOffset,
+                                        boolean uiResource) {
+        DerivedColor color;
+        if (uiResource) {
+            color = new DerivedColor.UIResource(parentUin,
+                    hOffset, sOffset, bOffset, aOffset);
+        } else {
+            color = new DerivedColor(parentUin, hOffset, sOffset,
+                bOffset, aOffset);
+        }
+
+        if (derivedColors.containsKey(color)) {
+            return derivedColors.get(color);
+        } else {
+            derivedColors.put(color, color);
+            color.rederiveColor(); /// move to ARP.decodeColor() ?
+            colorTree.addColor(uin, color);
+            return color;
+        }
+    }
+
+    private Map<DerivedColor, DerivedColor> derivedColors =
+            new HashMap<DerivedColor, DerivedColor>();
+
+    private class ColorTree implements PropertyChangeListener {
+        private Node root = new Node(null, null);
+        private Map<String, Node> nodes = new HashMap<String, Node>();
+
+        public Color getColor(String uin) {
+            return nodes.get(uin).color;
+        }
+
+        public void addColor(String uin, Color color) {
+            Node parent = getParentNode(color);
+            Node node = new Node(color, parent);
+            parent.children.add(node);
+            if (uin != null) {
+                nodes.put(uin, node);
+            }
+        }
+
+        private Node getParentNode(Color color) {
+            Node parent = root;
+            if (color instanceof DerivedColor) {
+                String parentUin = ((DerivedColor)color).getUiDefaultParentName();
+                Node p = nodes.get(parentUin);
+                if (p != null) {
+                    parent = p;
+                }
+            }
+            return parent;
+        }
+
+        public void update() {
+            root.update();
         }
 
         @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof DerivedColorKey)) return false;
-            DerivedColorKey that = (DerivedColorKey) o;
-            if (aOffset != that.aOffset) return false;
-            if (Float.compare(that.bOffset, bOffset) != 0) return false;
-            if (Float.compare(that.hOffset, hOffset) != 0) return false;
-            if (Float.compare(that.sOffset, sOffset) != 0) return false;
-            if (uiDefaultParentName != null ?
-                !uiDefaultParentName.equals(that.uiDefaultParentName) :
-                that.uiDefaultParentName != null) return false;
-            if (this.uiResource != that.uiResource) return false;
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = super.hashCode();
-            result = 31 * result + uiDefaultParentName.hashCode();
-            result = 31 * result + hOffset != +0.0f ?
-                    Float.floatToIntBits(hOffset) : 0;
-            result = 31 * result + sOffset != +0.0f ?
-                    Float.floatToIntBits(sOffset) : 0;
-            result = 31 * result + bOffset != +0.0f ?
-                    Float.floatToIntBits(bOffset) : 0;
-            result = 31 * result + aOffset;
-            result = 31 * result + (uiResource ? 1 : 0);
-            return result;
+        public void propertyChange(PropertyChangeEvent ev) {
+            String name = ev.getPropertyName();
+            Node node = nodes.get(name);
+            if (node != null) {
+                // this is a registered color
+                node.parent.children.remove(node);
+                Color color = (Color) ev.getNewValue();
+                Node parent = getParentNode(color);
+                node.set(color, parent);
+                parent.children.add(node);
+                node.update();
+            }
+        }
+
+        class Node {
+            Color color;
+            Node parent;
+            List<Node> children = new LinkedList<Node>();
+
+            Node(Color color, Node parent) {
+                set(color, parent);
+            }
+
+            public void set(Color color, Node parent) {
+                this.color = color;
+                this.parent = parent;
+            }
+
+            public void update() {
+                if (color instanceof DerivedColor) {
+                    ((DerivedColor)color).rederiveColor();
+                }
+                for (Node child: children) {
+                    child.update();
+                }
+            }
         }
     }
 
@@ -786,49 +801,12 @@ final class ${LAF_NAME}Defaults {
     private class DefaultsListener implements PropertyChangeListener {
         @Override
         public void propertyChange(PropertyChangeEvent evt) {
-            Object src = evt.getSource();
-            String key = evt.getPropertyName();
-            if (key.equals("lookAndFeel")){
+            if ("lookAndFeel".equals(evt.getPropertyName())) {
                 // LAF has been installed, this is the first point at which we
                 // can access our defaults table via UIManager so before now
                 // all derived colors will be incorrect.
                 // First we need to update
-                for (DerivedColor color : derivedColorsMap.values()) {
-                    color.rederiveColor();
-                }
-            } else if (src instanceof DerivedColor && key.equals("rgb")) {
-                // derived color that is in UIManager defaults has changed
-                // update all its dependent colors. Don't worry about doing
-                // this recursively since calling rederiveColor will cause
-                // another PCE to be fired, ending up here and essentially
-                // recursing
-                DerivedColor parentColor = (DerivedColor)src;
-                String parentKey = null;
-                Set<Map.Entry<Object,Object>> entries =
-                        UIManager.getDefaults().entrySet();
-                
-                for (Map.Entry entry : entries) {
-                    Object value = entry.getValue();
-                    if (value == parentColor) {
-                        parentKey = entry.getKey().toString();
-                    }
-                }
-                
-                if (parentKey == null) {
-                    //couldn't find the DerivedColor in the UIDefaults map,
-                    //so we just bail.
-                    return;
-                }
-                
-                for (Map.Entry entry : entries) {
-                    Object value = entry.getValue();
-                    if (value instanceof DerivedColor) {
-                        DerivedColor color = (DerivedColor)entry.getValue();
-                        if (parentKey.equals(color.getUiDefaultParentName())) {
-                            color.rederiveColor();
-                        }
-                    }
-                }
+                colorTree.update();
             }
         }
     }
@@ -875,4 +853,3 @@ final class ${LAF_NAME}Defaults {
         }
     }
 }
-
--- a/src/share/classes/javax/swing/plaf/nimbus/DerivedColor.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/nimbus/DerivedColor.java	Tue Sep 22 01:20:51 2009 -0700
@@ -39,8 +39,6 @@ import java.beans.PropertyChangeListener
  * @author Jasper Potts
  */
 class DerivedColor extends Color {
-    private final PropertyChangeSupport changeSupport =
-            new PropertyChangeSupport(this);
     private final String uiDefaultParentName;
     private final float hOffset, sOffset, bOffset;
     private final int aOffset;
@@ -79,7 +77,6 @@ class DerivedColor extends Color {
      * Recalculate the derived color from the UIManager parent color and offsets
      */
     public void rederiveColor() {
-        int old = argbValue;
         Color src = UIManager.getColor(uiDefaultParentName);
         if (src != null) {
             float[] tmp = Color.RGBtoHSB(src.getRed(), src.getGreen(), src.getBlue(), null);
@@ -97,7 +94,6 @@ class DerivedColor extends Color {
             int alpha = clamp(aOffset);
             argbValue = (Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) & 0xFFFFFF) | (alpha << 24);
         }
-        changeSupport.firePropertyChange("rgb", old, argbValue);
     }
 
     /**
@@ -141,35 +137,6 @@ class DerivedColor extends Color {
         return result;
     }
 
-     /**
-     * Add a PropertyChangeListener to the listener list.
-     * The listener is registered for all properties.
-     * The same listener object may be added more than once, and will be called
-     * as many times as it is added.
-     * If <code>listener</code> is null, no exception is thrown and no action
-     * is taken.
-     *
-     * @param listener  The PropertyChangeListener to be added
-     */
-    public void addPropertyChangeListener(PropertyChangeListener listener) {
-        changeSupport.addPropertyChangeListener(listener);
-    }
-
-    /**
-     * Remove a PropertyChangeListener from the listener list.
-     * This removes a PropertyChangeListener that was registered
-     * for all properties.
-     * If <code>listener</code> was added more than once to the same event
-     * source, it will be notified one less time after being removed.
-     * If <code>listener</code> is null, or was never added, no exception is
-     * thrown and no action is taken.
-     *
-     * @param listener  The PropertyChangeListener to be removed
-     */
-    public void removePropertyChangeListener(PropertyChangeListener listener) {
-        changeSupport.removePropertyChangeListener(listener);
-    }
-
     private float clamp(float value) {
         if (value < 0) {
             value = 0;
@@ -211,5 +178,15 @@ class DerivedColor extends Color {
                    float bOffset, int aOffset) {
             super(uiDefaultParentName, hOffset, sOffset, bOffset, aOffset);
         }
+
+        @Override
+        public boolean equals(Object o) {
+            return (o instanceof UIResource) && super.equals(o);
+        }
+
+        @Override
+        public int hashCode() {
+            return super.hashCode() + 7;
+        }
     }
 }
--- a/src/share/classes/javax/swing/plaf/nimbus/NimbusLookAndFeel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/nimbus/NimbusLookAndFeel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -40,6 +40,9 @@ import java.awt.Graphics2D;
 import java.awt.Graphics2D;
 import java.awt.LayoutManager;
 import java.awt.image.BufferedImage;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.util.*;
 import javax.swing.GrayFilter;
 import javax.swing.Icon;
 import javax.swing.JToolBar;
@@ -87,6 +90,8 @@ public class NimbusLookAndFeel extends S
      */
     private UIDefaults uiDefaults;
 
+    private DefaultsListener defaultsListener = new DefaultsListener();
+
     /**
      * Create a new NimbusLookAndFeel.
      */
@@ -115,8 +120,7 @@ public class NimbusLookAndFeel extends S
         defaults.uninitialize();
         // clear all cached images to free memory
         ImageCache.getInstance().flush();
-        // remove the listeners and things installed by NimbusStyle
-        NimbusStyle.uninitialize();
+        UIManager.getDefaults().removePropertyChangeListener(defaultsListener);
     }
 
     /**
@@ -515,4 +519,62 @@ public class NimbusLookAndFeel extends S
             return obj;
         }
     }
+
+    private Map<String, Map<String, Object>> compiledDefaults = null;
+    private boolean defaultListenerAdded = false;
+
+    static String parsePrefix(String key) {
+        if (key == null) {
+            return null;
+        }
+        boolean inquotes = false;
+        for (int i = 0; i < key.length(); i++) {
+            char c = key.charAt(i);
+            if (c == '"') {
+                inquotes = !inquotes;
+            } else if ((c == '[' || c == '.') && !inquotes) {
+                return key.substring(0, i);
+            }
+        }
+        return null;
+    }
+
+    Map<String, Object> getDefaultsForPrefix(String prefix) {
+        if (compiledDefaults == null) {
+            compiledDefaults = new HashMap<String, Map<String, Object>>();
+            for (Map.Entry<Object, Object> entry: UIManager.getDefaults().entrySet()) {
+                if (entry.getKey() instanceof String) {
+                    addDefault((String) entry.getKey(), entry.getValue());
+                }
+            }
+            if (! defaultListenerAdded) {
+                UIManager.getDefaults().addPropertyChangeListener(defaultsListener);
+                defaultListenerAdded = true;
+            }
+        }
+        return compiledDefaults.get(prefix);
+    }
+
+    private void addDefault(String key, Object value) {
+        String prefix = parsePrefix(key);
+        if (prefix != null) {
+            Map<String, Object> keys = compiledDefaults.get(prefix);
+            if (keys == null) {
+                keys = new HashMap<String, Object>();
+                compiledDefaults.put(prefix, keys);
+            }
+            keys.put(key, value);
+        }
+    }
+
+    private class DefaultsListener implements PropertyChangeListener {
+        @Override public void propertyChange(PropertyChangeEvent ev) {
+            String key = ev.getPropertyName();
+            if ("UIDefaults".equals(key)) {
+                compiledDefaults = null;
+            } else {
+                addDefault(key, ev.getNewValue());
+            }
+        }
+    }
 }
--- a/src/share/classes/javax/swing/plaf/nimbus/NimbusStyle.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/nimbus/NimbusStyle.java	Tue Sep 22 01:20:51 2009 -0700
@@ -26,7 +26,6 @@ package javax.swing.plaf.nimbus;
 
 import javax.swing.Painter;
 
-import java.beans.PropertyChangeEvent;
 import javax.swing.JComponent;
 import javax.swing.UIDefaults;
 import javax.swing.UIManager;
@@ -39,16 +38,13 @@ import java.awt.Color;
 import java.awt.Color;
 import java.awt.Font;
 import java.awt.Insets;
-import java.beans.PropertyChangeListener;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
-import sun.awt.AppContext;
 
 /**
  * <p>A SynthStyle implementation used by Nimbus. Each Region that has been
@@ -232,42 +228,6 @@ public final class NimbusStyle extends S
         super.installDefaults(ctx);
     }
 
-    static String parsePrefix(String key) {
-       if (key == null) return null;
-       boolean inquotes = false;
-       for (int i=0; i<key.length(); i++) {
-           char c = key.charAt(i);
-           if (c == '"') {
-               inquotes = !inquotes;
-           } else if ((c == '[' || c == '.') && !inquotes) {
-               return key.substring(0, i);
-           }
-       }
-       return null;
-    }
-
-    /**
-     * Called by NimbusLookAndFeel when the look and feel is being uninstalled.
-     * Performs general cleanup of any app-context specific data.
-     */
-    static void uninitialize() {
-        // get the appcontext that we've stored data in
-        AppContext ctx = AppContext.getAppContext();
-
-        // get the pcl stored in app context
-        PropertyChangeListener pcl = (PropertyChangeListener)
-                ctx.get("NimbusStyle.defaults.pcl");
-
-        // if the pcl exists, uninstall it from the UIDefaults tables
-        if (pcl != null) {
-            UIManager.getDefaults().removePropertyChangeListener(pcl);
-            UIManager.getLookAndFeelDefaults().removePropertyChangeListener(pcl);
-        }
-
-        // clear out the compiled defaults
-        ctx.put("NimbusStyle.defaults", null);
-    }
-
     /**
      * Pulls data out of UIDefaults, if it has not done so already, and sets
      * up the internal state.
@@ -283,66 +243,9 @@ public final class NimbusStyle extends S
         // any Nimbus.Overrides)
         values = new Values();
 
-        // the profiler revealed that a great deal of CPU time and useless
-        // garbage was being produced by this method and the init method. One
-        // culprit was the creation and reparsing of the entire UIDefaults
-        // map on each call to this method where "values" was null. It turns
-        // out this was happening a lot.
-        // To remove this bottleneck, we store the compiled TreeMaps of defaults
-        // in the appContext for reuse. It is nulled whenever the UIDefaults
-        // changes and recomputed when necessary.
-        final AppContext ctx = AppContext.getAppContext();
-
-        // fetch the defaults from the app context. If null, then create and
-        // store the compiled defaults
-        Map<String, TreeMap<String, Object>> compiledDefaults =
-                (Map<String, TreeMap<String, Object>>)
-                    ctx.get("NimbusStyle.defaults");
-
-        if (compiledDefaults == null) {
-            // the entire UIDefaults tables are parsed and compiled into
-            // this map of maps. The key of the compiledDefaults is the
-            // prefix for each style, while the value is a map of
-            // keys->values for that prefix.
-            compiledDefaults = new HashMap<String, TreeMap<String, Object>>();
-
-            // get all the defaults from UIManager.getDefaults() and put them
-            // into the compiledDefaults
-            compileDefaults(compiledDefaults, UIManager.getDefaults());
-
-            // This second statement pulls defaults from the laf defaults
-            UIDefaults lafDefaults = UIManager.getLookAndFeelDefaults();
-            compileDefaults(compiledDefaults, lafDefaults);
-
-            // if it has not already been done, add a listener to both
-            // UIManager.getDefaults() and UIManager.getLookAndFeelDefaults().
-            PropertyChangeListener pcl = (PropertyChangeListener)
-                    ctx.get("NimbusStyle.defaults.pcl");
-
-            // if pcl is null, then it has not yet been registered with
-            // the UIManager defaults for this app context
-            if (pcl == null) {
-                // create a PCL which will simply clear out the compiled
-                // defaults from the app context, causing it to be recomputed
-                // on subsequent passes
-                pcl = new DefaultsListener();
-                // add the PCL to both defaults tables that we pay attention
-                // to, so that if the UIDefaults are updated, then the
-                // precompiled defaults will be cleared from the app context
-                // and recomputed on subsequent passes
-                UIManager.getDefaults().addPropertyChangeListener(pcl);
-                UIManager.getLookAndFeelDefaults().addPropertyChangeListener(pcl);
-                // save the PCL to the app context as a marker indicating
-                // that the PCL has been registered so we don't end up adding
-                // more than one listener to the UIDefaults tables.
-                ctx.put("NimbusStyle.defaults.pcl", pcl);
-            }
-
-            // store the defaults for reuse
-            ctx.put("NimbusStyle.defaults", compiledDefaults);
-        }
-
-        TreeMap<String, Object> defaults = compiledDefaults.get(prefix);
+        Map<String, Object> defaults =
+                ((NimbusLookAndFeel) UIManager.getLookAndFeel()).
+                        getDefaultsForPrefix(prefix);
 
         // inspect the client properties for the key "Nimbus.Overrides". If the
         // value is an instance of UIDefaults, then these defaults are used
@@ -371,52 +274,6 @@ public final class NimbusStyle extends S
             }
         }
 
-        // Now that I've accumulated all the defaults pertaining to this
-        // style, call init which will read these defaults and configure
-        // the default "values".
-        init(values, defaults);
-    }
-
-    /**
-     * Iterates over all the keys in the specified UIDefaults and compiles
-     * those keys into the comiledDefaults data structure. It relies on
-     * parsing the "prefix" out of the key. If the key is not a String or is
-     * null then it is ignored. In all other cases a prefix is parsed out
-     * (even if that prefix is the empty String or is a "fake" prefix. That
-     * is, suppose you had a key Foo~~MySpecial.KeyThing~~. In this case this
-     * is not a Nimbus formatted key, but we don't care, we treat it as if it
-     * is. This doesn't pose any harm, it will simply never be used).
-     *
-     * @param compiledDefaults
-     * @param d
-     */
-    private void compileDefaults(
-            Map<String, TreeMap<String,Object>> compiledDefaults,
-            UIDefaults d) {
-        for (Object obj : new HashSet(d.keySet())) {
-            if (obj instanceof String) {
-                String key = (String)obj;
-                String kp = parsePrefix(key);
-                if (kp == null) continue;
-                TreeMap<String,Object> map = compiledDefaults.get(kp);
-                if (map == null) {
-                    map = new TreeMap<String,Object>();
-                    compiledDefaults.put(kp, map);
-                }
-                map.put(key, d.get(key));
-            }
-        }
-    }
-
-    /**
-     * Initializes the given <code>Values</code> object with the defaults
-     * contained in the given TreeMap.
-     *
-     * @param v The Values object to be initialized
-     * @param myDefaults a map of UIDefaults to use in initializing the Values.
-     *        This map must contain only keys associated with this Style.
-     */
-    private void init(Values v, TreeMap<String, Object> myDefaults) {
         //a list of the different types of states used by this style. This
         //list may contain only "standard" states (those defined by Synth),
         //or it may contain custom states, or it may contain only "standard"
@@ -433,7 +290,7 @@ public final class NimbusStyle extends S
         //"values" stateTypes to be a non-null array.
         //Otherwise, let the "values" stateTypes be null to indicate that
         //there are no custom states or custom state ordering
-        String statesString = (String)myDefaults.get(prefix + ".States");
+        String statesString = (String)defaults.get(prefix + ".States");
         if (statesString != null) {
             String s[] = statesString.split(",");
             for (int i=0; i<s.length; i++) {
@@ -442,7 +299,7 @@ public final class NimbusStyle extends S
                     //this is a non-standard state name, so look for the
                     //custom state associated with it
                     String stateName = prefix + "." + s[i];
-                    State customState = (State)myDefaults.get(stateName);
+                    State customState = (State)defaults.get(stateName);
                     if (customState != null) {
                         states.add(customState);
                     }
@@ -455,7 +312,7 @@ public final class NimbusStyle extends S
             //to be non-null. Otherwise, leave it null (meaning, use the
             //standard synth states).
             if (states.size() > 0) {
-                v.stateTypes = states.toArray(new State[states.size()]);
+                values.stateTypes = states.toArray(new State[states.size()]);
             }
 
             //assign codes for each of the state types
@@ -490,7 +347,7 @@ public final class NimbusStyle extends S
         }
 
         //Now iterate over all the keys in the defaults table
-        for (String key : myDefaults.keySet()) {
+        for (String key : defaults.keySet()) {
             //The key is something like JButton.Enabled.backgroundPainter,
             //or JButton.States, or JButton.background.
             //Remove the "JButton." portion of the key
@@ -528,11 +385,11 @@ public final class NimbusStyle extends S
                 //otherwise, assume it is a property and install it on the
                 //values object
                 if ("contentMargins".equals(property)) {
-                    v.contentMargins = (Insets)myDefaults.get(key);
+                    values.contentMargins = (Insets)defaults.get(key);
                 } else if ("States".equals(property)) {
                     //ignore
                 } else {
-                    v.defaults.put(property, myDefaults.get(key));
+                    values.defaults.put(property, defaults.get(key));
                 }
             } else {
                 //it is possible that the developer has a malformed UIDefaults
@@ -582,13 +439,13 @@ public final class NimbusStyle extends S
                 //so put it in the UIDefaults associated with that runtime
                 //state
                 if ("backgroundPainter".equals(property)) {
-                    rs.backgroundPainter = (Painter)myDefaults.get(key);
+                    rs.backgroundPainter = getPainter(defaults, key);
                 } else if ("foregroundPainter".equals(property)) {
-                    rs.foregroundPainter = (Painter) myDefaults.get(key);
+                    rs.foregroundPainter = getPainter(defaults, key);
                 } else if ("borderPainter".equals(property)) {
-                    rs.borderPainter = (Painter) myDefaults.get(key);
+                    rs.borderPainter = getPainter(defaults, key);
                 } else {
-                    rs.defaults.put(property, myDefaults.get(key));
+                    rs.defaults.put(property, defaults.get(key));
                 }
             }
         }
@@ -598,7 +455,15 @@ public final class NimbusStyle extends S
         Collections.sort(runtimeStates, STATE_COMPARATOR);
 
         //finally, set the array of runtime states on the values object
-        v.states = runtimeStates.toArray(new RuntimeState[runtimeStates.size()]);
+        values.states = runtimeStates.toArray(new RuntimeState[runtimeStates.size()]);
+    }
+
+    private Painter getPainter(Map<String, Object> defaults, String key) {
+        Object p = defaults.get(key);
+        if (p instanceof UIDefaults.LazyValue) {
+            p = ((UIDefaults.LazyValue)p).createValue(UIManager.getDefaults());
+        }
+        return (p instanceof Painter ? (Painter)p : null);
     }
 
     /**
@@ -1245,15 +1110,4 @@ public final class NimbusStyle extends S
             return hash;
         }
     }
-
-    /**
-     * This listener is used to listen to the UIDefaults tables and clear out
-     * the cached-precompiled map of defaults in that case.
-     */
-    private static final class DefaultsListener implements PropertyChangeListener {
-        @Override
-        public void propertyChange(PropertyChangeEvent evt) {
-            AppContext.getAppContext().put("NimbusStyle.defaults", null);
-        }
-    }
 }
--- a/src/share/classes/javax/swing/plaf/synth/SynthMenuItemLayoutHelper.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/plaf/synth/SynthMenuItemLayoutHelper.java	Tue Sep 22 01:20:51 2009 -0700
@@ -195,7 +195,7 @@ class SynthMenuItemLayoutHelper extends 
                     getHorizontalAlignment(), getVerticalAlignment(),
                     getHorizontalTextPosition(), getVerticalTextPosition(),
                     getViewRect(), iconRect, textRect, getGap());
-            textRect.width += getLeftTextExtraWidth() + getRightTextExtraWidth();
+            textRect.width += getLeftTextExtraWidth();
             Rectangle labelRect = iconRect.union(textRect);
             getLabelSize().setHeight(labelRect.height);
             getLabelSize().setWidth(labelRect.width);
--- a/src/share/classes/javax/swing/text/JTextComponent.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/text/JTextComponent.java	Tue Sep 22 01:20:51 2009 -0700
@@ -2069,8 +2069,9 @@ public abstract class JTextComponent ext
      *   width to match its own
      */
     public boolean getScrollableTracksViewportWidth() {
-        if (getParent() instanceof JViewport) {
-            return (getParent().getWidth() > getPreferredSize().width);
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return port.getWidth() > getPreferredSize().width;
         }
         return false;
     }
@@ -2089,8 +2090,9 @@ public abstract class JTextComponent ext
      *   to match its own
      */
     public boolean getScrollableTracksViewportHeight() {
-        if (getParent() instanceof JViewport) {
-            return (getParent().getHeight() > getPreferredSize().height);
+        JViewport port = SwingUtilities2.getViewport(this);
+        if (port != null) {
+            return (port.getHeight() > getPreferredSize().height);
         }
         return false;
     }
@@ -4813,7 +4815,18 @@ public abstract class JTextComponent ext
                 new AttributedString(text, composedIndex, text.getEndIndex()));
     }
 
-    private boolean saveComposedText(int pos) {
+    /**
+     * Saves composed text around the specified position.
+     *
+     * The composed text (if any) around the specified position is saved
+     * in a backing store and removed from the document.
+     *
+     * @param pos  document position to identify the composed text location
+     * @return  {@code true} if the composed text exists and is saved,
+     *          {@code false} otherwise
+     * @see #restoreComposedText
+     */
+    protected boolean saveComposedText(int pos) {
         if (composedTextExists()) {
             int start = composedTextStart.getOffset();
             int len = composedTextEnd.getOffset() -
@@ -4828,7 +4841,15 @@ public abstract class JTextComponent ext
         return false;
     }
 
-    private void restoreComposedText() {
+    /**
+     * Restores composed text previously saved by {@code saveComposedText}.
+     *
+     * The saved composed text is inserted back into the document. This method
+     * should be invoked only if {@code saveComposedText} returns {@code true}.
+     *
+     * @see #saveComposedText
+     */
+    protected void restoreComposedText() {
         Document doc = getDocument();
         try {
             doc.insertString(caret.getDot(),
--- a/src/share/classes/javax/swing/text/ParagraphView.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/text/ParagraphView.java	Tue Sep 22 01:20:51 2009 -0700
@@ -716,7 +716,7 @@ public class ParagraphView extends FlowV
      * @param axis  the minor axis
      * @param r     the input {@code SizeRequirements} object
      * @return      the new or adjusted {@code SizeRequirements} object
-     * @throw IllegalArgumentException  if the {@code axis} parameter is invalid
+     * @throws IllegalArgumentException  if the {@code axis} parameter is invalid
      */
     @Override
     protected SizeRequirements calculateMinorAxisRequirements(int axis,
--- a/src/share/classes/javax/swing/text/html/ParagraphView.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/text/html/ParagraphView.java	Tue Sep 22 01:20:51 2009 -0700
@@ -150,7 +150,7 @@ public class ParagraphView extends javax
      * @param axis  the minor axis
      * @param r     the input {@code SizeRequirements} object
      * @return      the new or adjusted {@code SizeRequirements} object
-     * @throw IllegalArgumentException  if the {@code axis} parameter is invalid
+     * @throws IllegalArgumentException  if the {@code axis} parameter is invalid
      */
     protected SizeRequirements calculateMinorAxisRequirements(
                                                 int axis, SizeRequirements r) {
--- a/src/share/classes/javax/swing/tree/DefaultTreeSelectionModel.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/javax/swing/tree/DefaultTreeSelectionModel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1067,10 +1067,13 @@ public class DefaultTreeSelectionModel i
     }
 
     /**
-      * Notifies listeners of a change in path. changePaths should contain
-      * instances of PathPlaceHolder.
-      */
-    protected void notifyPathChange(Vector<PathPlaceHolder> changedPaths,
+     * Notifies listeners of a change in path. changePaths should contain
+     * instances of PathPlaceHolder.
+     *
+     * @deprecated As of JDK version 1.7
+     */
+    @Deprecated
+    protected void notifyPathChange(Vector changedPaths,
                                     TreePath oldLeadSelection) {
         int                    cPathCount = changedPaths.size();
         boolean[]              newness = new boolean[cPathCount];
@@ -1078,7 +1081,7 @@ public class DefaultTreeSelectionModel i
         PathPlaceHolder        placeholder;
 
         for(int counter = 0; counter < cPathCount; counter++) {
-            placeholder = changedPaths.elementAt(counter);
+            placeholder = (PathPlaceHolder) changedPaths.elementAt(counter);
             newness[counter] = placeholder.isNew;
             paths[counter] = placeholder.path;
         }
--- a/src/share/classes/sun/io/CharToByteDBCS_ASCII.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/io/CharToByteDBCS_ASCII.java	Tue Sep 22 01:20:51 2009 -0700
@@ -91,7 +91,7 @@ public abstract class CharToByteDBCS_ASC
             }
 
             // Is this a high surrogate?
-            if (Surrogate.isHigh(inputChar)) {
+            if (Character.isHighSurrogate(inputChar)) {
                 // Is this the last character of the input?
                 if (charOff + inputSize >= inEnd) {
                     highHalfZoneCode = inputChar;
@@ -101,7 +101,7 @@ public abstract class CharToByteDBCS_ASC
 
                 // Is there a low surrogate following?
                 inputChar = input[charOff + inputSize];
-                if (Surrogate.isLow(inputChar)) {
+                if (Character.isLowSurrogate(inputChar)) {
                     // We have a valid surrogate pair.  Too bad we don't do
                     // surrogates.  Is substitution enabled?
                     if (subMode) {
@@ -125,7 +125,7 @@ public abstract class CharToByteDBCS_ASC
                  }
             }
             // Is this an unaccompanied low surrogate?
-            else if (Surrogate.isLow(inputChar)) {
+            else if (Character.isLowSurrogate(inputChar)) {
                 badInputLength = 1;
                 throw new MalformedInputException();
             } else {
--- a/src/share/classes/sun/io/CharToByteDBCS_EBCDIC.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/io/CharToByteDBCS_EBCDIC.java	Tue Sep 22 01:20:51 2009 -0700
@@ -108,7 +108,7 @@ public abstract class CharToByteDBCS_EBC
            }
 
            // Is this a high surrogate?
-           if (Surrogate.isHigh(inputChar)) {
+           if (Character.isHighSurrogate(inputChar)) {
               // Is this the last character of the input?
               if (charOff + inputSize >= inEnd) {
                  highHalfZoneCode = inputChar;
@@ -118,7 +118,7 @@ public abstract class CharToByteDBCS_EBC
 
               // Is there a low surrogate following?
               inputChar = input[charOff + inputSize];
-              if (Surrogate.isLow(inputChar)) {
+              if (Character.isLowSurrogate(inputChar)) {
                  // We have a valid surrogate pair.  Too bad we don't do
                  // surrogates.  Is substitution enabled?
                  if (subMode) {
@@ -142,7 +142,7 @@ public abstract class CharToByteDBCS_EBC
               }
            }
            // Is this an unaccompanied low surrogate?
-           else if (Surrogate.isLow(inputChar)) {
+           else if (Character.isLowSurrogate(inputChar)) {
                badInputLength = 1;
                throw new MalformedInputException();
            } else {
--- a/src/share/classes/sun/nio/ch/AsynchronousChannelGroupImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/AsynchronousChannelGroupImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -32,8 +32,8 @@ import java.io.FileDescriptor;
 import java.io.FileDescriptor;
 import java.util.Queue;
 import java.util.concurrent.*;
-import java.util.concurrent.locks.*;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.security.PrivilegedAction;
 import java.security.AccessController;
 import java.security.AccessControlContext;
@@ -65,11 +65,8 @@ abstract class AsynchronousChannelGroupI
     private final Queue<Runnable> taskQueue;
 
     // group shutdown
-    // shutdownLock is RW lock so as to allow for concurrent queuing of tasks
-    // when using a fixed thread pool.
-    private final ReadWriteLock shutdownLock = new ReentrantReadWriteLock();
+    private final AtomicBoolean shutdown = new AtomicBoolean();
     private final Object shutdownNowLock = new Object();
-    private volatile boolean shutdown;
     private volatile boolean terminateInitiated;
 
     AsynchronousChannelGroupImpl(AsynchronousChannelProvider provider,
@@ -214,7 +211,7 @@ abstract class AsynchronousChannelGroupI
 
     @Override
     public final boolean isShutdown() {
-        return shutdown;
+        return shutdown.get();
     }
 
     @Override
@@ -260,17 +257,10 @@ abstract class AsynchronousChannelGroupI
 
     @Override
     public final void shutdown() {
-        shutdownLock.writeLock().lock();
-        try {
-            if (shutdown) {
-                // already shutdown
-                return;
-            }
-            shutdown = true;
-        } finally {
-            shutdownLock.writeLock().unlock();
-        }
-
+        if (shutdown.getAndSet(true)) {
+            // already shutdown
+            return;
+        }
         // if there are channels in the group then shutdown will continue
         // when the last channel is closed
         if (!isEmpty()) {
@@ -289,12 +279,7 @@ abstract class AsynchronousChannelGroupI
 
     @Override
     public final void shutdownNow() throws IOException {
-        shutdownLock.writeLock().lock();
-        try {
-            shutdown = true;
-        } finally {
-            shutdownLock.writeLock().unlock();
-        }
+        shutdown.set(true);
         synchronized (shutdownNowLock) {
             if (!terminateInitiated) {
                 terminateInitiated = true;
@@ -303,6 +288,18 @@ abstract class AsynchronousChannelGroupI
                 shutdownExecutors();
             }
         }
+    }
+
+    /**
+     * For use by AsynchronousFileChannel to release resources without shutting
+     * down the thread pool.
+     */
+    final void detachFromThreadPool() {
+        if (shutdown.getAndSet(true))
+            throw new AssertionError("Already shutdown");
+        if (!isEmpty())
+            throw new AssertionError("Group not empty");
+        shutdownHandlerTasks();
     }
 
     @Override
--- a/src/share/classes/sun/nio/ch/AsynchronousFileChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/AsynchronousFileChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -25,8 +25,10 @@
 
 package sun.nio.ch;
 
+import java.nio.ByteBuffer;
 import java.nio.channels.*;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import java.util.concurrent.locks.*;
 import java.io.FileDescriptor;
 import java.io.IOException;
@@ -100,6 +102,33 @@ abstract class AsynchronousFileChannelIm
     }
 
     // -- file locking --
+
+    abstract <A> Future<FileLock> implLock(long position,
+                                           long size,
+                                           boolean shared,
+                                           A attachment,
+                                           CompletionHandler<FileLock,? super A> handler);
+
+    @Override
+    public final Future<FileLock> lock(long position,
+                                       long size,
+                                       boolean shared)
+
+    {
+        return implLock(position, size, shared, null, null);
+    }
+
+    @Override
+    public final <A> void lock(long position,
+                               long size,
+                               boolean shared,
+                               A attachment,
+                               CompletionHandler<FileLock,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implLock(position, size, shared, attachment, handler);
+    }
 
     private volatile FileLockTable fileLockTable;
 
@@ -175,4 +204,50 @@ abstract class AsynchronousFileChannelIm
             end();
         }
     }
+
+
+    // -- reading and writing --
+
+    abstract <A> Future<Integer> implRead(ByteBuffer dst,
+                                         long position,
+                                         A attachment,
+                                         CompletionHandler<Integer,? super A> handler);
+
+    @Override
+    public final Future<Integer> read(ByteBuffer dst, long position) {
+        return implRead(dst, position, null, null);
+    }
+
+    @Override
+    public final <A> void read(ByteBuffer dst,
+                               long position,
+                               A attachment,
+                               CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implRead(dst, position, attachment, handler);
+    }
+
+    abstract <A> Future<Integer> implWrite(ByteBuffer src,
+                                           long position,
+                                           A attachment,
+                                           CompletionHandler<Integer,? super A> handler);
+
+
+    @Override
+    public final Future<Integer> write(ByteBuffer src, long position) {
+        return implWrite(src, position, null, null);
+    }
+
+    @Override
+    public final <A> void write(ByteBuffer src,
+                                long position,
+                                A attachment,
+                                CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implWrite(src, position, attachment, handler);
+    }
 }
--- a/src/share/classes/sun/nio/ch/AsynchronousServerSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/AsynchronousServerSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -35,6 +35,7 @@ import java.util.Set;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
+import java.util.concurrent.Future;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import sun.net.NetHooks;
@@ -106,6 +107,29 @@ abstract class AsynchronousServerSocketC
             closeLock.writeLock().unlock();
         }
         implClose();
+    }
+
+    /**
+     * Invoked by accept to accept connection
+     */
+    abstract Future<AsynchronousSocketChannel>
+        implAccept(Object attachment,
+                   CompletionHandler<AsynchronousSocketChannel,Object> handler);
+
+
+    @Override
+    public final Future<AsynchronousSocketChannel> accept() {
+        return implAccept(null, null);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public final <A> void accept(A attachment,
+                                 CompletionHandler<AsynchronousSocketChannel,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implAccept(attachment, (CompletionHandler<AsynchronousSocketChannel,Object>)handler);
     }
 
     final boolean isAcceptKilled() {
--- a/src/share/classes/sun/nio/ch/AsynchronousSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/AsynchronousSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -184,28 +184,53 @@ abstract class AsynchronousSocketChannel
     }
 
     /**
+     * Invoked by connect to initiate the connect operation.
+     */
+    abstract <A> Future<Void> implConnect(SocketAddress remote,
+                                          A attachment,
+                                          CompletionHandler<Void,? super A> handler);
+
+    @Override
+    public final Future<Void> connect(SocketAddress remote) {
+        return implConnect(remote, null, null);
+    }
+
+    @Override
+    public final <A> void connect(SocketAddress remote,
+                                  A attachment,
+                                  CompletionHandler<Void,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implConnect(remote, attachment, handler);
+    }
+
+    /**
      * Invoked by read to initiate the I/O operation.
      */
-    abstract <V extends Number,A> Future<V> readImpl(ByteBuffer[] dsts,
-                                                     boolean isScatteringRead,
+    abstract <V extends Number,A> Future<V> implRead(boolean isScatteringRead,
+                                                     ByteBuffer dst,
+                                                     ByteBuffer[] dsts,
                                                      long timeout,
                                                      TimeUnit unit,
                                                      A attachment,
                                                      CompletionHandler<V,? super A> handler);
 
     @SuppressWarnings("unchecked")
-    private <V extends Number,A> Future<V> read(ByteBuffer[] dsts,
-                                                boolean isScatteringRead,
+    private <V extends Number,A> Future<V> read(boolean isScatteringRead,
+                                                ByteBuffer dst,
+                                                ByteBuffer[] dsts,
                                                 long timeout,
                                                 TimeUnit unit,
-                                                A attachment,
+                                                A att,
                                                 CompletionHandler<V,? super A> handler)
     {
         if (!isOpen()) {
-            CompletedFuture<V,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable e = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(e);
+            Invoker.invoke(this, handler, att, null, e);
+            return null;
         }
 
         if (remoteAddress == null)
@@ -213,13 +238,13 @@ abstract class AsynchronousSocketChannel
         if (timeout < 0L)
             throw new IllegalArgumentException("Negative timeout");
 
-        boolean hasSpaceToRead = isScatteringRead || dsts[0].hasRemaining();
+        boolean hasSpaceToRead = isScatteringRead || dst.hasRemaining();
         boolean shutdown = false;
 
         // check and update state
         synchronized (readLock) {
             if (readKilled)
-                throw new RuntimeException("Reading not allowed due to timeout or cancellation");
+                throw new IllegalStateException("Reading not allowed due to timeout or cancellation");
             if (reading)
                 throw new ReadPendingException();
             if (readShutdown) {
@@ -234,44 +259,53 @@ abstract class AsynchronousSocketChannel
         // immediately complete with -1 if shutdown for read
         // immediately complete with 0 if no space remaining
         if (shutdown || !hasSpaceToRead) {
-            CompletedFuture<V,A> result;
+            Number result;
             if (isScatteringRead) {
-                Long value = (shutdown) ? Long.valueOf(-1L) : Long.valueOf(0L);
-                result = (CompletedFuture<V,A>)CompletedFuture.withResult(this, value, attachment);
+                result = (shutdown) ? Long.valueOf(-1L) : Long.valueOf(0L);
             } else {
-                int value = (shutdown) ? -1 : 0;
-                result = (CompletedFuture<V,A>)CompletedFuture.withResult(this, value, attachment);
-            }
-            Invoker.invoke(handler, result);
-            return result;
-        }
-
-        return readImpl(dsts, isScatteringRead, timeout, unit, attachment, handler);
-    }
-
-    @Override
-    public final <A> Future<Integer> read(ByteBuffer dst,
-                                          long timeout,
-                                          TimeUnit unit,
-                                          A attachment,
-                                          CompletionHandler<Integer,? super A> handler)
-    {
+                result = (shutdown) ? -1 : 0;
+            }
+            if (handler == null)
+                return CompletedFuture.withResult((V)result);
+            Invoker.invoke(this, handler, att, (V)result, null);
+            return null;
+        }
+
+        return implRead(isScatteringRead, dst, dsts, timeout, unit, att, handler);
+    }
+
+    @Override
+    public final Future<Integer> read(ByteBuffer dst) {
         if (dst.isReadOnly())
             throw new IllegalArgumentException("Read-only buffer");
-        ByteBuffer[] bufs = new ByteBuffer[1];
-        bufs[0] = dst;
-        return read(bufs, false, timeout, unit, attachment, handler);
-    }
-
-    @Override
-    public final <A> Future<Long> read(ByteBuffer[] dsts,
-                                       int offset,
-                                       int length,
-                                       long timeout,
-                                       TimeUnit unit,
-                                       A attachment,
-                                       CompletionHandler<Long,? super A> handler)
-    {
+        return read(false, dst, null, 0L, TimeUnit.MILLISECONDS, null, null);
+    }
+
+    @Override
+    public final <A> void read(ByteBuffer dst,
+                               long timeout,
+                               TimeUnit unit,
+                               A attachment,
+                               CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        if (dst.isReadOnly())
+            throw new IllegalArgumentException("Read-only buffer");
+        read(false, dst, null, timeout, unit, attachment, handler);
+    }
+
+    @Override
+    public final <A> void read(ByteBuffer[] dsts,
+                               int offset,
+                               int length,
+                               long timeout,
+                               TimeUnit unit,
+                               A attachment,
+                               CompletionHandler<Long,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
         if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
             throw new IndexOutOfBoundsException();
         ByteBuffer[] bufs = Util.subsequence(dsts, offset, length);
@@ -279,39 +313,41 @@ abstract class AsynchronousSocketChannel
             if (bufs[i].isReadOnly())
                 throw new IllegalArgumentException("Read-only buffer");
         }
-        return read(bufs, true, timeout, unit, attachment, handler);
+        read(true, null, bufs, timeout, unit, attachment, handler);
     }
 
     /**
      * Invoked by write to initiate the I/O operation.
      */
-    abstract <V extends Number,A> Future<V> writeImpl(ByteBuffer[] srcs,
-                                                      boolean isGatheringWrite,
+    abstract <V extends Number,A> Future<V> implWrite(boolean isGatheringWrite,
+                                                      ByteBuffer src,
+                                                      ByteBuffer[] srcs,
                                                       long timeout,
                                                       TimeUnit unit,
                                                       A attachment,
                                                       CompletionHandler<V,? super A> handler);
 
     @SuppressWarnings("unchecked")
-    private <V extends Number,A> Future<V> write(ByteBuffer[] srcs,
-                                                 boolean isGatheringWrite,
+    private <V extends Number,A> Future<V> write(boolean isGatheringWrite,
+                                                 ByteBuffer src,
+                                                 ByteBuffer[] srcs,
                                                  long timeout,
                                                  TimeUnit unit,
-                                                 A attachment,
+                                                 A att,
                                                  CompletionHandler<V,? super A> handler)
     {
-        boolean hasDataToWrite = isGatheringWrite || srcs[0].hasRemaining();
+        boolean hasDataToWrite = isGatheringWrite || src.hasRemaining();
 
         boolean closed = false;
         if (isOpen()) {
             if (remoteAddress == null)
                 throw new NotYetConnectedException();
-            if (timeout < 0L)
+             if (timeout < 0L)
                 throw new IllegalArgumentException("Negative timeout");
             // check and update state
             synchronized (writeLock) {
                 if (writeKilled)
-                    throw new RuntimeException("Writing not allowed due to timeout or cancellation");
+                    throw new IllegalStateException("Writing not allowed due to timeout or cancellation");
                 if (writing)
                     throw new WritePendingException();
                 if (writeShutdown) {
@@ -327,52 +363,57 @@ abstract class AsynchronousSocketChannel
 
         // channel is closed or shutdown for write
         if (closed) {
-            CompletedFuture<V,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable e = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(e);
+            Invoker.invoke(this, handler, att, null, e);
+            return null;
         }
 
         // nothing to write so complete immediately
         if (!hasDataToWrite) {
-            CompletedFuture<V,A> result;
-            if (isGatheringWrite) {
-                result = (CompletedFuture<V,A>)CompletedFuture.withResult(this, 0L, attachment);
-            } else {
-                result = (CompletedFuture<V,A>)CompletedFuture.withResult(this, 0, attachment);
-            }
-            Invoker.invoke(handler, result);
-            return result;
-        }
-
-        return writeImpl(srcs, isGatheringWrite, timeout, unit, attachment, handler);
-    }
-
-    @Override
-    public final <A> Future<Integer> write(ByteBuffer src,
-                                           long timeout,
-                                           TimeUnit unit,
-                                           A attachment,
-                                           CompletionHandler<Integer,? super A> handler)
-    {
-        ByteBuffer[] bufs = new ByteBuffer[1];
-        bufs[0] = src;
-        return write(bufs, false, timeout, unit, attachment, handler);
-    }
-
-    @Override
-    public final <A> Future<Long> write(ByteBuffer[] srcs,
-                                        int offset,
-                                        int length,
-                                        long timeout,
-                                        TimeUnit unit,
-                                        A attachment,
-                                        CompletionHandler<Long,? super A> handler)
-    {
+            Number result = (isGatheringWrite) ? (Number)0L : (Number)0;
+            if (handler == null)
+                return CompletedFuture.withResult((V)result);
+            Invoker.invoke(this, handler, att, (V)result, null);
+            return null;
+        }
+
+        return implWrite(isGatheringWrite, src, srcs, timeout, unit, att, handler);
+    }
+
+    @Override
+    public final Future<Integer> write(ByteBuffer src) {
+        return write(false, src, null, 0L, TimeUnit.MILLISECONDS, null, null);
+    }
+
+    @Override
+    public final <A> void write(ByteBuffer src,
+                                long timeout,
+                                TimeUnit unit,
+                                A attachment,
+                                CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        write(false, src, null, timeout, unit, attachment, handler);
+    }
+
+    @Override
+    public final <A> void  write(ByteBuffer[] srcs,
+                                 int offset,
+                                 int length,
+                                 long timeout,
+                                 TimeUnit unit,
+                                 A attachment,
+                                 CompletionHandler<Long,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
         if ((offset < 0) || (length < 0) || (offset > srcs.length - length))
             throw new IndexOutOfBoundsException();
         srcs = Util.subsequence(srcs, offset, length);
-        return write(srcs, true, timeout, unit, attachment, handler);
+        write(true, null, srcs, timeout, unit, attachment, handler);
     }
 
     @Override
@@ -461,7 +502,6 @@ abstract class AsynchronousSocketChannel
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public final SocketAddress getRemoteAddress() throws IOException {
         if (!isOpen())
             throw new ClosedChannelException();
--- a/src/share/classes/sun/nio/ch/CompletedFuture.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/CompletedFuture.java	Tue Sep 22 01:20:51 2009 -0700
@@ -25,7 +25,7 @@
 
 package sun.nio.ch;
 
-import java.nio.channels.AsynchronousChannel;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.ExecutionException;
 import java.io.IOException;
@@ -35,39 +35,35 @@ import java.io.IOException;
  * completed.
  */
 
-final class CompletedFuture<V,A>
-    extends AbstractFuture<V,A>
-{
+final class CompletedFuture<V> implements Future<V> {
     private final V result;
     private final Throwable exc;
 
-    private CompletedFuture(AsynchronousChannel channel,
-                            V result,
-                            Throwable exc,
-                            A attachment)
-    {
-        super(channel, attachment);
+    private CompletedFuture(V result, Throwable exc) {
         this.result = result;
         this.exc = exc;
     }
 
     @SuppressWarnings("unchecked")
-    static <V,A> CompletedFuture<V,A> withResult(AsynchronousChannel channel,
-                                                 V result,
-                                                 A attachment)
-    {
-        return new CompletedFuture<V,A>(channel, result, null, attachment);
+    static <V> CompletedFuture<V> withResult(V result) {
+        return new CompletedFuture<V>(result, null);
     }
 
     @SuppressWarnings("unchecked")
-    static <V,A> CompletedFuture<V,A> withFailure(AsynchronousChannel channel,
-                                                  Throwable exc,
-                                                  A attachment)
-    {
+    static <V> CompletedFuture<V> withFailure(Throwable exc) {
         // exception must be IOException or SecurityException
         if (!(exc instanceof IOException) && !(exc instanceof SecurityException))
             exc = new IOException(exc);
-        return new CompletedFuture(channel, null, exc, attachment);
+        return new CompletedFuture(null, exc);
+    }
+
+    @SuppressWarnings("unchecked")
+    static <V> CompletedFuture<V> withResult(V result, Throwable exc) {
+        if (exc == null) {
+            return withResult(result);
+        } else {
+            return withFailure(exc);
+        }
     }
 
     @Override
@@ -100,14 +96,4 @@ final class CompletedFuture<V,A>
     public boolean cancel(boolean mayInterruptIfRunning) {
         return false;
     }
-
-    @Override
-    Throwable exception() {
-        return exc;
-    }
-
-    @Override
-    V value() {
-        return result;
-    }
 }
--- a/src/share/classes/sun/nio/ch/Invoker.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/Invoker.java	Tue Sep 22 01:20:51 2009 -0700
@@ -117,33 +117,32 @@ class Invoker {
      * Invoke handler without checking the thread identity or number of handlers
      * on the thread stack.
      */
-    @SuppressWarnings("unchecked")
     static <V,A> void invokeUnchecked(CompletionHandler<V,? super A> handler,
-                                      AbstractFuture<V,A> result)
-    {
-        if (handler != null && !result.isCancelled()) {
-            Throwable exc = result.exception();
-            if (exc == null) {
-                handler.completed(result.value(), result.attachment());
-            } else {
-                handler.failed(exc, result.attachment());
-            }
-
-            // clear interrupt
-            Thread.interrupted();
-        }
-    }
-
-
-    /**
-     * Invoke handler after incrementing the invoke count.
+                                      A attachment,
+                                      V value,
+                                      Throwable exc)
+    {
+        if (exc == null) {
+            handler.completed(value, attachment);
+        } else {
+            handler.failed(exc, attachment);
+        }
+
+        // clear interrupt
+        Thread.interrupted();
+    }
+
+    /**
+     * Invoke handler assuming thread identity already checked
      */
     static <V,A> void invokeDirect(GroupAndInvokeCount myGroupAndInvokeCount,
                                    CompletionHandler<V,? super A> handler,
-                                   AbstractFuture<V,A> result)
+                                   A attachment,
+                                   V result,
+                                   Throwable exc)
     {
         myGroupAndInvokeCount.incrementInvokeCount();
-        invokeUnchecked(handler, result);
+        Invoker.invokeUnchecked(handler, attachment, result, exc);
     }
 
     /**
@@ -151,84 +150,84 @@ class Invoker {
      * thread pool then the handler is invoked directly, otherwise it is
      * invoked indirectly.
      */
-    static <V,A> void invoke(CompletionHandler<V,? super A> handler,
-                             AbstractFuture<V,A> result)
-    {
-        if (handler != null) {
-            boolean invokeDirect = false;
-            boolean identityOkay = false;
-            GroupAndInvokeCount thisGroupAndInvokeCount = myGroupAndInvokeCount.get();
-            if (thisGroupAndInvokeCount != null) {
-                AsynchronousChannel channel = result.channel();
-                if ((thisGroupAndInvokeCount.group() == ((Groupable)channel).group()))
-                    identityOkay = true;
-                if (identityOkay &&
-                    (thisGroupAndInvokeCount.invokeCount() < maxHandlerInvokeCount))
-                {
-                    // group match
-                    invokeDirect = true;
+    static <V,A> void invoke(AsynchronousChannel channel,
+                             CompletionHandler<V,? super A> handler,
+                             A attachment,
+                             V result,
+                             Throwable exc)
+    {
+        boolean invokeDirect = false;
+        boolean identityOkay = false;
+        GroupAndInvokeCount thisGroupAndInvokeCount = myGroupAndInvokeCount.get();
+        if (thisGroupAndInvokeCount != null) {
+            if ((thisGroupAndInvokeCount.group() == ((Groupable)channel).group()))
+                identityOkay = true;
+            if (identityOkay &&
+                (thisGroupAndInvokeCount.invokeCount() < maxHandlerInvokeCount))
+            {
+                // group match
+                invokeDirect = true;
+            }
+        }
+        if (invokeDirect) {
+            invokeDirect(thisGroupAndInvokeCount, handler, attachment, result, exc);
+        } else {
+            try {
+                invokeIndirectly(channel, handler, attachment, result, exc);
+            } catch (RejectedExecutionException ree) {
+                // channel group shutdown; fallback to invoking directly
+                // if the current thread has the right identity.
+                if (identityOkay) {
+                    invokeDirect(thisGroupAndInvokeCount,
+                                 handler, attachment, result, exc);
+                } else {
+                    throw new ShutdownChannelGroupException();
                 }
             }
-            if (invokeDirect) {
-                thisGroupAndInvokeCount.incrementInvokeCount();
-                invokeUnchecked(handler, result);
-            } else {
-                try {
-                    invokeIndirectly(handler, result);
-                } catch (RejectedExecutionException ree) {
-                    // channel group shutdown; fallback to invoking directly
-                    // if the current thread has the right identity.
-                    if (identityOkay) {
-                        invokeUnchecked(handler, result);
-                    } else {
-                        throw new ShutdownChannelGroupException();
-                    }
+        }
+    }
+
+    /**
+     * Invokes the handler indirectly via the channel group's thread pool.
+     */
+    static <V,A> void invokeIndirectly(AsynchronousChannel channel,
+                                       final CompletionHandler<V,? super A> handler,
+                                       final A attachment,
+                                       final V result,
+                                       final Throwable exc)
+    {
+        try {
+            ((Groupable)channel).group().executeOnPooledThread(new Runnable() {
+                public void run() {
+                    GroupAndInvokeCount thisGroupAndInvokeCount =
+                        myGroupAndInvokeCount.get();
+                    if (thisGroupAndInvokeCount != null)
+                        thisGroupAndInvokeCount.setInvokeCount(1);
+                    invokeUnchecked(handler, attachment, result, exc);
                 }
-            }
-        }
-    }
-
-    /**
-     * Invokes the handler "indirectly" in the channel group's thread pool.
+            });
+        } catch (RejectedExecutionException ree) {
+            throw new ShutdownChannelGroupException();
+        }
+    }
+
+    /**
+     * Invokes the handler "indirectly" in the given Executor
      */
     static <V,A> void invokeIndirectly(final CompletionHandler<V,? super A> handler,
-                                       final AbstractFuture<V,A> result)
-    {
-        if (handler != null) {
-            AsynchronousChannel channel = result.channel();
-            try {
-                ((Groupable)channel).group().executeOnPooledThread(new Runnable() {
-                    public void run() {
-                        GroupAndInvokeCount thisGroupAndInvokeCount =
-                            myGroupAndInvokeCount.get();
-                        if (thisGroupAndInvokeCount != null)
-                            thisGroupAndInvokeCount.setInvokeCount(1);
-                        invokeUnchecked(handler, result);
-                    }
-                });
-            } catch (RejectedExecutionException ree) {
-                throw new ShutdownChannelGroupException();
-            }
-        }
-    }
-
-    /**
-     * Invokes the handler "indirectly" in the given Executor
-     */
-    static <V,A> void invokeIndirectly(final CompletionHandler<V,? super A> handler,
-                                       final AbstractFuture<V,A> result,
+                                       final A attachment,
+                                       final V value,
+                                       final Throwable exc,
                                        Executor executor)
     {
-        if (handler != null) {
-            try {
-                executor.execute(new Runnable() {
-                    public void run() {
-                        invokeUnchecked(handler, result);
-                    }
-                });
-            } catch (RejectedExecutionException ree) {
-                throw new ShutdownChannelGroupException();
-            }
+         try {
+            executor.execute(new Runnable() {
+                public void run() {
+                    invokeUnchecked(handler, attachment, value, exc);
+                }
+            });
+        } catch (RejectedExecutionException ree) {
+            throw new ShutdownChannelGroupException();
         }
     }
 
@@ -258,4 +257,52 @@ class Invoker {
             throw new ShutdownChannelGroupException();
         }
     }
+
+    /**
+     * Invoke handler with completed result. This method does not check the
+     * thread identity or the number of handlers on the thread stack.
+     */
+    static <V,A> void invokeUnchecked(PendingFuture<V,A> future) {
+        assert future.isDone();
+        CompletionHandler<V,? super A> handler = future.handler();
+        if (handler != null) {
+            invokeUnchecked(handler,
+                            future.attachment(),
+                            future.value(),
+                            future.exception());
+        }
+    }
+
+    /**
+     * Invoke handler with completed result. If the current thread is in the
+     * channel group's thread pool then the handler is invoked directly,
+     * otherwise it is invoked indirectly.
+     */
+    static <V,A> void invoke(PendingFuture<V,A> future) {
+        assert future.isDone();
+        CompletionHandler<V,? super A> handler = future.handler();
+        if (handler != null) {
+            invoke(future.channel(),
+                   handler,
+                   future.attachment(),
+                   future.value(),
+                   future.exception());
+        }
+    }
+
+    /**
+     * Invoke handler with completed result. The handler is invoked indirectly,
+     * via the channel group's thread pool.
+     */
+    static <V,A> void invokeIndirectly(PendingFuture<V,A> future) {
+        assert future.isDone();
+        CompletionHandler<V,? super A> handler = future.handler();
+        if (handler != null) {
+            invokeIndirectly(future.channel(),
+                             handler,
+                             future.attachment(),
+                             future.value(),
+                             future.exception());
+        }
+    }
 }
--- a/src/share/classes/sun/nio/ch/PendingFuture.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/PendingFuture.java	Tue Sep 22 01:20:51 2009 -0700
@@ -34,13 +34,13 @@ import java.io.IOException;
  * attachment of an additional arbitrary context object and a timer task.
  */
 
-final class PendingFuture<V,A>
-    extends AbstractFuture<V,A>
-{
+final class PendingFuture<V,A> implements Future<V> {
     private static final CancellationException CANCELLED =
         new CancellationException();
 
+    private final AsynchronousChannel channel;
     private final CompletionHandler<V,? super A> handler;
+    private final A attachment;
 
     // true if result (or exception) is available
     private volatile boolean haveResult;
@@ -56,14 +56,14 @@ final class PendingFuture<V,A>
     // optional context object
     private volatile Object context;
 
-
     PendingFuture(AsynchronousChannel channel,
                   CompletionHandler<V,? super A> handler,
                   A attachment,
                   Object context)
     {
-        super(channel, attachment);
+        this.channel = channel;
         this.handler = handler;
+        this.attachment = attachment;
         this.context = context;
     }
 
@@ -71,12 +71,29 @@ final class PendingFuture<V,A>
                   CompletionHandler<V,? super A> handler,
                   A attachment)
     {
-        super(channel, attachment);
+        this.channel = channel;
         this.handler = handler;
+        this.attachment = attachment;
+    }
+
+    PendingFuture(AsynchronousChannel channel) {
+        this(channel, null, null);
+    }
+
+    PendingFuture(AsynchronousChannel channel, Object context) {
+        this(channel, null, null, context);
+    }
+
+    AsynchronousChannel channel() {
+        return channel;
     }
 
     CompletionHandler<V,? super A> handler() {
         return handler;
+    }
+
+    A attachment() {
+        return attachment;
     }
 
     void setContext(Object context) {
@@ -113,36 +130,45 @@ final class PendingFuture<V,A>
     /**
      * Sets the result, or a no-op if the result or exception is already set.
      */
-    boolean setResult(V res) {
-        synchronized (this) {
-            if (haveResult)
-                return false;
+    void setResult(V res) {
+        synchronized (this) {
+            if (haveResult)
+                return;
             result = res;
             haveResult = true;
             if (timeoutTask != null)
                 timeoutTask.cancel(false);
             if (latch != null)
                 latch.countDown();
-            return true;
         }
     }
 
     /**
      * Sets the result, or a no-op if the result or exception is already set.
      */
-    boolean setFailure(Throwable x) {
+    void setFailure(Throwable x) {
         if (!(x instanceof IOException) && !(x instanceof SecurityException))
             x = new IOException(x);
         synchronized (this) {
             if (haveResult)
-                return false;
+                return;
             exc = x;
             haveResult = true;
             if (timeoutTask != null)
                 timeoutTask.cancel(false);
             if (latch != null)
                 latch.countDown();
-            return true;
+        }
+    }
+
+    /**
+     * Sets the result
+     */
+    void setResult(V res, Throwable x) {
+        if (x == null) {
+            setResult(res);
+        } else {
+            setFailure(x);
         }
     }
 
@@ -178,12 +204,10 @@ final class PendingFuture<V,A>
         return result;
     }
 
-    @Override
     Throwable exception() {
         return (exc != CANCELLED) ? exc : null;
     }
 
-    @Override
     V value() {
         return result;
     }
@@ -203,33 +227,6 @@ final class PendingFuture<V,A>
         synchronized (this) {
             if (haveResult)
                 return false;    // already completed
-
-            // A shutdown of the channel group will close all channels and
-            // shutdown the executor. To ensure that the completion handler
-            // is executed we queue the task while holding the lock.
-            if (handler != null) {
-                prepareForWait();
-                Runnable cancelTask = new Runnable() {
-                    public void run() {
-                        while (!haveResult) {
-                            try {
-                                latch.await();
-                            } catch (InterruptedException ignore) { }
-                        }
-                        handler.cancelled(attachment());
-                    }
-                };
-                AsynchronousChannel ch = channel();
-                if (ch instanceof Groupable) {
-                    ((Groupable)ch).group().executeOnPooledThread(cancelTask);
-                } else {
-                    if (ch instanceof AsynchronousFileChannelImpl) {
-                        ((AsynchronousFileChannelImpl)ch).executor().execute(cancelTask);
-                    } else {
-                        throw new AssertionError("Should not get here");
-                    }
-                }
-            }
 
             // notify channel
             if (channel() instanceof Cancellable)
@@ -249,7 +246,7 @@ final class PendingFuture<V,A>
             } catch (IOException ignore) { }
         }
 
-        // release waiters (this also releases the invoker)
+        // release waiters
         if (latch != null)
             latch.countDown();
         return true;
--- a/src/share/classes/sun/nio/ch/SimpleAsynchronousDatagramChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/SimpleAsynchronousDatagramChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -317,51 +317,71 @@ class SimpleAsynchronousDatagramChannelI
         return new WrappedMembershipKey(this, key);
     }
 
-    @Override
-    public <A> Future<Integer> send(ByteBuffer src,
-                                    SocketAddress target,
-                                    long timeout,
-                                    TimeUnit unit,
-                                    A attachment,
-                                    CompletionHandler<Integer,? super A> handler)
-    {
-        if (timeout < 0L)
-            throw new IllegalArgumentException("Negative timeout");
-        if (unit == null)
-            throw new NullPointerException();
-
-        CompletedFuture<Integer,A> result;
+    private <A> Future<Integer> implSend(ByteBuffer src,
+                                         SocketAddress target,
+                                         A attachment,
+                                         CompletionHandler<Integer,? super A> handler)
+    {
+        int n = 0;
+        Throwable exc = null;
         try {
-            int n = dc.send(src, target);
-            result = CompletedFuture.withResult(this, n, attachment);
+            n = dc.send(src, target);
         } catch (IOException ioe) {
-            result = CompletedFuture.withFailure(this, ioe, attachment);
-        }
-        Invoker.invoke(handler, result);
-        return result;
-    }
-
-    @Override
-    public <A> Future<Integer> write(ByteBuffer src,
-                                     long timeout,
-                                     TimeUnit unit,
-                                     A attachment,
-                                     CompletionHandler<Integer,? super A> handler)
-    {
-        if (timeout < 0L)
-            throw new IllegalArgumentException("Negative timeout");
-        if (unit == null)
-            throw new NullPointerException();
-
-        CompletedFuture<Integer,A> result;
+            exc = ioe;
+        }
+        if (handler == null)
+            return CompletedFuture.withResult(n, exc);
+        Invoker.invoke(this, handler, attachment, n, exc);
+        return null;
+    }
+
+    @Override
+    public Future<Integer> send(ByteBuffer src, SocketAddress target) {
+        return implSend(src, target, null, null);
+    }
+
+    @Override
+    public <A> void send(ByteBuffer src,
+                         SocketAddress target,
+                         A attachment,
+                         CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implSend(src, target, attachment, handler);
+    }
+
+    private <A> Future<Integer> implWrite(ByteBuffer src,
+                                          A attachment,
+                                          CompletionHandler<Integer,? super A> handler)
+    {
+        int n = 0;
+        Throwable exc = null;
         try {
-            int n = dc.write(src);
-            result = CompletedFuture.withResult(this, n, attachment);
+            n = dc.write(src);
         } catch (IOException ioe) {
-            result = CompletedFuture.withFailure(this, ioe, attachment);
-        }
-        Invoker.invoke(handler, result);
-        return result;
+            exc = ioe;
+        }
+        if (handler == null)
+            return CompletedFuture.withResult(n, exc);
+        Invoker.invoke(this, handler, attachment, n, exc);
+        return null;
+
+    }
+
+    @Override
+    public Future<Integer> write(ByteBuffer src) {
+        return implWrite(src, null, null);
+    }
+
+    @Override
+    public <A> void write(ByteBuffer src,
+                          A attachment,
+                          CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implWrite(src, attachment, handler);
     }
 
     /**
@@ -390,12 +410,11 @@ class SimpleAsynchronousDatagramChannelI
         }
     }
 
-    @Override
-    public <A> Future<SocketAddress> receive(final ByteBuffer dst,
-                                             final long timeout,
-                                             final TimeUnit unit,
-                                             A attachment,
-                                             final CompletionHandler<SocketAddress,? super A> handler)
+    private <A> Future<SocketAddress> implReceive(final ByteBuffer dst,
+                                                  final long timeout,
+                                                  final TimeUnit unit,
+                                                  A attachment,
+                                                  final CompletionHandler<SocketAddress,? super A> handler)
     {
         if (dst.isReadOnly())
             throw new IllegalArgumentException("Read-only buffer");
@@ -406,10 +425,11 @@ class SimpleAsynchronousDatagramChannelI
 
         // complete immediately if channel closed
         if (!isOpen()) {
-            CompletedFuture<SocketAddress,A> result = CompletedFuture.withFailure(this,
-                new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
         }
 
         final AccessControlContext acc = (System.getSecurityManager() == null) ?
@@ -471,7 +491,7 @@ class SimpleAsynchronousDatagramChannelI
                         x = new AsynchronousCloseException();
                     result.setFailure(x);
                 }
-                Invoker.invokeUnchecked(handler, result);
+                Invoker.invokeUnchecked(result);
             }
         };
         try {
@@ -483,11 +503,27 @@ class SimpleAsynchronousDatagramChannelI
     }
 
     @Override
-    public <A> Future<Integer> read(final ByteBuffer dst,
-                                    final long timeout,
-                                    final TimeUnit unit,
-                                    A attachment,
-                                    final CompletionHandler<Integer,? super A> handler)
+    public Future<SocketAddress> receive(ByteBuffer dst) {
+        return implReceive(dst, 0L, TimeUnit.MILLISECONDS, null, null);
+    }
+
+    @Override
+    public <A> void receive(ByteBuffer dst,
+                            long timeout,
+                            TimeUnit unit,
+                            A attachment,
+                            CompletionHandler<SocketAddress,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implReceive(dst, timeout, unit, attachment, handler);
+    }
+
+    private <A> Future<Integer> implRead(final ByteBuffer dst,
+                                         final long timeout,
+                                         final TimeUnit unit,
+                                         A attachment,
+                                         final CompletionHandler<Integer,? super A> handler)
     {
         if (dst.isReadOnly())
             throw new IllegalArgumentException("Read-only buffer");
@@ -495,17 +531,19 @@ class SimpleAsynchronousDatagramChannelI
             throw new IllegalArgumentException("Negative timeout");
         if (unit == null)
             throw new NullPointerException();
+
+        // complete immediately if channel closed
+        if (!isOpen()) {
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
+        }
+
         // another thread may disconnect before read is initiated
         if (!dc.isConnected())
             throw new NotYetConnectedException();
-
-        // complete immediately if channel closed
-        if (!isOpen()) {
-            CompletedFuture<Integer,A> result = CompletedFuture.withFailure(this,
-                new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
-        }
 
         final PendingFuture<Integer,A> result =
             new PendingFuture<Integer,A>(this, handler, attachment);
@@ -563,7 +601,7 @@ class SimpleAsynchronousDatagramChannelI
                         x = new AsynchronousCloseException();
                     result.setFailure(x);
                 }
-                Invoker.invokeUnchecked(handler, result);
+                Invoker.invokeUnchecked(result);
             }
         };
         try {
@@ -575,6 +613,23 @@ class SimpleAsynchronousDatagramChannelI
     }
 
     @Override
+    public Future<Integer> read(ByteBuffer dst) {
+        return implRead(dst, 0L, TimeUnit.MILLISECONDS, null, null);
+    }
+
+    @Override
+    public <A> void read(ByteBuffer dst,
+                            long timeout,
+                            TimeUnit unit,
+                            A attachment,
+                            CompletionHandler<Integer,? super A> handler)
+    {
+        if (handler == null)
+            throw new NullPointerException("'handler' is null");
+        implRead(dst, timeout, unit, attachment, handler);
+    }
+
+    @Override
     public  AsynchronousDatagramChannel bind(SocketAddress local)
         throws IOException
     {
--- a/src/share/classes/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/ch/SimpleAsynchronousFileChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -50,9 +50,6 @@ public class SimpleAsynchronousFileChann
     // Used to make native read and write calls
     private static final FileDispatcher nd = new FileDispatcherImpl();
 
-    // indicates if the associated thread pool is the default thread pool
-    private final boolean isDefaultExecutor;
-
     // Thread-safe set of IDs of native threads, for signalling
     private final NativeThreadSet threads = new NativeThreadSet(2);
 
@@ -60,11 +57,9 @@ public class SimpleAsynchronousFileChann
     SimpleAsynchronousFileChannelImpl(FileDescriptor fdObj,
                                       boolean reading,
                                       boolean writing,
-                                      ExecutorService executor,
-                                      boolean isDefaultexecutor)
+                                      ExecutorService executor)
     {
         super(fdObj, reading, writing, executor);
-        this.isDefaultExecutor = isDefaultexecutor;
     }
 
     public static AsynchronousFileChannel open(FileDescriptor fdo,
@@ -73,17 +68,9 @@ public class SimpleAsynchronousFileChann
                                                ThreadPool pool)
     {
         // Executor is either default or based on pool parameters
-        ExecutorService executor;
-        boolean isDefaultexecutor;
-        if (pool == null) {
-            executor = DefaultExecutorHolder.defaultExecutor;
-            isDefaultexecutor = true;
-        } else {
-            executor = pool.executor();
-            isDefaultexecutor = false;
-        }
-        return new SimpleAsynchronousFileChannelImpl(fdo,
-            reading, writing, executor, isDefaultexecutor);
+        ExecutorService executor = (pool == null) ?
+            DefaultExecutorHolder.defaultExecutor : pool.executor();
+        return new SimpleAsynchronousFileChannelImpl(fdo, reading, writing, executor);
     }
 
     @Override
@@ -114,16 +101,6 @@ public class SimpleAsynchronousFileChann
 
         // close file
         nd.close(fdObj);
-
-        // shutdown executor if specific to this channel
-        if (!isDefaultExecutor) {
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                public Void run() {
-                    executor.shutdown();
-                    return null;
-                }
-            });
-        }
     }
 
     @Override
@@ -194,11 +171,11 @@ public class SimpleAsynchronousFileChann
     }
 
     @Override
-    public <A> Future<FileLock> lock(final long position,
-                                     final long size,
-                                     final boolean shared,
-                                     A attachment,
-                                     final CompletionHandler<FileLock,? super A> handler)
+    <A> Future<FileLock> implLock(final long position,
+                                  final long size,
+                                  final boolean shared,
+                                  final A attachment,
+                                  final CompletionHandler<FileLock,? super A> handler)
     {
         if (shared && !reading)
             throw new NonReadableChannelException();
@@ -208,16 +185,19 @@ public class SimpleAsynchronousFileChann
         // add to lock table
         final FileLockImpl fli = addToFileLockTable(position, size, shared);
         if (fli == null) {
-            CompletedFuture<FileLock,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invokeIndirectly(handler, result, executor);
-            return result;
-        }
-
-        final PendingFuture<FileLock,A> result =
-            new PendingFuture<FileLock,A>(this, handler, attachment);
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invokeIndirectly(handler, attachment, null, exc, executor);
+            return null;
+        }
+
+        final PendingFuture<FileLock,A> result = (handler == null) ?
+            new PendingFuture<FileLock,A>(this) : null;
         Runnable task = new Runnable() {
             public void run() {
+                Throwable exc = null;
+
                 int ti = threads.add();
                 try {
                     int n;
@@ -226,31 +206,36 @@ public class SimpleAsynchronousFileChann
                         do {
                             n = nd.lock(fdObj, true, position, size, shared);
                         } while ((n == FileDispatcher.INTERRUPTED) && isOpen());
-                        if (n == FileDispatcher.LOCKED && isOpen()) {
-                            result.setResult(fli);
-                        } else {
+                        if (n != FileDispatcher.LOCKED || !isOpen()) {
                             throw new AsynchronousCloseException();
                         }
                     } catch (IOException x) {
                         removeFromFileLockTable(fli);
                         if (!isOpen())
                             x = new AsynchronousCloseException();
-                        result.setFailure(x);
+                        exc = x;
                     } finally {
                         end();
                     }
                 } finally {
                     threads.remove(ti);
                 }
-                Invoker.invokeUnchecked(handler, result);
+                if (handler == null) {
+                    result.setResult(fli, exc);
+                } else {
+                    Invoker.invokeUnchecked(handler, attachment, fli, exc);
+                }
             }
         };
+        boolean executed = false;
         try {
             executor.execute(task);
-        } catch (RejectedExecutionException ree) {
-            // rollback
-            removeFromFileLockTable(fli);
-            throw new ShutdownChannelGroupException();
+            executed = true;
+        } finally {
+            if (!executed) {
+                // rollback
+                removeFromFileLockTable(fli);
+            }
         }
         return result;
     }
@@ -301,10 +286,10 @@ public class SimpleAsynchronousFileChann
     }
 
     @Override
-    public <A> Future<Integer> read(final ByteBuffer dst,
-                                    final long position,
-                                    A attachment,
-                                    final CompletionHandler<Integer,? super A> handler)
+    <A> Future<Integer> implRead(final ByteBuffer dst,
+                                 final long position,
+                                 final A attachment,
+                                 final CompletionHandler<Integer,? super A> handler)
     {
         if (position < 0)
             throw new IllegalArgumentException("Negative position");
@@ -315,55 +300,52 @@ public class SimpleAsynchronousFileChann
 
         // complete immediately if channel closed or no space remaining
         if (!isOpen() || (dst.remaining() == 0)) {
-            CompletedFuture<Integer,A> result;
-            if (isOpen()) {
-                result = CompletedFuture.withResult(this, 0, attachment);
-            } else {
-                result = CompletedFuture.withFailure(this,
-                    new ClosedChannelException(), attachment);
-            }
-            Invoker.invokeIndirectly(handler, result, executor);
-            return result;
-        }
-
-        final PendingFuture<Integer,A> result =
-            new PendingFuture<Integer,A>(this, handler, attachment);
+            Throwable exc = (isOpen()) ? null : new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withResult(0, exc);
+            Invoker.invokeIndirectly(handler, attachment, 0, exc, executor);
+            return null;
+        }
+
+        final PendingFuture<Integer,A> result = (handler == null) ?
+            new PendingFuture<Integer,A>(this) : null;
         Runnable task = new Runnable() {
             public void run() {
+                int n = 0;
+                Throwable exc = null;
+
                 int ti = threads.add();
                 try {
                     begin();
-                    int n;
                     do {
                         n = IOUtil.read(fdObj, dst, position, nd, null);
                     } while ((n == IOStatus.INTERRUPTED) && isOpen());
                     if (n < 0 && !isOpen())
                         throw new AsynchronousCloseException();
-                    result.setResult(n);
                 } catch (IOException x) {
                     if (!isOpen())
                         x = new AsynchronousCloseException();
-                    result.setFailure(x);
+                    exc = x;
                 } finally {
                     end();
                     threads.remove(ti);
                 }
-                Invoker.invokeUnchecked(handler, result);
+                if (handler == null) {
+                    result.setResult(n, exc);
+                } else {
+                    Invoker.invokeUnchecked(handler, attachment, n, exc);
+                }
             }
         };
-        try {
-            executor.execute(task);
-        } catch (RejectedExecutionException ree) {
-            throw new ShutdownChannelGroupException();
-        }
+        executor.execute(task);
         return result;
     }
 
     @Override
-    public <A> Future<Integer> write(final ByteBuffer src,
-                                     final long position,
-                                     A attachment,
-                                     final CompletionHandler<Integer,? super A> handler)
+    <A> Future<Integer> implWrite(final ByteBuffer src,
+                                  final long position,
+                                  final A attachment,
+                                  final CompletionHandler<Integer,? super A> handler)
     {
         if (position < 0)
             throw new IllegalArgumentException("Negative position");
@@ -372,47 +354,44 @@ public class SimpleAsynchronousFileChann
 
         // complete immediately if channel is closed or no bytes remaining
         if (!isOpen() || (src.remaining() == 0)) {
-            CompletedFuture<Integer,A> result;
-            if (isOpen()) {
-                result = CompletedFuture.withResult(this, 0, attachment);
-            } else {
-                result = CompletedFuture.withFailure(this,
-                    new ClosedChannelException(), attachment);
-            }
-            Invoker.invokeIndirectly(handler, result, executor);
-            return result;
-        }
-
-        final PendingFuture<Integer,A> result =
-            new PendingFuture<Integer,A>(this, handler, attachment);
+            Throwable exc = (isOpen()) ? null : new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withResult(0, exc);
+            Invoker.invokeIndirectly(handler, attachment, 0, exc, executor);
+            return null;
+        }
+
+        final PendingFuture<Integer,A> result = (handler == null) ?
+            new PendingFuture<Integer,A>(this) : null;
         Runnable task = new Runnable() {
             public void run() {
+                int n = 0;
+                Throwable exc = null;
+
                 int ti = threads.add();
                 try {
                     begin();
-                    int n;
                     do {
                         n = IOUtil.write(fdObj, src, position, nd, null);
                     } while ((n == IOStatus.INTERRUPTED) && isOpen());
                     if (n < 0 && !isOpen())
                         throw new AsynchronousCloseException();
-                    result.setResult(n);
                 } catch (IOException x) {
                     if (!isOpen())
                         x = new AsynchronousCloseException();
-                    result.setFailure(x);
+                    exc = x;
                 } finally {
                     end();
                     threads.remove(ti);
                 }
-                Invoker.invokeUnchecked(handler, result);
+                if (handler == null) {
+                    result.setResult(n, exc);
+                } else {
+                    Invoker.invokeUnchecked(handler, attachment, n, exc);
+                }
             }
         };
-        try {
-            executor.execute(task);
-        } catch (RejectedExecutionException ree) {
-            throw new ShutdownChannelGroupException();
-        }
+        executor.execute(task);
         return result;
     }
 }
--- a/src/share/classes/sun/nio/cs/ISO_8859_1.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ISO_8859_1.java	Tue Sep 22 01:20:51 2009 -0700
@@ -228,8 +228,8 @@ class ISO_8859_1
                     dst[dp++] = (byte)c;
                     continue;
                 }
-                if (Surrogate.isHigh(c) && sp < sl &&
-                    Surrogate.isLow(src[sp])) {
+                if (Character.isHighSurrogate(c) && sp < sl &&
+                    Character.isLowSurrogate(src[sp])) {
                     if (len > dst.length) {
                         sl++;
                         len--;
--- a/src/share/classes/sun/nio/cs/SingleByte.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/SingleByte.java	Tue Sep 22 01:20:51 2009 -0700
@@ -171,7 +171,7 @@ public class SingleByte
                 char c = sa[sp];
                 int b = encode(c);
                 if (b == UNMAPPABLE_ENCODING) {
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp == null)
                             sgp = new Surrogate.Parser();
                         if (sgp.parse(c, sa, sp, sl) < 0)
@@ -194,7 +194,7 @@ public class SingleByte
                     char c = src.get();
                     int b = encode(c);
                     if (b == UNMAPPABLE_ENCODING) {
-                        if (Surrogate.is(c)) {
+                        if (Character.isSurrogate(c)) {
                             if (sgp == null)
                                 sgp = new Surrogate.Parser();
                             if (sgp.parse(c, src) < 0)
@@ -243,8 +243,8 @@ public class SingleByte
                     dst[dp++] = (byte)b;
                     continue;
                 }
-                if (Surrogate.isHigh(c) && sp < sl &&
-                    Surrogate.isLow(src[sp])) {
+                if (Character.isHighSurrogate(c) && sp < sl &&
+                    Character.isLowSurrogate(src[sp])) {
                     if (len > dst.length) {
                         sl++;
                         len--;
--- a/src/share/classes/sun/nio/cs/SingleByteEncoder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/SingleByteEncoder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -84,7 +84,7 @@ public abstract class SingleByteEncoder
         try {
             while (sp < sl) {
                 char c = sa[sp];
-                if (Surrogate.is(c)) {
+                if (Character.isSurrogate(c)) {
                     if (sgp.parse(c, sa, sp, sl) < 0)
                         return sgp.error();
                     return sgp.unmappableResult();
@@ -117,7 +117,7 @@ public abstract class SingleByteEncoder
         try {
             while (src.hasRemaining()) {
                 char c = src.get();
-                if (Surrogate.is(c)) {
+                if (Character.isSurrogate(c)) {
                     if (sgp.parse(c, src) < 0)
                         return sgp.error();
                     return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/Surrogate.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/Surrogate.java	Tue Sep 22 01:20:51 2009 -0700
@@ -51,21 +51,24 @@ public class Surrogate {
     public static final int UCS4_MAX  = Character.MAX_CODE_POINT;
 
     /**
-     * Tells whether or not the given UTF-16 value is a high surrogate.
+     * Tells whether or not the given value is in the high surrogate range.
+     * Use of {@link Character#isHighSurrogate} is generally preferred.
      */
     public static boolean isHigh(int c) {
         return (MIN_HIGH <= c) && (c <= MAX_HIGH);
     }
 
     /**
-     * Tells whether or not the given UTF-16 value is a low surrogate.
+     * Tells whether or not the given value is in the low surrogate range.
+     * Use of {@link Character#isLowSurrogate} is generally preferred.
      */
     public static boolean isLow(int c) {
         return (MIN_LOW <= c) && (c <= MAX_LOW);
     }
 
     /**
-     * Tells whether or not the given UTF-16 value is a surrogate character,
+     * Tells whether or not the given value is in the surrogate range.
+     * Use of {@link Character#isSurrogate} is generally preferred.
      */
     public static boolean is(int c) {
         return (MIN <= c) && (c <= MAX);
@@ -88,7 +91,7 @@ public class Surrogate {
     }
 
     /**
-     * Returns the high UTF-16 surrogate for the given UCS-4 character.
+     * Returns the high UTF-16 surrogate for the given supplementary UCS-4 character.
      */
     public static char high(int uc) {
         assert Character.isSupplementaryCodePoint(uc);
@@ -98,7 +101,7 @@ public class Surrogate {
     }
 
     /**
-     * Returns the low UTF-16 surrogate for the given UCS-4 character.
+     * Returns the low UTF-16 surrogate for the given supplementary UCS-4 character.
      */
     public static char low(int uc) {
         assert Character.isSupplementaryCodePoint(uc);
--- a/src/share/classes/sun/nio/cs/US_ASCII.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/US_ASCII.java	Tue Sep 22 01:20:51 2009 -0700
@@ -247,8 +247,8 @@ public class US_ASCII
                     dst[dp++] = (byte)c;
                     continue;
                 }
-                if (Surrogate.isHigh(c) && sp < sl &&
-                    Surrogate.isLow(src[sp])) {
+                if (Character.isHighSurrogate(c) && sp < sl &&
+                    Character.isLowSurrogate(src[sp])) {
                     if (len > dst.length) {
                         sl++;
                         len--;
--- a/src/share/classes/sun/nio/cs/UTF_32Coder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/UTF_32Coder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -154,11 +154,11 @@ class UTF_32Coder {
             try {
                 while (src.hasRemaining()) {
                     char c = src.get();
-                    if (Surrogate.isHigh(c)) {
+                    if (Character.isHighSurrogate(c)) {
                         if (!src.hasRemaining())
                             return CoderResult.UNDERFLOW;
                         char low = src.get();
-                        if (Surrogate.isLow(low)) {
+                        if (Character.isLowSurrogate(low)) {
                             if (dst.remaining() < 4)
                                 return CoderResult.OVERFLOW;
                             mark += 2;
@@ -166,7 +166,7 @@ class UTF_32Coder {
                         } else {
                             return CoderResult.malformedForLength(1);
                         }
-                    } else if (Surrogate.isLow(c)) {
+                    } else if (Character.isLowSurrogate(c)) {
                         return CoderResult.malformedForLength(1);
                     } else {
                         if (dst.remaining() < 4)
--- a/src/share/classes/sun/nio/cs/UTF_8.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/UTF_8.java	Tue Sep 22 01:20:51 2009 -0700
@@ -334,7 +334,7 @@ class UTF_8 extends Unicode
         }
 
         public boolean canEncode(char c) {
-            return !Surrogate.is(c);
+            return !Character.isSurrogate(c);
         }
 
         public boolean isLegalReplacement(byte[] repl) {
@@ -370,7 +370,7 @@ class UTF_8 extends Unicode
             while (dp < dlASCII && sa[sp] < '\u0080')
                 da[dp++] = (byte) sa[sp++];
             while (sp < sl) {
-                int c = sa[sp];
+                char c = sa[sp];
                 if (c < 0x80) {
                     // Have at most seven bits
                     if (dp >= dl)
@@ -382,11 +382,11 @@ class UTF_8 extends Unicode
                         return overflow(src, sp, dst, dp);
                     da[dp++] = (byte)(0xc0 | ((c >> 06)));
                     da[dp++] = (byte)(0x80 | (c & 0x3f));
-                } else if (Surrogate.is(c)) {
+                } else if (Character.isSurrogate(c)) {
                     // Have a surrogate pair
                     if (sgp == null)
                         sgp = new Surrogate.Parser();
-                    int uc = sgp.parse((char)c, sa, sp, sl);
+                    int uc = sgp.parse(c, sa, sp, sl);
                     if (uc < 0) {
                         updatePositions(src, sp, dst, dp);
                         return sgp.error();
@@ -417,7 +417,7 @@ class UTF_8 extends Unicode
         {
             int mark = src.position();
             while (src.hasRemaining()) {
-                int c = src.get();
+                char c = src.get();
                 if (c < 0x80) {
                     // Have at most seven bits
                     if (!dst.hasRemaining())
@@ -429,11 +429,11 @@ class UTF_8 extends Unicode
                         return overflow(src, mark);
                     dst.put((byte)(0xc0 | ((c >> 06))));
                     dst.put((byte)(0x80 | (c & 0x3f)));
-                } else if (Surrogate.is(c)) {
+                } else if (Character.isSurrogate(c)) {
                     // Have a surrogate pair
                     if (sgp == null)
                         sgp = new Surrogate.Parser();
-                    int uc = sgp.parse((char)c, src);
+                    int uc = sgp.parse(c, src);
                     if (uc < 0) {
                         src.position(mark);
                         return sgp.error();
--- a/src/share/classes/sun/nio/cs/UnicodeDecoder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/UnicodeDecoder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -97,12 +97,12 @@ abstract class UnicodeDecoder extends Ch
                 }
 
                 // Surrogates
-                if (Surrogate.is(c)) {
-                    if (Surrogate.isHigh(c)) {
+                if (Character.isSurrogate(c)) {
+                    if (Character.isHighSurrogate(c)) {
                         if (src.remaining() < 2)
                             return CoderResult.UNDERFLOW;
                         char c2 = decode(src.get() & 0xff, src.get() & 0xff);
-                        if (!Surrogate.isLow(c2))
+                        if (!Character.isLowSurrogate(c2))
                             return CoderResult.malformedForLength(4);
                         if (dst.remaining() < 2)
                             return CoderResult.OVERFLOW;
--- a/src/share/classes/sun/nio/cs/UnicodeEncoder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/UnicodeEncoder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -80,7 +80,7 @@ public abstract class UnicodeEncoder ext
         try {
             while (src.hasRemaining()) {
                 char c = src.get();
-                if (!Surrogate.is(c)) {
+                if (!Character.isSurrogate(c)) {
                     if (dst.remaining() < 2)
                         return CoderResult.OVERFLOW;
                     mark++;
@@ -107,6 +107,6 @@ public abstract class UnicodeEncoder ext
     }
 
     public boolean canEncode(char c) {
-        return ! Surrogate.is(c);
+        return ! Character.isSurrogate(c);
     }
 }
--- a/src/share/classes/sun/nio/cs/ext/DoubleByte.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/DoubleByte.java	Tue Sep 22 01:20:51 2009 -0700
@@ -449,7 +449,7 @@ public class DoubleByte {
                     char c = sa[sp];
                     int bb = encodeChar(c);
                     if (bb == UNMAPPABLE_ENCODING) {
-                        if (Surrogate.is(c)) {
+                        if (Character.isSurrogate(c)) {
                             if (sgp().parse(c, sa, sp, sl) < 0)
                                 return sgp.error();
                             return sgp.unmappableResult();
@@ -484,7 +484,7 @@ public class DoubleByte {
                     char c = src.get();
                     int bb = encodeChar(c);
                     if (bb == UNMAPPABLE_ENCODING) {
-                        if (Surrogate.is(c)) {
+                        if (Character.isSurrogate(c)) {
                             if (sgp().parse(c, src) < 0)
                                 return sgp.error();
                             return sgp.unmappableResult();
@@ -659,7 +659,7 @@ public class DoubleByte {
                     char c = sa[sp];
                     int bb = encodeChar(c);
                     if (bb == UNMAPPABLE_ENCODING) {
-                        if (Surrogate.is(c)) {
+                        if (Character.isSurrogate(c)) {
                             if (sgp().parse(c, sa, sp, sl) < 0)
                                 return sgp.error();
                             return sgp.unmappableResult();
@@ -705,7 +705,7 @@ public class DoubleByte {
                     char c = src.get();
                     int bb = encodeChar(c);
                     if (bb == UNMAPPABLE_ENCODING) {
-                        if (Surrogate.is(c)) {
+                        if (Character.isSurrogate(c)) {
                             if (sgp().parse(c, src) < 0)
                                 return sgp.error();
                             return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/ext/DoubleByteEncoder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/DoubleByteEncoder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -95,7 +95,7 @@ public abstract class DoubleByteEncoder
         try {
             while (sp < sl) {
                 char c = sa[sp];
-                if (Surrogate.is(c)) {
+                if (Character.isSurrogate(c)) {
                     if (sgp.parse(c, sa, sp, sl) < 0)
                         return sgp.error();
                     if (sl - sp < 2)
@@ -153,7 +153,7 @@ public abstract class DoubleByteEncoder
         try {
             while (src.hasRemaining()) {
                 char c = src.get();
-                if (Surrogate.is(c)) {
+                if (Character.isSurrogate(c)) {
                     int surr;
                     if ((surr = sgp.parse(c, src)) < 0)
                         return sgp.error();
--- a/src/share/classes/sun/nio/cs/ext/EUC_JP.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/EUC_JP.java	Tue Sep 22 01:20:51 2009 -0700
@@ -318,7 +318,7 @@ public class EUC_JP
                     outputByte = tmpBuf;
                     char c = sa[sp];
 
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp.parse(c, sa, sp, sl) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
@@ -372,7 +372,7 @@ public class EUC_JP
                 while (src.hasRemaining()) {
                     outputByte = tmpBuf;
                     char c = src.get();
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp.parse(c, src) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/ext/EUC_JP_LINUX.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/EUC_JP_LINUX.java	Tue Sep 22 01:20:51 2009 -0700
@@ -285,7 +285,7 @@ public class EUC_JP_LINUX
                 while (sp < sl) {
                     char c = sa[sp];
 
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp.parse(c, sa, sp, sl) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
@@ -327,7 +327,7 @@ public class EUC_JP_LINUX
             try {
                 while (src.hasRemaining()) {
                     char c = src.get();
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp.parse(c, src) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/ext/EUC_TW.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/EUC_TW.java	Tue Sep 22 01:20:51 2009 -0700
@@ -310,11 +310,11 @@ public class EUC_TW extends Charset impl
             int i = 0;
             while (i < cs.length()) {
                 char c = cs.charAt(i++);
-                if (Surrogate.isHigh(c)) {
+                if (Character.isHighSurrogate(c)) {
                     if (i == cs.length())
                         return false;
                     char low = cs.charAt(i++);
-                    if (!Surrogate.isLow(low) || toEUC(c, low, bb) == -1)
+                    if (!Character.isLowSurrogate(low) || toEUC(c, low, bb) == -1)
                         return false;
                 } else if (!canEncode(c)) {
                     return false;
@@ -361,14 +361,14 @@ public class EUC_TW extends Charset impl
                             // supplementary character encoding. given the use
                             // of supplementary characters is really rare, this
                             // is something worth doing.
-                            if (Surrogate.isHigh(c)) {
+                            if (Character.isHighSurrogate(c)) {
                                 if ((sp + 1) == sl)
                                     return CoderResult.UNDERFLOW;
-                                if (!Surrogate.isLow(sa[sp + 1]))
+                                if (!Character.isLowSurrogate(sa[sp + 1]))
                                     return CoderResult.malformedForLength(1);
                                 outSize = toEUC(c, sa[sp+1], bb);
                                     inSize = 2;
-                            } else if (Surrogate.isLow(c)) {
+                            } else if (Character.isLowSurrogate(c)) {
                                 return CoderResult.malformedForLength(1);
                             }
                         }
@@ -405,15 +405,15 @@ public class EUC_TW extends Charset impl
                     } else {
                         outSize = toEUC(c, bb);
                         if (outSize == -1) {
-                            if (Surrogate.isHigh(c)) {
+                            if (Character.isHighSurrogate(c)) {
                                 if (!src.hasRemaining())
                                     return CoderResult.UNDERFLOW;
                                 char c2 = src.get();
-                                if (!Surrogate.isLow(c2))
+                                if (!Character.isLowSurrogate(c2))
                                     return CoderResult.malformedForLength(1);
                                 outSize = toEUC(c, c2, bb);
                                 inSize = 2;
-                            } else if (Surrogate.isLow(c)) {
+                            } else if (Character.isLowSurrogate(c)) {
                                 return CoderResult.malformedForLength(1);
                             }
                         }
--- a/src/share/classes/sun/nio/cs/ext/GB18030.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/GB18030.java	Tue Sep 22 01:20:51 2009 -0700
@@ -12586,7 +12586,7 @@ public class GB18030
         }
 
         public boolean canEncode(char c) {
-            return ! Surrogate.is(c);
+            return ! Character.isSurrogate(c);
         }
 
         private final Surrogate.Parser sgp = new Surrogate.Parser();
@@ -12625,7 +12625,7 @@ public class GB18030
                     int inputSize = 1;
                     char c = sa[sp];
 
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if ((condensedKey=sgp.parse(c, sa, sp, sl)) < 0)
                             return sgp.error();
                         // Surogate.toUCS4 looks like
@@ -12719,7 +12719,7 @@ public class GB18030
                 while (src.hasRemaining()) {
                     char c = src.get();
                     int inputSize = 1;
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if ((condensedKey = sgp.parse(c, src))<0)
                            return sgp.error();
                         condensedKey += 0x1e248;
--- a/src/share/classes/sun/nio/cs/ext/ISCII91.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/ISCII91.java	Tue Sep 22 01:20:51 2009 -0700
@@ -885,7 +885,7 @@ public class ISCII91 extends Charset imp
                         index = ((int)(inputChar) - 0x0900)*2;
                     }
 
-                    if (Surrogate.is(inputChar)) {
+                    if (Character.isSurrogate(inputChar)) {
                         if (sgp.parse(inputChar, sa, sp, sl) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
@@ -948,7 +948,7 @@ public class ISCII91 extends Charset imp
                         index = ((int)(inputChar) - 0x0900)*2;
                     }
 
-                    if (Surrogate.is(inputChar)) {
+                    if (Character.isSurrogate(inputChar)) {
                         if (sgp.parse(inputChar, src) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/ext/ISO2022.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/ISO2022.java	Tue Sep 22 01:20:51 2009 -0700
@@ -388,9 +388,9 @@ abstract class ISO2022
 
     protected static class Encoder extends CharsetEncoder {
         private final Surrogate.Parser sgp = new Surrogate.Parser();
-        private final byte SS2 = (byte)0x8e;
-        private final byte PLANE2 = (byte)0xA2;
-        private final byte PLANE3 = (byte)0xA3;
+        public static final byte SS2 = (byte)0x8e;
+        public static final byte PLANE2 = (byte)0xA2;
+        public static final byte PLANE3 = (byte)0xA3;
         private final byte MSB = (byte)0x80;
 
         protected final byte maximumDesignatorLength = 4;
@@ -515,7 +515,7 @@ abstract class ISO2022
             try {
                 while (sp < sl) {
                     char c = sa[sp];
-                    if (Surrogate.is(c)) {
+                    if (Character.isSurrogate(c)) {
                         if (sgp.parse(c, sa, sp, sl) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
@@ -576,7 +576,7 @@ abstract class ISO2022
             try {
                 while (src.hasRemaining()) {
                     char inputChar = src.get();
-                    if (Surrogate.is(inputChar)) {
+                    if (Character.isSurrogate(inputChar)) {
                         if (sgp.parse(inputChar, src) < 0)
                             return sgp.error();
                         return sgp.unmappableResult();
--- a/src/share/classes/sun/nio/cs/ext/ISO2022_CN_CNS.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/ISO2022_CN_CNS.java	Tue Sep 22 01:20:51 2009 -0700
@@ -76,6 +76,15 @@ public class ISO2022_CN_CNS extends ISO2
             } catch (Exception e) { }
         }
 
+        private byte[] bb = new byte[4];
+        public boolean canEncode(char c) {
+            int n = 0;
+            return (c <= '\u007f' ||
+                    (n = ((EUC_TW.Encoder)ISOEncoder).toEUC(c, bb)) == 2 ||
+                    (n == 4 && bb[0] == SS2 &&
+                     (bb[1] == PLANE2 || bb[1] == PLANE3)));
+        }
+
         /*
          * Since ISO2022-CN-CNS possesses a CharsetEncoder
          * without the corresponding CharsetDecoder half the
--- a/src/share/classes/sun/nio/cs/ext/ISO2022_JP.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/ISO2022_JP.java	Tue Sep 22 01:20:51 2009 -0700
@@ -637,7 +637,7 @@ public class ISO2022_JP
                             da[dp++] = (byte)(index >> 8);
                             da[dp++] = (byte)(index & 0xff);
                         } else {
-                            if (Surrogate.is(c) && sgp.parse(c, sa, sp, sl) < 0)
+                            if (Character.isSurrogate(c) && sgp.parse(c, sa, sp, sl) < 0)
                                 return sgp.error();
                             if (unmappableCharacterAction()
                                 == CodingErrorAction.REPLACE
@@ -655,7 +655,7 @@ public class ISO2022_JP
                                 }
                                 currentMode = replaceMode;
                             }
-                            if (Surrogate.is(c))
+                            if (Character.isSurrogate(c))
                                 return sgp.unmappableResult();
                             return CoderResult.unmappableForLength(1);
                         }
@@ -745,7 +745,7 @@ public class ISO2022_JP
                             dst.put((byte)(index >> 8));
                             dst.put((byte)(index & 0xff));
                         } else {
-                            if (Surrogate.is(c) && sgp.parse(c, src) < 0)
+                            if (Character.isSurrogate(c) && sgp.parse(c, src) < 0)
                                 return sgp.error();
                             if (unmappableCharacterAction() == CodingErrorAction.REPLACE
                                 && currentMode != replaceMode) {
@@ -762,7 +762,7 @@ public class ISO2022_JP
                                 }
                                 currentMode = replaceMode;
                             }
-                            if (Surrogate.is(c))
+                            if (Character.isSurrogate(c))
                                 return sgp.unmappableResult();
                             return CoderResult.unmappableForLength(1);
                         }
--- a/src/share/classes/sun/nio/cs/ext/SimpleEUCEncoder.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/nio/cs/ext/SimpleEUCEncoder.java	Tue Sep 22 01:20:51 2009 -0700
@@ -114,7 +114,7 @@ public abstract class SimpleEUCEncoder
             while (sp < sl) {
                 boolean allZeroes = true;
                 char inputChar = sa[sp];
-                if (Surrogate.is(inputChar)) {
+                if (Character.isSurrogate(inputChar)) {
                     if (sgp.parse(inputChar, sa, sp, sl) < 0)
                         return sgp.error();
                     return sgp.unmappableResult();
@@ -194,7 +194,7 @@ public abstract class SimpleEUCEncoder
             while (src.hasRemaining()) {
                 char inputChar = src.get();
                 boolean allZeroes = true;
-                if (Surrogate.is(inputChar)) {
+                if (Character.isSurrogate(inputChar)) {
                     if (sgp.parse(inputChar, src) < 0)
                         return sgp.error();
                     return sgp.unmappableResult();
--- a/src/share/classes/sun/security/jgss/SunProvider.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/jgss/SunProvider.java	Tue Sep 22 01:20:51 2009 -0700
@@ -62,7 +62,7 @@ public final class SunProvider extends P
 
     public SunProvider() {
         /* We are the Sun JGSS provider */
-        super("SunJGSS", 1.0, INFO);
+        super("SunJGSS", 1.7d, INFO);
 
         AccessController.doPrivileged(
                         new java.security.PrivilegedAction<Void>() {
--- a/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/krb5/internal/ktab/KeyTab.java	Tue Sep 22 01:20:51 2009 -0700
@@ -41,6 +41,7 @@ import java.io.FileInputStream;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.File;
+import java.util.Comparator;
 import java.util.StringTokenizer;
 
 /**
@@ -229,10 +230,11 @@ public class KeyTab implements KeyTabCon
     /**
      * Reads the service key from the keytab file.
      * @param service the PrincipalName of the requested service.
-     * @return the last service key in the keytab
+     * @return the last service key in the keytab with the highest kvno
      */
     public EncryptionKey readServiceKey(PrincipalName service) {
         KeyTabEntry entry = null;
+        EncryptionKey key = null;
         if (entries != null) {
             // Find latest entry for this service that has an etype
             // that has been configured for use
@@ -240,9 +242,12 @@ public class KeyTab implements KeyTabCon
                 entry = entries.elementAt(i);
                 if (entry.service.match(service)) {
                     if (EType.isSupported(entry.keyType)) {
-                        return new EncryptionKey(entry.keyblock,
+                        if (key == null ||
+                                entry.keyVersion > key.getKeyVersionNumber()) {
+                            key = new EncryptionKey(entry.keyblock,
                                              entry.keyType,
                                              new Integer(entry.keyVersion));
+                        }
                     } else if (DEBUG) {
                         System.out.println("Found unsupported keytype (" +
                             entry.keyType + ") for " + service);
@@ -250,12 +255,13 @@ public class KeyTab implements KeyTabCon
                 }
             }
         }
-        return null;
+        return key;
     }
 
     /**
      * Reads all keys for a service from the keytab file that have
-     * etypes that have been configured for use.
+     * etypes that have been configured for use. If there are multiple
+     * keys with same etype, the one with the highest kvno is returned.
      * @param service the PrincipalName of the requested service
      * @return an array containing all the service keys
      */
@@ -288,49 +294,39 @@ public class KeyTab implements KeyTabCon
         size = keys.size();
         if (size == 0)
             return null;
-        EncryptionKey[] retVal = new EncryptionKey[size];
+        EncryptionKey[] retVal = keys.toArray(new EncryptionKey[size]);
 
         // Sort keys according to default_tkt_enctypes
-        int pos = 0;
-        EncryptionKey k;
         if (DEBUG) {
             System.out.println("Ordering keys wrt default_tkt_enctypes list");
         }
-        int[] etypes = EType.getDefaults("default_tkt_enctypes");
-        if (etypes == null || etypes == EType.getBuiltInDefaults()) {
-            // Either no supported types specified in default_tkt_enctypes
-            // or no default_tkt_enctypes entry at all. For both cases,
-            // just return supported keys in the order retrieved
-            for (int i = 0; i < size; i++) {
-                retVal[pos++] = keys.get(i);
-            }
-        } else {
-            for (int j = 0; j < etypes.length && pos < size; j++) {
-                int target = etypes[j];
-                for (int i = 0; i < size && pos < size; i++) {
-                    k = keys.get(i);
-                    if (k != null && k.getEType() == target) {
-                        if (DEBUG) {
-                            System.out.println(pos + ": " + k);
+
+        final int[] etypes = EType.getDefaults("default_tkt_enctypes");
+
+        // Sort the keys, k1 is preferred than k2 if:
+        // 1. k1's etype appears earlier in etypes than k2's
+        // 2. If same, k1's KVNO is higher
+        Arrays.sort(retVal, new Comparator<EncryptionKey>() {
+            @Override
+            public int compare(EncryptionKey o1, EncryptionKey o2) {
+                if (etypes != null && etypes != EType.getBuiltInDefaults()) {
+                    int o1EType = o1.getEType();
+                    int o2EType = o2.getEType();
+                    if (o1EType != o2EType) {
+                        for (int i=0; i<etypes.length; i++) {
+                            if (etypes[i] == o1EType) {
+                                return -1;
+                            } else if (etypes[i] == o2EType) {
+                                return 1;
+                            }
                         }
-                        retVal[pos++] = k;
-                        keys.set(i, null);  // Cleared from consideration
-                    }
-                }
-            }
-            // copy the rest
-            for (int i = 0; i < size && pos < size; i++) {
-                k = keys.get(i);
-                if (k != null) {
-                    retVal[pos++] = k;
-                }
-            }
-        }
-        if (pos != size) {
-            throw new RuntimeException(
-                "Internal Error: did not copy all keys;expecting " + size +
-                    "; got " + pos);
-        }
+                    }
+                }
+                return o2.getKeyVersionNumber().intValue()
+                        - o1.getKeyVersionNumber().intValue();
+            }
+        });
+
         return retVal;
     }
 
--- a/src/share/classes/sun/security/provider/Sun.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/provider/Sun.java	Tue Sep 22 01:20:51 2009 -0700
@@ -46,7 +46,7 @@ public final class Sun extends Provider 
 
     public Sun() {
         /* We are the SUN provider */
-        super("SUN", 1.6, INFO);
+        super("SUN", 1.7, INFO);
 
         // if there is no security manager installed, put directly into
         // the provider. Otherwise, create a temporary map and use a
--- a/src/share/classes/sun/security/smartcardio/SunPCSC.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/smartcardio/SunPCSC.java	Tue Sep 22 01:20:51 2009 -0700
@@ -40,7 +40,7 @@ public final class SunPCSC extends Provi
     private static final long serialVersionUID = 6168388284028876579L;
 
     public SunPCSC() {
-        super("SunPCSC", 1.6d, "Sun PC/SC provider");
+        super("SunPCSC", 1.7d, "Sun PC/SC provider");
         AccessController.doPrivileged(new PrivilegedAction<Void>() {
             public Void run() {
                 put("TerminalFactory.PC/SC", "sun.security.smartcardio.SunPCSC$Factory");
--- a/src/share/classes/sun/security/ssl/SunJSSE.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/ssl/SunJSSE.java	Tue Sep 22 01:20:51 2009 -0700
@@ -103,7 +103,7 @@ public abstract class SunJSSE extends ja
 
     // standard constructor
     protected SunJSSE() {
-        super("SunJSSE", 1.6d, info);
+        super("SunJSSE", 1.7d, info);
         subclassCheck();
         if (Boolean.TRUE.equals(fips)) {
             throw new ProviderException
--- a/src/share/classes/sun/security/tools/JarSigner.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/tools/JarSigner.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1978,20 +1978,35 @@ public class JarSigner {
         String[] base64Digests = getDigests(ze, zf, digests, encoder);
 
         for (int i=0; i<digests.length; i++) {
-            String name = digests[i].getAlgorithm()+"-Digest";
-            String mfDigest = attrs.getValue(name);
-            if (mfDigest == null
-                && digests[i].getAlgorithm().equalsIgnoreCase("SHA")) {
-                // treat "SHA" and "SHA1" the same
-                mfDigest = attrs.getValue("SHA-Digest");
-            }
-            if (mfDigest == null) {
-                // compute digest and add it to list of attributes
+            // The entry name to be written into attrs
+            String name = null;
+            try {
+                // Find if the digest already exists
+                AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
+                for (Object key: attrs.keySet()) {
+                    if (key instanceof Attributes.Name) {
+                        String n = ((Attributes.Name)key).toString();
+                        if (n.toUpperCase(Locale.ENGLISH).endsWith("-DIGEST")) {
+                            String tmp = n.substring(0, n.length() - 7);
+                            if (AlgorithmId.get(tmp).equals(aid)) {
+                                name = n;
+                                break;
+                            }
+                        }
+                    }
+                }
+            } catch (NoSuchAlgorithmException nsae) {
+                // Ignored. Writing new digest entry.
+            }
+
+            if (name == null) {
+                name = digests[i].getAlgorithm()+"-Digest";
                 attrs.putValue(name, base64Digests[i]);
                 update=true;
             } else {
                 // compare digests, and replace the one in the manifest
                 // if they are different
+                String mfDigest = attrs.getValue(name);
                 if (!mfDigest.equalsIgnoreCase(base64Digests[i])) {
                     attrs.putValue(name, base64Digests[i]);
                     update=true;
--- a/src/share/classes/sun/security/util/Password.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/util/Password.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2003-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,14 @@ public class Password {
 public class Password {
     /** Reads user password from given input stream. */
     public static char[] readPassword(InputStream in) throws IOException {
+        return readPassword(in, false);
+    }
+
+    /** Reads user password from given input stream.
+     * @param isEchoOn true if the password should be echoed on the screen
+     */
+    public static char[] readPassword(InputStream in, boolean isEchoOn)
+            throws IOException {
 
         char[] consoleEntered = null;
         byte[] consoleBytes = null;
@@ -44,7 +52,7 @@ public class Password {
         try {
             // Use the new java.io.Console class
             Console con = null;
-            if (in == System.in && ((con = System.console()) != null)) {
+            if (!isEchoOn && in == System.in && ((con = System.console()) != null)) {
                 consoleEntered = con.readPassword();
                 // readPassword returns "" if you just print ENTER,
                 // to be compatible with old Password class, change to null
--- a/src/share/classes/sun/security/x509/AlgorithmId.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/security/x509/AlgorithmId.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -530,6 +530,18 @@ public class AlgorithmId implements Seri
         if (name.equalsIgnoreCase("SHA1withECDSA")
                 || name.equalsIgnoreCase("ECDSA")) {
             return AlgorithmId.sha1WithECDSA_oid;
+        }
+        if (name.equalsIgnoreCase("SHA224withECDSA")) {
+            return AlgorithmId.sha224WithECDSA_oid;
+        }
+        if (name.equalsIgnoreCase("SHA256withECDSA")) {
+            return AlgorithmId.sha256WithECDSA_oid;
+        }
+        if (name.equalsIgnoreCase("SHA384withECDSA")) {
+            return AlgorithmId.sha384WithECDSA_oid;
+        }
+        if (name.equalsIgnoreCase("SHA512withECDSA")) {
+            return AlgorithmId.sha512WithECDSA_oid;
         }
 
         // See if any of the installed providers supply a mapping from
--- a/src/share/classes/sun/swing/MenuItemLayoutHelper.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/swing/MenuItemLayoutHelper.java	Tue Sep 22 01:20:51 2009 -0700
@@ -84,7 +84,6 @@ public class MenuItemLayoutHelper {
     private int minTextOffset;
 
     private int leftTextExtraWidth;
-    private int rightTextExtraWidth;
 
     private Rectangle viewRect;
 
@@ -157,22 +156,12 @@ public class MenuItemLayoutHelper {
 
     private void calcExtraWidths() {
         leftTextExtraWidth = getLeftExtraWidth(text);
-        rightTextExtraWidth = getRightExtraWidth(text);
     }
 
     private int getLeftExtraWidth(String str) {
         int lsb = SwingUtilities2.getLeftSideBearing(mi, fm, str);
         if (lsb < 0) {
             return -lsb;
-        } else {
-            return 0;
-        }
-    }
-
-    private int getRightExtraWidth(String str) {
-        int rsb = SwingUtilities2.getRightSideBearing(mi, fm, str);
-        if (rsb > 0) {
-            return rsb;
         } else {
             return 0;
         }
@@ -313,7 +302,7 @@ public class MenuItemLayoutHelper {
                     verticalAlignment, horizontalAlignment,
                     verticalTextPosition, horizontalTextPosition,
                     viewRect, iconRect, textRect, gap);
-            textRect.width += leftTextExtraWidth + rightTextExtraWidth;
+            textRect.width += leftTextExtraWidth;
             Rectangle labelRect = iconRect.union(textRect);
             labelSize.height = labelRect.height;
             labelSize.width = labelRect.width;
@@ -1121,10 +1110,6 @@ public class MenuItemLayoutHelper {
         return leftTextExtraWidth;
     }
 
-    public int getRightTextExtraWidth() {
-        return rightTextExtraWidth;
-    }
-
     /**
      * Returns false if the component is a JMenu and it is a top
      * level menu (on the menubar).
--- a/src/share/classes/sun/swing/SwingUtilities2.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/classes/sun/swing/SwingUtilities2.java	Tue Sep 22 01:20:51 2009 -0700
@@ -27,7 +27,6 @@ package sun.swing;
 
 import java.security.*;
 import java.lang.reflect.*;
-import java.lang.ref.SoftReference;
 import java.awt.*;
 import static java.awt.RenderingHints.*;
 import java.awt.event.*;
@@ -78,17 +77,23 @@ public class SwingUtilities2 {
     public static final Object LAF_STATE_KEY =
             new StringBuffer("LookAndFeel State");
 
-    // Most of applications use 10 or less fonts simultaneously
-    private static final int STRONG_BEARING_CACHE_SIZE = 10;
-    // Strong cache for the left and right side bearings
-    // for STRONG_BEARING_CACHE_SIZE most recently used fonts.
-    private static BearingCacheEntry[] strongBearingCache =
-            new BearingCacheEntry[STRONG_BEARING_CACHE_SIZE];
-    // Next index to insert an entry into the strong bearing cache
-    private static int strongBearingCacheNextIndex = 0;
-    // Soft cache for the left and right side bearings
-    private static Set<SoftReference<BearingCacheEntry>> softBearingCache =
-            new HashSet<SoftReference<BearingCacheEntry>>();
+    // Maintain a cache of CACHE_SIZE fonts and the left side bearing
+     // of the characters falling into the range MIN_CHAR_INDEX to
+     // MAX_CHAR_INDEX. The values in fontCache are created as needed.
+     private static LSBCacheEntry[] fontCache;
+     // Windows defines 6 font desktop properties, we will therefore only
+     // cache the metrics for 6 fonts.
+     private static final int CACHE_SIZE = 6;
+     // nextIndex in fontCache to insert a font into.
+     private static int nextIndex;
+     // LSBCacheEntry used to search in fontCache to see if we already
+     // have an entry for a particular font
+     private static LSBCacheEntry searchKey;
+
+     // getLeftSideBearing will consult all characters that fall in the
+     // range MIN_CHAR_INDEX to MAX_CHAR_INDEX.
+     private static final int MIN_CHAR_INDEX = (int)'W';
+     private static final int MAX_CHAR_INDEX = (int)'W' + 1;
 
     public static final FontRenderContext DEFAULT_FRC =
         new FontRenderContext(null, false, false);
@@ -182,6 +187,10 @@ public class SwingUtilities2 {
     private static final int CHAR_BUFFER_SIZE = 100;
     private static final Object charsBufferLock = new Object();
     private static char[] charsBuffer = new char[CHAR_BUFFER_SIZE];
+
+    static {
+        fontCache = new LSBCacheEntry[CACHE_SIZE];
+    }
 
     /**
      * checks whether TextLayout is required to handle characters.
@@ -226,7 +235,9 @@ public class SwingUtilities2 {
 
     /**
      * Returns the left side bearing of the first character of string. The
-     * left side bearing is calculated from the passed in FontMetrics.
+     * left side bearing is calculated from the passed in
+     * FontMetrics.  If the passed in String is less than one
+     * character, this will throw a StringIndexOutOfBoundsException exception.
      *
      * @param c JComponent that will display the string
      * @param fm FontMetrics used to measure the String width
@@ -234,14 +245,11 @@ public class SwingUtilities2 {
      */
     public static int getLeftSideBearing(JComponent c, FontMetrics fm,
                                          String string) {
-        if ((string == null) || (string.length() == 0)) {
-            return 0;
-        }
         return getLeftSideBearing(c, fm, string.charAt(0));
     }
 
     /**
-     * Returns the left side bearing of the specified character. The
+     * Returns the left side bearing of the first character of string. The
      * left side bearing is calculated from the passed in FontMetrics.
      *
      * @param c JComponent that will display the string
@@ -250,105 +258,37 @@ public class SwingUtilities2 {
      */
     public static int getLeftSideBearing(JComponent c, FontMetrics fm,
                                          char firstChar) {
-        return getBearing(c, fm, firstChar, true);
-    }
-
-    /**
-     * Returns the right side bearing of the last character of string. The
-     * right side bearing is calculated from the passed in FontMetrics.
-     *
-     * @param c JComponent that will display the string
-     * @param fm FontMetrics used to measure the String width
-     * @param string String to get the right side bearing for.
-     */
-    public static int getRightSideBearing(JComponent c, FontMetrics fm,
-                                          String string) {
-        if ((string == null) || (string.length() == 0)) {
-            return 0;
-        }
-        return getRightSideBearing(c, fm, string.charAt(string.length() - 1));
-    }
-
-    /**
-     * Returns the right side bearing of the specified character. The
-     * right side bearing is calculated from the passed in FontMetrics.
-     *
-     * @param c JComponent that will display the string
-     * @param fm FontMetrics used to measure the String width
-     * @param lastChar Character to get the right side bearing for.
-     */
-    public static int getRightSideBearing(JComponent c, FontMetrics fm,
-                                         char lastChar) {
-        return getBearing(c, fm, lastChar, false);
-    }
-
-    /* Calculates the left and right side bearing for a character.
-     * Strongly caches bearings for STRONG_BEARING_CACHE_SIZE
-     * most recently used Fonts and softly caches as many as GC allows.
-     */
-    private static int getBearing(JComponent comp, FontMetrics fm, char c,
-                                  boolean isLeftBearing) {
-        if (fm == null) {
-            if (comp == null) {
-                return 0;
-            } else {
-                fm = comp.getFontMetrics(comp.getFont());
-            }
-        }
-        synchronized (SwingUtilities2.class) {
-            BearingCacheEntry entry = null;
-            BearingCacheEntry searchKey = new BearingCacheEntry(fm);
-            // See if we already have an entry in the strong cache
-            for (BearingCacheEntry cacheEntry : strongBearingCache) {
-                if (searchKey.equals(cacheEntry)) {
-                    entry = cacheEntry;
-                    break;
+        int charIndex = (int) firstChar;
+        if (charIndex < MAX_CHAR_INDEX && charIndex >= MIN_CHAR_INDEX) {
+            byte[] lsbs = null;
+
+            FontRenderContext frc = getFontRenderContext(c, fm);
+            Font font = fm.getFont();
+            synchronized (SwingUtilities2.class) {
+                LSBCacheEntry entry = null;
+                if (searchKey == null) {
+                    searchKey = new LSBCacheEntry(frc, font);
+                } else {
+                    searchKey.reset(frc, font);
                 }
-            }
-            // See if we already have an entry in the soft cache
-            if (entry == null) {
-                Iterator<SoftReference<BearingCacheEntry>> iter =
-                        softBearingCache.iterator();
-                while (iter.hasNext()) {
-                    BearingCacheEntry cacheEntry = iter.next().get();
-                    if (cacheEntry == null) {
-                        // Remove discarded soft reference from the cache
-                        iter.remove();
-                        continue;
-                    }
+                // See if we already have an entry for this pair
+                for (LSBCacheEntry cacheEntry : fontCache) {
                     if (searchKey.equals(cacheEntry)) {
                         entry = cacheEntry;
-                        putEntryInStrongCache(entry);
                         break;
                     }
                 }
-            }
-            if (entry == null) {
-                // No entry, add it
-                entry = searchKey;
-                cacheEntry(entry);
-            }
-            return (isLeftBearing)
-                    ? entry.getLeftSideBearing(c)
-                    : entry.getRightSideBearing(c);
-        }
-    }
-
-    private synchronized static void cacheEntry(BearingCacheEntry entry) {
-        // Move the oldest entry from the strong cache into the soft cache
-        BearingCacheEntry oldestEntry =
-                strongBearingCache[strongBearingCacheNextIndex];
-        if (oldestEntry != null) {
-            softBearingCache.add(new SoftReference<BearingCacheEntry>(oldestEntry));
-        }
-        // Put entry in the strong cache
-        putEntryInStrongCache(entry);
-    }
-
-    private synchronized static void putEntryInStrongCache(BearingCacheEntry entry) {
-        strongBearingCache[strongBearingCacheNextIndex] = entry;
-        strongBearingCacheNextIndex = (strongBearingCacheNextIndex + 1)
-                % STRONG_BEARING_CACHE_SIZE;
+                if (entry == null) {
+                    // No entry for this pair, add it.
+                    entry = searchKey;
+                    fontCache[nextIndex] = searchKey;
+                    searchKey = null;
+                    nextIndex = (nextIndex + 1) % CACHE_SIZE;
+                }
+                return entry.getLeftSideBearing(firstChar);
+            }
+        }
+        return 0;
     }
 
     /**
@@ -1063,99 +1003,72 @@ public class SwingUtilities2 {
     }
 
     /**
-     * BearingCacheEntry is used to cache left and right character bearings
-     * for a particular <code>Font</code> and <code>FontRenderContext</code>.
-     */
-    private static class BearingCacheEntry {
-        private FontMetrics fontMetrics;
+     * LSBCacheEntry is used to cache the left side bearing (lsb) for
+     * a particular <code>Font</code> and <code>FontRenderContext</code>.
+     * This only caches characters that fall in the range
+     * <code>MIN_CHAR_INDEX</code> to <code>MAX_CHAR_INDEX</code>.
+     */
+    private static class LSBCacheEntry {
+        // Used to indicate a particular entry in lsb has not been set.
+        private static final byte UNSET = Byte.MAX_VALUE;
+        // Used in creating a GlyphVector to get the lsb
+        private static final char[] oneChar = new char[1];
+
+        private byte[] lsbCache;
         private Font font;
         private FontRenderContext frc;
-        private Map<Character, Short> cache;
-        // Used for the creation of a GlyphVector
-        private static final char[] oneChar = new char[1];
-
-        public BearingCacheEntry(FontMetrics fontMetrics) {
-            this.fontMetrics = fontMetrics;
-            this.font = fontMetrics.getFont();
-            this.frc = fontMetrics.getFontRenderContext();
-            this.cache = new HashMap<Character, Short>();
-            assert (font != null && frc != null);
+
+
+        public LSBCacheEntry(FontRenderContext frc, Font font) {
+            lsbCache = new byte[MAX_CHAR_INDEX - MIN_CHAR_INDEX];
+            reset(frc, font);
+
+        }
+
+        public void reset(FontRenderContext frc, Font font) {
+            this.font = font;
+            this.frc = frc;
+            for (int counter = lsbCache.length - 1; counter >= 0; counter--) {
+                lsbCache[counter] = UNSET;
+            }
         }
 
         public int getLeftSideBearing(char aChar) {
-            Short bearing = cache.get(aChar);
-            if (bearing == null) {
-                bearing = calcBearing(aChar);
-                cache.put(aChar, bearing);
-            }
-            return ((0xFF00 & bearing) >>> 8) - 127;
-        }
-
-        public int getRightSideBearing(char aChar) {
-            Short bearing = cache.get(aChar);
-            if (bearing == null) {
-                bearing = calcBearing(aChar);
-                cache.put(aChar, bearing);
-            }
-            return (0xFF & bearing) - 127;
-        }
-
-        /* Calculates left and right side bearings for a character.
-         * Makes an assumption that bearing is a value between -127 and +127.
-         * Stores LSB and RSB as single two-byte number (short):
-         * LSB is the high byte, RSB is the low byte.
-         */
-        private short calcBearing(char aChar) {
-            oneChar[0] = aChar;
-            GlyphVector gv = font.createGlyphVector(frc, oneChar);
-            Rectangle pixelBounds = gv.getGlyphPixelBounds(0, frc, 0f, 0f);
-
-            // Get bearings
-            int lsb = pixelBounds.x;
-            int rsb = pixelBounds.width - fontMetrics.charWidth(aChar);
-
-            /* HRGB/HBGR LCD glyph images will always have a pixel
-             * on the left and a pixel on the right
-             * used in colour fringe reduction.
-             * Text rendering positions this correctly but here
-             * we are using the glyph image to adjust that position
-             * so must account for it.
-             */
-            if (lsb < 0) {
-                 Object aaHint = frc.getAntiAliasingHint();
-                 if (aaHint == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||
-                     aaHint == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
-                     lsb++;
-                 }
-            }
-            if (rsb > 0) {
-                 Object aaHint = frc.getAntiAliasingHint();
-                 if (aaHint == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||
-                     aaHint == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
-                     rsb--;
-                 }
-            }
-
-            // Make sure that LSB and RSB are valid (see 6472972)
-            if (lsb < -127 || lsb > 127) {
-                lsb = 0;
-            }
-            if (rsb < -127 || rsb > 127) {
-                rsb = 0;
-            }
-
-            int bearing = ((lsb + 127) << 8) + (rsb + 127);
-            return (short)bearing;
+            int index = aChar - MIN_CHAR_INDEX;
+            assert (index >= 0 && index < (MAX_CHAR_INDEX - MIN_CHAR_INDEX));
+            byte lsb = lsbCache[index];
+            if (lsb == UNSET) {
+                oneChar[0] = aChar;
+                GlyphVector gv = font.createGlyphVector(frc, oneChar);
+                lsb = (byte) gv.getGlyphPixelBounds(0, frc, 0f, 0f).x;
+                if (lsb < 0) {
+                    /* HRGB/HBGR LCD glyph images will always have a pixel
+                     * on the left used in colour fringe reduction.
+                     * Text rendering positions this correctly but here
+                     * we are using the glyph image to adjust that position
+                     * so must account for it.
+                     */
+                    Object aaHint = frc.getAntiAliasingHint();
+                    if (aaHint == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||
+                            aaHint == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
+                        lsb++;
+                    }
+                }
+                lsbCache[index] = lsb;
+            }
+            return lsb;
+
+
         }
 
         public boolean equals(Object entry) {
             if (entry == this) {
                 return true;
             }
-            if (!(entry instanceof BearingCacheEntry)) {
+            if (!(entry instanceof LSBCacheEntry)) {
                 return false;
             }
-            BearingCacheEntry oEntry = (BearingCacheEntry)entry;
+            LSBCacheEntry oEntry = (LSBCacheEntry) entry;
             return (font.equals(oEntry.font) &&
                     frc.equals(oEntry.frc));
         }
@@ -1172,7 +1085,6 @@ public class SwingUtilities2 {
         }
     }
 
-
     /*
      * here goes the fix for 4856343 [Problem with applet interaction
      * with system selection clipboard]
@@ -1181,36 +1093,34 @@ public class SwingUtilities2 {
      * are to be performed
      */
 
-
-    /**
-     * checks the security permissions for accessing system clipboard
-     *
-     * for untrusted context (see isTrustedContext) checks the
-     * permissions for the current event being handled
-     *
-     */
-    public static boolean canAccessSystemClipboard() {
-        boolean canAccess = false;
-        if (!GraphicsEnvironment.isHeadless()) {
-            SecurityManager sm = System.getSecurityManager();
-            if (sm == null) {
-                canAccess = true;
-            } else {
-                try {
-                    sm.checkSystemClipboardAccess();
-                    canAccess = true;
-                } catch (SecurityException e) {
-                }
-                if (canAccess && ! isTrustedContext()) {
-                    canAccess = canCurrentEventAccessSystemClipboard(true);
-                }
-            }
-        }
-        return canAccess;
-    }
-
-    /**
-     * Returns true if EventQueue.getCurrentEvent() has the permissions to
+    /**
+    * checks the security permissions for accessing system clipboard
+    *
+    * for untrusted context (see isTrustedContext) checks the
+    * permissions for the current event being handled
+    *
+    */
+   public static boolean canAccessSystemClipboard() {
+       boolean canAccess = false;
+       if (!GraphicsEnvironment.isHeadless()) {
+           SecurityManager sm = System.getSecurityManager();
+           if (sm == null) {
+               canAccess = true;
+           } else {
+               try {
+                   sm.checkSystemClipboardAccess();
+                   canAccess = true;
+               } catch (SecurityException e) {
+               }
+               if (canAccess && ! isTrustedContext()) {
+                   canAccess = canCurrentEventAccessSystemClipboard(true);
+               }
+           }
+       }
+       return canAccess;
+   }
+    /**
+    * Returns true if EventQueue.getCurrentEvent() has the permissions to
      * access the system clipboard
      */
     public static boolean canCurrentEventAccessSystemClipboard() {
@@ -1844,4 +1754,22 @@ public class SwingUtilities2 {
                                          boolean three) {
         return liesIn(rect, p, false, false, three);
     }
+
+    /**
+     * Returns the {@code JViewport} instance for the {@code component}
+     * or {@code null}.
+     *
+     * @return the {@code JViewport} instance for the {@code component}
+     * or {@code null}
+     * @throws NullPointerException if {@code component} is {@code null}
+     */
+    public static JViewport getViewport(Component component) {
+        do {
+            component = component.getParent();
+            if (component instanceof JViewport) {
+                return (JViewport) component;
+            }
+        } while(component instanceof JLayer);
+        return null;
+    }
 }
--- a/src/share/native/sun/security/ec/ec.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/native/sun/security/ec/ec.c	Tue Sep 22 01:20:51 2009 -0700
@@ -422,7 +422,7 @@ ec_GenerateRandomPrivateKey(const unsign
      */
     if ((privKeyBytes = PORT_Alloc(2*len, kmflag)) == NULL) goto cleanup;
     if (randomlen != 2 * len) {
-        goto cleanup;
+        randomlen = 2 * len;
     }
     /* No need to generate - random bytes are now supplied */
     /* CHECK_SEC_OK( RNG_GenerateGlobalRandomBytes(privKeyBytes, 2*len) );*/
--- a/src/share/sample/nio/file/Xdd.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/sample/nio/file/Xdd.java	Tue Sep 22 01:20:51 2009 -0700
@@ -57,9 +57,9 @@ public class Xdd {
         Path file = (args.length == 1) ?
             Paths.get(args[0]) : Paths.get(args[2]);
 
-        // check that user defined attributes are supported by the file system
+        // check that user defined attributes are supported by the file store
         FileStore store = file.getFileStore();
-        if (!store.supportsFileAttributeView("user")) {
+        if (!store.supportsFileAttributeView(UserDefinedFileAttributeView.class)) {
             System.err.format("UserDefinedFileAttributeView not supported on %s\n", store);
             System.exit(-1);
 
--- a/src/share/transport/socket/socketTransport.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/share/transport/socket/socketTransport.c	Tue Sep 22 01:20:51 2009 -0700
@@ -134,15 +134,16 @@ setOptions(int fd)
 
 static jdwpTransportError
 handshake(int fd, jlong timeout) {
-    char *hello = "JDWP-Handshake";
+    const char *hello = "JDWP-Handshake";
     char b[16];
-    int rv, received, i;
+    int rv, helloLen, received;
 
     if (timeout > 0) {
         dbgsysConfigureBlocking(fd, JNI_FALSE);
     }
+    helloLen = (int)strlen(hello);
     received = 0;
-    while (received < (int)strlen(hello)) {
+    while (received < helloLen) {
         int n;
         char *buf;
         if (timeout > 0) {
@@ -154,7 +155,7 @@ handshake(int fd, jlong timeout) {
         }
         buf = b;
         buf += received;
-        n = dbgsysRecv(fd, buf, (int)strlen(hello)-received, 0);
+        n = dbgsysRecv(fd, buf, helloLen-received, 0);
         if (n == 0) {
             setLastError(0, "handshake failed - connection prematurally closed");
             return JDWPTRANSPORT_ERROR_IO_ERROR;
@@ -167,20 +168,19 @@ handshake(int fd, jlong timeout) {
     if (timeout > 0) {
         dbgsysConfigureBlocking(fd, JNI_TRUE);
     }
-    for (i=0; i<(int)strlen(hello); i++) {
-        if (b[i] != hello[i]) {
-            char msg[64];
-            strcpy(msg, "handshake failed - received >");
-            strncat(msg, b, strlen(hello));
-            strcat(msg, "< - excepted >");
-            strcat(msg, hello);
-            strcat(msg, "<");
-            setLastError(0, msg);
-            return JDWPTRANSPORT_ERROR_IO_ERROR;
-        }
-    }
-
-    if (dbgsysSend(fd, hello, (int)strlen(hello), 0) != (int)strlen(hello)) {
+    if (strncmp(b, hello, received) != 0) {
+        char msg[80+2*16];
+        b[received] = '\0';
+        /*
+         * We should really use snprintf here but it's not available on Windows.
+         * We can't use jio_snprintf without linking the transport against the VM.
+         */
+        sprintf(msg, "handshake failed - received >%s< - expected >%s<", b, hello);
+        setLastError(0, msg);
+        return JDWPTRANSPORT_ERROR_IO_ERROR;
+    }
+
+    if (dbgsysSend(fd, (char*)hello, helloLen, 0) != helloLen) {
         RETURN_IO_ERROR("send failed during handshake");
     }
     return JDWPTRANSPORT_ERROR_NONE;
--- a/src/solaris/classes/sun/nio/ch/EPollPort.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/ch/EPollPort.java	Tue Sep 22 01:20:51 2009 -0700
@@ -248,12 +248,13 @@ final class EPollPort
         public void run() {
             Invoker.GroupAndInvokeCount myGroupAndInvokeCount =
                 Invoker.getGroupAndInvokeCount();
+            final boolean isPooledThread = (myGroupAndInvokeCount != null);
             boolean replaceMe = false;
             Event ev;
             try {
                 for (;;) {
                     // reset invoke count
-                    if (myGroupAndInvokeCount != null)
+                    if (isPooledThread)
                         myGroupAndInvokeCount.resetInvokeCount();
 
                     try {
@@ -289,7 +290,7 @@ final class EPollPort
 
                     // process event
                     try {
-                        ev.channel().onEvent(ev.events());
+                        ev.channel().onEvent(ev.events(), isPooledThread);
                     } catch (Error x) {
                         replaceMe = true; throw x;
                     } catch (RuntimeException x) {
--- a/src/solaris/classes/sun/nio/ch/Port.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/ch/Port.java	Tue Sep 22 01:20:51 2009 -0700
@@ -49,7 +49,7 @@ abstract class Port extends Asynchronous
      * Implemented by clients registered with this port.
      */
     interface PollableChannel extends Closeable {
-        void onEvent(int events);
+        void onEvent(int events, boolean mayInvokeDirect);
     }
 
     // maps fd to "pollable" channel
@@ -121,7 +121,7 @@ abstract class Port extends Asynchronous
     final Object attachForeignChannel(final Channel channel, FileDescriptor fd) {
         int fdVal = IOUtil.fdVal(fd);
         register(fdVal, new PollableChannel() {
-            public void onEvent(int events) { }
+            public void onEvent(int events, boolean mayInvokeDirect) { }
             public void close() throws IOException {
                 channel.close();
             }
--- a/src/solaris/classes/sun/nio/ch/SolarisEventPort.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/ch/SolarisEventPort.java	Tue Sep 22 01:20:51 2009 -0700
@@ -151,12 +151,13 @@ class SolarisEventPort
         public void run() {
             Invoker.GroupAndInvokeCount myGroupAndInvokeCount =
                 Invoker.getGroupAndInvokeCount();
+            final boolean isPooledThread = (myGroupAndInvokeCount != null);
             boolean replaceMe = false;
             long address = unsafe.allocateMemory(SIZEOF_PORT_EVENT);
             try {
                 for (;;) {
                     // reset invoke count
-                    if (myGroupAndInvokeCount != null)
+                    if (isPooledThread)
                         myGroupAndInvokeCount.resetInvokeCount();
 
                     // wait for I/O completion event
@@ -205,7 +206,7 @@ class SolarisEventPort
                     if (ch != null) {
                         replaceMe = true;
                         // no need to translate events
-                        ch.onEvent(events);
+                        ch.onEvent(events, isPooledThread);
                     }
                 }
             } finally {
--- a/src/solaris/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -59,10 +59,13 @@ class UnixAsynchronousServerSocketChanne
     private final Object updateLock = new Object();
 
     // pending accept
-    private PendingFuture<AsynchronousSocketChannel,Object> pendingAccept;
+    private boolean acceptPending;
+    private CompletionHandler<AsynchronousSocketChannel,Object> acceptHandler;
+    private Object acceptAttachment;
+    private PendingFuture<AsynchronousSocketChannel,Object> acceptFuture;
 
     // context for permission check when security manager set
-    private AccessControlContext acc;
+    private AccessControlContext acceptAcc;
 
 
     UnixAsynchronousServerSocketChannelImpl(Port port)
@@ -83,15 +86,6 @@ class UnixAsynchronousServerSocketChanne
         port.register(fdVal, this);
     }
 
-    // returns and clears the result of a pending accept
-    private PendingFuture<AsynchronousSocketChannel,Object> grabPendingAccept() {
-        synchronized (updateLock) {
-            PendingFuture<AsynchronousSocketChannel,Object> result = pendingAccept;
-            pendingAccept = null;
-            return result;
-        }
-    }
-
     @Override
     void implClose() throws IOException {
         // remove the mapping
@@ -101,17 +95,27 @@ class UnixAsynchronousServerSocketChanne
         nd.close(fd);
 
         // if there is a pending accept then complete it
-        final PendingFuture<AsynchronousSocketChannel,Object> result =
-            grabPendingAccept();
-        if (result != null) {
-            // discard the stack trace as otherwise it may appear that implClose
-            // has thrown the exception.
-            AsynchronousCloseException x = new AsynchronousCloseException();
-            x.setStackTrace(new StackTraceElement[0]);
-            result.setFailure(x);
-
+        CompletionHandler<AsynchronousSocketChannel,Object> handler;
+        Object att;
+        PendingFuture<AsynchronousSocketChannel,Object> future;
+        synchronized (updateLock) {
+            if (!acceptPending)
+                return;  // no pending accept
+            acceptPending = false;
+            handler = acceptHandler;
+            att = acceptAttachment;
+            future = acceptFuture;
+        }
+
+        // discard the stack trace as otherwise it may appear that implClose
+        // has thrown the exception.
+        AsynchronousCloseException x = new AsynchronousCloseException();
+        x.setStackTrace(new StackTraceElement[0]);
+        if (handler == null) {
+            future.setFailure(x);
+        } else {
             // invoke by submitting task rather than directly
-            Invoker.invokeIndirectly(result.handler(), result);
+            Invoker.invokeIndirectly(this, handler, att, null, x);
         }
     }
 
@@ -124,15 +128,17 @@ class UnixAsynchronousServerSocketChanne
      * Invoked by event handling thread when listener socket is polled
      */
     @Override
-    public void onEvent(int events) {
-        PendingFuture<AsynchronousSocketChannel,Object> result = grabPendingAccept();
-        if (result == null)
-            return; // may have been grabbed by asynchronous close
+    public void onEvent(int events, boolean mayInvokeDirect) {
+        synchronized (updateLock) {
+            if (!acceptPending)
+                return;  // may have been grabbed by asynchronous close
+            acceptPending = false;
+        }
 
         // attempt to accept connection
         FileDescriptor newfd = new FileDescriptor();
         InetSocketAddress[] isaa = new InetSocketAddress[1];
-        boolean accepted = false;
+        Throwable exc = null;
         try {
             begin();
             int n = accept0(this.fd, newfd, isaa);
@@ -140,49 +146,52 @@ class UnixAsynchronousServerSocketChanne
             // spurious wakeup, is this possible?
             if (n == IOStatus.UNAVAILABLE) {
                 synchronized (updateLock) {
-                    this.pendingAccept = result;
+                    acceptPending = true;
                 }
                 port.startPoll(fdVal, Port.POLLIN);
                 return;
             }
 
-            // connection accepted
-            accepted = true;
-
         } catch (Throwable x) {
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            enableAccept();
-            result.setFailure(x);
+            exc = x;
         } finally {
             end();
         }
 
         // Connection accepted so finish it when not holding locks.
         AsynchronousSocketChannel child = null;
-        if (accepted) {
+        if (exc == null) {
             try {
-                child = finishAccept(newfd, isaa[0], acc);
-                enableAccept();
-                result.setResult(child);
+                child = finishAccept(newfd, isaa[0], acceptAcc);
             } catch (Throwable x) {
-                enableAccept();
                 if (!(x instanceof IOException) && !(x instanceof SecurityException))
                     x = new IOException(x);
-                result.setFailure(x);
-            }
-        }
-
-        // if an async cancel has already cancelled the operation then
-        // close the new channel so as to free resources
-        if (child != null && result.isCancelled()) {
-            try {
-                child.close();
-            } catch (IOException ignore) { }
-        }
-
-        // invoke the handler
-        Invoker.invoke(result.handler(), result);
+                exc = x;
+            }
+        }
+
+        // copy field befores accept is re-renabled
+        CompletionHandler<AsynchronousSocketChannel,Object> handler = acceptHandler;
+        Object att = acceptAttachment;
+        PendingFuture<AsynchronousSocketChannel,Object> future = acceptFuture;
+
+        // re-enable accepting and invoke handler
+        enableAccept();
+
+        if (handler == null) {
+            future.setResult(child, exc);
+            // if an async cancel has already cancelled the operation then
+            // close the new channel so as to free resources
+            if (child != null && future.isCancelled()) {
+                try {
+                    child.close();
+                } catch (IOException ignore) { }
+            }
+        } else {
+            Invoker.invoke(this, handler, att, child, exc);
+        }
     }
 
     /**
@@ -234,16 +243,18 @@ class UnixAsynchronousServerSocketChanne
     }
 
     @Override
-    @SuppressWarnings("unchecked")
-    public <A> Future<AsynchronousSocketChannel> accept(A attachment,
-        final CompletionHandler<AsynchronousSocketChannel,? super A> handler)
+    Future<AsynchronousSocketChannel> implAccept(Object att,
+        CompletionHandler<AsynchronousSocketChannel,Object> handler)
     {
         // complete immediately if channel is closed
         if (!isOpen()) {
-            CompletedFuture<AsynchronousSocketChannel,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invokeIndirectly(handler, result);
-            return result;
+            Throwable e = new ClosedChannelException();
+            if (handler == null) {
+                return CompletedFuture.withFailure(e);
+            } else {
+                Invoker.invoke(this, handler, att, null, e);
+                return null;
+            }
         }
         if (localAddress == null)
             throw new NotYetBoundException();
@@ -258,25 +269,31 @@ class UnixAsynchronousServerSocketChanne
             throw new AcceptPendingException();
 
         // attempt accept
-        AbstractFuture<AsynchronousSocketChannel,A> result = null;
         FileDescriptor newfd = new FileDescriptor();
         InetSocketAddress[] isaa = new InetSocketAddress[1];
+        Throwable exc = null;
         try {
             begin();
 
             int n = accept0(this.fd, newfd, isaa);
             if (n == IOStatus.UNAVAILABLE) {
-                // no connection to accept
-                result = new PendingFuture<AsynchronousSocketChannel,A>(this, handler, attachment);
 
                 // need calling context when there is security manager as
                 // permission check may be done in a different thread without
                 // any application call frames on the stack
-                synchronized (this) {
-                    this.acc = (System.getSecurityManager() == null) ?
+                PendingFuture<AsynchronousSocketChannel,Object> result = null;
+                synchronized (updateLock) {
+                    if (handler == null) {
+                        this.acceptHandler = null;
+                        result = new PendingFuture<AsynchronousSocketChannel,Object>(this);
+                        this.acceptFuture = result;
+                    } else {
+                        this.acceptHandler = handler;
+                        this.acceptAttachment = att;
+                    }
+                    this.acceptAcc = (System.getSecurityManager() == null) ?
                         null : AccessController.getContext();
-                    this.pendingAccept =
-                        (PendingFuture<AsynchronousSocketChannel,Object>)result;
+                    this.acceptPending = true;
                 }
 
                 // register for connections
@@ -287,25 +304,30 @@ class UnixAsynchronousServerSocketChanne
             // accept failed
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            result = CompletedFuture.withFailure(this, x, attachment);
+            exc = x;
         } finally {
             end();
         }
 
-        // connection accepted immediately
-        if (result == null) {
+        AsynchronousSocketChannel child = null;
+        if (exc == null) {
+            // connection accepted immediately
             try {
-                AsynchronousSocketChannel ch = finishAccept(newfd, isaa[0], null);
-                result = CompletedFuture.withResult(this, ch, attachment);
+                child = finishAccept(newfd, isaa[0], null);
             } catch (Throwable x) {
-                result = CompletedFuture.withFailure(this, x, attachment);
-            }
-        }
-
-        // re-enable accepting and invoke handler
+                exc = x;
+            }
+        }
+
+        // re-enable accepting before invoking handler
         enableAccept();
-        Invoker.invokeIndirectly(handler, result);
-        return result;
+
+        if (handler == null) {
+            return CompletedFuture.withResult(child, exc);
+        } else {
+            Invoker.invokeIndirectly(this, handler, att, child, exc);
+            return null;
+        }
     }
 
     // -- Native methods --
--- a/src/solaris/classes/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -61,20 +61,33 @@ class UnixAsynchronousSocketChannelImpl
     private final Object updateLock = new Object();
 
     // pending connect (updateLock)
-    private PendingFuture<Void,Object> pendingConnect;
-
-    // pending remote address (statLock)
+    private boolean connectPending;
+    private CompletionHandler<Void,Object> connectHandler;
+    private Object connectAttachment;
+    private PendingFuture<Void,Object> connectFuture;
+
+    // pending remote address (stateLock)
     private SocketAddress pendingRemote;
 
     // pending read (updateLock)
+    private boolean readPending;
+    private boolean isScatteringRead;
+    private ByteBuffer readBuffer;
     private ByteBuffer[] readBuffers;
-    private boolean scatteringRead;
-    private PendingFuture<Number,Object> pendingRead;
+    private CompletionHandler<Number,Object> readHandler;
+    private Object readAttachment;
+    private PendingFuture<Number,Object> readFuture;
+    private Future<?> readTimer;
 
     // pending write (updateLock)
+    private boolean writePending;
+    private boolean isGatheringWrite;
+    private ByteBuffer writeBuffer;
     private ByteBuffer[] writeBuffers;
-    private boolean gatheringWrite;
-    private PendingFuture<Number,Object> pendingWrite;
+    private CompletionHandler<Number,Object> writeHandler;
+    private Object writeAttachment;
+    private PendingFuture<Number,Object> writeFuture;
+    private Future<?> writeTimer;
 
 
     UnixAsynchronousSocketChannelImpl(Port port)
@@ -128,80 +141,69 @@ class UnixAsynchronousSocketChannelImpl
     private void updateEvents() {
         assert Thread.holdsLock(updateLock);
         int events = 0;
-        if (pendingRead != null)
+        if (readPending)
             events |= Port.POLLIN;
-        if (pendingConnect != null || pendingWrite != null)
+        if (connectPending || writePending)
             events |= Port.POLLOUT;
         if (events != 0)
             port.startPoll(fdVal, events);
+    }
+
+    // invoke to finish read and/or write operations
+    private void finish(boolean mayInvokeDirect,
+                        boolean readable,
+                        boolean writable)
+    {
+        boolean finishRead = false;
+        boolean finishWrite = false;
+        boolean finishConnect = false;
+
+        // map event to pending result
+        synchronized (updateLock) {
+            if (readable && this.readPending) {
+                this.readPending = false;
+                finishRead = true;
+            }
+            if (writable) {
+                if (this.writePending) {
+                    this.writePending = false;
+                    finishWrite = true;
+                } else if (this.connectPending) {
+                    this.connectPending = false;
+                    finishConnect = true;
+                }
+            }
+        }
+
+        // complete the I/O operation. Special case for when channel is
+        // ready for both reading and writing. In that case, submit task to
+        // complete write if write operation has a completion handler.
+        if (finishRead) {
+            if (finishWrite)
+                finishWrite(false);
+            finishRead(mayInvokeDirect);
+            return;
+        }
+        if (finishWrite) {
+            finishWrite(mayInvokeDirect);
+        }
+        if (finishConnect) {
+            finishConnect(mayInvokeDirect);
+        }
     }
 
     /**
      * Invoked by event handler thread when file descriptor is polled
      */
     @Override
-    public void onEvent(int events) {
+    public void onEvent(int events, boolean mayInvokeDirect) {
         boolean readable = (events & Port.POLLIN) > 0;
         boolean writable = (events & Port.POLLOUT) > 0;
         if ((events & (Port.POLLERR | Port.POLLHUP)) > 0) {
             readable = true;
             writable = true;
         }
-
-        PendingFuture<Void,Object> connectResult = null;
-        PendingFuture<Number,Object> readResult = null;
-        PendingFuture<Number,Object> writeResult = null;
-
-        // map event to pending result
-        synchronized (updateLock) {
-            if (readable && (pendingRead != null)) {
-                readResult = pendingRead;
-                pendingRead = null;
-            }
-            if (writable) {
-                if (pendingWrite != null) {
-                    writeResult = pendingWrite;
-                    pendingWrite = null;
-                } else if (pendingConnect != null) {
-                    connectResult = pendingConnect;
-                    pendingConnect = null;
-                }
-            }
-        }
-
-        // complete the I/O operation. Special case for when channel is
-        // ready for both reading and writing. In that case, submit task to
-        // complete write if write operation has a completion handler.
-        if (readResult != null) {
-            if (writeResult != null)
-                finishWrite(writeResult, false);
-            finishRead(readResult, true);
-            return;
-        }
-        if (writeResult != null) {
-            finishWrite(writeResult, true);
-        }
-        if (connectResult != null) {
-            finishConnect(connectResult, true);
-        }
-    }
-
-    // returns and clears the result of a pending read
-    PendingFuture<Number,Object> grabPendingRead() {
-        synchronized (updateLock) {
-            PendingFuture<Number,Object> result = pendingRead;
-            pendingRead = null;
-            return result;
-        }
-    }
-
-    // returns and clears the result of a pending write
-    PendingFuture<Number,Object> grabPendingWrite() {
-        synchronized (updateLock) {
-            PendingFuture<Number,Object> result = pendingWrite;
-            pendingWrite = null;
-            return result;
-        }
+        finish(mayInvokeDirect, readable, writable);
     }
 
     @Override
@@ -213,26 +215,7 @@ class UnixAsynchronousSocketChannelImpl
         nd.close(fd);
 
         // All outstanding I/O operations are required to fail
-        final PendingFuture<Void,Object> readyToConnect;
-        final PendingFuture<Number,Object> readyToRead;
-        final PendingFuture<Number,Object> readyToWrite;
-        synchronized (updateLock) {
-            readyToConnect = pendingConnect;
-            pendingConnect = null;
-            readyToRead = pendingRead;
-            pendingRead = null;
-            readyToWrite = pendingWrite;
-            pendingWrite = null;
-        }
-        if (readyToConnect != null) {
-            finishConnect(readyToConnect, false);
-        }
-        if (readyToRead != null) {
-            finishRead(readyToRead, false);
-        }
-        if (readyToWrite != null) {
-            finishWrite(readyToWrite, false);
-        }
+        finish(false, true, true);
     }
 
     @Override
@@ -240,9 +223,9 @@ class UnixAsynchronousSocketChannelImpl
         if (task.getContext() == OpType.CONNECT)
             killConnect();
         if (task.getContext() == OpType.READ)
-            killConnect();
+            killReading();
         if (task.getContext() == OpType.WRITE)
-            killConnect();
+            killWriting();
     }
 
     // -- connect --
@@ -255,15 +238,12 @@ class UnixAsynchronousSocketChannelImpl
         }
     }
 
-    private void finishConnect(PendingFuture<Void,Object> result,
-                               boolean invokeDirect)
-    {
+    private void finishConnect(boolean mayInvokeDirect) {
         Throwable e = null;
         try {
             begin();
             checkConnect(fdVal);
             setConnected();
-            result.setResult(null);
         } catch (Throwable x) {
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
@@ -276,26 +256,38 @@ class UnixAsynchronousSocketChannelImpl
             try {
                 close();
             } catch (IOException ignore) { }
-            result.setFailure(e);
-        }
-        if (invokeDirect) {
-            Invoker.invoke(result.handler(), result);
+        }
+
+
+        // invoke handler and set result
+        CompletionHandler<Void,Object> handler = connectHandler;
+        Object att = connectAttachment;
+        PendingFuture<Void,Object> future = connectFuture;
+        if (handler == null) {
+            future.setResult(null, e);
         } else {
-            Invoker.invokeIndirectly(result.handler(), result);
+            if (mayInvokeDirect) {
+                Invoker.invokeUnchecked(handler, att, null, e);
+            } else {
+                Invoker.invokeIndirectly(this, handler, att, null, e);
+            }
         }
     }
 
     @Override
     @SuppressWarnings("unchecked")
-    public <A> Future<Void> connect(SocketAddress remote,
-                                    A attachment,
-                                    CompletionHandler<Void,? super A> handler)
+    <A> Future<Void> implConnect(SocketAddress remote,
+                                 A attachment,
+                                 CompletionHandler<Void,? super A> handler)
     {
         if (!isOpen()) {
-            CompletedFuture<Void,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable e = new ClosedChannelException();
+            if (handler == null) {
+                return CompletedFuture.withFailure(e);
+            } else {
+                Invoker.invoke(this, handler, attachment, null, e);
+                return null;
+            }
         }
 
         InetSocketAddress isa = Net.checkAddress(remote);
@@ -317,7 +309,6 @@ class UnixAsynchronousSocketChannelImpl
             notifyBeforeTcpConnect = (localAddress == null);
         }
 
-        AbstractFuture<Void,A> result = null;
         Throwable e = null;
         try {
             begin();
@@ -327,15 +318,21 @@ class UnixAsynchronousSocketChannelImpl
             int n = Net.connect(fd, isa.getAddress(), isa.getPort());
             if (n == IOStatus.UNAVAILABLE) {
                 // connection could not be established immediately
-                result = new PendingFuture<Void,A>(this, handler, attachment, OpType.CONNECT);
+                PendingFuture<Void,A> result = null;
                 synchronized (updateLock) {
-                    this.pendingConnect = (PendingFuture<Void,Object>)result;
+                    if (handler == null) {
+                        result = new PendingFuture<Void,A>(this, OpType.CONNECT);
+                        this.connectFuture = (PendingFuture<Void,Object>)result;
+                    } else {
+                        this.connectHandler = (CompletionHandler<Void,Object>)handler;
+                        this.connectAttachment = attachment;
+                    }
+                    this.connectPending = true;
                     updateEvents();
                 }
                 return result;
             }
             setConnected();
-            result = CompletedFuture.withResult(this, null, attachment);
         } catch (Throwable x) {
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
@@ -349,84 +346,111 @@ class UnixAsynchronousSocketChannelImpl
             try {
                 close();
             } catch (IOException ignore) { }
-            result = CompletedFuture.withFailure(this, e, attachment);
-        }
-
-        Invoker.invoke(handler, result);
-        return result;
+        }
+        if (handler == null) {
+            return CompletedFuture.withResult(null, e);
+        } else {
+            Invoker.invoke(this, handler, attachment, null, e);
+            return null;
+        }
     }
 
     // -- read --
 
-    @SuppressWarnings("unchecked")
-    private void finishRead(PendingFuture<Number,Object> result,
-                            boolean invokeDirect)
-    {
+    private void finishRead(boolean mayInvokeDirect) {
         int n = -1;
-        PendingFuture<Number,Object> pending = null;
+        Throwable exc = null;
+
+        // copy fields as we can't access them after reading is re-enabled.
+        boolean scattering = isScatteringRead;
+        CompletionHandler<Number,Object> handler = readHandler;
+        Object att = readAttachment;
+        PendingFuture<Number,Object> future = readFuture;
+        Future<?> timeout = readTimer;
+
         try {
             begin();
 
-            ByteBuffer[] dsts = readBuffers;
-            if (dsts.length == 1) {
-                n = IOUtil.read(fd, dsts[0], -1, nd, null);
-            } else {
-                n = (int)IOUtil.read(fd, dsts, nd);
+            if (scattering) {
+                n = (int)IOUtil.read(fd, readBuffers, nd);
+            } else {
+                n = IOUtil.read(fd, readBuffer, -1, nd, null);
             }
             if (n == IOStatus.UNAVAILABLE) {
                 // spurious wakeup, is this possible?
-                pending = result;
+                synchronized (updateLock) {
+                    readPending = true;
+                }
                 return;
             }
 
-            // allow buffer(s) to be GC'ed.
-            readBuffers = null;
+            // allow objects to be GC'ed.
+            this.readBuffer = null;
+            this.readBuffers = null;
+            this.readAttachment = null;
 
             // allow another read to be initiated
-            boolean wasScatteringRead = scatteringRead;
             enableReading();
-
-            // result is Integer or Long
-            if (wasScatteringRead) {
-                result.setResult(Long.valueOf(n));
-            } else {
-                result.setResult(Integer.valueOf(n));
-            }
 
         } catch (Throwable x) {
             enableReading();
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            result.setFailure(x);
+            exc = x;
         } finally {
             // restart poll in case of concurrent write
             synchronized (updateLock) {
-                if (pending != null)
-                    this.pendingRead = pending;
                 updateEvents();
             }
             end();
         }
 
-        if (invokeDirect) {
-            Invoker.invoke(result.handler(), result);
+        // cancel the associated timer
+        if (timeout != null)
+            timeout.cancel(false);
+
+        // create result
+        Number result = (exc != null) ? null : (scattering) ?
+            (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
+
+        // invoke handler or set result
+        if (handler == null) {
+            future.setResult(result, exc);
         } else {
-            Invoker.invokeIndirectly(result.handler(), result);
+            if (mayInvokeDirect) {
+                Invoker.invokeUnchecked(handler, att, result, exc);
+            } else {
+                Invoker.invokeIndirectly(this, handler, att, result, exc);
+            }
         }
     }
 
     private Runnable readTimeoutTask = new Runnable() {
         public void run() {
-            PendingFuture<Number,Object> result = grabPendingRead();
-            if (result == null)
-                return;     // already completed
+            CompletionHandler<Number,Object> handler = null;
+            Object att = null;
+            PendingFuture<Number,Object> future = null;
+
+            synchronized (updateLock) {
+                if (!readPending)
+                    return;
+                readPending = false;
+                handler = readHandler;
+                att = readAttachment;
+                future = readFuture;
+            }
 
             // kill further reading before releasing waiters
             enableReading(true);
 
-            // set completed and invoke handler
-            result.setFailure(new InterruptedByTimeoutException());
-            Invoker.invokeIndirectly(result.handler(), result);
+            // invoke handler or set result
+            Exception exc = new InterruptedByTimeoutException();
+            if (handler == null) {
+                future.setFailure(exc);
+            } else {
+                AsynchronousChannel ch = UnixAsynchronousSocketChannelImpl.this;
+                Invoker.invokeIndirectly(ch, handler, att, null, exc);
+            }
         }
     };
 
@@ -435,8 +459,9 @@ class UnixAsynchronousSocketChannelImpl
      */
     @Override
     @SuppressWarnings("unchecked")
-    <V extends Number,A> Future<V> readImpl(ByteBuffer[] dsts,
-                                            boolean isScatteringRead,
+    <V extends Number,A> Future<V> implRead(boolean isScatteringRead,
+                                            ByteBuffer dst,
+                                            ByteBuffer[] dsts,
                                             long timeout,
                                             TimeUnit unit,
                                             A attachment,
@@ -450,144 +475,178 @@ class UnixAsynchronousSocketChannelImpl
         boolean invokeDirect = false;
         boolean attemptRead = false;
         if (!disableSynchronousRead) {
-            myGroupAndInvokeCount = Invoker.getGroupAndInvokeCount();
-            invokeDirect = Invoker.mayInvokeDirect(myGroupAndInvokeCount, port);
-            attemptRead = (handler == null) || invokeDirect ||
-                !port.isFixedThreadPool();  // okay to attempt read with user thread pool
-        }
-
-        AbstractFuture<V,A> result;
+            if (handler == null) {
+                attemptRead = true;
+            } else {
+                myGroupAndInvokeCount = Invoker.getGroupAndInvokeCount();
+                invokeDirect = Invoker.mayInvokeDirect(myGroupAndInvokeCount, port);
+                // okay to attempt read with user thread pool
+                attemptRead = invokeDirect || !port.isFixedThreadPool();
+            }
+        }
+
+        int n = IOStatus.UNAVAILABLE;
+        Throwable exc = null;
+        boolean pending = false;
+
         try {
             begin();
 
-            int n;
             if (attemptRead) {
                 if (isScatteringRead) {
                     n = (int)IOUtil.read(fd, dsts, nd);
                 } else {
-                    n = IOUtil.read(fd, dsts[0], -1, nd, null);
-                }
-            } else {
-                n = IOStatus.UNAVAILABLE;
+                    n = IOUtil.read(fd, dst, -1, nd, null);
+                }
             }
 
             if (n == IOStatus.UNAVAILABLE) {
-                result = new PendingFuture<V,A>(this, handler, attachment, OpType.READ);
-
-                // update evetns so that read will complete asynchronously
+                PendingFuture<V,A> result = null;
                 synchronized (updateLock) {
+                    this.isScatteringRead = isScatteringRead;
+                    this.readBuffer = dst;
                     this.readBuffers = dsts;
-                    this.scatteringRead = isScatteringRead;
-                    this.pendingRead = (PendingFuture<Number,Object>)result;
+                    if (handler == null) {
+                        this.readHandler = null;
+                        result = new PendingFuture<V,A>(this, OpType.READ);
+                        this.readFuture = (PendingFuture<Number,Object>)result;
+                        this.readAttachment = null;
+                    } else {
+                        this.readHandler = (CompletionHandler<Number,Object>)handler;
+                        this.readAttachment = attachment;
+                        this.readFuture = null;
+                    }
+                    if (timeout > 0L) {
+                        this.readTimer = port.schedule(readTimeoutTask, timeout, unit);
+                    }
+                    this.readPending = true;
                     updateEvents();
                 }
-
-                // schedule timeout
-                if (timeout > 0L) {
-                    Future<?> timeoutTask =
-                        port.schedule(readTimeoutTask, timeout, unit);
-                    ((PendingFuture<V,A>)result).setTimeoutTask(timeoutTask);
-                }
+                pending = true;
                 return result;
             }
-
-            // data available
-            enableReading();
-
-            // result type is Long or Integer
-            if (isScatteringRead) {
-                result = (CompletedFuture<V,A>)CompletedFuture
-                    .withResult(this, Long.valueOf(n), attachment);
-            } else {
-                result = (CompletedFuture<V,A>)CompletedFuture
-                    .withResult(this, Integer.valueOf(n), attachment);
-            }
         } catch (Throwable x) {
-            enableReading();
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            result = CompletedFuture.withFailure(this, x, attachment);
+            exc = x;
         } finally {
+            if (!pending)
+                enableReading();
             end();
         }
 
-        if (invokeDirect) {
-            Invoker.invokeDirect(myGroupAndInvokeCount, handler, result);
+        Number result = (exc != null) ? null : (isScatteringRead) ?
+            (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
+
+        // read completed immediately
+        if (handler != null) {
+            if (invokeDirect) {
+                Invoker.invokeDirect(myGroupAndInvokeCount, handler, attachment, (V)result, exc);
+            } else {
+                Invoker.invokeIndirectly(this, handler, attachment, (V)result, exc);
+            }
+            return null;
         } else {
-            Invoker.invokeIndirectly(handler, result);
-        }
-        return result;
+            return CompletedFuture.withResult((V)result, exc);
+        }
     }
 
     // -- write --
 
-    private void finishWrite(PendingFuture<Number,Object> result,
-                             boolean invokeDirect)
-    {
-        PendingFuture<Number,Object> pending = null;
+    private void finishWrite(boolean mayInvokeDirect) {
+        int n = -1;
+        Throwable exc = null;
+
+        // copy fields as we can't access them after reading is re-enabled.
+        boolean gathering = this.isGatheringWrite;
+        CompletionHandler<Number,Object> handler = this.writeHandler;
+        Object att = this.writeAttachment;
+        PendingFuture<Number,Object> future = this.writeFuture;
+        Future<?> timer = this.writeTimer;
+
         try {
             begin();
 
-            ByteBuffer[] srcs = writeBuffers;
-            int n;
-            if (srcs.length == 1) {
-                n = IOUtil.write(fd, srcs[0], -1, nd, null);
-            } else {
-                n = (int)IOUtil.write(fd, srcs, nd);
+            if (gathering) {
+                n = (int)IOUtil.write(fd, writeBuffers, nd);
+            } else {
+                n = IOUtil.write(fd, writeBuffer, -1, nd, null);
             }
             if (n == IOStatus.UNAVAILABLE) {
                 // spurious wakeup, is this possible?
-                pending = result;
+                synchronized (updateLock) {
+                    writePending = true;
+                }
                 return;
             }
 
-            // allow buffer(s) to be GC'ed.
-            writeBuffers = null;
+            // allow objects to be GC'ed.
+            this.writeBuffer = null;
+            this.writeBuffers = null;
+            this.writeAttachment = null;
 
             // allow another write to be initiated
-            boolean wasGatheringWrite = gatheringWrite;
             enableWriting();
-
-            // result is a Long or Integer
-            if (wasGatheringWrite) {
-                result.setResult(Long.valueOf(n));
-            } else {
-                result.setResult(Integer.valueOf(n));
-            }
 
         } catch (Throwable x) {
             enableWriting();
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            result.setFailure(x);
+            exc = x;
         } finally {
-            // restart poll in case of concurrent read
-            synchronized (this) {
-                if (pending != null)
-                    this.pendingWrite = pending;
+            // restart poll in case of concurrent write
+            synchronized (updateLock) {
                 updateEvents();
             }
             end();
         }
-        if (invokeDirect) {
-            Invoker.invoke(result.handler(), result);
+
+        // cancel the associated timer
+        if (timer != null)
+            timer.cancel(false);
+
+        // create result
+        Number result = (exc != null) ? null : (gathering) ?
+            (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
+
+        // invoke handler or set result
+        if (handler == null) {
+            future.setResult(result, exc);
         } else {
-            Invoker.invokeIndirectly(result.handler(), result);
+            if (mayInvokeDirect) {
+                Invoker.invokeUnchecked(handler, att, result, exc);
+            } else {
+                Invoker.invokeIndirectly(this, handler, att, result, exc);
+            }
         }
     }
 
     private Runnable writeTimeoutTask = new Runnable() {
         public void run() {
-            PendingFuture<Number,Object> result = grabPendingWrite();
-            if (result == null)
-                return;     // already completed
+            CompletionHandler<Number,Object> handler = null;
+            Object att = null;
+            PendingFuture<Number,Object> future = null;
+
+            synchronized (updateLock) {
+                if (!writePending)
+                    return;
+                writePending = false;
+                handler = writeHandler;
+                att = writeAttachment;
+                future = writeFuture;
+            }
 
             // kill further writing before releasing waiters
             enableWriting(true);
 
-            // set completed and invoke handler
-            result.setFailure(new InterruptedByTimeoutException());
-            Invoker.invokeIndirectly(result.handler(), result);
+            // invoke handler or set result
+            Exception exc = new InterruptedByTimeoutException();
+            if (handler != null) {
+                Invoker.invokeIndirectly(UnixAsynchronousSocketChannelImpl.this,
+                    handler, att, null, exc);
+            } else {
+                future.setFailure(exc);
+            }
         }
     };
 
@@ -596,8 +655,9 @@ class UnixAsynchronousSocketChannelImpl
      */
     @Override
     @SuppressWarnings("unchecked")
-    <V extends Number,A> Future<V> writeImpl(ByteBuffer[] srcs,
-                                             boolean isGatheringWrite,
+    <V extends Number,A> Future<V> implWrite(boolean isGatheringWrite,
+                                             ByteBuffer src,
+                                             ByteBuffer[] srcs,
                                              long timeout,
                                              TimeUnit unit,
                                              A attachment,
@@ -607,66 +667,72 @@ class UnixAsynchronousSocketChannelImpl
             Invoker.getGroupAndInvokeCount();
         boolean invokeDirect = Invoker.mayInvokeDirect(myGroupAndInvokeCount, port);
         boolean attemptWrite = (handler == null) || invokeDirect ||
-            !port.isFixedThreadPool();  // okay to attempt read with user thread pool
-
-        AbstractFuture<V,A> result;
+            !port.isFixedThreadPool();  // okay to attempt write with user thread pool
+
+        int n = IOStatus.UNAVAILABLE;
+        Throwable exc = null;
+        boolean pending = false;
+
         try {
             begin();
 
-            int n;
             if (attemptWrite) {
                 if (isGatheringWrite) {
                     n = (int)IOUtil.write(fd, srcs, nd);
                 } else {
-                    n = IOUtil.write(fd, srcs[0], -1, nd, null);
-                }
-            } else {
-                n = IOStatus.UNAVAILABLE;
+                    n = IOUtil.write(fd, src, -1, nd, null);
+                }
             }
 
             if (n == IOStatus.UNAVAILABLE) {
-                result = new PendingFuture<V,A>(this, handler, attachment, OpType.WRITE);
-
-                // update evetns so that read will complete asynchronously
+                PendingFuture<V,A> result = null;
                 synchronized (updateLock) {
+                    this.isGatheringWrite = isGatheringWrite;
+                    this.writeBuffer = src;
                     this.writeBuffers = srcs;
-                    this.gatheringWrite = isGatheringWrite;
-                    this.pendingWrite = (PendingFuture<Number,Object>)result;
+                    if (handler == null) {
+                        this.writeHandler = null;
+                        result = new PendingFuture<V,A>(this, OpType.WRITE);
+                        this.writeFuture = (PendingFuture<Number,Object>)result;
+                        this.writeAttachment = null;
+                    } else {
+                        this.writeHandler = (CompletionHandler<Number,Object>)handler;
+                        this.writeAttachment = attachment;
+                        this.writeFuture = null;
+                    }
+                    if (timeout > 0L) {
+                        this.writeTimer = port.schedule(writeTimeoutTask, timeout, unit);
+                    }
+                    this.writePending = true;
                     updateEvents();
                 }
-
-                // schedule timeout
-                if (timeout > 0L) {
-                    Future<?> timeoutTask =
-                        port.schedule(writeTimeoutTask, timeout, unit);
-                    ((PendingFuture<V,A>)result).setTimeoutTask(timeoutTask);
-                }
+                pending = true;
                 return result;
             }
-
-            // data available
-            enableWriting();
-            if (isGatheringWrite) {
-                result = (CompletedFuture<V,A>)CompletedFuture
-                    .withResult(this, Long.valueOf(n), attachment);
-            } else {
-                result = (CompletedFuture<V,A>)CompletedFuture
-                    .withResult(this, Integer.valueOf(n), attachment);
-            }
         } catch (Throwable x) {
-            enableWriting();
             if (x instanceof ClosedChannelException)
                 x = new AsynchronousCloseException();
-            result = CompletedFuture.withFailure(this, x, attachment);
+            exc = x;
         } finally {
+            if (!pending)
+                enableWriting();
             end();
         }
-        if (invokeDirect) {
-            Invoker.invokeDirect(myGroupAndInvokeCount, handler, result);
+
+        Number result = (exc != null) ? null : (isGatheringWrite) ?
+            (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
+
+        // write completed immediately
+        if (handler != null) {
+            if (invokeDirect) {
+                Invoker.invokeDirect(myGroupAndInvokeCount, handler, attachment, (V)result, exc);
+            } else {
+                Invoker.invokeIndirectly(this, handler, attachment, (V)result, exc);
+            }
+            return null;
         } else {
-            Invoker.invokeIndirectly(handler, result);
-        }
-        return result;
+            return CompletedFuture.withResult((V)result, exc);
+        }
     }
 
     // -- Native methods --
--- a/src/solaris/classes/sun/nio/fs/LinuxFileStore.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/fs/LinuxFileStore.java	Tue Sep 22 01:20:51 2009 -0700
@@ -25,6 +25,7 @@
 
 package sun.nio.fs;
 
+import java.nio.file.attribute.*;
 import java.util.*;
 import java.io.IOException;
 
@@ -113,10 +114,12 @@ class LinuxFileStore
     }
 
     @Override
-    public boolean supportsFileAttributeView(String name) {
+    public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
         // support DosFileAttributeView and UserDefinedAttributeView if extended
         // attributes enabled
-        if (name.equals("dos") || name.equals("user")) {
+        if (type == DosFileAttributeView.class ||
+            type == UserDefinedFileAttributeView.class)
+        {
             // lookup fstypes.properties
             FeatureStatus status = checkIfFeaturePresent("user_xattr");
             if (status == FeatureStatus.PRESENT)
@@ -142,7 +145,15 @@ class LinuxFileStore
             }
             return xattrEnabled;
         }
+        return super.supportsFileAttributeView(type);
+    }
 
+    @Override
+    public boolean supportsFileAttributeView(String name) {
+        if (name.equals("dos"))
+            return supportsFileAttributeView(DosFileAttributeView.class);
+        if (name.equals("user"))
+            return supportsFileAttributeView(UserDefinedFileAttributeView.class);
         return super.supportsFileAttributeView(name);
     }
 
--- a/src/solaris/classes/sun/nio/fs/SolarisFileStore.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/fs/SolarisFileStore.java	Tue Sep 22 01:20:51 2009 -0700
@@ -25,6 +25,7 @@
 
 package sun.nio.fs;
 
+import java.nio.file.attribute.*;
 import java.io.IOException;
 
 import static sun.nio.fs.UnixNativeDispatcher.*;
@@ -72,27 +73,39 @@ class SolarisFileStore
     }
 
     @Override
-    public boolean supportsFileAttributeView(String name) {
-        if (name.equals("acl")) {
+    public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
+        if (type == AclFileAttributeView.class) {
             // lookup fstypes.properties
             FeatureStatus status = checkIfFeaturePresent("nfsv4acl");
-            if (status == FeatureStatus.PRESENT)
-                return true;
-            if (status == FeatureStatus.NOT_PRESENT)
-                return false;
-            // AclFileAttributeView available on ZFS
-            return (type().equals("zfs"));
+            switch (status) {
+                case PRESENT     : return true;
+                case NOT_PRESENT : return false;
+                default :
+                    // AclFileAttributeView available on ZFS
+                    return (type().equals("zfs"));
+            }
         }
-        if (name.equals("user")) {
+        if (type == UserDefinedFileAttributeView.class) {
             // lookup fstypes.properties
             FeatureStatus status = checkIfFeaturePresent("xattr");
-            if (status == FeatureStatus.PRESENT)
-                return true;
-            if (status == FeatureStatus.NOT_PRESENT)
-                return false;
-            return xattrEnabled;
+            switch (status) {
+                case PRESENT     : return true;
+                case NOT_PRESENT : return false;
+                default :
+                    // UserDefinedFileAttributeView available if extended
+                    // attributes supported
+                    return xattrEnabled;
+            }
         }
+        return super.supportsFileAttributeView(type);
+    }
 
+    @Override
+    public boolean supportsFileAttributeView(String name) {
+        if (name.equals("acl"))
+            return supportsFileAttributeView(AclFileAttributeView.class);
+        if (name.equals("user"))
+            return supportsFileAttributeView(UserDefinedFileAttributeView.class);
         return super.supportsFileAttributeView(name);
     }
 
--- a/src/solaris/classes/sun/nio/fs/UnixFileStore.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/fs/UnixFileStore.java	Tue Sep 22 01:20:51 2009 -0700
@@ -145,9 +145,8 @@ abstract class UnixFileStore
         {
             // lookup fstypes.properties
             FeatureStatus status = checkIfFeaturePresent("posix");
-            if (status == FeatureStatus.NOT_PRESENT)
-                return false;
-            return true;
+            // assume supported if UNKNOWN
+            return (status != FeatureStatus.NOT_PRESENT);
         }
         return false;
     }
--- a/src/solaris/classes/sun/nio/fs/UnixPath.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/classes/sun/nio/fs/UnixPath.java	Tue Sep 22 01:20:51 2009 -0700
@@ -64,9 +64,6 @@ class UnixPath
 
     // array of offsets of elements in path (created lazily)
     private volatile int[] offsets;
-
-    // file permissions (created lazily)
-    private volatile FilePermission[] perms;
 
     UnixPath(UnixFileSystem fs, byte[] path) {
         this.fs = fs;
@@ -768,45 +765,23 @@ class UnixPath
         }
     }
 
-    // create file permissions used for read and write checks
-    private void checkReadOrWrite(boolean checkRead) {
+
+    void checkRead() {
         SecurityManager sm = System.getSecurityManager();
-        if (sm == null)
-            return;
-        if (perms == null) {
-            synchronized (this) {
-                if (perms == null) {
-                    FilePermission[] p = new FilePermission[2];
-                    String pathForPermCheck = getPathForPermissionCheck();
-                    p[0] = new FilePermission(pathForPermCheck,
-                        SecurityConstants.FILE_READ_ACTION);
-                    p[1] = new FilePermission(pathForPermCheck,
-                        SecurityConstants.FILE_WRITE_ACTION);
-                    perms = p;
-                }
-            }
-        }
-        if (checkRead) {
-            sm.checkPermission(perms[0]);
-        } else {
-            sm.checkPermission(perms[1]);
-        }
-    }
-
-    void checkRead() {
-        checkReadOrWrite(true);
+        if (sm != null)
+            sm.checkRead(getPathForPermissionCheck());
     }
 
     void checkWrite() {
-        checkReadOrWrite(false);
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkWrite(getPathForPermissionCheck());
     }
 
     void checkDelete() {
         SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            // permission not cached
+        if (sm != null)
             sm.checkDelete(getPathForPermissionCheck());
-        }
     }
 
     @Override
--- a/src/solaris/native/java/util/TimeZone_md.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/solaris/native/java/util/TimeZone_md.c	Tue Sep 22 01:20:51 2009 -0700
@@ -51,9 +51,9 @@
 
 #ifdef __linux__
 
-static const char *sysconfig_clock_file = "/etc/sysconfig/clock";
-static const char *zoneinfo_dir = "/usr/share/zoneinfo";
-static const char *defailt_zoneinfo_file = "/etc/localtime";
+static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
+static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
+static const char *DEFAULT_ZONEINFO_FILE = "/etc/localtime";
 
 /*
  * Returns a point to the zone ID portion of the given zoneinfo file
@@ -201,53 +201,22 @@ getPlatformTimeZoneID()
     size_t size;
 
     /*
-     * First, try the ZONE entry in /etc/sysconfig/clock. However, the
-     * ZONE entry is not set up after initial Red Hat Linux
-     * installation. In case that /etc/localtime is set up without
-     * using timeconfig, there might be inconsistency between
-     * /etc/localtime and the ZONE entry. The inconsistency between
-     * timeconfig and linuxconf is reported as a bug in the Red Hat
-     * web page as of May 1, 2000.
-     */
-    if ((fp = fopen(sysconfig_clock_file, "r")) != NULL) {
+     * Try reading the /etc/timezone file for Debian distros. There's
+     * no spec of the file format available. This parsing assumes that
+     * there's one line of an Olson tzid followed by a '\n', no
+     * leading or trailing spaces, no comments.
+     */
+    if ((fp = fopen(ETC_TIMEZONE_FILE, "r")) != NULL) {
         char line[256];
 
-        while (fgets(line, sizeof(line), fp) != NULL) {
-            char *p = line;
-            char *s;
-
-            SKIP_SPACE(p);
-            if (*p != 'Z') {
-                continue;
-            }
-            if (strncmp(p, "ZONE=\"", 6) == 0) {
-                p += 6;
-            } else {
-                /*
-                 * In case we need to parse it token by token.
-                 */
-                if (strncmp(p, "ZONE", 4) != 0) {
-                    continue;
-                }
-                p += 4;
-                SKIP_SPACE(p);
-                if (*p++ != '=') {
-                    break;
-                }
-                SKIP_SPACE(p);
-                if (*p++ != '"') {
-                    break;
-                }
-            }
-            for (s = p; *s && *s != '"'; s++)
-                ;
-            if (*s != '"') {
-                /* this ZONE entry is broken. */
-                break;
-            }
-            *s = '\0';
-            tz = strdup(p);
-            break;
+        if (fgets(line, sizeof(line), fp) != NULL) {
+            char *p = strchr(line, '\n');
+            if (p != NULL) {
+                *p = '\0';
+            }
+            if (strlen(line) > 0) {
+                tz = strdup(line);
+            }
         }
         (void) fclose(fp);
         if (tz != NULL) {
@@ -258,7 +227,7 @@ getPlatformTimeZoneID()
     /*
      * Next, try /etc/localtime to find the zone ID.
      */
-    if (lstat(defailt_zoneinfo_file, &statbuf) == -1) {
+    if (lstat(DEFAULT_ZONEINFO_FILE, &statbuf) == -1) {
         return NULL;
     }
 
@@ -273,9 +242,9 @@ getPlatformTimeZoneID()
         char linkbuf[PATH_MAX+1];
         int len;
 
-        if ((len = readlink(defailt_zoneinfo_file, linkbuf, sizeof(linkbuf)-1)) == -1) {
+        if ((len = readlink(DEFAULT_ZONEINFO_FILE, linkbuf, sizeof(linkbuf)-1)) == -1) {
             jio_fprintf(stderr, (const char *) "can't get a symlink of %s\n",
-                        defailt_zoneinfo_file);
+                        DEFAULT_ZONEINFO_FILE);
             return NULL;
         }
         linkbuf[len] = '\0';
@@ -295,7 +264,7 @@ getPlatformTimeZoneID()
     if (buf == NULL) {
         return NULL;
     }
-    if ((fd = open(defailt_zoneinfo_file, O_RDONLY)) == -1) {
+    if ((fd = open(DEFAULT_ZONEINFO_FILE, O_RDONLY)) == -1) {
         free((void *) buf);
         return NULL;
     }
@@ -307,7 +276,7 @@ getPlatformTimeZoneID()
     }
     (void) close(fd);
 
-    tz = findZoneinfoFile(buf, size, zoneinfo_dir);
+    tz = findZoneinfoFile(buf, size, ZONEINFO_DIR);
     free((void *) buf);
     return tz;
 }
--- a/src/windows/classes/sun/awt/windows/fontconfig.properties	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/awt/windows/fontconfig.properties	Tue Sep 22 01:20:51 2009 -0700
@@ -1,6 +1,6 @@
 #
 # 
-# Copyright 2003-2004 Sun Microsystems, Inc.  All Rights Reserved.
+# Copyright 2003-2009 Sun Microsystems, Inc.  All Rights Reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -31,8 +31,11 @@ version=1
 # Component Font Mappings
 
 allfonts.chinese-ms936=SimSun
+allfonts.chinese-ms936-extb=SimSun-ExtB
 allfonts.chinese-gb18030=SimSun-18030
+allfonts.chinese-gb18030-extb=SimSun-ExtB
 allfonts.chinese-hkscs=MingLiU_HKSCS
+allfonts.chinese-ms950-extb=MingLiU-ExtB
 allfonts.devanagari=Mangal
 allfonts.dingbats=Wingdings
 allfonts.lucida=Lucida Sans Regular
@@ -41,120 +44,140 @@ allfonts.thai=Lucida Sans Regular
 
 serif.plain.alphabetic=Times New Roman
 serif.plain.chinese-ms950=MingLiU
+serif.plain.chinese-ms950-extb=MingLiU-ExtB
 serif.plain.hebrew=David
 serif.plain.japanese=MS Mincho
 serif.plain.korean=Batang
 
 serif.bold.alphabetic=Times New Roman Bold
 serif.bold.chinese-ms950=PMingLiU
+serif.bold.chinese-ms950-extb=PMingLiU-ExtB
 serif.bold.hebrew=David Bold
 serif.bold.japanese=MS Mincho
 serif.bold.korean=Batang
 
 serif.italic.alphabetic=Times New Roman Italic
 serif.italic.chinese-ms950=PMingLiU
+serif.italic.chinese-ms950-extb=PMingLiU-ExtB
 serif.italic.hebrew=David
 serif.italic.japanese=MS Mincho
 serif.italic.korean=Batang
 
 serif.bolditalic.alphabetic=Times New Roman Bold Italic
 serif.bolditalic.chinese-ms950=PMingLiU
+serif.bolditalic.chinese-ms950-extb=PMingLiU-ExtB
 serif.bolditalic.hebrew=David Bold
 serif.bolditalic.japanese=MS Mincho
 serif.bolditalic.korean=Batang
 
 sansserif.plain.alphabetic=Arial
 sansserif.plain.chinese-ms950=MingLiU
+sansserif.plain.chinese-ms950-extb=MingLiU-ExtB
 sansserif.plain.hebrew=David
 sansserif.plain.japanese=MS Gothic
 sansserif.plain.korean=Gulim
 
 sansserif.bold.alphabetic=Arial Bold
 sansserif.bold.chinese-ms950=PMingLiU
+sansserif.bold.chinese-ms950-extb=PMingLiU-ExtB
 sansserif.bold.hebrew=David Bold
 sansserif.bold.japanese=MS Gothic
 sansserif.bold.korean=Gulim
 
 sansserif.italic.alphabetic=Arial Italic
 sansserif.italic.chinese-ms950=PMingLiU
+sansserif.italic.chinese-ms950-extb=PMingLiU-ExtB
 sansserif.italic.hebrew=David
 sansserif.italic.japanese=MS Gothic
 sansserif.italic.korean=Gulim
 
 sansserif.bolditalic.alphabetic=Arial Bold Italic
 sansserif.bolditalic.chinese-ms950=PMingLiU
+sansserif.bolditalic.chinese-ms950-extb=PMingLiU-ExtB
 sansserif.bolditalic.hebrew=David Bold
 sansserif.bolditalic.japanese=MS Gothic
 sansserif.bolditalic.korean=Gulim
 
 monospaced.plain.alphabetic=Courier New
 monospaced.plain.chinese-ms950=MingLiU
+monospaced.plain.chinese-ms950-extb=MingLiU-ExtB
 monospaced.plain.hebrew=David
 monospaced.plain.japanese=MS Gothic
 monospaced.plain.korean=GulimChe
 
 monospaced.bold.alphabetic=Courier New Bold
 monospaced.bold.chinese-ms950=PMingLiU
+monospaced.bold.chinese-ms950-extb=PMingLiU-ExtB
 monospaced.bold.hebrew=David Bold
 monospaced.bold.japanese=MS Gothic
 monospaced.bold.korean=GulimChe
 
 monospaced.italic.alphabetic=Courier New Italic
 monospaced.italic.chinese-ms950=PMingLiU
+monospaced.italic.chinese-ms950-extb=PMingLiU-ExtB
 monospaced.italic.hebrew=David
 monospaced.italic.japanese=MS Gothic
 monospaced.italic.korean=GulimChe
 
 monospaced.bolditalic.alphabetic=Courier New Bold Italic
 monospaced.bolditalic.chinese-ms950=PMingLiU
+monospaced.bolditalic.chinese-ms950-extb=PMingLiU-ExtB
 monospaced.bolditalic.hebrew=David Bold
 monospaced.bolditalic.japanese=MS Gothic
 monospaced.bolditalic.korean=GulimChe
 
 dialog.plain.alphabetic=Arial
 dialog.plain.chinese-ms950=MingLiU
+dialog.plain.chinese-ms950-extb=MingLiU-ExtB
 dialog.plain.hebrew=David
 dialog.plain.japanese=MS Gothic
 dialog.plain.korean=Gulim
 
 dialog.bold.alphabetic=Arial Bold
 dialog.bold.chinese-ms950=PMingLiU
+dialog.bold.chinese-ms950-extb=PMingLiU-ExtB
 dialog.bold.hebrew=David Bold
 dialog.bold.japanese=MS Gothic
 dialog.bold.korean=Gulim
 
 dialog.italic.alphabetic=Arial Italic
 dialog.italic.chinese-ms950=PMingLiU
+dialog.italic.chinese-ms950-extb=PMingLiU-ExtB
 dialog.italic.hebrew=David
 dialog.italic.japanese=MS Gothic
 dialog.italic.korean=Gulim
 
 dialog.bolditalic.alphabetic=Arial Bold Italic
 dialog.bolditalic.chinese-ms950=PMingLiU
+dialog.bolditalic.chinese-ms950-extb=PMingLiU-ExtB
 dialog.bolditalic.hebrew=David Bold
 dialog.bolditalic.japanese=MS Gothic
 dialog.bolditalic.korean=Gulim
 
 dialoginput.plain.alphabetic=Courier New
 dialoginput.plain.chinese-ms950=MingLiU
+dialoginput.plain.chinese-ms950-extb=MingLiU-ExtB
 dialoginput.plain.hebrew=David
 dialoginput.plain.japanese=MS Gothic
 dialoginput.plain.korean=Gulim
 
 dialoginput.bold.alphabetic=Courier New Bold
 dialoginput.bold.chinese-ms950=PMingLiU
+dialoginput.bold.chinese-ms950-extb=PMingLiU-ExtB
 dialoginput.bold.hebrew=David Bold
 dialoginput.bold.japanese=MS Gothic
 dialoginput.bold.korean=Gulim
 
 dialoginput.italic.alphabetic=Courier New Italic
 dialoginput.italic.chinese-ms950=PMingLiU
+dialoginput.italic.chinese-ms950-extb=PMingLiU-ExtB
 dialoginput.italic.hebrew=David
 dialoginput.italic.japanese=MS Gothic
 dialoginput.italic.korean=Gulim
 
 dialoginput.bolditalic.alphabetic=Courier New Bold Italic
 dialoginput.bolditalic.chinese-ms950=PMingLiU
+dialoginput.bolditalic.chinese-ms950-extb=PMingLiU-ExtB
 dialoginput.bolditalic.hebrew=David Bold
 dialoginput.bolditalic.japanese=MS Gothic
 dialoginput.bolditalic.korean=Gulim
@@ -163,31 +186,32 @@ dialoginput.bolditalic.korean=Gulim
 
 sequence.allfonts=alphabetic/default,dingbats,symbol
 
-sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol
-sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol
-sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol
-sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol
-sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol
-
-sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol
-sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol
-sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol
-sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol
-sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol
-
-sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol
-sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol
-sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol
-sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol
-sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol
-
-sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol
-sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol
-sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol
-sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol
-sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol
+sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb
+sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb
+sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol,chinese-ms936-extb
+sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb
+sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb
+
+sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb
+sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb
+sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol,chinese-gb18030-extb
+sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb
+sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb
+
+sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb
+sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb
+sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol,chinese-ms950-extb
+sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb
+sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb
+
+sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb
+sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb
+sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb
+sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb
+sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb
 
 sequence.allfonts.UTF-8.hi=alphabetic/1252,devanagari,dingbats,symbol
+sequence.allfonts.UTF-8.ja=alphabetic,japanese,devanagari,dingbats,symbol
 
 sequence.allfonts.windows-1255=hebrew,alphabetic/1252,dingbats,symbol
 
@@ -207,7 +231,7 @@ sequence.allfonts.x-windows-874=alphabet
 
 sequence.fallback=lucida,\
                   chinese-ms950,chinese-hkscs,chinese-ms936,chinese-gb18030,\
-                  japanese,korean
+                  japanese,korean,chinese-ms950-extb,chinese-ms936-extb
 
 # Exclusion Ranges
 
@@ -220,6 +244,7 @@ proportional.MS_Gothic=MS PGothic
 proportional.MS_Gothic=MS PGothic
 proportional.MS_Mincho=MS PMincho
 proportional.MingLiU=PMingLiU
+proportional.MingLiU-ExtB=PMingLiU-ExtB
 
 # Font File Names
 
@@ -240,9 +265,12 @@ filename.Times_New_Roman_Bold_Italic=TIM
 
 filename.SimSun=SIMSUN.TTC
 filename.SimSun-18030=SIMSUN18030.TTC
+filename.SimSun-ExtB=SIMSUNB.TTF
 
 filename.MingLiU=MINGLIU.TTC
+filename.MingLiU-ExtB=MINGLIUB.TTC
 filename.PMingLiU=MINGLIU.TTC
+filename.PMingLiU-ExtB=MINGLIUB.TTC
 filename.MingLiU_HKSCS=hkscsm3u.ttf
 
 filename.David=DAVID.TTF
--- a/src/windows/classes/sun/nio/ch/Iocp.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/ch/Iocp.java	Tue Sep 22 01:20:51 2009 -0700
@@ -34,6 +34,8 @@ import java.util.concurrent.*;
 import java.util.concurrent.*;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.security.AccessController;
+import sun.security.action.GetPropertyAction;
 import sun.misc.Unsafe;
 
 /**
@@ -44,6 +46,7 @@ class Iocp extends AsynchronousChannelGr
 class Iocp extends AsynchronousChannelGroupImpl {
     private static final Unsafe unsafe = Unsafe.getUnsafe();
     private static final long INVALID_HANDLE_VALUE  = -1L;
+    private static final boolean supportsThreadAgnosticIo;
 
     // maps completion key to channel
     private final ReadWriteLock keyToChannelLock = new ReentrantReadWriteLock();
@@ -85,6 +88,13 @@ class Iocp extends AsynchronousChannelGr
          * Returns a reference to the pending I/O result.
          */
         <V,A> PendingFuture<V,A> getByOverlapped(long overlapped);
+    }
+
+    /**
+     * Indicates if this operating system supports thread agnostic I/O.
+     */
+    static boolean supportsThreadAgnosticIo() {
+        return supportsThreadAgnosticIo;
     }
 
     // release all resources
@@ -216,8 +226,9 @@ class Iocp extends AsynchronousChannelGr
             } while ((key == 0) || keyToChannel.containsKey(key));
 
             // associate with I/O completion port
-            if (handle != 0L)
+            if (handle != 0L) {
                 createIoCompletionPort(handle, port, key, 0);
+            }
 
             // setup mapping
             keyToChannel.put(key, ch);
@@ -282,7 +293,7 @@ class Iocp extends AsynchronousChannelGr
         /**
          * Invoked if the I/O operation completes successfully.
          */
-        public void completed(int bytesTransferred);
+        public void completed(int bytesTransferred, boolean canInvokeDirect);
 
         /**
          * Invoked if the I/O operation fails.
@@ -305,6 +316,7 @@ class Iocp extends AsynchronousChannelGr
         public void run() {
             Invoker.GroupAndInvokeCount myGroupAndInvokeCount =
                 Invoker.getGroupAndInvokeCount();
+            boolean canInvokeDirect = (myGroupAndInvokeCount != null);
             CompletionStatus ioResult = new CompletionStatus();
             boolean replaceMe = false;
 
@@ -382,7 +394,7 @@ class Iocp extends AsynchronousChannelGr
                     ResultHandler rh = (ResultHandler)result.getContext();
                     replaceMe = true; // (if error/exception then replace thread)
                     if (error == 0) {
-                        rh.completed(ioResult.bytesTransferred());
+                        rh.completed(ioResult.bytesTransferred(), canInvokeDirect);
                     } else {
                         rh.failed(error, translateErrorToIOException(error));
                     }
@@ -433,5 +445,11 @@ class Iocp extends AsynchronousChannelGr
     static {
         Util.load();
         initIDs();
+
+        // thread agnostic I/O on Vista/2008 or newer
+        String osversion = AccessController.doPrivileged(
+            new GetPropertyAction("os.version"));
+        String vers[] = osversion.split("\\.");
+        supportsThreadAgnosticIo = Integer.parseInt(vers[0]) >= 6;
     }
 }
--- a/src/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -146,10 +146,12 @@ public class WindowsAsynchronousFileChan
         // waits until all I/O operations have completed
         ioCache.close();
 
-        // disassociate from port and shutdown thread pool if not default
+        // disassociate from port
         iocp.disassociate(completionKey);
+
+        // for the non-default group close the port
         if (!isDefaultIocp)
-            iocp.shutdown();
+            iocp.detachFromThreadPool();
     }
 
     @Override
@@ -258,14 +260,18 @@ public class WindowsAsynchronousFileChan
             }
 
             // invoke completion handler
-            Invoker.invoke(result.handler(), result);
-        }
-
-        @Override
-        public void completed(int bytesTransferred) {
+            Invoker.invoke(result);
+        }
+
+        @Override
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             // release waiters and invoke completion handler
             result.setResult(fli);
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         @Override
@@ -279,16 +285,16 @@ public class WindowsAsynchronousFileChan
             } else {
                 result.setFailure(new AsynchronousCloseException());
             }
-            Invoker.invoke(result.handler(), result);
-        }
-    }
-
-    @Override
-    public <A> Future<FileLock> lock(long position,
-                                     long size,
-                                     boolean shared,
-                                     A attachment,
-                                     CompletionHandler<FileLock,? super A> handler)
+            Invoker.invoke(result);
+        }
+    }
+
+    @Override
+    <A> Future<FileLock> implLock(final long position,
+                                  final long size,
+                                  final boolean shared,
+                                  A attachment,
+                                  final CompletionHandler<FileLock,? super A> handler)
     {
         if (shared && !reading)
             throw new NonReadableChannelException();
@@ -298,10 +304,11 @@ public class WindowsAsynchronousFileChan
         // add to lock table
         FileLockImpl fli = addToFileLockTable(position, size, shared);
         if (fli == null) {
-            CompletedFuture<FileLock,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
         }
 
         // create Future and task that will be invoked to acquire lock
@@ -310,13 +317,20 @@ public class WindowsAsynchronousFileChan
         LockTask lockTask = new LockTask<A>(position, fli, result);
         result.setContext(lockTask);
 
-        // initiate I/O (can only be done from thread in thread pool)
-        try {
-            Invoker.invokeOnThreadInThreadPool(this, lockTask);
-        } catch (ShutdownChannelGroupException e) {
-            // rollback
-            removeFromFileLockTable(fli);
-            throw e;
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            lockTask.run();
+        } else {
+            boolean executed = false;
+            try {
+                Invoker.invokeOnThreadInThreadPool(this, lockTask);
+                executed = true;
+            } finally {
+                if (!executed) {
+                    // rollback
+                    removeFromFileLockTable(fli);
+                }
+            }
         }
         return result;
     }
@@ -461,14 +475,14 @@ public class WindowsAsynchronousFileChan
             releaseBufferIfSubstituted();
 
             // invoke completion handler
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
          * Executed when the I/O has completed
          */
         @Override
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             updatePosition(bytesTransferred);
 
             // return direct buffer to cache if substituted
@@ -476,14 +490,18 @@ public class WindowsAsynchronousFileChan
 
             // release waiters and invoke completion handler
             result.setResult(bytesTransferred);
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         @Override
         public void failed(int error, IOException x) {
             // if EOF detected asynchronously then it is reported as error
             if (error == ERROR_HANDLE_EOF) {
-                completed(-1);
+                completed(-1, false);
             } else {
                 // return direct buffer to cache if substituted
                 releaseBufferIfSubstituted();
@@ -494,16 +512,16 @@ public class WindowsAsynchronousFileChan
                 } else {
                     result.setFailure(new AsynchronousCloseException());
                 }
-                Invoker.invoke(result.handler(), result);
-            }
-        }
-    }
-
-    @Override
-    public <A> Future<Integer> read(ByteBuffer dst,
-                                    long position,
-                                    A attachment,
-                                    CompletionHandler<Integer,? super A> handler)
+                Invoker.invoke(result);
+            }
+        }
+    }
+
+    @Override
+    <A> Future<Integer> implRead(ByteBuffer dst,
+                                 long position,
+                                 A attachment,
+                                 CompletionHandler<Integer,? super A> handler)
     {
         if (!reading)
             throw new NonReadableChannelException();
@@ -514,10 +532,11 @@ public class WindowsAsynchronousFileChan
 
         // check if channel is closed
         if (!isOpen()) {
-            CompletedFuture<Integer,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
         }
 
         int pos = dst.position();
@@ -527,10 +546,10 @@ public class WindowsAsynchronousFileChan
 
         // no space remaining
         if (rem == 0) {
-            CompletedFuture<Integer,A> result =
-                CompletedFuture.withResult(this, 0, attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            if (handler == null)
+                return CompletedFuture.withResult(0);
+            Invoker.invoke(this, handler, attachment, 0, null);
+            return null;
         }
 
         // create Future and task that initiates read
@@ -539,8 +558,12 @@ public class WindowsAsynchronousFileChan
         ReadTask readTask = new ReadTask<A>(dst, pos, rem, position, result);
         result.setContext(readTask);
 
-        // initiate I/O (can only be done from thread in thread pool)
-        Invoker.invokeOnThreadInThreadPool(this, readTask);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            readTask.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, readTask);
+        }
         return result;
     }
 
@@ -639,14 +662,14 @@ public class WindowsAsynchronousFileChan
             }
 
             // invoke completion handler
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
          * Executed when the I/O has completed
          */
         @Override
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             updatePosition(bytesTransferred);
 
             // return direct buffer to cache if substituted
@@ -654,7 +677,11 @@ public class WindowsAsynchronousFileChan
 
             // release waiters and invoke completion handler
             result.setResult(bytesTransferred);
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         @Override
@@ -668,15 +695,14 @@ public class WindowsAsynchronousFileChan
             } else {
                 result.setFailure(new AsynchronousCloseException());
             }
-            Invoker.invoke(result.handler(), result);
-        }
-    }
-
-    @Override
-    public <A> Future<Integer> write(ByteBuffer src,
-                                     long position,
-                                     A attachment,
-                                     CompletionHandler<Integer,? super A> handler)
+            Invoker.invoke(result);
+        }
+    }
+
+    <A> Future<Integer> implWrite(ByteBuffer src,
+                                  long position,
+                                  A attachment,
+                                  CompletionHandler<Integer,? super A> handler)
     {
         if (!writing)
             throw new NonWritableChannelException();
@@ -685,10 +711,11 @@ public class WindowsAsynchronousFileChan
 
         // check if channel is closed
         if (!isOpen()) {
-            CompletedFuture<Integer,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+           Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
         }
 
         int pos = src.position();
@@ -698,10 +725,10 @@ public class WindowsAsynchronousFileChan
 
         // nothing to write
         if (rem == 0) {
-            CompletedFuture<Integer,A> result =
-                CompletedFuture.withResult(this, 0, attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            if (handler == null)
+                return CompletedFuture.withResult(0);
+            Invoker.invoke(this, handler, attachment, 0, null);
+            return null;
         }
 
         // create Future and task to initiate write
@@ -710,8 +737,12 @@ public class WindowsAsynchronousFileChan
         WriteTask writeTask = new WriteTask<A>(src, pos, rem, position, result);
         result.setContext(writeTask);
 
-        // initiate I/O (can only be done from thread in thread pool)
-        Invoker.invokeOnThreadInThreadPool(this, writeTask);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            writeTask.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, writeTask);
+        }
         return result;
     }
 
--- a/src/windows/classes/sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/ch/WindowsAsynchronousServerSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -113,14 +113,14 @@ class WindowsAsynchronousServerSocketCha
     /**
      * Task to initiate accept operation and to handle result.
      */
-    private class AcceptTask<A> implements Runnable, Iocp.ResultHandler {
+    private class AcceptTask implements Runnable, Iocp.ResultHandler {
         private final WindowsAsynchronousSocketChannelImpl channel;
         private final AccessControlContext acc;
-        private final PendingFuture<AsynchronousSocketChannel,A> result;
+        private final PendingFuture<AsynchronousSocketChannel,Object> result;
 
         AcceptTask(WindowsAsynchronousSocketChannelImpl channel,
                    AccessControlContext acc,
-                   PendingFuture<AsynchronousSocketChannel,A> result)
+                   PendingFuture<AsynchronousSocketChannel,Object> result)
         {
             this.channel = channel;
             this.acc = acc;
@@ -222,14 +222,14 @@ class WindowsAsynchronousServerSocketCha
             }
 
             // invoke completion handler
-            Invoker.invokeIndirectly(result.handler(), result);
+            Invoker.invokeIndirectly(result);
         }
 
         /**
          * Executed when the I/O has completed
          */
         @Override
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             try {
                 // connection accept after group has shutdown
                 if (iocp.isShutdown()) {
@@ -269,7 +269,7 @@ class WindowsAsynchronousServerSocketCha
             }
 
             // invoke handler (but not directly)
-            Invoker.invokeIndirectly(result.handler(), result);
+            Invoker.invokeIndirectly(result);
         }
 
         @Override
@@ -283,19 +283,20 @@ class WindowsAsynchronousServerSocketCha
             } else {
                 result.setFailure(new AsynchronousCloseException());
             }
-            Invoker.invokeIndirectly(result.handler(), result);
-        }
-    }
-
-    @Override
-    public <A> Future<AsynchronousSocketChannel> accept(A attachment,
-        final CompletionHandler<AsynchronousSocketChannel,? super A> handler)
+            Invoker.invokeIndirectly(result);
+        }
+    }
+
+    @Override
+    Future<AsynchronousSocketChannel> implAccept(Object attachment,
+        final CompletionHandler<AsynchronousSocketChannel,Object> handler)
     {
         if (!isOpen()) {
-            CompletedFuture<AsynchronousSocketChannel,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invokeIndirectly(handler, result);
-            return result;
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invokeIndirectly(this, handler, attachment, null, exc);
+            return null;
         }
         if (isAcceptKilled())
             throw new RuntimeException("Accept not allowed due to cancellation");
@@ -319,10 +320,10 @@ class WindowsAsynchronousServerSocketCha
             end();
         }
         if (ioe != null) {
-            CompletedFuture<AsynchronousSocketChannel,A> result =
-                CompletedFuture.withFailure(this, ioe, attachment);
-            Invoker.invokeIndirectly(handler, result);
-            return result;
+            if (handler == null)
+                return CompletedFuture.withFailure(ioe);
+            Invoker.invokeIndirectly(this, handler, attachment, null, ioe);
+            return null;
         }
 
         // need calling context when there is security manager as
@@ -331,20 +332,21 @@ class WindowsAsynchronousServerSocketCha
         AccessControlContext acc = (System.getSecurityManager() == null) ?
             null : AccessController.getContext();
 
-        PendingFuture<AsynchronousSocketChannel,A> result =
-            new PendingFuture<AsynchronousSocketChannel,A>(this, handler, attachment);
-        AcceptTask task = new AcceptTask<A>(ch, acc, result);
+        PendingFuture<AsynchronousSocketChannel,Object> result =
+            new PendingFuture<AsynchronousSocketChannel,Object>(this, handler, attachment);
+        AcceptTask task = new AcceptTask(ch, acc, result);
         result.setContext(task);
 
         // check and set flag to prevent concurrent accepting
         if (!accepting.compareAndSet(false, true))
             throw new AcceptPendingException();
 
-        // initiate accept. As I/O operations are tied to the initiating thread
-        // then it will only be invoked direcly if this thread is in the thread
-        // pool. If this thread is not in the thread pool when a task is
-        // submitted to initiate the accept.
-        Invoker.invokeOnThreadInThreadPool(this, task);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            task.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, task);
+        }
         return result;
     }
 
--- a/src/windows/classes/sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/ch/WindowsAsynchronousSocketChannelImpl.java	Tue Sep 22 01:20:51 2009 -0700
@@ -250,14 +250,14 @@ class WindowsAsynchronousSocketChannelIm
                 closeChannel();
                 result.setFailure(toIOException(exc));
             }
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
          * Invoked by handler thread when connection established.
          */
         @Override
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             Throwable exc = null;
             try {
                 begin();
@@ -276,7 +276,11 @@ class WindowsAsynchronousSocketChannelIm
                 result.setFailure(toIOException(exc));
             }
 
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         /**
@@ -290,20 +294,21 @@ class WindowsAsynchronousSocketChannelIm
             } else {
                 result.setFailure(new AsynchronousCloseException());
             }
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
     }
 
     @Override
-    public <A> Future<Void> connect(SocketAddress remote,
-                                    A attachment,
-                                    CompletionHandler<Void,? super A> handler)
+    <A> Future<Void> implConnect(SocketAddress remote,
+                                 A attachment,
+                                 CompletionHandler<Void,? super A> handler)
     {
         if (!isOpen()) {
-            CompletedFuture<Void,A> result = CompletedFuture
-                .withFailure(this, new ClosedChannelException(), attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            Throwable exc = new ClosedChannelException();
+            if (handler == null)
+                return CompletedFuture.withFailure(exc);
+            Invoker.invoke(this, handler, attachment, null, exc);
+            return null;
         }
 
         InetSocketAddress isa = Net.checkAddress(remote);
@@ -337,10 +342,10 @@ class WindowsAsynchronousSocketChannelIm
             try {
                 close();
             } catch (IOException ignore) { }
-            CompletedFuture<Void,A> result = CompletedFuture
-                .withFailure(this, bindException, attachment);
-            Invoker.invoke(handler, result);
-            return result;
+            if (handler == null)
+                return CompletedFuture.withFailure(bindException);
+            Invoker.invoke(this, handler, attachment, null, bindException);
+            return null;
         }
 
         // setup task
@@ -349,8 +354,12 @@ class WindowsAsynchronousSocketChannelIm
         ConnectTask task = new ConnectTask<A>(isa, result);
         result.setContext(task);
 
-        // initiate I/O (can only be done from thread in thread pool)
-        Invoker.invokeOnThreadInThreadPool(this, task);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            task.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, task);
+        }
         return result;
     }
 
@@ -514,7 +523,7 @@ class WindowsAsynchronousSocketChannelIm
             }
 
             // invoke completion handler
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
@@ -522,7 +531,7 @@ class WindowsAsynchronousSocketChannelIm
          */
         @Override
         @SuppressWarnings("unchecked")
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             if (bytesTransferred == 0) {
                 bytesTransferred = -1;  // EOF
             } else {
@@ -543,7 +552,11 @@ class WindowsAsynchronousSocketChannelIm
                     result.setResult((V)Integer.valueOf(bytesTransferred));
                 }
             }
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         @Override
@@ -561,7 +574,7 @@ class WindowsAsynchronousSocketChannelIm
                 enableReading();
                 result.setFailure(x);
             }
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
@@ -579,13 +592,14 @@ class WindowsAsynchronousSocketChannelIm
             }
 
             // invoke handler without any locks
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
     }
 
     @Override
-    <V extends Number,A> Future<V> readImpl(ByteBuffer[] bufs,
-                                            boolean scatteringRead,
+    <V extends Number,A> Future<V> implRead(boolean isScatteringRead,
+                                            ByteBuffer dst,
+                                            ByteBuffer[] dsts,
                                             long timeout,
                                             TimeUnit unit,
                                             A attachment,
@@ -594,7 +608,14 @@ class WindowsAsynchronousSocketChannelIm
         // setup task
         PendingFuture<V,A> result =
             new PendingFuture<V,A>(this, handler, attachment);
-        final ReadTask readTask = new ReadTask<V,A>(bufs, scatteringRead, result);
+        ByteBuffer[] bufs;
+        if (isScatteringRead) {
+            bufs = dsts;
+        } else {
+            bufs = new ByteBuffer[1];
+            bufs[0] = dst;
+        }
+        final ReadTask readTask = new ReadTask<V,A>(bufs, isScatteringRead, result);
         result.setContext(readTask);
 
         // schedule timeout
@@ -607,8 +628,12 @@ class WindowsAsynchronousSocketChannelIm
             result.setTimeoutTask(timeoutTask);
         }
 
-        // initiate I/O (can only be done from thread in thread pool)
-        Invoker.invokeOnThreadInThreadPool(this, readTask);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            readTask.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, readTask);
+        }
         return result;
     }
 
@@ -710,7 +735,7 @@ class WindowsAsynchronousSocketChannelIm
         }
 
         @Override
-        @SuppressWarnings("unchecked")
+        //@SuppressWarnings("unchecked")
         public void run() {
             long overlapped = 0L;
             boolean prepared = false;
@@ -759,7 +784,7 @@ class WindowsAsynchronousSocketChannelIm
             }
 
             // invoke completion handler
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
@@ -767,7 +792,7 @@ class WindowsAsynchronousSocketChannelIm
          */
         @Override
         @SuppressWarnings("unchecked")
-        public void completed(int bytesTransferred) {
+        public void completed(int bytesTransferred, boolean canInvokeDirect) {
             updateBuffers(bytesTransferred);
 
             // return direct buffer to cache if substituted
@@ -784,7 +809,11 @@ class WindowsAsynchronousSocketChannelIm
                     result.setResult((V)Integer.valueOf(bytesTransferred));
                 }
             }
-            Invoker.invoke(result.handler(), result);
+            if (canInvokeDirect) {
+                Invoker.invokeUnchecked(result);
+            } else {
+                Invoker.invoke(result);
+            }
         }
 
         @Override
@@ -802,7 +831,7 @@ class WindowsAsynchronousSocketChannelIm
                 enableWriting();
                 result.setFailure(x);
             }
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
 
         /**
@@ -820,13 +849,14 @@ class WindowsAsynchronousSocketChannelIm
             }
 
             // invoke handler without any locks
-            Invoker.invoke(result.handler(), result);
+            Invoker.invoke(result);
         }
     }
 
     @Override
-    <V extends Number,A> Future<V> writeImpl(ByteBuffer[] bufs,
-                                             boolean gatheringWrite,
+    <V extends Number,A> Future<V> implWrite(boolean gatheringWrite,
+                                             ByteBuffer src,
+                                             ByteBuffer[] srcs,
                                              long timeout,
                                              TimeUnit unit,
                                              A attachment,
@@ -835,6 +865,13 @@ class WindowsAsynchronousSocketChannelIm
         // setup task
         PendingFuture<V,A> result =
             new PendingFuture<V,A>(this, handler, attachment);
+        ByteBuffer[] bufs;
+        if (gatheringWrite) {
+            bufs = srcs;
+        } else {
+            bufs = new ByteBuffer[1];
+            bufs[0] = src;
+        }
         final WriteTask writeTask = new WriteTask<V,A>(bufs, gatheringWrite, result);
         result.setContext(writeTask);
 
@@ -849,7 +886,12 @@ class WindowsAsynchronousSocketChannelIm
         }
 
         // initiate I/O (can only be done from thread in thread pool)
-        Invoker.invokeOnThreadInThreadPool(this, writeTask);
+        // initiate I/O
+        if (Iocp.supportsThreadAgnosticIo()) {
+            writeTask.run();
+        } else {
+            Invoker.invokeOnThreadInThreadPool(this, writeTask);
+        }
         return result;
     }
 
--- a/src/windows/classes/sun/nio/fs/WindowsFileAttributeViews.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsFileAttributeViews.java	Tue Sep 22 01:20:51 2009 -0700
@@ -46,6 +46,7 @@ class WindowsFileAttributeViews {
 
         @Override
         public WindowsFileAttributes readAttributes() throws IOException {
+            file.checkRead();
             try {
                 return WindowsFileAttributes.get(file, followLinks);
             } catch (WindowsException x) {
--- a/src/windows/classes/sun/nio/fs/WindowsFileAttributes.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsFileAttributes.java	Tue Sep 22 01:20:51 2009 -0700
@@ -246,8 +246,8 @@ class WindowsFileAttributes
         long lastWriteTime = unsafe.getLong(address + OFFSETOF_FIND_DATA_LASTWRITETIME);
         long size = ((long)(unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZEHIGH)) << 32)
             + (unsafe.getInt(address + OFFSETOF_FIND_DATA_SIZELOW) & 0xFFFFFFFFL);
-        int reparseTag = ((fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) != 0) ?
-            + unsafe.getInt(address + OFFSETOF_FIND_DATA_RESERVED0) : 0;
+        int reparseTag = isReparsePoint(fileAttrs) ?
+            unsafe.getInt(address + OFFSETOF_FIND_DATA_RESERVED0) : 0;
         return new WindowsFileAttributes(fileAttrs,
                                          creationTime,
                                          lastAccessTime,
@@ -275,7 +275,7 @@ class WindowsFileAttributes
             int reparseTag = 0;
             int fileAttrs = unsafe
                 .getInt(address + OFFSETOF_FILE_INFORMATION_ATTRIBUTES);
-            if ((fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) != 0) {
+            if (isReparsePoint(fileAttrs)) {
                 int size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
                 NativeBuffer reparseBuffer = NativeBuffers.getNativeBuffer(size);
                 try {
@@ -311,7 +311,7 @@ class WindowsFileAttributes
                 // just return the attributes
                 int fileAttrs = unsafe
                     .getInt(address + OFFSETOF_FILE_ATTRIBUTE_DATA_ATTRIBUTES);
-                if ((fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) == 0)
+                if (!isReparsePoint(fileAttrs))
                     return fromFileAttributeData(address, 0);
             } catch (WindowsException x) {
                 if (x.lastError() != ERROR_SHARING_VIOLATION)
@@ -358,7 +358,7 @@ class WindowsFileAttributes
     }
 
     /**
-     * Returns true if the attribtues are of the same file - both files must
+     * Returns true if the attributes are of the same file - both files must
      * be open.
      */
     static boolean isSameFile(WindowsFileAttributes attrs1,
@@ -370,6 +370,13 @@ class WindowsFileAttributes
                (attrs1.fileIndexLow == attrs2.fileIndexLow);
     }
 
+    /**
+     * Returns true if the attributes are of a file with a reparse point.
+     */
+    static boolean isReparsePoint(int attributes) {
+        return (attributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0;
+    }
+
     // package-private
     int attributes() {
         return fileAttrs;
@@ -420,7 +427,7 @@ class WindowsFileAttributes
 
     // package private
     boolean isReparsePoint() {
-        return (fileAttrs & FILE_ATTRIBUTE_REPARSE_POINT) != 0;
+        return isReparsePoint(fileAttrs);
     }
 
     boolean isDirectoryLink() {
--- a/src/windows/classes/sun/nio/fs/WindowsFileStore.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsFileStore.java	Tue Sep 22 01:20:51 2009 -0700
@@ -153,7 +153,7 @@ class WindowsFileStore
     public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
         if (type == null)
             throw new NullPointerException();
-        if (type == BasicFileAttributeView.class)
+        if (type == BasicFileAttributeView.class || type == DosFileAttributeView.class)
             return true;
         if (type == AclFileAttributeView.class || type == FileOwnerAttributeView.class)
             return ((volInfo.flags() & FILE_PERSISTENT_ACLS) != 0);
--- a/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsFileSystem.java	Tue Sep 22 01:20:51 2009 -0700
@@ -283,25 +283,15 @@ class WindowsFileSystem
             }
         }
 
-        // match in uppercase
-        StringBuilder sb = new StringBuilder(expr.length());
-        for (int i=0; i<expr.length(); i++) {
-            sb.append(Character.toUpperCase(expr.charAt(i)));
-        }
-        expr = sb.toString();
+        // match in unicode_case_insensitive
+        final Pattern pattern = Pattern.compile(expr,
+            Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
         // return matcher
-        final Pattern pattern = Pattern.compile(expr);
         return new PathMatcher() {
             @Override
             public boolean matches(Path path) {
-                // match in uppercase
-                String s = path.toString();
-                StringBuilder sb = new StringBuilder(s.length());
-                for (int i=0; i<s.length(); i++) {
-                    sb.append( Character.toUpperCase(s.charAt(i)) );
-                }
-                return pattern.matcher(sb).matches();
+                return pattern.matcher(path.toString()).matches();
             }
         };
     }
--- a/src/windows/classes/sun/nio/fs/WindowsLinkSupport.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsLinkSupport.java	Tue Sep 22 01:20:51 2009 -0700
@@ -63,6 +63,30 @@ class WindowsLinkSupport {
     }
 
     /**
+     * Returns the final path (all symbolic links resolved) or null if this
+     * operation is not supported.
+     */
+    private static String getFinalPath(WindowsPath input) throws IOException {
+        long h = 0;
+        try {
+            h = input.openForReadAttributeAccess(true);
+        } catch (WindowsException x) {
+            x.rethrowAsIOException(input);
+        }
+        try {
+            return stripPrefix(GetFinalPathNameByHandle(h));
+        } catch (WindowsException x) {
+            // ERROR_INVALID_LEVEL is the error returned when not supported
+            // (a sym link to file on FAT32 or Samba server for example)
+            if (x.lastError() != ERROR_INVALID_LEVEL)
+                x.rethrowAsIOException(input);
+        } finally {
+            CloseHandle(h);
+        }
+        return null;
+    }
+
+    /**
      * Returns the final path of a given path as a String. This should be used
      * prior to calling Win32 system calls that do not follow links.
      */
@@ -70,7 +94,6 @@ class WindowsLinkSupport {
         throws IOException
     {
         WindowsFileSystem fs = input.getFileSystem();
-
         try {
             // if not following links then don't need final path
             if (!followLinks || !fs.supportsLinks())
@@ -84,25 +107,10 @@ class WindowsLinkSupport {
             x.rethrowAsIOException(input);
         }
 
-        // The file is a symbolic link so we open it and try to get the
-        // normalized path. This should succeed on NTFS but may fail if there
-        // is a link to a non-NFTS file system.
-        long h = 0;
-        try {
-            h = input.openForReadAttributeAccess(true);
-        } catch (WindowsException x) {
-            x.rethrowAsIOException(input);
-        }
-        try {
-            return stripPrefix(GetFinalPathNameByHandle(h));
-        } catch (WindowsException x) {
-            // ERROR_INVALID_LEVEL is the error returned when not supported by
-            // the file system
-            if (x.lastError() != ERROR_INVALID_LEVEL)
-                x.rethrowAsIOException(input);
-        } finally {
-            CloseHandle(h);
-        }
+        // The file is a symbolic link so attempt to get the final path
+        String result = getFinalPath(input);
+        if (result != null)
+            return result;
 
         // Fallback: read target of link, resolve against parent, and repeat
         // until file is not a link.
@@ -149,30 +157,8 @@ class WindowsLinkSupport {
         throws IOException
     {
         WindowsFileSystem fs = input.getFileSystem();
-        if (!fs.supportsLinks())
+        if (resolveLinks && !fs.supportsLinks())
             resolveLinks = false;
-
-        // On Vista use GetFinalPathNameByHandle. This should succeed on NTFS
-        // but may fail if there is a link to a non-NFTS file system.
-        if (resolveLinks) {
-            long h = 0;
-            try {
-                h = input.openForReadAttributeAccess(true);
-            } catch (WindowsException x) {
-                x.rethrowAsIOException(input);
-            }
-            try {
-                return stripPrefix(GetFinalPathNameByHandle(h));
-            } catch (WindowsException x) {
-                if (x.lastError() != ERROR_INVALID_LEVEL)
-                    x.rethrowAsIOException(input);
-            } finally {
-                CloseHandle(h);
-            }
-        }
-
-        // Not resolving links or we are on Windows Vista (or newer) with a
-        // link to non-NFTS file system.
 
         // Start with absolute path
         String path = null;
@@ -183,15 +169,12 @@ class WindowsLinkSupport {
         }
 
         // Collapse "." and ".."
-        try {
-            path = GetFullPathName(path);
-        } catch (WindowsException x) {
-            x.rethrowAsIOException(input);
-        }
-
-        // eliminate all symbolic links
-        if (resolveLinks) {
-            path = resolveAllLinks(WindowsPath.createFromNormalizedPath(fs, path));
+        if (path.indexOf('.') >= 0) {
+            try {
+                path = GetFullPathName(path);
+            } catch (WindowsException x) {
+                x.rethrowAsIOException(input);
+            }
         }
 
         // string builder to build up components of path
@@ -229,12 +212,15 @@ class WindowsLinkSupport {
             throw new AssertionError("path type not recognized");
         }
 
-        // check root directory exists
-        try {
-            FirstFile fileData = FindFirstFile(sb.toString() + "*");
-            FindClose(fileData.handle());
-        } catch (WindowsException x) {
-            x.rethrowAsIOException(path);
+        // if the result is only a root component then we simply check it exists
+        if (start >= path.length()) {
+            String result = sb.toString();
+            try {
+                GetFileAttributes(result);
+            } catch (WindowsException x) {
+                x.rethrowAsIOException(path);
+            }
+            return result;
         }
 
         // iterate through each component to get its actual name in the
@@ -246,13 +232,28 @@ class WindowsLinkSupport {
             String search = sb.toString() + path.substring(curr, end);
             try {
                 FirstFile fileData = FindFirstFile(addLongPathPrefixIfNeeded(search));
-                try {
-                    sb.append(fileData.name());
-                    if (next != -1) {
-                        sb.append('\\');
+                FindClose(fileData.handle());
+
+                // if a reparse point is encountered then we must return the
+                // final path.
+                if (resolveLinks &&
+                    WindowsFileAttributes.isReparsePoint(fileData.attributes()))
+                {
+                    String result = getFinalPath(input);
+                    if (result == null) {
+                        // Fallback to slow path, usually because there is a sym
+                        // link to a file system that doesn't support sym links.
+                        WindowsPath resolved = resolveAllLinks(
+                            WindowsPath.createFromNormalizedPath(fs, path));
+                        result = getRealPath(resolved, false);
                     }
-                } finally {
-                    FindClose(fileData.handle());
+                    return result;
+                }
+
+                // add the name to the result
+                sb.append(fileData.name());
+                if (next != -1) {
+                    sb.append('\\');
                 }
             } catch (WindowsException e) {
                 e.rethrowAsIOException(path);
@@ -342,7 +343,7 @@ class WindowsLinkSupport {
     /**
      * Resolve all symbolic-links in a given absolute and normalized path
      */
-    private static String resolveAllLinks(WindowsPath path)
+    private static WindowsPath resolveAllLinks(WindowsPath path)
         throws IOException
     {
         assert path.isAbsolute();
@@ -401,7 +402,7 @@ class WindowsLinkSupport {
             }
         }
 
-        return path.toString();
+        return path;
     }
 
     /**
--- a/src/windows/classes/sun/nio/fs/WindowsNativeDispatcher.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/classes/sun/nio/fs/WindowsNativeDispatcher.java	Tue Sep 22 01:20:51 2009 -0700
@@ -180,10 +180,12 @@ class WindowsNativeDispatcher {
     static class FirstFile {
         private long handle;
         private String name;
+        private int attributes;
 
         private FirstFile() { }
         public long handle()    { return handle; }
         public String name()    { return name; }
+        public int attributes() { return attributes; }
     }
     private static native void FindFirstFile0(long lpFileName, FirstFile obj)
         throws WindowsException;
--- a/src/windows/lib/tzmappings	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/lib/tzmappings	Tue Sep 22 01:20:51 2009 -0700
@@ -82,8 +82,8 @@ GMT Standard Time:0,1::Europe/London:
 GMT Standard Time:0,1::Europe/London:
 Ekaterinburg:10,11::Asia/Yekaterinburg:
 Ekaterinburg Standard Time:10,11::Asia/Yekaterinburg:
-West Asia:10,11::Asia/Karachi:
-West Asia Standard Time:10,11::Asia/Karachi:
+West Asia:10,11:UZ:Asia/Tashkent:
+West Asia Standard Time:10,11:UZ:Asia/Tashkent:
 Central Asia:12,13::Asia/Dhaka:
 Central Asia Standard Time:12,13::Asia/Dhaka:
 N. Central Asia Standard Time:12,13::Asia/Novosibirsk:
@@ -146,8 +146,8 @@ South Africa Standard Time:4,69::Africa/
 South Africa Standard Time:4,69::Africa/Harare:
 Atlantic:40,41::America/Halifax:
 Atlantic Standard Time:40,41::America/Halifax:
-SA Eastern:42,43::America/Buenos_Aires:
-SA Eastern Standard Time:42,43::America/Buenos_Aires:
+SA Eastern:42,43:GF:America/Cayenne:
+SA Eastern Standard Time:42,43:GF:America/Cayenne:
 Mid-Atlantic:44,45::Atlantic/South_Georgia:
 Mid-Atlantic Standard Time:44,45::Atlantic/South_Georgia:
 Azores:46,47::Atlantic/Azores:
@@ -160,21 +160,28 @@ Tonga Standard Time:78,79::Pacific/Tonga
 Tonga Standard Time:78,79::Pacific/Tongatapu:
 Arabian:8,9::Asia/Muscat:
 Arabian Standard Time:8,9::Asia/Muscat:
-Caucasus:8,9::GMT+0400:
-Caucasus Standard Time:8,9::GMT+0400:
+Caucasus:8,9:AM:Asia/Yerevan:
+Caucasus Standard Time:8,9:AM:Asia/Yerevan:
 GMT Standard Time:88,89::GMT:
 Greenwich:88,89::GMT:
 Greenwich Standard Time:88,89::GMT:
-Central Brazilian Standard Time:900,900:BR:America/Manaus:
-Central Standard Time (Mexico):901,901::America/Mexico_City:
-Georgian Standard Time:902,902:GE:Asia/Tbilisi:
-Mountain Standard Time (Mexico):903,903:MX:America/Chihuahua:
-Namibia Standard Time:904,904:NA:Africa/Windhoek:
-Pacific Standard Time (Mexico):905,905:MX:America/Tijuana:
-Western Brazilian Standard Time:906,906:BR:America/Rio_Branco:
-Azerbaijan Standard Time:907,907:AZ:Asia/Baku:
-Jordan Standard Time:908,908:JO:Asia/Amman:
-Middle East Standard Time:909,909:LB:Asia/Beirut:
-Armenian Standard Time:910,910:AM:Asia/Yerevan:
-Montevideo Standard Time:911,911:UY:America/Montevideo:
-Venezuela Standard Time:912,912::America/Caracas:
+Argentina Standard Time:900,900::America/Buenos_Aires:
+Azerbaijan Standard Time:901,901:AZ:Asia/Baku:
+Central Brazilian Standard Time:902,902:BR:America/Manaus:
+Central Standard Time (Mexico):903,903::America/Mexico_City:
+Georgian Standard Time:904,904:GE:Asia/Tbilisi:
+Jordan Standard Time:905,905:JO:Asia/Amman:
+Mauritius Standard Time:906,906:MU:Indian/Mauritius:
+Middle East Standard Time:907,907:LB:Asia/Beirut:
+Montevideo Standard Time:908,908:UY:America/Montevideo:
+Morocco Standard Time:909,909:MA:Africa/Casablanca:
+Mountain Standard Time (Mexico):910,910:MX:America/Chihuahua:
+Namibia Standard Time:911,911:NA:Africa/Windhoek:
+Pacific Standard Time (Mexico):912,912:MX:America/Tijuana:
+Pakistan Standard Time:913,913::Asia/Karachi:
+UTC:914,914::UTC:
+Venezuela Standard Time:915,915::America/Caracas:
+Kamchatka Standard Time:916,916:RU:Asia/Kamchatka:
+Paraguay Standard Time:917,917:PY:America/Asuncion:
+Western Brazilian Standard Time:918,918:BR:America/Rio_Branco:
+Armenian Standard Time:919,919:AM:Asia/Yerevan:
--- a/src/windows/native/java/io/WinNTFileSystem_md.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/native/java/io/WinNTFileSystem_md.c	Tue Sep 22 01:20:51 2009 -0700
@@ -51,19 +51,163 @@ static struct {
     jfieldID path;
 } ids;
 
+/**
+ * GetFinalPathNameByHandle is available on Windows Vista and newer
+ */
+typedef BOOL (WINAPI* GetFinalPathNameByHandleProc) (HANDLE, LPWSTR, DWORD, DWORD);
+static GetFinalPathNameByHandleProc GetFinalPathNameByHandle_func;
+
 JNIEXPORT void JNICALL
 Java_java_io_WinNTFileSystem_initIDs(JNIEnv *env, jclass cls)
 {
+    HANDLE handle;
     jclass fileClass = (*env)->FindClass(env, "java/io/File");
     if (!fileClass) return;
     ids.path =
              (*env)->GetFieldID(env, fileClass, "path", "Ljava/lang/String;");
+    handle = LoadLibrary("kernel32");
+    if (handle != NULL) {
+        GetFinalPathNameByHandle_func = (GetFinalPathNameByHandleProc)
+            GetProcAddress(handle, "GetFinalPathNameByHandleW");
+    }
 }
 
 /* -- Path operations -- */
 
 extern int wcanonicalize(const WCHAR *path, WCHAR *out, int len);
 extern int wcanonicalizeWithPrefix(const WCHAR *canonicalPrefix, const WCHAR *pathWithCanonicalPrefix, WCHAR *out, int len);
+
+/**
+ * Retrieves the fully resolved (final) path for the given path or NULL
+ * if the function fails.
+ */
+static WCHAR* getFinalPath(const WCHAR *path)
+{
+    HANDLE h;
+    WCHAR *result;
+    DWORD error;
+
+    /* Need Windows Vista or newer to get the final path */
+    if (GetFinalPathNameByHandle_func == NULL)
+        return NULL;
+
+    h = CreateFileW(path,
+                    FILE_READ_ATTRIBUTES,
+                    FILE_SHARE_DELETE |
+                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL,
+                    OPEN_EXISTING,
+                    FILE_FLAG_BACKUP_SEMANTICS,
+                    NULL);
+    if (h == INVALID_HANDLE_VALUE)
+        return NULL;
+
+    /**
+     * Allocate a buffer for the resolved path. For a long path we may need
+     * to allocate a larger buffer.
+     */
+    result = (WCHAR*)malloc(MAX_PATH * sizeof(WCHAR));
+    if (result != NULL) {
+        DWORD len = (*GetFinalPathNameByHandle_func)(h, result, MAX_PATH, 0);
+        if (len >= MAX_PATH) {
+            /* retry with a buffer of the right size */
+            result = (WCHAR*)realloc(result, (len+1) * sizeof(WCHAR));
+            if (result != NULL) {
+                len = (*GetFinalPathNameByHandle_func)(h, result, len, 0);
+            } else {
+                len = 0;
+            }
+        }
+        if (len > 0) {
+            /**
+             * Strip prefix (should be \\?\ or \\?\UNC)
+             */
+            if (result[0] == L'\\' && result[1] == L'\\' &&
+                result[2] == L'?' && result[3] == L'\\')
+            {
+                int isUnc = (result[4] == L'U' &&
+                             result[5] == L'N' &&
+                             result[6] == L'C');
+                int prefixLen = (isUnc) ? 7 : 4;
+                /* actual result length (includes terminator) */
+                int resultLen = len - prefixLen + (isUnc ? 1 : 0) + 1;
+
+                /* copy result without prefix into new buffer */
+                WCHAR *tmp = (WCHAR*)malloc(resultLen * sizeof(WCHAR));
+                if (tmp == NULL) {
+                    len = 0;
+                } else {
+                    WCHAR *p = result;
+                    p += prefixLen;
+                    if (isUnc) {
+                        WCHAR *p2 = tmp;
+                        p2[0] = L'\\';
+                        p2++;
+                        wcscpy(p2, p);
+                    } else {
+                        wcscpy(tmp, p);
+                    }
+                    free(result);
+                    result = tmp;
+                }
+            }
+        }
+
+        /* unable to get final path */
+        if (len == 0 && result != NULL) {
+            free(result);
+            result = NULL;
+        }
+    }
+
+    error = GetLastError();
+    if (CloseHandle(h))
+        SetLastError(error);
+    return result;
+}
+
+/**
+ * Retrieves file information for the specified file. If the file is
+ * symbolic link then the information on fully resolved target is
+ * returned.
+ */
+static BOOL getFileInformation(const WCHAR *path,
+                               BY_HANDLE_FILE_INFORMATION *finfo)
+{
+    BOOL result;
+    DWORD error;
+    HANDLE h = CreateFileW(path,
+                           FILE_READ_ATTRIBUTES,
+                           FILE_SHARE_DELETE |
+                               FILE_SHARE_READ | FILE_SHARE_WRITE,
+                           NULL,
+                           OPEN_EXISTING,
+                           FILE_FLAG_BACKUP_SEMANTICS,
+                           NULL);
+    if (h == INVALID_HANDLE_VALUE)
+        return FALSE;
+    result = GetFileInformationByHandle(h, finfo);
+    error = GetLastError();
+    if (CloseHandle(h))
+        SetLastError(error);
+    return result;
+}
+
+/**
+ * If the given attributes are the attributes of a reparse point, then
+ * read and return the attributes of the final target.
+ */
+DWORD getFinalAttributesIfReparsePoint(WCHAR *path, DWORD a)
+{
+    if ((a != INVALID_FILE_ATTRIBUTES) &&
+        ((a & FILE_ATTRIBUTE_REPARSE_POINT) != 0))
+    {
+        BY_HANDLE_FILE_INFORMATION finfo;
+        BOOL res = getFileInformation(path, &finfo);
+        a = (res) ? finfo.dwFileAttributes : INVALID_FILE_ATTRIBUTES;
+    }
+    return a;
+}
 
 JNIEXPORT jstring JNICALL
 Java_java_io_WinNTFileSystem_canonicalize0(JNIEnv *env, jobject this,
@@ -202,12 +346,15 @@ Java_java_io_WinNTFileSystem_getBooleanA
         return rv;
     if (!isReservedDeviceNameW(pathbuf)) {
         if (GetFileAttributesExW(pathbuf, GetFileExInfoStandard, &wfad)) {
-            rv = (java_io_FileSystem_BA_EXISTS
-                  | ((wfad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
-                     ? java_io_FileSystem_BA_DIRECTORY
-                     : java_io_FileSystem_BA_REGULAR)
-                  | ((wfad.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
-                     ? java_io_FileSystem_BA_HIDDEN : 0));
+            DWORD a = getFinalAttributesIfReparsePoint(pathbuf, wfad.dwFileAttributes);
+            if (a != INVALID_FILE_ATTRIBUTES) {
+                rv = (java_io_FileSystem_BA_EXISTS
+                    | ((a & FILE_ATTRIBUTE_DIRECTORY)
+                        ? java_io_FileSystem_BA_DIRECTORY
+                        : java_io_FileSystem_BA_REGULAR)
+                    | ((a & FILE_ATTRIBUTE_HIDDEN)
+                        ? java_io_FileSystem_BA_HIDDEN : 0));
+            }
         } else { /* pagefile.sys is a special case */
             if (GetLastError() == ERROR_SHARING_VIOLATION) {
                 rv = java_io_FileSystem_BA_EXISTS;
@@ -234,6 +381,7 @@ JNICALL Java_java_io_WinNTFileSystem_che
     if (pathbuf == NULL)
         return JNI_FALSE;
     attr = GetFileAttributesW(pathbuf);
+    attr = getFinalAttributesIfReparsePoint(pathbuf, attr);
     free(pathbuf);
     if (attr == INVALID_FILE_ATTRIBUTES)
         return JNI_FALSE;
@@ -272,6 +420,20 @@ Java_java_io_WinNTFileSystem_setPermissi
     if (pathbuf == NULL)
         return JNI_FALSE;
     a = GetFileAttributesW(pathbuf);
+
+    /* if reparse point, get final target */
+    if ((a != INVALID_FILE_ATTRIBUTES) &&
+        ((a & FILE_ATTRIBUTE_REPARSE_POINT) != 0))
+    {
+        WCHAR *fp = getFinalPath(pathbuf);
+        if (fp == NULL) {
+            a = INVALID_FILE_ATTRIBUTES;
+        } else {
+            free(pathbuf);
+            pathbuf = fp;
+            a = GetFileAttributesW(pathbuf);
+        }
+    }
     if (a != INVALID_FILE_ATTRIBUTES) {
         if (enable)
             a =  a & ~FILE_ATTRIBUTE_READONLY;
@@ -305,7 +467,7 @@ Java_java_io_WinNTFileSystem_getLastModi
                     /* Open existing or fail */
                     OPEN_EXISTING,
                     /* Backup semantics for directories */
-                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
+                    FILE_FLAG_BACKUP_SEMANTICS,
                     /* No template file */
                     NULL);
     if (h != INVALID_HANDLE_VALUE) {
@@ -332,7 +494,16 @@ Java_java_io_WinNTFileSystem_getLength(J
     if (GetFileAttributesExW(pathbuf,
                              GetFileExInfoStandard,
                              &wfad)) {
-        rv = wfad.nFileSizeHigh * ((jlong)MAXDWORD + 1) + wfad.nFileSizeLow;
+        if ((wfad.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == 0) {
+            rv = wfad.nFileSizeHigh * ((jlong)MAXDWORD + 1) + wfad.nFileSizeLow;
+        } else {
+            /* file is a reparse point so read attributes of final target */
+            BY_HANDLE_FILE_INFORMATION finfo;
+            if (getFileInformation(pathbuf, &finfo)) {
+                rv = finfo.nFileSizeHigh * ((jlong)MAXDWORD + 1) +
+                    finfo.nFileSizeLow;
+            }
+        }
     } else {
         if (GetLastError() == ERROR_SHARING_VIOLATION) {
             /* The error is "share violation", which means the file/dir
@@ -360,31 +531,29 @@ Java_java_io_WinNTFileSystem_createFileE
     if (pathbuf == NULL)
         return JNI_FALSE;
     h = CreateFileW(
-        pathbuf,                             /* Wide char path name */
-        GENERIC_READ | GENERIC_WRITE,  /* Read and write permission */
+        pathbuf,                              /* Wide char path name */
+        GENERIC_READ | GENERIC_WRITE,         /* Read and write permission */
         FILE_SHARE_READ | FILE_SHARE_WRITE,   /* File sharing flags */
-        NULL,                                /* Security attributes */
-        CREATE_NEW,                         /* creation disposition */
-        FILE_ATTRIBUTE_NORMAL,              /* flags and attributes */
+        NULL,                                 /* Security attributes */
+        CREATE_NEW,                           /* creation disposition */
+        FILE_ATTRIBUTE_NORMAL |
+            FILE_FLAG_OPEN_REPARSE_POINT,     /* flags and attributes */
         NULL);
 
     if (h == INVALID_HANDLE_VALUE) {
         DWORD error = GetLastError();
         if ((error != ERROR_FILE_EXISTS) && (error != ERROR_ALREADY_EXISTS)) {
-
-            // If a directory by the named path already exists,
-            // return false (behavior of solaris and linux) instead of
-            // throwing an exception
-            DWORD fattr = GetFileAttributesW(pathbuf);
-            if ((fattr == INVALID_FILE_ATTRIBUTES) ||
-                    (fattr & ~FILE_ATTRIBUTE_DIRECTORY)) {
+            // return false rather than throwing an exception when there is
+            // an existing file.
+            DWORD a = GetFileAttributesW(pathbuf);
+            if (a == INVALID_FILE_ATTRIBUTES) {
                 SetLastError(error);
                 JNU_ThrowIOExceptionWithLastError(env, "Could not open file");
             }
          }
          free(pathbuf);
          return JNI_FALSE;
-    }
+        }
     free(pathbuf);
     CloseHandle(h);
     return JNI_TRUE;
@@ -396,9 +565,9 @@ removeFileOrDirectory(const jchar *path)
     /* Returns 0 on success */
     DWORD a;
 
-    SetFileAttributesW(path, 0);
+    SetFileAttributesW(path, FILE_ATTRIBUTE_NORMAL);
     a = GetFileAttributesW(path);
-    if (a == ((DWORD)-1)) {
+    if (a == INVALID_FILE_ATTRIBUTES) {
         return 1;
     } else if (a & FILE_ATTRIBUTE_DIRECTORY) {
         return !RemoveDirectoryW(path);
@@ -578,8 +747,13 @@ Java_java_io_WinNTFileSystem_setLastModi
     HANDLE h;
     if (pathbuf == NULL)
         return JNI_FALSE;
-    h = CreateFileW(pathbuf, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
-                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, 0);
+    h = CreateFileW(pathbuf,
+                    FILE_WRITE_ATTRIBUTES,
+                    FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL,
+                    OPEN_EXISTING,
+                    FILE_FLAG_BACKUP_SEMANTICS,
+                    0);
     if (h != INVALID_HANDLE_VALUE) {
         LARGE_INTEGER modTime;
         FILETIME t;
@@ -607,6 +781,21 @@ Java_java_io_WinNTFileSystem_setReadOnly
     if (pathbuf == NULL)
         return JNI_FALSE;
     a = GetFileAttributesW(pathbuf);
+
+    /* if reparse point, get final target */
+    if ((a != INVALID_FILE_ATTRIBUTES) &&
+        ((a & FILE_ATTRIBUTE_REPARSE_POINT) != 0))
+    {
+        WCHAR *fp = getFinalPath(pathbuf);
+        if (fp == NULL) {
+            a = INVALID_FILE_ATTRIBUTES;
+        } else {
+            free(pathbuf);
+            pathbuf = fp;
+            a = GetFileAttributesW(pathbuf);
+        }
+    }
+
     if (a != INVALID_FILE_ATTRIBUTES) {
         if (SetFileAttributesW(pathbuf, a | FILE_ATTRIBUTE_READONLY))
         rv = JNI_TRUE;
--- a/src/windows/native/sun/nio/ch/Iocp.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/native/sun/nio/ch/Iocp.c	Tue Sep 22 01:20:51 2009 -0700
@@ -56,6 +56,16 @@ Java_sun_nio_ch_Iocp_initIDs(JNIEnv* env
     completionStatus_completionKey = (*env)->GetFieldID(env, clazz, "completionKey", "I");
     if (completionStatus_completionKey == NULL) return;
     completionStatus_overlapped = (*env)->GetFieldID(env, clazz, "overlapped", "J");
+}
+
+JNIEXPORT jint JNICALL
+Java_sun_nio_ch_Iocp_osMajorVersion(JNIEnv* env, jclass this)
+{
+    OSVERSIONINFOEX ver;
+    ver.dwOSVersionInfoSize = sizeof(ver);
+    GetVersionEx((OSVERSIONINFO *) &ver);
+    return (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) ?
+        (jint)(ver.dwMajorVersion) : (jint)0;
 }
 
 JNIEXPORT jlong JNICALL
--- a/src/windows/native/sun/nio/fs/WindowsNativeDispatcher.c	Tue Sep 15 16:15:36 2009 +0400
+++ b/src/windows/native/sun/nio/fs/WindowsNativeDispatcher.c	Tue Sep 22 01:20:51 2009 -0700
@@ -48,6 +48,7 @@
  */
 static jfieldID findFirst_handle;
 static jfieldID findFirst_name;
+static jfieldID findFirst_attributes;
 
 static jfieldID findStream_handle;
 static jfieldID findStream_name;
@@ -134,6 +135,7 @@ Java_sun_nio_fs_WindowsNativeDispatcher_
     }
     findFirst_handle = (*env)->GetFieldID(env, clazz, "handle", "J");
     findFirst_name = (*env)->GetFieldID(env, clazz, "name", "Ljava/lang/String;");
+    findFirst_attributes = (*env)->GetFieldID(env, clazz, "attributes", "I");
 
     clazz = (*env)->FindClass(env, "sun/nio/fs/WindowsNativeDispatcher$FirstStream");
     if (clazz == NULL) {
@@ -371,6 +373,7 @@ Java_sun_nio_fs_WindowsNativeDispatcher_
             return;
         (*env)->SetLongField(env, obj, findFirst_handle, ptr_to_jlong(handle));
         (*env)->SetObjectField(env, obj, findFirst_name, name);
+        (*env)->SetIntField(env, obj, findFirst_attributes, data.dwFileAttributes);
     } else {
         throwWindowsException(env, GetLastError());
     }
@@ -387,7 +390,7 @@ Java_sun_nio_fs_WindowsNativeDispatcher_
     if (handle == INVALID_HANDLE_VALUE) {
         throwWindowsException(env, GetLastError());
     }
-        return ptr_to_jlong(handle);
+    return ptr_to_jlong(handle);
 }
 
 JNIEXPORT jstring JNICALL
--- a/test/com/sun/jdi/BadHandshakeTest.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/com/sun/jdi/BadHandshakeTest.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 6306165
+ * @bug 6306165 6432567
  * @summary Check that a bad handshake doesn't cause a debuggee to abort
  *
  * @build VMConnection BadHandshakeTest Exit0
--- a/test/java/lang/String/Split.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/lang/String/Split.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,14 +23,18 @@
 
 /**
  * @test
+ * @bug 6840246
  * @summary test String.split()
  */
+import java.util.Arrays;
+import java.util.Random;
 import java.util.regex.*;
 
 public class Split {
 
     public static void main(String[] args) throws Exception {
         String source = "0123456789";
+
         for (int limit=-2; limit<3; limit++) {
             for (int x=0; x<10; x++) {
                 String[] result = source.split(Integer.toString(x), limit);
@@ -80,5 +84,48 @@ public class Split {
             throw new RuntimeException("String.split failure 8");
         if (!result[0].equals(source))
             throw new RuntimeException("String.split failure 9");
+
+        // check fastpath of String.split()
+        source = "0123456789abcdefgABCDEFG";
+        Random r = new Random();
+
+        for (boolean doEscape: new boolean[] {false, true}) {
+            for (int cp = 0; cp < 0x11000; cp++) {
+                Pattern p = null;
+                String regex = new String(Character.toChars(cp));
+                if (doEscape)
+                    regex = "\\" + regex;
+                try {
+                    p = Pattern.compile(regex);
+                } catch (PatternSyntaxException pse) {
+                    // illegal syntax
+                    try {
+                        "abc".split(regex);
+                    } catch (PatternSyntaxException pse0) {
+                        continue;
+                    }
+                    throw new RuntimeException("String.split failure 11");
+                }
+                int off = r.nextInt(source.length());
+                String[] srcStrs = new String[] {
+                    "",
+                    source,
+                    regex + source,
+                    source + regex,
+                    source.substring(0, 3)
+                        + regex + source.substring(3, 9)
+                        + regex + source.substring(9, 15)
+                        + regex + source.substring(15),
+                    source.substring(0, off) + regex + source.substring(off)
+                };
+                for (String src: srcStrs) {
+                    for (int limit=-2; limit<3; limit++) {
+                        if (!Arrays.equals(src.split(regex, limit),
+                                           p.split(src, limit)))
+                            throw new RuntimeException("String.split failure 12");
+                    }
+                }
+            }
+        }
     }
 }
--- a/test/java/lang/reflect/Generics/Probe.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/lang/reflect/Generics/Probe.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,11 +23,9 @@
 
 /*
  * @test
- * @bug 5003916 6704655
+ * @bug 5003916 6704655 6873951
  * @summary Testing parsing of signatures attributes of nested classes
  * @author Joseph D. Darcy
- * @compile -source 1.5 Probe.java
- * @run main Probe
  */
 
 import java.lang.reflect.*;
@@ -35,50 +33,34 @@ import java.util.*;
 import java.util.*;
 import static java.util.Arrays.*;
 
-@Classes(value={
-        "java.util.concurrent.FutureTask",
-        "java.util.concurrent.ConcurrentHashMap$EntryIterator",
-        "java.util.concurrent.ConcurrentHashMap$KeyIterator",
-        "java.util.concurrent.ConcurrentHashMap$ValueIterator",
-        "java.util.AbstractList$ListItr",
-        "java.util.EnumMap$EntryIterator",
-        "java.util.EnumMap$KeyIterator",
-        "java.util.EnumMap$ValueIterator",
-        "java.util.IdentityHashMap$EntryIterator",
-        "java.util.IdentityHashMap$KeyIterator",
-        "java.util.IdentityHashMap$ValueIterator",
-        "java.util.WeakHashMap$EntryIterator",
-        "java.util.WeakHashMap$KeyIterator",
-        "java.util.WeakHashMap$ValueIterator",
-        "java.util.TreeMap$EntryIterator",
-        "java.util.TreeMap$KeyIterator",
-        "java.util.TreeMap$ValueIterator",
-        "java.util.HashMap$EntryIterator",
-        "java.util.HashMap$KeyIterator",
-        "java.util.HashMap$ValueIterator",
-        "java.util.LinkedHashMap$EntryIterator",
-        "java.util.LinkedHashMap$KeyIterator",
-        "java.util.LinkedHashMap$ValueIterator"
-        },
-        sunClasses={
-        "javax.crypto.SunJCE_c",
-        "javax.crypto.SunJCE_e",
-        "javax.crypto.SunJCE_f",
-        "javax.crypto.SunJCE_j",
-        "javax.crypto.SunJCE_k",
-        "javax.crypto.SunJCE_l"
-        })
+@Classes({"java.util.concurrent.FutureTask",
+          "java.util.concurrent.ConcurrentHashMap$EntryIterator",
+          "java.util.concurrent.ConcurrentHashMap$KeyIterator",
+          "java.util.concurrent.ConcurrentHashMap$ValueIterator",
+          "java.util.AbstractList$ListItr",
+          "java.util.EnumMap$EntryIterator",
+          "java.util.EnumMap$KeyIterator",
+          "java.util.EnumMap$ValueIterator",
+          "java.util.IdentityHashMap$EntryIterator",
+          "java.util.IdentityHashMap$KeyIterator",
+          "java.util.IdentityHashMap$ValueIterator",
+          "java.util.WeakHashMap$EntryIterator",
+          "java.util.WeakHashMap$KeyIterator",
+          "java.util.WeakHashMap$ValueIterator",
+          "java.util.TreeMap$EntryIterator",
+          "java.util.TreeMap$KeyIterator",
+          "java.util.TreeMap$ValueIterator",
+          "java.util.HashMap$EntryIterator",
+          "java.util.HashMap$KeyIterator",
+          "java.util.HashMap$ValueIterator",
+          "java.util.LinkedHashMap$EntryIterator",
+          "java.util.LinkedHashMap$KeyIterator",
+          "java.util.LinkedHashMap$ValueIterator"})
 public class Probe {
-    public static void main (String[] args) throws Throwable {
+    public static void main (String... args) throws Throwable {
         Classes classesAnnotation = (Probe.class).getAnnotation(Classes.class);
         List<String> names =
             new ArrayList<String>(asList(classesAnnotation.value()));
-
-        if (System.getProperty("java.runtime.name").startsWith("Java(TM)")) {
-            // Sun production JDK; test crypto classes too
-            for(String name: classesAnnotation.sunClasses())
-                names.add(name);
-        }
 
         int errs = 0;
         for(String name: names) {
@@ -152,5 +134,4 @@ public class Probe {
 @Retention(RetentionPolicy.RUNTIME)
 @interface Classes {
     String [] value(); // list of classes to probe
-    String [] sunClasses(); // list of Sun-production JDK specific classes to probe
 }
--- a/test/java/math/BigDecimal/DivideTests.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/math/BigDecimal/DivideTests.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4851776 4907265 6177836
+ * @bug 4851776 4907265 6177836 6876282
  * @summary Some tests for the divide methods.
  * @author Joseph D. Darcy
  * @compile -source 1.5 DivideTests.java
@@ -328,6 +328,35 @@ public class DivideTests {
             }
         }
 
+        // 6876282
+        BigDecimal[][] testCases2 = {
+            // { dividend, divisor, expected quotient }
+            { new BigDecimal(3090), new BigDecimal(7), new BigDecimal(441) },
+            { new BigDecimal("309000000000000000000000"), new BigDecimal("700000000000000000000"),
+              new BigDecimal(441) },
+            { new BigDecimal("962.430000000000"), new BigDecimal("8346463.460000000000"),
+              new BigDecimal("0.000115309916") },
+            { new BigDecimal("18446744073709551631"), new BigDecimal("4611686018427387909"),
+              new BigDecimal(4) },
+            { new BigDecimal("18446744073709551630"), new BigDecimal("4611686018427387909"),
+              new BigDecimal(4) },
+            { new BigDecimal("23058430092136939523"), new BigDecimal("4611686018427387905"),
+              new BigDecimal(5) },
+            { new BigDecimal("-18446744073709551661"), new BigDecimal("-4611686018427387919"),
+              new BigDecimal(4) },
+            { new BigDecimal("-18446744073709551660"), new BigDecimal("-4611686018427387919"),
+              new BigDecimal(4) },
+        };
+
+        for (BigDecimal test[] : testCases2) {
+            BigDecimal quo = test[0].divide(test[1], RoundingMode.HALF_UP);
+            if (!quo.equals(test[2])) {
+                failures++;
+                System.err.println("Unexpected quotient from " + test[0] + " / " + test[1] +
+                                   " rounding mode HALF_UP" +
+                                   "; expected " + test[2] + " got " + quo);
+            }
+        }
         return failures;
     }
 
--- a/test/java/nio/channels/AsynchronousChannelGroup/GroupOfOne.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousChannelGroup/GroupOfOne.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousChannelGroup
  */
 
@@ -49,8 +49,6 @@ public class GroupOfOne {
                 listener.accept((Void)null, this);
             }
             public void failed(Throwable exc, Void att) {
-            }
-            public void cancelled(Void att) {
             }
         });
 
@@ -97,9 +95,6 @@ public class GroupOfOne {
                         System.out.println("Read failed (expected)");
                         latch.countDown();
                     }
-                    public void cancelled(Void att) {
-                        throw new RuntimeException();
-                    }
                 });
 
                 // close channel or shutdown group
@@ -122,9 +117,6 @@ public class GroupOfOne {
             public void failed(Throwable exc, Void att) {
                 throw new RuntimeException(exc);
             }
-            public void cancelled(Void att) {
-                throw new RuntimeException();
-            }
         });
 
         latch.await();
--- a/test/java/nio/channels/AsynchronousChannelGroup/Identity.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousChannelGroup/Identity.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousChannelGroup
  */
 
@@ -90,13 +90,9 @@ public class Identity {
                     }
                     public void failed(Throwable exc, Void att) {
                     }
-                    public void cancelled(Void att) {
-                    }
                 });
             }
             public void failed(Throwable exc, Void att) {
-            }
-            public void cancelled(Void att) {
             }
         });
         int port = ((InetSocketAddress)(listener.getLocalAddress())).getPort();
@@ -141,9 +137,6 @@ public class Identity {
             public void failed(Throwable exc, Integer groupId) {
                 fail(exc.getMessage());
             }
-            public void cancelled(Integer groupId) {
-                fail("I/O operation was cancelled");
-            }
         });
 
         // wait until
--- a/test/java/nio/channels/AsynchronousChannelGroup/Restart.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousChannelGroup/Restart.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousChannelGroup
  * @build Restart
  * @run main/othervm -XX:-UseVMInterruptibleIO Restart
@@ -111,8 +111,6 @@ public class Restart {
                 }
                 public void failed(Throwable exc, Void att) {
                 }
-                public void cancelled(Void att) {
-                }
             });
 
             // establish loopback connection which should cause completion
--- a/test/java/nio/channels/AsynchronousChannelGroup/Unbounded.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousChannelGroup/Unbounded.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousChannelGroup
  */
 
@@ -51,8 +51,6 @@ public class Unbounded {
                 listener.accept((Void)null, this);
             }
             public void failed(Throwable exc, Void att) {
-            }
-            public void cancelled(Void att) {
             }
         });
         System.out.println("Listener created.");
@@ -97,8 +95,6 @@ public class Unbounded {
                     }
                     public void failed(Throwable exc, AsynchronousSocketChannel ch) {
                     }
-                    public void cancelled(AsynchronousSocketChannel ch) {
-                    }
                 });
         }
         System.out.println("All read operations outstanding.");
--- a/test/java/nio/channels/AsynchronousDatagramChannel/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousDatagramChannel/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4527345
+ * @bug 4527345 6842687
  * @summary Unit test for AsynchronousDatagramChannel
  */
 
@@ -72,8 +72,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
         Thread.sleep(2000);
         sender.send(ByteBuffer.wrap(msg), sa);
@@ -87,8 +85,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
                 exception.set(exc);
-            }
-            public void cancelled(Void att) {
             }
         });
         Throwable result;
@@ -107,8 +103,6 @@ public class Basic {
             public void failed (Throwable exc, Void att) {
                 exception.set(exc);
             }
-            public void cancelled(Void att) {
-            }
         });
         ch.close();
         while ((result = exception.get()) == null) {
@@ -162,8 +156,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
         Thread.sleep(2000);
         sender.send(ByteBuffer.wrap(msg), sa);
@@ -178,8 +170,6 @@ public class Basic {
             public void failed (Throwable exc, Void att) {
                 exception.set(exc);
             }
-            public void cancelled(Void att) {
-            }
         });
         Throwable result;
         while ((result = exception.get()) == null) {
@@ -196,8 +186,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
                 exception.set(exc);
-            }
-            public void cancelled(Void att) {
             }
         });
         ch.close();
@@ -246,8 +234,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
         l2.await(5, TimeUnit.SECONDS);
 
@@ -271,8 +257,6 @@ public class Basic {
                 } else {
                     throw new RuntimeException(exc);
                 }
-            }
-            public void cancelled(Void att) {
             }
         });
         l3.await(5, TimeUnit.SECONDS);
@@ -323,8 +307,6 @@ public class Basic {
             }
             public void failed (Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
         l2.await(5, TimeUnit.SECONDS);
 
@@ -340,7 +322,7 @@ public class Basic {
         reader.close();
     }
 
-    static void cancelAndCheck(Future<?> result, CountDownLatch latch)
+    static void cancelAndCheck(Future<?> result)
         throws InterruptedException
     {
         boolean cancelled = result.cancel(false);
@@ -356,37 +338,22 @@ public class Basic {
         } catch (ExecutionException e) {
             throw new RuntimeException("Should not fail");
         }
-
-        // make sure that completion handler is invoked
-        latch.await();
     }
 
     // basic cancel tests
     static void doCancelTests() throws Exception {
         InetAddress lh = InetAddress.getLocalHost();
 
-        // timed and non-timed receive
+        // receive
         for (int i=0; i<2; i++) {
             AsynchronousDatagramChannel ch =
                 AsynchronousDatagramChannel.open().bind(new InetSocketAddress(0));
-            final CountDownLatch latch = new CountDownLatch(1);
-            long timeout = (i == 0) ? 0L : 60L;
-            Future<SocketAddress> remote = ch
-                .receive(ByteBuffer.allocate(100), timeout, TimeUnit.SECONDS, (Void)null,
-                    new CompletionHandler<SocketAddress,Void>() {
-                        public void completed(SocketAddress source, Void att) {
-                        }
-                        public void failed (Throwable exc, Void att) {
-                        }
-                        public void cancelled(Void att) {
-                            latch.countDown();
-                        }
-                    });
-            cancelAndCheck(remote, latch);
+            Future<SocketAddress> remote = ch.receive(ByteBuffer.allocate(100));
+            cancelAndCheck(remote);
             ch.close();
         }
 
-        // timed and non-timed read
+        // read
         for (int i=0; i<2; i++) {
             AsynchronousDatagramChannel ch =
                 AsynchronousDatagramChannel.open().bind(new InetSocketAddress(0));
@@ -394,18 +361,8 @@ public class Basic {
                 ((InetSocketAddress)(ch.getLocalAddress())).getPort()));
             final CountDownLatch latch = new CountDownLatch(1);
             long timeout = (i == 0) ? 0L : 60L;
-            Future<Integer> result = ch
-                .read(ByteBuffer.allocate(100), timeout, TimeUnit.SECONDS, (Void)null,
-                    new CompletionHandler<Integer,Void>() {
-                        public void completed(Integer bytesRead, Void att) {
-                        }
-                        public void failed (Throwable exc, Void att) {
-                        }
-                        public void cancelled(Void att) {
-                            latch.countDown();
-                        }
-                    });
-            cancelAndCheck(result, latch);
+            Future<Integer> result = ch.read(ByteBuffer.allocate(100));
+            cancelAndCheck(result);
             ch.close();
         }
     }
--- a/test/java/nio/channels/AsynchronousFileChannel/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousFileChannel/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272 6822643 6830721
+ * @bug 4607272 6822643 6830721 6842687
  * @summary Unit test for AsynchronousFileChannel
  */
 
@@ -195,8 +195,6 @@ public class Basic {
                     }
                     public void failed(Throwable exc, Void att) {
                     }
-                    public void cancelled(Void att) {
-                    }
                 });
                 throw new RuntimeException("OverlappingFileLockException expected");
             } catch (OverlappingFileLockException x) {
@@ -228,8 +226,6 @@ public class Basic {
                 }
             }
             public void failed(Throwable exc, Void att) {
-            }
-            public void cancelled(Void att) {
             }
         });
 
@@ -317,8 +313,6 @@ public class Basic {
                             latch.countDown();
                         }
                         public void failed(Throwable exc, Void att) {
-                        }
-                        public void cancelled(Void att) {
                         }
                     });
                     await(latch);
@@ -338,7 +332,40 @@ public class Basic {
                 }
             } finally {
                 ch.close();
-            }
+                executor.shutdown();
+            }
+        }
+
+
+        // test sharing a thread pool between many channels
+        ExecutorService executor = Executors
+            .newFixedThreadPool(1+rand.nextInt(10), threadFactory);
+        final int n = 50 + rand.nextInt(50);
+        AsynchronousFileChannel[] channels = new AsynchronousFileChannel[n];
+        try {
+            for (int i=0; i<n; i++) {
+                Set<StandardOpenOption> opts = EnumSet.of(WRITE);
+                channels[i] = AsynchronousFileChannel.open(file, opts, executor);
+                final CountDownLatch latch = new CountDownLatch(1);
+                channels[i].write(genBuffer(), 0L, (Void)null, new CompletionHandler<Integer,Void>() {
+                    public void completed(Integer result, Void att) {
+                        latch.countDown();
+                    }
+                    public void failed(Throwable exc, Void att) {
+                    }
+                });
+                await(latch);
+
+                // close ~half the channels
+                if (rand.nextBoolean())
+                    channels[i].close();
+            }
+        } finally {
+            // close remaining channels
+            for (int i=0; i<n; i++) {
+                if (channels[i] != null) channels[i].close();
+            }
+            executor.shutdown();
         }
     }
 
@@ -409,17 +436,7 @@ public class Basic {
                 .open(file, WRITE, SYNC);
 
             // start write operation
-            final CountDownLatch latch = new CountDownLatch(1);
-            Future<Integer> res = ch.write(genBuffer(), 0L, (Void)null,
-                new CompletionHandler<Integer,Void>() {
-                    public void completed(Integer result, Void att) {
-                    }
-                    public void failed(Throwable exc, Void att) {
-                    }
-                    public void cancelled(Void att) {
-                        latch.countDown();
-                    }
-            });
+            Future<Integer> res = ch.write(genBuffer(), 0L);
 
             // cancel operation
             boolean cancelled = res.cancel(mayInterruptIfRunning);
@@ -455,10 +472,6 @@ public class Basic {
             } catch (InterruptedException x) {
                 throw new RuntimeException(x);
             }
-
-            // check that cancelled method is invoked
-            if (cancelled)
-                await(latch);
 
             ch.close();
         }
@@ -547,8 +560,6 @@ public class Basic {
             }
             public void failed(Throwable exc, Long position) {
             }
-            public void cancelled(Long position) {
-            }
         });
 
         // wait for writes to complete
@@ -574,8 +585,6 @@ public class Basic {
             }
             public void failed(Throwable exc, Long position) {
             }
-            public void cancelled(Long position) {
-            }
         });
 
         // wait for reads to complete
--- a/test/java/nio/channels/AsynchronousFileChannel/CustomThreadPool.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousFileChannel/CustomThreadPool.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for java.nio.channels.AsynchronousFileChannel
  * @build CustomThreadPool MyThreadFactory
  * @run main/othervm -Djava.nio.channels.DefaultThreadPool.threadFactory=MyThreadFactory CustomThreadPool
@@ -51,8 +51,6 @@ public class CustomThreadPool {
                 }
                 public void failed(Throwable exc, AtomicReference<Thread> invoker) {
                 }
-                public void cancelled(AtomicReference<Thread> invoker) {
-                }
             });
         Thread t;
         while ((t = invoker.get()) == null) {
--- a/test/java/nio/channels/AsynchronousFileChannel/Lock.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousFileChannel/Lock.java	Tue Sep 22 01:20:51 2009 -0700
@@ -23,7 +23,7 @@
 
 
 /* @test
- * @bug 4607272 6814948
+ * @bug 4607272 6814948 6842687
  * @summary Unit test for AsynchronousFileChannel#lock method
  */
 
@@ -97,7 +97,7 @@ public class Lock {
         slave.lock(0, 10, false);
 
         // this VM acquires lock on non-overlapping range
-        fl = ch.lock(10, 10, false, null, null).get();
+        fl = ch.lock(10, 10, false).get();
         fl.release();
 
         // done
--- a/test/java/nio/channels/AsynchronousServerSocketChannel/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousServerSocketChannel/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousServerSocketChannel
  * @run main/timeout=180 Basic
  */
@@ -104,8 +104,6 @@ public class Basic {
             public void failed(Throwable exc, Void att) {
                 exception.set(exc);
             }
-            public void cancelled(Void att) {
-            }
         });
 
         // check AcceptPendingException
--- a/test/java/nio/channels/AsynchronousSocketChannel/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousSocketChannel/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4607272
+ * @bug 4607272 6842687
  * @summary Unit test for AsynchronousSocketChannel
  * @run main/timeout=600 Basic
  */
@@ -187,8 +187,6 @@ public class Basic {
             public void failed(Throwable exc, Void att) {
                 connectException.set(exc);
             }
-            public void cancelled(Void att) {
-            }
         });
         while (connectException.get() == null) {
             Thread.sleep(100);
@@ -289,8 +287,6 @@ public class Basic {
             public void failed(Throwable x, AsynchronousSocketChannel ch) {
                 writeException.set(x);
             }
-            public void cancelled(AsynchronousSocketChannel ch) {
-            }
         });
 
         // give time for socket buffer to fill up.
@@ -330,18 +326,8 @@ public class Basic {
             SocketChannel peer = server.accept();
 
             // start read operation
-            final CountDownLatch latch = new CountDownLatch(1);
             ByteBuffer buf = ByteBuffer.allocate(1);
-            Future<Integer> res = ch.read(buf, (Void)null,
-                new CompletionHandler<Integer,Void>() {
-                    public void completed(Integer result, Void att) {
-                    }
-                    public void failed(Throwable exc, Void att) {
-                    }
-                    public void cancelled(Void att) {
-                        latch.countDown();
-                    }
-            });
+            Future<Integer> res = ch.read(buf);
 
             // cancel operation
             boolean cancelled = res.cancel(mayInterruptIfRunning);
@@ -362,8 +348,11 @@ public class Basic {
             } catch (CancellationException x) {
             }
 
-            // check that completion handler executed.
-            latch.await();
+            // check that the cancel doesn't impact writing to the channel
+            if (!mayInterruptIfRunning) {
+                buf = ByteBuffer.wrap("a".getBytes());
+                ch.write(buf).get();
+            }
 
             ch.close();
             peer.close();
@@ -408,8 +397,6 @@ public class Basic {
             }
             public void failed(Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
 
         latch.await();
@@ -459,8 +446,6 @@ public class Basic {
                 }
             }
             public void failed(Throwable exc, Void att) {
-            }
-            public void cancelled(Void att) {
             }
         });
 
@@ -507,18 +492,16 @@ public class Basic {
         }
 
         // scattering read that completes ascynhronously
-        final CountDownLatch latch = new CountDownLatch(1);
+        final CountDownLatch l1 = new CountDownLatch(1);
         ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
             new CompletionHandler<Long,Void>() {
                 public void completed(Long result, Void att) {
                     long n = result;
                     if (n <= 0)
                         throw new RuntimeException("No bytes read");
-                    latch.countDown();
+                    l1.countDown();
                 }
                 public void failed(Throwable exc, Void att) {
-                }
-                public void cancelled(Void att) {
                 }
         });
 
@@ -526,7 +509,7 @@ public class Basic {
         sc.write(genBuffer());
 
         // read should now complete
-        latch.await();
+        l1.await();
 
         // write more bytes
         sc.write(genBuffer());
@@ -535,10 +518,20 @@ public class Basic {
         for (int i=0; i<dsts.length; i++) {
             dsts[i].rewind();
         }
-        long n = ch
-            .read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null, null).get();
-        if (n <= 0)
-            throw new RuntimeException("No bytes read");
+
+        final CountDownLatch l2 = new CountDownLatch(1);
+        ch.read(dsts, 0, dsts.length, 0L, TimeUnit.SECONDS, (Void)null,
+            new CompletionHandler<Long,Void>() {
+                public void completed(Long result, Void att) {
+                    long n = result;
+                    if (n <= 0)
+                        throw new RuntimeException("No bytes read");
+                    l2.countDown();
+                }
+                public void failed(Throwable exc, Void att) {
+                }
+        });
+        l2.await();
 
         ch.close();
         sc.close();
@@ -574,8 +567,6 @@ public class Basic {
             }
             public void failed(Throwable exc, Void att) {
             }
-            public void cancelled(Void att) {
-            }
         });
 
         // read to EOF or buffer full
@@ -613,18 +604,28 @@ public class Basic {
         ch.connect(server.address()).get();
         SocketChannel sc = server.accept();
 
+        // number of bytes written
+        final AtomicLong bytesWritten = new AtomicLong(0);
+
         // write buffers (should complete immediately)
         ByteBuffer[] srcs = genBuffers(1);
-        long n = ch
-            .write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null, null).get();
-        if (n <= 0)
-            throw new RuntimeException("No bytes written");
+        final CountDownLatch l1 = new CountDownLatch(1);
+        ch.write(srcs, 0, srcs.length, 0L, TimeUnit.SECONDS, (Void)null,
+            new CompletionHandler<Long,Void>() {
+                public void completed(Long result, Void att) {
+                    long n = result;
+                    if (n <= 0)
+                        throw new RuntimeException("No bytes read");
+                    bytesWritten.addAndGet(n);
+                    l1.countDown();
+                }
+                public void failed(Throwable exc, Void att) {
+                }
+        });
+        l1.await();
 
         // set to true to signal that no more buffers should be written
         final AtomicBoolean continueWriting = new AtomicBoolean(true);
-
-        // number of bytes written
-        final AtomicLong bytesWritten = new AtomicLong(n);
 
         // write until socket buffer is full so as to create the conditions
         // for when a write does not complete immediately
@@ -644,8 +645,6 @@ public class Basic {
                 }
                 public void failed(Throwable exc, Void att) {
                 }
-                public void cancelled(Void att) {
-                }
         });
 
         // give time for socket buffer to fill up.
@@ -658,7 +657,7 @@ public class Basic {
         ByteBuffer buf = ByteBuffer.allocateDirect(4096);
         long total = 0L;
         do {
-            n = sc.read(buf);
+            int n = sc.read(buf);
             if (n <= 0)
                 throw new RuntimeException("No bytes read");
             buf.rewind();
@@ -714,15 +713,27 @@ public class Basic {
 
         System.out.println("-- timeout when reading --");
 
+        ByteBuffer dst = ByteBuffer.allocate(512);
+
+        final AtomicReference<Throwable> readException = new AtomicReference<Throwable>();
+
         // this read should timeout
-        ByteBuffer dst = ByteBuffer.allocate(512);
-        try {
-            ch.read(dst, 3, TimeUnit.SECONDS, (Void)null, null).get();
-            throw new RuntimeException("Read did not timeout");
-        } catch (ExecutionException x) {
-            if (!(x.getCause() instanceof InterruptedByTimeoutException))
-                throw new RuntimeException("InterruptedByTimeoutException expected");
-        }
+        ch.read(dst, 3, TimeUnit.SECONDS, (Void)null,
+            new CompletionHandler<Integer,Void>()
+        {
+            public void completed(Integer result, Void att) {
+                throw new RuntimeException("Should not complete");
+            }
+            public void failed(Throwable exc, Void att) {
+                readException.set(exc);
+            }
+        });
+        // wait for exception
+        while (readException.get() == null) {
+            Thread.sleep(100);
+        }
+        if (!(readException.get() instanceof InterruptedByTimeoutException))
+            throw new RuntimeException("InterruptedByTimeoutException expected");
 
         // after a timeout then further reading should throw unspecified runtime exception
         boolean exceptionThrown = false;
@@ -751,8 +762,6 @@ public class Basic {
             }
             public void failed(Throwable exc, AsynchronousSocketChannel ch) {
                 writeException.set(exc);
-            }
-            public void cancelled(AsynchronousSocketChannel ch) {
             }
         });
 
--- a/test/java/nio/channels/AsynchronousSocketChannel/StressLoopback.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/AsynchronousSocketChannel/StressLoopback.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 6834246
+ * @bug 6834246 6842687
  * @summary Stress test connections through the loopback interface
  */
 
@@ -114,8 +114,6 @@ public class StressLoopback {
                     exc.printStackTrace();
                     closeUnchecked(channel);
                 }
-                public void cancelled(Void att) {
-                }
             });
         }
 
@@ -156,8 +154,6 @@ public class StressLoopback {
                     exc.printStackTrace();
                     closeUnchecked(channel);
                 }
-                public void cancelled(Void att) {
-                }
             });
         }
 
--- a/test/java/nio/channels/FileChannel/ReleaseOnCloseDeadlock.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/channels/FileChannel/ReleaseOnCloseDeadlock.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 6543863
+ * @bug 6543863 6842687
  * @summary Try to cause a deadlock between (Asynchronous)FileChannel.close
  *   and FileLock.release
  */
@@ -56,7 +56,7 @@ public class ReleaseOnCloseDeadlock {
         AsynchronousFileChannel ch = AsynchronousFileChannel.open(file, READ, WRITE);
         for (int i=0; i<LOCK_COUNT; i++) {
             try {
-                locks[i] = ch.lock(i, 1, true, null, null).get();
+                locks[i] = ch.lock(i, 1, true).get();
             } catch (InterruptedException x) {
                 throw new RuntimeException(x);
             } catch (ExecutionException x) {
--- a/test/java/nio/file/FileStore/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/file/FileStore/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4313887
+ * @bug 4313887 6873621
  * @summary Unit test for java.nio.file.FileStore
  * @library ..
  */
@@ -67,6 +67,15 @@ public class Basic {
          * Test: File and FileStore attributes
          */
         assertTrue(store1.supportsFileAttributeView("basic"));
+        assertTrue(store1.supportsFileAttributeView(BasicFileAttributeView.class));
+        assertTrue(store1.supportsFileAttributeView("posix") ==
+            store1.supportsFileAttributeView(PosixFileAttributeView.class));
+        assertTrue(store1.supportsFileAttributeView("dos") ==
+            store1.supportsFileAttributeView(DosFileAttributeView.class));
+        assertTrue(store1.supportsFileAttributeView("acl") ==
+            store1.supportsFileAttributeView(AclFileAttributeView.class));
+        assertTrue(store1.supportsFileAttributeView("user") ==
+            store1.supportsFileAttributeView(UserDefinedFileAttributeView.class));
 
         /**
          * Test: Enumerate all FileStores
--- a/test/java/nio/file/Path/Misc.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/file/Path/Misc.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4313887 6838333 6866804
+ * @bug 4313887 6838333 6867101
  * @summary Unit test for java.nio.file.Path for miscellenous methods not
  *   covered by other tests
  * @library ..
--- a/test/java/nio/file/PathMatcher/Basic.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/nio/file/PathMatcher/Basic.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 4313887
+ * @bug 4313887 6866397
  * @summary Unit test for java.nio.file.PathMatcher
  */
 
@@ -67,6 +67,20 @@ public class Basic {
             System.out.println("Failed to compile ==> OKAY");
         }
     }
+
+    static void assertRegExMatch(String path, String pattern) {
+        System.out.format("Test regex pattern: %s", pattern);
+        Path file = Paths.get(path);
+        boolean matched =  file.getFileSystem()
+                               .getPathMatcher("regex:" + pattern).matches(file);
+        if (matched) {
+            System.out.println(" OKAY");
+        } else {
+            System.out.println(" ==> UNEXPECTED RESULT!");
+            failures++;
+        }
+    }
+
 
     public static void main(String[] args) {
         // basic
@@ -140,21 +154,13 @@ public class Basic {
             assertMatch("one*two", "one\\*two");
         }
 
+        // regex syntax
+        assertRegExMatch("foo.html", ".*\\.html");
 
-
-        // regex syntax
-        {
-            String pattern = ".*\\.html";
-            System.out.format("Test regex pattern: %s", pattern);
-            Path file = Paths.get("foo.html");
-            boolean matched =  file.getFileSystem()
-                .getPathMatcher("regex:" + pattern).matches(file);
-            if (matched) {
-                System.out.println(" OKAY");
-            } else {
-                System.out.println(" ==> UNEXPECTED RESULT!");
-                failures++;
-            }
+        if (System.getProperty("os.name").startsWith("Windows")) {
+            assertRegExMatch("foo012", "foo\\d+");
+            assertRegExMatch("fo o", "fo\\so");
+            assertRegExMatch("foo", "\\w+");
         }
 
         // unknown syntax
--- a/test/java/util/Collection/BiggernYours.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/Collection/BiggernYours.java	Tue Sep 22 01:20:51 2009 -0700
@@ -177,6 +177,11 @@ public class BiggernYours {
             new ConcurrentLinkedQueue(),
             new ConcurrentLinkedQueue() {
                 public int size() {return randomize(super.size());}});
+
+//         testCollections(
+//             new LinkedTransferQueue(),
+//             new LinkedTransferQueue() {
+//                 public int size() {return randomize(super.size());}});
 
         testCollections(
             new LinkedBlockingQueue(),
--- a/test/java/util/Collection/IteratorAtEnd.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/Collection/IteratorAtEnd.java	Tue Sep 22 01:20:51 2009 -0700
@@ -49,6 +49,7 @@ public class IteratorAtEnd {
         testCollection(new LinkedBlockingQueue());
         testCollection(new ArrayBlockingQueue(100));
         testCollection(new ConcurrentLinkedQueue());
+//         testCollection(new LinkedTransferQueue());
 
         testMap(new HashMap());
         testMap(new Hashtable());
--- a/test/java/util/Collection/MOAT.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/Collection/MOAT.java	Tue Sep 22 01:20:51 2009 -0700
@@ -76,6 +76,7 @@ public class MOAT {
         testCollection(new LinkedBlockingQueue<Integer>(20));
         testCollection(new LinkedBlockingDeque<Integer>(20));
         testCollection(new ConcurrentLinkedQueue<Integer>());
+//         testCollection(new LinkedTransferQueue<Integer>());
         testCollection(new ConcurrentSkipListSet<Integer>());
         testCollection(Arrays.asList(new Integer(42)));
         testCollection(Arrays.asList(1,2,3));
@@ -161,6 +162,7 @@ public class MOAT {
         equal(c.toString(),"[]");
         equal(c.toArray().length, 0);
         equal(c.toArray(new Object[0]).length, 0);
+        check(c.toArray(new Object[]{42})[0] == null);
 
         Object[] a = new Object[1]; a[0] = Boolean.TRUE;
         equal(c.toArray(a), a);
--- a/test/java/util/Collections/RacingCollections.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/Collections/RacingCollections.java	Tue Sep 22 01:20:51 2009 -0700
@@ -234,6 +234,7 @@ public class RacingCollections {
         List<Queue<Integer>> list =
             new ArrayList<Queue<Integer>>(newConcurrentDeques());
         list.add(new LinkedBlockingQueue<Integer>(10));
+//         list.add(new LinkedTransferQueue<Integer>());
         return list;
     }
 
--- a/test/java/util/PriorityQueue/RemoveContains.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/PriorityQueue/RemoveContains.java	Tue Sep 22 01:20:51 2009 -0700
@@ -69,6 +69,7 @@ public class RemoveContains {
         test(new ArrayBlockingQueue<String>(10));
         test(new LinkedBlockingQueue<String>(10));
         test(new LinkedBlockingDeque<String>(10));
+//         test(new LinkedTransferQueue<String>());
         test(new ArrayDeque<String>(10));
 
         System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
--- a/test/java/util/concurrent/BlockingQueue/CancelledProducerConsumerLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/CancelledProducerConsumerLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -75,10 +75,12 @@ public class CancelledProducerConsumerLo
    }
 
     static void oneRun(BlockingQueue<Integer> q, int npairs, int iters) throws Exception {
+        if (print)
+            System.out.printf("%-18s", q.getClass().getSimpleName());
         LoopHelpers.BarrierTimer timer = new LoopHelpers.BarrierTimer();
         CyclicBarrier barrier = new CyclicBarrier(npairs * 2 + 1, timer);
-        Future[] prods = new Future[npairs];
-        Future[] cons = new Future[npairs];
+        Future<?>[] prods = new Future<?>[npairs];
+        Future<?>[] cons  = new Future<?>[npairs];
 
         for (int i = 0; i < npairs; ++i) {
             prods[i] = pool.submit(new Producer(q, barrier, iters));
@@ -119,21 +121,13 @@ public class CancelledProducerConsumerLo
 
     static void oneTest(int pairs, int iters) throws Exception {
 
-        if (print)
-            System.out.print("ArrayBlockingQueue      ");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY), pairs, iters);
-
-        if (print)
-            System.out.print("LinkedBlockingQueue     ");
         oneRun(new LinkedBlockingQueue<Integer>(CAPACITY), pairs, iters);
-
-        if (print)
-            System.out.print("SynchronousQueue        ");
+        oneRun(new LinkedBlockingDeque<Integer>(CAPACITY), pairs, iters);
+//         oneRun(new LinkedTransferQueue<Integer>(), pairs, iters);
         oneRun(new SynchronousQueue<Integer>(), pairs, iters / 8);
 
         /* PriorityBlockingQueue is unbounded
-        if (print)
-            System.out.print("PriorityBlockingQueue   ");
         oneRun(new PriorityBlockingQueue<Integer>(iters / 2 * pairs), pairs, iters / 4);
         */
     }
--- a/test/java/util/concurrent/BlockingQueue/Interrupt.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/Interrupt.java	Tue Sep 22 01:20:51 2009 -0700
@@ -66,7 +66,8 @@ public class Interrupt {
     static void testQueue(final BlockingQueue<Object> q) {
         try {
             final BlockingDeque<Object> deq =
-                q instanceof BlockingDeque ? (BlockingDeque<Object>) q : null;
+                (q instanceof BlockingDeque<?>) ?
+                (BlockingDeque<Object>) q : null;
             q.clear();
             List<Fun> fs = new ArrayList<Fun>();
             fs.add(new Fun() { void f() throws Throwable
@@ -107,7 +108,10 @@ public class Interrupt {
                         { deq.offerLast(1, 7, SECONDS); }});
             }
             checkInterrupted(fs);
-        } catch (Throwable t) { unexpected(t); }
+        } catch (Throwable t) {
+          System.out.printf("Failed: %s%n", q.getClass().getSimpleName());
+          unexpected(t);
+        }
     }
 
     private static void realMain(final String[] args) throws Throwable {
--- a/test/java/util/concurrent/BlockingQueue/MultipleProducersSingleConsumerLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/MultipleProducersSingleConsumerLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -77,6 +77,7 @@ public class MultipleProducersSingleCons
         print = true;
 
         for (int i = 1; i <= maxProducers; i += (i+1) >>> 1) {
+            System.out.println("----------------------------------------");
             System.out.println("Producers:" + i);
             oneTest(i, iters);
             Thread.sleep(100);
@@ -87,29 +88,20 @@ public class MultipleProducersSingleCons
    }
 
     static void oneTest(int producers, int iters) throws Exception {
-        if (print)
-            System.out.print("ArrayBlockingQueue      ");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY), producers, iters);
-
-        if (print)
-            System.out.print("LinkedBlockingQueue     ");
         oneRun(new LinkedBlockingQueue<Integer>(CAPACITY), producers, iters);
+        oneRun(new LinkedBlockingDeque<Integer>(CAPACITY), producers, iters);
+//         oneRun(new LinkedTransferQueue<Integer>(), producers, iters);
 
         // Don't run PBQ since can legitimately run out of memory
         //        if (print)
         //            System.out.print("PriorityBlockingQueue   ");
         //        oneRun(new PriorityBlockingQueue<Integer>(), producers, iters);
 
+        oneRun(new SynchronousQueue<Integer>(), producers, iters);
         if (print)
-            System.out.print("SynchronousQueue        ");
-        oneRun(new SynchronousQueue<Integer>(), producers, iters);
-
-        if (print)
-            System.out.print("SynchronousQueue(fair)  ");
+            System.out.println("fair implementations:");
         oneRun(new SynchronousQueue<Integer>(true), producers, iters);
-
-        if (print)
-            System.out.print("ArrayBlockingQueue(fair)");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY, true), producers, iters);
     }
 
@@ -174,6 +166,8 @@ public class MultipleProducersSingleCons
     }
 
     static void oneRun(BlockingQueue<Integer> q, int nproducers, int iters) throws Exception {
+        if (print)
+            System.out.printf("%-18s", q.getClass().getSimpleName());
         LoopHelpers.BarrierTimer timer = new LoopHelpers.BarrierTimer();
         CyclicBarrier barrier = new CyclicBarrier(nproducers + 2, timer);
         for (int i = 0; i < nproducers; ++i) {
--- a/test/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/OfferDrainToLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -34,28 +34,27 @@
 /*
  * @test
  * @bug 6805775 6815766
+ * @run main OfferDrainToLoops 300
  * @summary Test concurrent offer vs. drainTo
  */
 
 import java.util.*;
 import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
 
-@SuppressWarnings({"unchecked", "rawtypes"})
+@SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
 public class OfferDrainToLoops {
+    final long testDurationMillisDefault = 10L * 1000L;
+    final long testDurationMillis;
+
+    OfferDrainToLoops(String[] args) {
+        testDurationMillis = (args.length > 0) ?
+            Long.valueOf(args[0]) : testDurationMillisDefault;
+    }
+
     void checkNotContainsNull(Iterable it) {
         for (Object x : it)
             check(x != null);
-    }
-
-    abstract class CheckedThread extends Thread {
-        abstract protected void realRun();
-        public void run() {
-            try { realRun(); } catch (Throwable t) { unexpected(t); }
-        }
-        {
-            setDaemon(true);
-            start();
-        }
     }
 
     void test(String[] args) throws Throwable {
@@ -64,51 +63,106 @@ public class OfferDrainToLoops {
         test(new LinkedBlockingDeque());
         test(new LinkedBlockingDeque(2000));
         test(new ArrayBlockingQueue(2000));
+//         test(new LinkedTransferQueue());
+    }
+
+    Random getRandom() {
+        return new Random();
+        // return ThreadLocalRandom.current();
     }
 
     void test(final BlockingQueue q) throws Throwable {
         System.out.println(q.getClass().getSimpleName());
-        final long testDurationSeconds = 1L;
-        final long testDurationMillis = testDurationSeconds * 1000L;
-        final long quittingTimeNanos
-            = System.nanoTime() + testDurationSeconds * 1000L * 1000L * 1000L;
+        final long testDurationNanos = testDurationMillis * 1000L * 1000L;
+        final long quittingTimeNanos = System.nanoTime() + testDurationNanos;
+        final long timeoutMillis = 10L * 1000L;
 
-        Thread offerer = new CheckedThread() {
+        /** Poor man's bounded buffer. */
+        final AtomicLong approximateCount = new AtomicLong(0L);
+
+        abstract class CheckedThread extends Thread {
+            CheckedThread(String name) {
+                super(name);
+                setDaemon(true);
+                start();
+            }
+            /** Polls for quitting time. */
+            protected boolean quittingTime() {
+                return System.nanoTime() - quittingTimeNanos > 0;
+            }
+            /** Polls occasionally for quitting time. */
+            protected boolean quittingTime(long i) {
+                return (i % 1024) == 0 && quittingTime();
+            }
+            abstract protected void realRun();
+            public void run() {
+                try { realRun(); } catch (Throwable t) { unexpected(t); }
+            }
+        }
+
+        Thread offerer = new CheckedThread("offerer") {
             protected void realRun() {
-                for (long i = 0; ; i++) {
-                    if ((i % 1024) == 0 &&
-                        System.nanoTime() - quittingTimeNanos > 0)
-                        break;
-                    while (! q.offer(i))
+                long c = 0;
+                for (long i = 0; ! quittingTime(i); i++) {
+                    if (q.offer(c)) {
+                        if ((++c % 1024) == 0) {
+                            approximateCount.getAndAdd(1024);
+                            while (approximateCount.get() > 10000)
+                                Thread.yield();
+                        }
+                    } else {
                         Thread.yield();
-                }}};
+                    }}}};
 
-        Thread drainer = new CheckedThread() {
+        Thread drainer = new CheckedThread("drainer") {
             protected void realRun() {
-                for (long i = 0; ; i++) {
-                    if (System.nanoTime() - quittingTimeNanos > 0)
-                        break;
+                final Random rnd = getRandom();
+                while (! quittingTime()) {
                     List list = new ArrayList();
-                    int n = q.drainTo(list);
+                    int n = rnd.nextBoolean() ?
+                        q.drainTo(list) :
+                        q.drainTo(list, 100);
+                    approximateCount.getAndAdd(-n);
                     equal(list.size(), n);
                     for (int j = 0; j < n - 1; j++)
                         equal((Long) list.get(j) + 1L, list.get(j + 1));
                     Thread.yield();
-                }}};
+                }
+                q.clear();
+                approximateCount.set(0); // Releases waiting offerer thread
+            }};
 
-        Thread scanner = new CheckedThread() {
+        Thread scanner = new CheckedThread("scanner") {
             protected void realRun() {
-                for (long i = 0; ; i++) {
-                    if (System.nanoTime() - quittingTimeNanos > 0)
+                final Random rnd = getRandom();
+                while (! quittingTime()) {
+                    switch (rnd.nextInt(3)) {
+                    case 0: checkNotContainsNull(q); break;
+                    case 1: q.size(); break;
+                    case 2:
+                        Long[] a = (Long[]) q.toArray(new Long[0]);
+                        int n = a.length;
+                        for (int j = 0; j < n - 1; j++) {
+                            check(a[j] < a[j+1]);
+                            check(a[j] != null);
+                        }
                         break;
-                    checkNotContainsNull(q);
+                    }
                     Thread.yield();
                 }}};
 
-        offerer.join(10 * testDurationMillis);
-        drainer.join(10 * testDurationMillis);
-        check(! offerer.isAlive());
-        check(! drainer.isAlive());
+        for (Thread thread : new Thread[] { offerer, drainer, scanner }) {
+            thread.join(timeoutMillis + testDurationMillis);
+            if (thread.isAlive()) {
+                System.err.printf("Hung thread: %s%n", thread.getName());
+                failed++;
+                for (StackTraceElement e : thread.getStackTrace())
+                    System.err.println(e);
+                // Kludge alert
+                thread.stop();
+                thread.join(timeoutMillis);
+            }
+        }
     }
 
     //--------------------- Infrastructure ---------------------------
@@ -122,7 +176,7 @@ public class OfferDrainToLoops {
         if (x == null ? y == null : x.equals(y)) pass();
         else fail(x + " not equal to " + y);}
     public static void main(String[] args) throws Throwable {
-        new OfferDrainToLoops().instanceMain(args);}
+        new OfferDrainToLoops(args).instanceMain(args);}
     public void instanceMain(String[] args) throws Throwable {
         try {test(args);} catch (Throwable t) {unexpected(t);}
         System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
--- a/test/java/util/concurrent/BlockingQueue/PollMemoryLeak.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/PollMemoryLeak.java	Tue Sep 22 01:20:51 2009 -0700
@@ -46,6 +46,7 @@ public class PollMemoryLeak {
     public static void main(String[] args) throws InterruptedException {
         final BlockingQueue[] qs = {
             new LinkedBlockingQueue(10),
+//             new LinkedTransferQueue(),
             new ArrayBlockingQueue(10),
             new SynchronousQueue(),
             new SynchronousQueue(true),
--- a/test/java/util/concurrent/BlockingQueue/ProducerConsumerLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/ProducerConsumerLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -77,7 +77,8 @@ public class ProducerConsumerLoops {
         print = true;
 
         for (int i = 1; i <= maxPairs; i += (i+1) >>> 1) {
-            System.out.println("Pairs:" + i);
+            System.out.println("----------------------------------------");
+            System.out.println("Pairs: " + i);
             oneTest(i, iters);
             Thread.sleep(100);
         }
@@ -87,28 +88,17 @@ public class ProducerConsumerLoops {
    }
 
     static void oneTest(int pairs, int iters) throws Exception {
-        if (print)
-            System.out.print("ArrayBlockingQueue      ");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY), pairs, iters);
-
-        if (print)
-            System.out.print("LinkedBlockingQueue     ");
         oneRun(new LinkedBlockingQueue<Integer>(CAPACITY), pairs, iters);
-
-        if (print)
-            System.out.print("PriorityBlockingQueue   ");
+        oneRun(new LinkedBlockingDeque<Integer>(CAPACITY), pairs, iters);
+//         oneRun(new LinkedTransferQueue<Integer>(), pairs, iters);
         oneRun(new PriorityBlockingQueue<Integer>(), pairs, iters);
-
-        if (print)
-            System.out.print("SynchronousQueue        ");
         oneRun(new SynchronousQueue<Integer>(), pairs, iters);
 
         if (print)
-            System.out.print("SynchronousQueue(fair)  ");
+            System.out.println("fair implementations:");
+
         oneRun(new SynchronousQueue<Integer>(true), pairs, iters);
-
-        if (print)
-            System.out.print("ArrayBlockingQueue(fair)");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY, true), pairs, iters);
     }
 
@@ -174,6 +164,8 @@ public class ProducerConsumerLoops {
     }
 
     static void oneRun(BlockingQueue<Integer> q, int npairs, int iters) throws Exception {
+        if (print)
+            System.out.printf("%-18s", q.getClass().getSimpleName());
         LoopHelpers.BarrierTimer timer = new LoopHelpers.BarrierTimer();
         CyclicBarrier barrier = new CyclicBarrier(npairs * 2 + 1, timer);
         for (int i = 0; i < npairs; ++i) {
--- a/test/java/util/concurrent/BlockingQueue/SingleProducerMultipleConsumerLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/BlockingQueue/SingleProducerMultipleConsumerLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -63,7 +63,8 @@ public class SingleProducerMultipleConsu
         print = true;
 
         for (int i = 1; i <= maxConsumers; i += (i+1) >>> 1) {
-            System.out.println("Consumers:" + i);
+            System.out.println("----------------------------------------");
+            System.out.println("Consumers: " + i);
             oneTest(i, iters);
             Thread.sleep(100);
         }
@@ -73,28 +74,15 @@ public class SingleProducerMultipleConsu
    }
 
     static void oneTest(int consumers, int iters) throws Exception {
+        oneRun(new ArrayBlockingQueue<Integer>(CAPACITY), consumers, iters);
+        oneRun(new LinkedBlockingQueue<Integer>(CAPACITY), consumers, iters);
+        oneRun(new LinkedBlockingDeque<Integer>(CAPACITY), consumers, iters);
+//         oneRun(new LinkedTransferQueue<Integer>(), consumers, iters);
+        oneRun(new PriorityBlockingQueue<Integer>(), consumers, iters);
+        oneRun(new SynchronousQueue<Integer>(), consumers, iters);
         if (print)
-            System.out.print("ArrayBlockingQueue      ");
-        oneRun(new ArrayBlockingQueue<Integer>(CAPACITY), consumers, iters);
-
-        if (print)
-            System.out.print("LinkedBlockingQueue     ");
-        oneRun(new LinkedBlockingQueue<Integer>(CAPACITY), consumers, iters);
-
-        if (print)
-            System.out.print("PriorityBlockingQueue   ");
-        oneRun(new PriorityBlockingQueue<Integer>(), consumers, iters);
-
-        if (print)
-            System.out.print("SynchronousQueue        ");
-        oneRun(new SynchronousQueue<Integer>(), consumers, iters);
-
-        if (print)
-            System.out.print("SynchronousQueue(fair)  ");
+            System.out.println("fair implementations:");
         oneRun(new SynchronousQueue<Integer>(true), consumers, iters);
-
-        if (print)
-            System.out.print("ArrayBlockingQueue(fair)");
         oneRun(new ArrayBlockingQueue<Integer>(CAPACITY, true), consumers, iters);
     }
 
@@ -163,6 +151,8 @@ public class SingleProducerMultipleConsu
     }
 
     static void oneRun(BlockingQueue<Integer> q, int nconsumers, int iters) throws Exception {
+        if (print)
+            System.out.printf("%-18s", q.getClass().getSimpleName());
         LoopHelpers.BarrierTimer timer = new LoopHelpers.BarrierTimer();
         CyclicBarrier barrier = new CyclicBarrier(nconsumers + 2, timer);
         pool.execute(new Producer(q, barrier, iters * nconsumers));
--- a/test/java/util/concurrent/ConcurrentQueues/ConcurrentQueueLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/ConcurrentQueues/ConcurrentQueueLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -60,20 +60,10 @@ public class ConcurrentQueueLoops {
         //queues.add(new ArrayBlockingQueue<Integer>(count, true));
         queues.add(new LinkedBlockingQueue<Integer>());
         queues.add(new LinkedBlockingDeque<Integer>());
-
-        try {
-            queues.add((Queue<Integer>)
-                       Class.forName("java.util.concurrent.LinkedTransferQueue")
-                       .newInstance());
-        } catch (IllegalAccessException e) {
-        } catch (InstantiationException e) {
-        } catch (ClassNotFoundException e) {
-            // OK; not yet added to JDK
-        }
+//         queues.add(new LinkedTransferQueue<Integer>());
 
         // Following additional implementations are available from:
         // http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
-        // queues.add(new LinkedTransferQueue<Integer>());
         // queues.add(new SynchronizedLinkedListQueue<Integer>());
 
         // Avoid "first fast, second slow" benchmark effect.
--- a/test/java/util/concurrent/ConcurrentQueues/GCRetention.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/ConcurrentQueues/GCRetention.java	Tue Sep 22 01:20:51 2009 -0700
@@ -41,8 +41,9 @@ import java.util.concurrent.ArrayBlockin
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.LinkedBlockingDeque;
+// import java.util.concurrent.LinkedTransferQueue;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.LinkedList;
 import java.util.PriorityQueue;
@@ -69,20 +70,10 @@ public class GCRetention {
         queues.add(new PriorityBlockingQueue<Boolean>());
         queues.add(new PriorityQueue<Boolean>());
         queues.add(new LinkedList<Boolean>());
-
-        try {
-            queues.add((Queue<Boolean>)
-                       Class.forName("java.util.concurrent.LinkedTransferQueue")
-                       .newInstance());
-        } catch (IllegalAccessException e) {
-        } catch (InstantiationException e) {
-        } catch (ClassNotFoundException e) {
-            // OK; not yet added to JDK
-        }
+//         queues.add(new LinkedTransferQueue<Boolean>());
 
         // Following additional implementations are available from:
         // http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
-        // queues.add(new LinkedTransferQueue<Boolean>());
         // queues.add(new SynchronizedLinkedListQueue<Boolean>());
 
         // Avoid "first fast, second slow" benchmark effect.
--- a/test/java/util/concurrent/ConcurrentQueues/IteratorWeakConsistency.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/ConcurrentQueues/IteratorWeakConsistency.java	Tue Sep 22 01:20:51 2009 -0700
@@ -49,6 +49,7 @@ public class IteratorWeakConsistency {
         test(new LinkedBlockingDeque());
         test(new LinkedBlockingDeque(20));
         test(new ConcurrentLinkedQueue());
+//         test(new LinkedTransferQueue());
         // Other concurrent queues (e.g. ArrayBlockingQueue) do not
         // currently have weakly consistent iterators.
         // test(new ArrayBlockingQueue(20));
--- a/test/java/util/concurrent/ConcurrentQueues/RemovePollRace.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/java/util/concurrent/ConcurrentQueues/RemovePollRace.java	Tue Sep 22 01:20:51 2009 -0700
@@ -45,6 +45,7 @@ import java.util.concurrent.CountDownLat
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
+// import java.util.concurrent.LinkedTransferQueue;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -66,20 +67,10 @@ public class RemovePollRace {
         queues.add(new ArrayBlockingQueue<Boolean>(count, true));
         queues.add(new LinkedBlockingQueue<Boolean>());
         queues.add(new LinkedBlockingDeque<Boolean>());
-
-        try {
-            queues.add((Queue<Boolean>)
-                       Class.forName("java.util.concurrent.LinkedTransferQueue")
-                       .newInstance());
-        } catch (IllegalAccessException e) {
-        } catch (InstantiationException e) {
-        } catch (ClassNotFoundException e) {
-            // OK; not yet added to JDK
-        }
+//         queues.add(new LinkedTransferQueue<Boolean>());
 
         // Following additional implementations are available from:
         // http://gee.cs.oswego.edu/dl/concurrency-interest/index.html
-        // queues.add(new LinkedTransferQueue<Boolean>());
         // queues.add(new SynchronizedLinkedListQueue<Boolean>());
 
         // Avoid "first fast, second slow" benchmark effect.
--- a/test/javax/swing/JLayer/SerializationTest/SerializationTest.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/javax/swing/JLayer/SerializationTest/SerializationTest.java	Tue Sep 22 01:20:51 2009 -0700
@@ -1,3 +1,26 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
 /*
  * @test
  * @summary Makes sure that JLayer is synchronizable
@@ -50,4 +73,4 @@ public class SerializationTest {
             return "TestLayerUI";
         }
     }
-}
\ No newline at end of file
+}
--- a/test/sun/nio/cs/FindCanEncodeBugs.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/sun/nio/cs/FindCanEncodeBugs.java	Tue Sep 22 01:20:51 2009 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
-   @bug 5066863 5066867 5066874 5066879 5066884 5066887 5065777
+   @bug 5066863 5066867 5066874 5066879 5066884 5066887 5065777 6730652
    @summary canEncode() false iff encode() throws CharacterCodingException
    @run main/timeout=1200 FindCanEncodeBugs
    @author Martin Buchholz
@@ -52,9 +52,7 @@ public class FindCanEncodeBugs {
             String csn = e.getKey();
             Charset cs = e.getValue();
 
-            if (! cs.canEncode() ||
-                csn.matches("x-COMPOUND_TEXT")   ||
-                csn.matches("x-ISO-2022-CN-CNS"))  // ISO2022_CN_CNS supports less
+            if (! cs.canEncode() || csn.matches("x-COMPOUND_TEXT"))
                 continue;
 
             //System.out.println(csn);
--- a/test/sun/security/ec/TestEC.java	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/sun/security/ec/TestEC.java	Tue Sep 22 01:20:51 2009 -0700
@@ -53,7 +53,7 @@ public class TestEC {
         long start = System.currentTimeMillis();
         new TestECDH().main(p);
         new TestECDSA().main(p);
-        //new TestCurves().main(p);
+        new TestCurves().main(p);
         new TestKeyFactory().main(p);
         new TestECGenSpec().main(p);
         new ReadPKCS12().main(p);
--- a/test/sun/security/krb5/auto/basic.sh	Tue Sep 15 16:15:36 2009 +0400
+++ b/test/sun/security/krb5/auto/basic.sh	Tue Sep 22 01:20:51 2009 -0700
@@ -43,6 +43,10 @@ case "$OS" in
     FS="\\"
     SEP=";"
     ;;
+  CYGWIN* )
+    FS="/"
+    SEP=";"
+    ;;
   * )
     FS="/"
     SEP=":"
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/build.xml	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,74 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- You may freely edit this file. See commented blocks below for -->
+<!-- some examples of how to customize the build. -->
+<!-- (If you delete it and reopen the project it will be recreated.) -->
+<!-- By default, only the Clean and Build commands use this build script. -->
+<!-- Commands such as Run, Debug, and Test only use this build script if -->
+<!-- the Compile on Save feature is turned off for the project. -->
+<!-- You can turn off the Compile on Save (or Deploy on Save) setting -->
+<!-- in the project's Project Properties dialog box.-->
+<project name="jdwpgen" default="default" basedir=".">
+    <description>Builds, tests, and runs the project jdwpgen.</description>
+    <import file="nbproject/build-impl.xml"/>
+    <!--
+
+    There exist several targets which are by default empty and which can be 
+    used for execution of your tasks. These targets are usually executed 
+    before and after some main targets. They are: 
+
+      -pre-init:                 called before initialization of project properties
+      -post-init:                called after initialization of project properties
+      -pre-compile:              called before javac compilation
+      -post-compile:             called after javac compilation
+      -pre-compile-single:       called before javac compilation of single file
+      -post-compile-single:      called after javac compilation of single file
+      -pre-compile-test:         called before javac compilation of JUnit tests
+      -post-compile-test:        called after javac compilation of JUnit tests
+      -pre-compile-test-single:  called before javac compilation of single JUnit test
+      -post-compile-test-single: called after javac compilation of single JUunit test
+      -pre-jar:                  called before JAR building
+      -post-jar:                 called after JAR building
+      -post-clean:               called after cleaning build products
+
+    (Targets beginning with '-' are not intended to be called on their own.)
+
+    Example of inserting an obfuscator after compilation could look like this:
+
+        <target name="-post-compile">
+            <obfuscate>
+                <fileset dir="${build.classes.dir}"/>
+            </obfuscate>
+        </target>
+
+    For list of available properties check the imported 
+    nbproject/build-impl.xml file. 
+
+
+    Another way to customize the build is by overriding existing main targets.
+    The targets of interest are: 
+
+      -init-macrodef-javac:     defines macro for javac compilation
+      -init-macrodef-junit:     defines macro for junit execution
+      -init-macrodef-debug:     defines macro for class debugging
+      -init-macrodef-java:      defines macro for class execution
+      -do-jar-with-manifest:    JAR building (if you are using a manifest)
+      -do-jar-without-manifest: JAR building (if you are not using a manifest)
+      run:                      execution of project 
+      -javadoc-build:           Javadoc generation
+      test-report:              JUnit report generation
+
+    An example of overriding the target for project execution could look like this:
+
+        <target name="run" depends="jdwpgen-impl.jar">
+            <exec dir="bin" executable="launcher.exe">
+                <arg file="${dist.jar}"/>
+            </exec>
+        </target>
+
+    Notice that the overridden target depends on the jar target and not only on 
+    the compile target as the regular run target does. Again, for a list of available 
+    properties which you can use, check the target you are overriding in the
+    nbproject/build-impl.xml file. 
+
+    -->
+</project>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/build-impl.xml	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,642 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+
+For the purpose of easier reading the script
+is divided into following sections:
+
+  - initialization
+  - compilation
+  - jar
+  - execution
+  - debugging
+  - javadoc
+  - junit compilation
+  - junit execution
+  - junit debugging
+  - applet
+  - cleanup
+
+        -->
+<project xmlns:j2seproject1="http://www.netbeans.org/ns/j2se-project/1" xmlns:j2seproject3="http://www.netbeans.org/ns/j2se-project/3" xmlns:jaxrpc="http://www.netbeans.org/ns/j2se-project/jax-rpc" basedir=".." default="default" name="jdwpgen-impl">
+    <target depends="test,jar,javadoc" description="Build and test whole project." name="default"/>
+    <!-- 
+                ======================
+                INITIALIZATION SECTION 
+                ======================
+            -->
+    <target name="-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init" name="-init-private">
+        <property file="nbproject/private/config.properties"/>
+        <property file="nbproject/private/configs/${config}.properties"/>
+        <property file="nbproject/private/private.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private" name="-init-user">
+        <property file="${user.properties.file}"/>
+        <!-- The two properties below are usually overridden -->
+        <!-- by the active platform. Just a fallback. -->
+        <property name="default.javac.source" value="1.4"/>
+        <property name="default.javac.target" value="1.4"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user" name="-init-project">
+        <property file="nbproject/configs/${config}.properties"/>
+        <property file="nbproject/project.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property" name="-do-init">
+        <available file="${manifest.file}" property="manifest.available"/>
+        <condition property="manifest.available+main.class">
+            <and>
+                <isset property="manifest.available"/>
+                <isset property="main.class"/>
+                <not>
+                    <equals arg1="${main.class}" arg2="" trim="true"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="manifest.available+main.class+mkdist.available">
+            <and>
+                <istrue value="${manifest.available+main.class}"/>
+                <isset property="libs.CopyLibs.classpath"/>
+            </and>
+        </condition>
+        <condition property="have.tests">
+            <or>
+                <available file="${test.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="have.sources">
+            <or>
+                <available file="${src.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="netbeans.home+have.tests">
+            <and>
+                <isset property="netbeans.home"/>
+                <isset property="have.tests"/>
+            </and>
+        </condition>
+        <condition property="no.javadoc.preview">
+            <and>
+                <isset property="javadoc.preview"/>
+                <isfalse value="${javadoc.preview}"/>
+            </and>
+        </condition>
+        <property name="run.jvmargs" value=""/>
+        <property name="javac.compilerargs" value=""/>
+        <property name="work.dir" value="${basedir}"/>
+        <condition property="no.deps">
+            <and>
+                <istrue value="${no.dependencies}"/>
+            </and>
+        </condition>
+        <property name="javac.debug" value="true"/>
+        <property name="javadoc.preview" value="true"/>
+        <property name="application.args" value=""/>
+        <property name="source.encoding" value="${file.encoding}"/>
+        <condition property="javadoc.encoding.used" value="${javadoc.encoding}">
+            <and>
+                <isset property="javadoc.encoding"/>
+                <not>
+                    <equals arg1="${javadoc.encoding}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <property name="javadoc.encoding.used" value="${source.encoding}"/>
+        <property name="includes" value="**"/>
+        <property name="excludes" value=""/>
+        <property name="do.depend" value="false"/>
+        <condition property="do.depend.true">
+            <istrue value="${do.depend}"/>
+        </condition>
+        <condition else="" property="javac.compilerargs.jaxws" value="-Djava.endorsed.dirs='${jaxws.endorsed.dir}'">
+            <and>
+                <isset property="jaxws.endorsed.dir"/>
+                <available file="nbproject/jaxws-build.xml"/>
+            </and>
+        </condition>
+    </target>
+    <target name="-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init" name="-init-check">
+        <fail unless="src.src.dir">Must set src.src.dir</fail>
+        <fail unless="test.src.dir">Must set test.src.dir</fail>
+        <fail unless="build.dir">Must set build.dir</fail>
+        <fail unless="dist.dir">Must set dist.dir</fail>
+        <fail unless="build.classes.dir">Must set build.classes.dir</fail>
+        <fail unless="dist.javadoc.dir">Must set dist.javadoc.dir</fail>
+        <fail unless="build.test.classes.dir">Must set build.test.classes.dir</fail>
+        <fail unless="build.test.results.dir">Must set build.test.results.dir</fail>
+        <fail unless="build.classes.excludes">Must set build.classes.excludes</fail>
+        <fail unless="dist.jar">Must set dist.jar</fail>
+    </target>
+    <target name="-init-macrodef-property">
+        <macrodef name="property" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${@{value}}"/>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-javac">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="/does/not/exist" name="sourcepath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${javac.compilerargs} ${javac.compilerargs.jaxws}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+        <macrodef name="depend" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <sequential>
+                <depend cache="${build.dir}/depcache" destdir="@{destdir}" excludes="${excludes}" includes="${includes}" srcdir="@{srcdir}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </depend>
+            </sequential>
+        </macrodef>
+        <macrodef name="force-recompile" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <sequential>
+                <fail unless="javac.includes">Must set javac.includes</fail>
+                <pathconvert pathsep="," property="javac.includes.binary">
+                    <path>
+                        <filelist dir="@{destdir}" files="${javac.includes}"/>
+                    </path>
+                    <globmapper from="*.java" to="*.class"/>
+                </pathconvert>
+                <delete>
+                    <files includes="${javac.includes.binary}"/>
+                </delete>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-junit">
+        <macrodef name="junit" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <sequential>
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" showoutput="true">
+                    <batchtest todir="${build.test.results.dir}">
+                        <fileset dir="${test.src.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                            <filename name="@{testincludes}"/>
+                        </fileset>
+                    </batchtest>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <formatter type="brief" usefile="false"/>
+                    <formatter type="xml"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                </junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-nbjpda">
+        <macrodef name="nbjpdastart" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="name"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <attribute default="" name="stopclassname"/>
+            <sequential>
+                <nbjpdastart addressproperty="jpda.address" name="@{name}" stopclassname="@{stopclassname}" transport="${debug-transport}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </nbjpdastart>
+            </sequential>
+        </macrodef>
+        <macrodef name="nbjpdareload" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${build.classes.dir}" name="dir"/>
+            <sequential>
+                <nbjpdareload>
+                    <fileset dir="@{dir}" includes="${fix.classes}">
+                        <include name="${fix.includes}*.class"/>
+                    </fileset>
+                </nbjpdareload>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-debug-args">
+        <property name="version-output" value="java version &quot;${ant.java.version}"/>
+        <condition property="have-jdk-older-than-1.4">
+            <or>
+                <contains string="${version-output}" substring="java version &quot;1.0"/>
+                <contains string="${version-output}" substring="java version &quot;1.1"/>
+                <contains string="${version-output}" substring="java version &quot;1.2"/>
+                <contains string="${version-output}" substring="java version &quot;1.3"/>
+            </or>
+        </condition>
+        <condition else="-Xdebug" property="debug-args-line" value="-Xdebug -Xnoagent -Djava.compiler=none">
+            <istrue value="${have-jdk-older-than-1.4}"/>
+        </condition>
+        <condition else="dt_socket" property="debug-transport-by-os" value="dt_shmem">
+            <os family="windows"/>
+        </condition>
+        <condition else="${debug-transport-by-os}" property="debug-transport" value="${debug.transport}">
+            <isset property="debug.transport"/>
+        </condition>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-debug">
+        <macrodef name="debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true">
+                    <jvmarg line="${debug-args-line}"/>
+                    <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-java">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="classname"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true">
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="${run.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-presetdef-jar">
+        <presetdef name="jar" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <jar compress="${jar.compress}" jarfile="${dist.jar}">
+                <j2seproject1:fileset dir="${build.classes.dir}"/>
+            </jar>
+        </presetdef>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init,-post-init,-init-check,-init-macrodef-property,-init-macrodef-javac,-init-macrodef-junit,-init-macrodef-nbjpda,-init-macrodef-debug,-init-macrodef-java,-init-presetdef-jar" name="init"/>
+    <!--
+                ===================
+                COMPILATION SECTION
+                ===================
+            -->
+    <target depends="init" name="deps-jar" unless="no.deps"/>
+    <target depends="init,-check-automatic-build,-clean-after-automatic-build" name="-verify-automatic-build"/>
+    <target depends="init" name="-check-automatic-build">
+        <available file="${build.classes.dir}/.netbeans_automatic_build" property="netbeans.automatic.build"/>
+    </target>
+    <target depends="init" if="netbeans.automatic.build" name="-clean-after-automatic-build">
+        <antcall target="clean"/>
+    </target>
+    <target depends="init,deps-jar" name="-pre-pre-compile">
+        <mkdir dir="${build.classes.dir}"/>
+    </target>
+    <target name="-pre-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-depend">
+        <j2seproject3:depend/>
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile,-pre-compile,-compile-depend" if="have.sources" name="-do-compile">
+        <j2seproject3:javac/>
+        <copy todir="${build.classes.dir}">
+            <fileset dir="${src.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile,-do-compile,-post-compile" description="Compile project." name="compile"/>
+    <target name="-pre-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile" name="-do-compile-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile/>
+        <j2seproject3:javac excludes="" includes="${javac.includes}" sourcepath="${src.src.dir}"/>
+    </target>
+    <target name="-post-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile-single,-do-compile-single,-post-compile-single" name="compile-single"/>
+    <!--
+                ====================
+                JAR BUILDING SECTION
+                ====================
+            -->
+    <target depends="init" name="-pre-pre-jar">
+        <dirname file="${dist.jar}" property="dist.jar.dir"/>
+        <mkdir dir="${dist.jar.dir}"/>
+    </target>
+    <target name="-pre-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" name="-do-jar-without-manifest" unless="manifest.available">
+        <j2seproject1:jar/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available" name="-do-jar-with-manifest" unless="manifest.available+main.class">
+        <j2seproject1:jar manifest="${manifest.file}"/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available+main.class" name="-do-jar-with-mainclass" unless="manifest.available+main.class+mkdist.available">
+        <j2seproject1:jar manifest="${manifest.file}">
+            <j2seproject1:manifest>
+                <j2seproject1:attribute name="Main-Class" value="${main.class}"/>
+            </j2seproject1:manifest>
+        </j2seproject1:jar>
+        <echo>To run this application from the command line without Ant, try:</echo>
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <pathconvert property="run.classpath.with.dist.jar">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to="${dist.jar.resolved}"/>
+        </pathconvert>
+        <echo>java -cp "${run.classpath.with.dist.jar}" ${main.class}</echo>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available+main.class+mkdist.available" name="-do-jar-with-libraries">
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <pathconvert property="run.classpath.without.build.classes.dir">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to=""/>
+        </pathconvert>
+        <pathconvert pathsep=" " property="jar.classpath">
+            <path path="${run.classpath.without.build.classes.dir}"/>
+            <chainedmapper>
+                <flattenmapper/>
+                <globmapper from="*" to="lib/*"/>
+            </chainedmapper>
+        </pathconvert>
+        <taskdef classname="org.netbeans.modules.java.j2seproject.copylibstask.CopyLibs" classpath="${libs.CopyLibs.classpath}" name="copylibs"/>
+        <copylibs compress="${jar.compress}" jarfile="${dist.jar}" manifest="${manifest.file}" runtimeclasspath="${run.classpath.without.build.classes.dir}">
+            <fileset dir="${build.classes.dir}"/>
+            <manifest>
+                <attribute name="Main-Class" value="${main.class}"/>
+                <attribute name="Class-Path" value="${jar.classpath}"/>
+            </manifest>
+        </copylibs>
+        <echo>To run this application from the command line without Ant, try:</echo>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <echo>java -jar "${dist.jar.resolved}"</echo>
+    </target>
+    <target name="-post-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-jar,-do-jar-with-manifest,-do-jar-without-manifest,-do-jar-with-mainclass,-do-jar-with-libraries,-post-jar" description="Build JAR." name="jar"/>
+    <!--
+                =================
+                EXECUTION SECTION
+                =================
+            -->
+    <target depends="init,compile" description="Run a main class." name="run">
+        <j2seproject1:java>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <target name="-do-not-recompile">
+        <property name="javac.includes.binary" value=""/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-single" name="run-single">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}"/>
+    </target>
+    <!--
+                =================
+                DEBUGGING SECTION
+                =================
+            -->
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger">
+        <j2seproject1:nbjpdastart name="${debug.class}"/>
+    </target>
+    <target depends="init,compile" name="-debug-start-debuggee">
+        <j2seproject3:debug>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile,-debug-start-debugger,-debug-start-debuggee" description="Debug project in IDE." if="netbeans.home" name="debug"/>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-stepinto">
+        <j2seproject1:nbjpdastart stopclassname="${main.class}"/>
+    </target>
+    <target depends="init,compile,-debug-start-debugger-stepinto,-debug-start-debuggee" if="netbeans.home" name="debug-stepinto"/>
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-single">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}"/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-single,-debug-start-debugger,-debug-start-debuggee-single" if="netbeans.home" name="debug-single"/>
+    <target depends="init" name="-pre-debug-fix">
+        <fail unless="fix.includes">Must set fix.includes</fail>
+        <property name="javac.includes" value="${fix.includes}.java"/>
+    </target>
+    <target depends="init,-pre-debug-fix,compile-single" if="netbeans.home" name="-do-debug-fix">
+        <j2seproject1:nbjpdareload/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix" if="netbeans.home" name="debug-fix"/>
+    <!--
+                ===============
+                JAVADOC SECTION
+                ===============
+            -->
+    <target depends="init" name="-javadoc-build">
+        <mkdir dir="${dist.javadoc.dir}"/>
+        <javadoc additionalparam="${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
+            <classpath>
+                <path path="${javac.classpath}"/>
+            </classpath>
+            <fileset dir="${src.src.dir}" excludes="${excludes}" includes="${includes}">
+                <filename name="**/*.java"/>
+            </fileset>
+        </javadoc>
+    </target>
+    <target depends="init,-javadoc-build" if="netbeans.home" name="-javadoc-browse" unless="no.javadoc.preview">
+        <nbbrowse file="${dist.javadoc.dir}/index.html"/>
+    </target>
+    <target depends="init,-javadoc-build,-javadoc-browse" description="Build Javadoc." name="javadoc"/>
+    <!--
+                =========================
+                JUNIT COMPILATION SECTION
+                =========================
+            -->
+    <target depends="init,compile" if="have.tests" name="-pre-pre-compile-test">
+        <mkdir dir="${build.test.classes.dir}"/>
+    </target>
+    <target name="-pre-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-test-depend">
+        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend" if="have.tests" name="-do-compile-test">
+        <j2seproject3:javac classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-do-compile-test,-post-compile-test" name="compile-test"/>
+    <target name="-pre-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single" if="have.tests" name="-do-compile-test-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile destdir="${build.test.classes.dir}"/>
+        <j2seproject3:javac classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}" sourcepath="${test.src.dir}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single,-do-compile-test-single,-post-compile-test-single" name="compile-test-single"/>
+    <!--
+                =======================
+                JUNIT EXECUTION SECTION
+                =======================
+            -->
+    <target depends="init" if="have.tests" name="-pre-test-run">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run" if="have.tests" name="-do-test-run">
+        <j2seproject3:junit testincludes="**/*Test.java"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run" if="have.tests" name="-post-test-run">
+        <fail if="tests.failed">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init" if="have.tests" name="test-report"/>
+    <target depends="init" if="netbeans.home+have.tests" name="-test-browse"/>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run,test-report,-post-test-run,-test-browse" description="Run unit tests." name="test"/>
+    <target depends="init" if="have.tests" name="-pre-test-run-single">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-do-test-run-single">
+        <fail unless="test.includes">Must select some files in the IDE or set test.includes</fail>
+        <j2seproject3:junit excludes="" includes="${test.includes}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single" if="have.tests" name="-post-test-run-single">
+        <fail if="tests.failed">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init,-do-not-recompile,compile-test-single,-pre-test-run-single,-do-test-run-single,-post-test-run-single" description="Run single unit test." name="test-single"/>
+    <!--
+                =======================
+                JUNIT DEBUGGING SECTION
+                =======================
+            -->
+    <target depends="init,compile-test" if="have.tests" name="-debug-start-debuggee-test">
+        <fail unless="test.class">Must select one file in the IDE or set test.class</fail>
+        <property location="${build.test.results.dir}/TEST-${test.class}.xml" name="test.report.file"/>
+        <delete file="${test.report.file}"/>
+        <mkdir dir="${build.test.results.dir}"/>
+        <j2seproject3:debug classname="org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" classpath="${ant.home}/lib/ant.jar:${ant.home}/lib/ant-junit.jar:${debug.test.classpath}">
+            <customize>
+                <syspropertyset>
+                    <propertyref prefix="test-sys-prop."/>
+                    <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                </syspropertyset>
+                <arg value="${test.class}"/>
+                <arg value="showoutput=true"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,${test.report.file}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-test" if="netbeans.home+have.tests" name="-debug-start-debugger-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${test.class}"/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-test-single,-debug-start-debugger-test,-debug-start-debuggee-test" name="debug-test"/>
+    <target depends="init,-pre-debug-fix,compile-test-single" if="netbeans.home" name="-do-debug-fix-test">
+        <j2seproject1:nbjpdareload dir="${build.test.classes.dir}"/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix-test" if="netbeans.home" name="debug-fix-test"/>
+    <!--
+                =========================
+                APPLET EXECUTION SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" name="run-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject1:java classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <!--
+                =========================
+                APPLET DEBUGGING  SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject3:debug classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-applet" if="netbeans.home" name="debug-applet"/>
+    <!--
+                ===============
+                CLEANUP SECTION
+                ===============
+            -->
+    <target depends="init" name="deps-clean" unless="no.deps"/>
+    <target depends="init" name="-do-clean">
+        <delete dir="${build.dir}"/>
+        <delete dir="${dist.dir}"/>
+    </target>
+    <target name="-post-clean">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-clean,-do-clean,-post-clean" description="Clean build products." name="clean"/>
+</project>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/findbugs.settings	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,72 @@
+#FindBugs User Preferences
+#Mon Jun 15 13:37:16 PDT 2009
+detectorAbnormalFinallyBlockReturn=AbnormalFinallyBlockReturn|false
+detectorAbstractClassEmptyMethods=AbstractClassEmptyMethods|false
+detectorAbstractOverriddenMethod=AbstractOverriddenMethod|false
+detectorArrayBasedCollections=ArrayBasedCollections|false
+detectorArrayWrappedCallByReference=ArrayWrappedCallByReference|false
+detectorBloatedAssignmentScope=BloatedAssignmentScope|false
+detectorBloatedSynchronizedBlock=BloatedSynchronizedBlock|false
+detectorClassEnvy=ClassEnvy|false
+detectorCollectStatistics=CollectStatistics|false
+detectorConfusingAutoboxedOverloading=ConfusingAutoboxedOverloading|false
+detectorConstantListIndex=ConstantListIndex|false
+detectorCopiedOverriddenMethod=CopiedOverriddenMethod|false
+detectorCustomBuiltXML=CustomBuiltXML|false
+detectorCyclomaticComplexity=CyclomaticComplexity|false
+detectorDateComparison=DateComparison|false
+detectorDeclaredRuntimeException=DeclaredRuntimeException|false
+detectorDeletingWhileIterating=DeletingWhileIterating|false
+detectorDubiousListCollection=DubiousListCollection|false
+detectorFieldCouldBeLocal=FieldCouldBeLocal|false
+detectorFinalParameters=FinalParameters|false
+detectorFloatingPointLoops=FloatingPointLoops|false
+detectorInefficientStringBuffering=InefficientStringBuffering|false
+detectorInheritanceTypeChecking=InheritanceTypeChecking|false
+detectorJDBCVendorReliance=JDBCVendorReliance|false
+detectorListIndexedIterating=ListIndexedIterating|false
+detectorLiteralStringComparison=LiteralStringComparison|false
+detectorLocalSynchronizedCollection=LocalSynchronizedCollection|false
+detectorLostExceptionStackTrace=LostExceptionStackTrace|false
+detectorManualArrayCopy=ManualArrayCopy|false
+detectorMethodReturnsConstant=MethodReturnsConstant|false
+detectorNeedlessAutoboxing=NeedlessAutoboxing|false
+detectorNeedlessCustomSerialization=NeedlessCustomSerialization|false
+detectorNeedlessInstanceRetrieval=NeedlessInstanceRetrieval|false
+detectorNeedlessMemberCollectionSynchronization=NeedlessMemberCollectionSynchronization|false
+detectorNonCollectionMethodUse=NonCollectionMethodUse|false
+detectorNonOwnedSynchronization=NonOwnedSynchronization|false
+detectorNonRecycleableTaglibs=NonRecycleableTaglibs|false
+detectorOrphanedDOMNode=OrphanedDOMNode|false
+detectorOverlyConcreteParameter=OverlyConcreteParameter|false
+detectorParallelLists=ParallelLists|false
+detectorPartiallyConstructedObjectAccess=PartiallyConstructedObjectAccess|false
+detectorPossibleIncompleteSerialization=PossibleIncompleteSerialization|false
+detectorPossibleMemoryBloat=PossibleMemoryBloat|false
+detectorPossiblyRedundantMethodCalls=PossiblyRedundantMethodCalls|false
+detectorSQLInLoop=SQLInLoop|false
+detectorSection508Compliance=Section508Compliance|false
+detectorSillynessPotPourri=SillynessPotPourri|false
+detectorSloppyClassReflection=SloppyClassReflection|false
+detectorSluggishGui=SluggishGui|false
+detectorSpoiledChildInterfaceImplementor=SpoiledChildInterfaceImplementor|false
+detectorSpuriousThreadStates=SpuriousThreadStates|false
+detectorStaticArrayCreatedInMethod=StaticArrayCreatedInMethod|false
+detectorStaticMethodInstanceInvocation=StaticMethodInstanceInvocation|false
+detectorSuspiciousComparatorReturnValues=SuspiciousComparatorReturnValues|false
+detectorSuspiciousJDKVersionUse=SuspiciousJDKVersionUse|false
+detectorSuspiciousWaitOnConcurrentObject=SuspiciousWaitOnConcurrentObject|false
+detectorSyncCollectionIterators=SyncCollectionIterators|false
+detectorTailRecursion=TailRecursion|false
+detectorUnnecessaryStoreBeforeReturn=UnnecessaryStoreBeforeReturn|false
+detectorUnrelatedCollectionContents=UnrelatedCollectionContents|false
+detectorUnrelatedReturnValues=UnrelatedReturnValues|false
+detectorUseAddAll=UseAddAll|false
+detectorUseCharacterParameterizedMethod=UseCharacterParameterizedMethod|false
+detectorUseEnumCollections=UseEnumCollections|false
+detectorUseSplit=UseSplit|false
+detectorUseToArray=UseToArray|false
+detector_threshold=2
+effort=default
+filter_settings=Medium|BAD_PRACTICE,CORRECTNESS,I18N,MALICIOUS_CODE,MT_CORRECTNESS,PERFORMANCE,SECURITY,STYLE|false
+filter_settings_neg=|
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/genfiles.properties	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,8 @@
+build.xml.data.CRC32=b40e775f
+build.xml.script.CRC32=af8dc3cb
+build.xml.stylesheet.CRC32=958a1d3e
+# This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
+# Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
+nbproject/build-impl.xml.data.CRC32=b40e775f
+nbproject/build-impl.xml.script.CRC32=624d12c5
+nbproject/build-impl.xml.stylesheet.CRC32=65b8de21
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/project.properties	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,65 @@
+application.title=jdwpgen
+application.vendor=sun
+build.classes.dir=${build.dir}/classes
+build.classes.excludes=**/*.java,**/*.form
+# This directory is removed when the project is cleaned:
+build.dir=build
+build.generated.dir=${build.dir}/generated
+# Only compile against the classpath explicitly listed here:
+build.sysclasspath=ignore
+build.test.classes.dir=${build.dir}/test/classes
+build.test.results.dir=${build.dir}/test/results
+# Uncomment to specify the preferred debugger connection transport:
+#debug.transport=dt_socket
+debug.classpath=\
+    ${run.classpath}
+debug.test.classpath=\
+    ${run.test.classpath}
+# This directory is removed when the project is cleaned:
+dist.dir=dist
+dist.jar=${dist.dir}/jdwpgen.jar
+dist.javadoc.dir=${dist.dir}/javadoc
+excludes=
+file.reference.tools-jdwpgen=../../tools/src/build/tools/jdwpgen
+file.reference.tools-src=../../tools/src
+includes=build/tools/jdwpgen/**
+jar.compress=false
+javac.classpath=
+# Space-separated list of extra javac options
+javac.compilerargs=-Xlint:all
+javac.deprecation=false
+javac.source=1.5
+javac.target=1.5
+javac.test.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}:\
+    ${libs.junit.classpath}:\
+    ${libs.junit_4.classpath}
+javadoc.additionalparam=
+javadoc.author=false
+javadoc.encoding=${source.encoding}
+javadoc.noindex=true
+javadoc.nonavbar=true
+javadoc.notree=true
+javadoc.private=true
+javadoc.splitindex=false
+javadoc.use=false
+javadoc.version=false
+javadoc.windowtitle=
+main.class=jdwpgen.Main
+manifest.file=manifest.mf
+meta.inf.dir=${src.dir}/META-INF
+platform.active=default_platform
+run.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}
+# Space-separated list of JVM arguments used when running the project
+# (you may also define separate properties like run-sys-prop.name=value instead of -Dname=value
+# or test-sys-prop.name=value to set system properties for unit tests):
+run.jvmargs=
+run.test.classpath=\
+    ${javac.test.classpath}:\
+    ${build.test.classes.dir}
+source.encoding=UTF-8
+src.src.dir=${file.reference.tools-src}
+test.src.dir=test
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/project.xml	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://www.netbeans.org/ns/project/1">
+    <type>org.netbeans.modules.java.j2seproject</type>
+    <configuration>
+        <data xmlns="http://www.netbeans.org/ns/j2se-project/3">
+            <name>jdwpgen</name>
+            <minimum-ant-version>1.6.5</minimum-ant-version>
+            <source-roots>
+                <root id="src.src.dir"/>
+            </source-roots>
+            <test-roots>
+                <root id="test.src.dir"/>
+            </test-roots>
+        </data>
+    </configuration>
+</project>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/netbeans/jdwpgen/nbproject/sqe.properties	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,2 @@
+#Path to FindbugsSettingsFile (relative)
+findbugs.settings.file=findbugs.settings
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/generate_nimbus/Makefile	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,72 @@
+#
+# Copyright 1998-2005 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Sun designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Sun in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+#
+# Makefile for building the Nimbus generator
+#
+
+BUILDDIR = ../..
+PACKAGE = build.tools.generatenimbus
+PRODUCT = tools
+PROGRAM = generatenimbus
+include $(BUILDDIR)/common/Defs.gmk
+
+BUILDTOOL_SOURCE_ROOT = $(BUILDDIR)/tools/src
+BUILDTOOL_MAIN        = $(PKGDIR)/Generator.java
+
+
+#
+# Files
+#
+
+SOURCE_FILES    = Generator.java \
+                  ObjectFactory.java \
+                  Paint.java \
+                  SynthModel.java \
+                  UIDefault.java \
+                  UIStyle.java
+TEMPLATE_FILES  = Defaults.template \
+                  PainterImpl.template \
+                  StateImpl.template
+TEMPLATE_DEST   = $(BUILDTOOLCLASSDIR)/$(PKGDIR)/resources
+
+
+#
+# Rules
+#
+
+all: $(TEMPLATE_DEST) $(BUILDTOOL_JAR_FILE)
+
+include $(BUILDDIR)/common/BuildToolJar.gmk
+
+$(TEMPLATE_DEST): $(TEMPLATE_FILES:%=$(SHARE_SRC)/classes/javax/swing/plaf/nimbus/%)
+	$(MKDIR) -p $@
+	$(RM) $(TEMPLATE_FILES:%=$@/%)
+	$(CP) $^ $@
+
+BUILDTOOL_MAIN_SOURCE_FILE = $(SOURCE_FILES:%=$(BUILDTOOL_SOURCE_ROOT)/$(PKGDIR)/%)
+
+clean clobber::
+	$(RM) -r $(TEMPLATE_DEST)
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/Generator.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package build.tools.generatenimbus;
+
+import java.io.*;
+import java.util.HashMap;
+import java.util.Map;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Unmarshaller;
+
+/**
+ * Generates the various Java artifacts based on a SynthModel.
+ * <p/>
+ * Generated source files are split up among two different locations. There are those source files that are meant to be
+ * edited (generally, only the LookAndFeel class itself) and those that are autogenerated (everything else).
+ * <p/>
+ * All autogenerated files are placed in "buildPackageRoot" and are package private. A LAF author (one who has access to
+ * the generated sources) will be able to access any of the generated classes. Those referencing the library, however,
+ * will only be able to access the main LookAndFeel class itself (since everything else is package private).
+ *
+ * @author  Richard Bair
+ * @author  Jasper Potts
+ */
+public class Generator {
+    private static Generator instance;
+
+    /** A map of variables that are used for variable substitution in the template files. */
+    private Map<String, String> variables;
+    private boolean full = false;
+    private File buildPackageRoot;
+    private String packageNamePrefix;
+    private String lafName;
+    private SynthModel model;
+
+    /**
+     * MAIN APPLICATION
+     * <p/>
+     * This is for using the generator as part of the java build process
+     *
+     * @param args The commandline arguments
+     */
+    public static void main(String[] args) throws Exception {
+        if (args.length == 0 || (args.length % 2) != 0) {
+            System.out.println("Usage: generator [-options]\n" +
+                    "    -full <true|false>     True if we should build the whole LAF or false for building just states and painters.\n" +
+                    "    -skinFile <value>      Path to the skin.laf file for the LAF to be generated from.\n" +
+                    "    -buildDir <value>      The directory beneath which the build-controlled artifacts (such as the Painters) should\n" +
+                    "                           be placed. This is the root directory beneath which the necessary packages and source\n" +
+                    "                           files will be created.\n" +
+                    "    -resourcesDir <value>  The resources directory containing templates and images.\n" +
+                    "    -packagePrefix <value> The package name associated with this synth look and feel. For example,\n" +
+                    "                           \"org.mypackage.mylaf\"\n" +
+                    "    -lafName <value>       The name of the laf, such as \"MyLAF\".\n");
+        } else {
+            boolean full = false;
+            File skinFile = new File(System.getProperty("user.dir"));
+            File buildDir = new File(System.getProperty("user.dir"));
+            File resourcesDir = new File(System.getProperty("user.dir"));
+            String packagePrefix = "org.mypackage.mylaf";
+            String lafName = "MyLAF";
+            for (int i = 0; i < args.length; i += 2) {
+                String key = args[i].trim().toLowerCase();
+                String value = args[i + 1].trim();
+                if ("-full".equals(key)) {
+                    full = Boolean.parseBoolean(value);
+                } else if ("-skinfile".equals(key)) {
+                    skinFile = new File(value);
+                } else if ("-builddir".equals(key)) {
+                    buildDir = new File(value);
+                } else if ("-resourcesdir".equals(key)) {
+                    resourcesDir = new File(value);
+                } else if ("-packageprefix".equals(key)) {
+                    packagePrefix = value;
+                } else if ("-lafname".equals(key)) {
+                    lafName = value;
+                }
+            }
+            System.out.println("### GENERATING LAF CODE ################################");
+            System.out.println("   full          :" + full);
+            System.out.println("   skinFile      :" + skinFile.getAbsolutePath());
+            System.out.println("   buildDir      :" + buildDir.getAbsolutePath());
+            System.out.println("   resourcesDir  :" + resourcesDir.getAbsolutePath());
+            System.out.println("   packagePrefix :" +packagePrefix);
+            System.out.println("   lafName       :" +lafName);
+
+            JAXBContext ctx = JAXBContext.newInstance("build.tools.generatenimbus");
+            Unmarshaller u = ctx.createUnmarshaller();
+            SynthModel model = (SynthModel) u.unmarshal(skinFile);
+            Generator.init(full, buildDir, packagePrefix, lafName, model);
+            Generator.getInstance().generate();
+        }
+    }
+
+    /**
+     * Creates a new Generator, capable of outputting the source code artifacts related to a given SynthModel. It is
+     * capable of generating the one-time artifacts in addition to the regeneration of build-controlled artifacts.
+     *
+     * @param full              True if we should build the whole LAF or false for building just states and painters.
+     * @param buildDir          The directory beneath which the build-controlled artifacts (such as the Painters) should
+     *                          be placed. This is the root directory beneath which the necessary packages and source
+     *                          files will be created.
+     * @param srcDir            The directory beneath which the normal user-controlled artifacts (such as the core
+     *                          LookAndFeel file) should be placed. These are one-time generated files. This is the root
+     *                          directory beneath which the necessary packages and source files will be created.
+     * @param packageNamePrefix The package name associated with this synth look and feel. For example,
+     *                          org.mypackage.mylaf
+     * @param lafName           The name of the laf, such as MyLAF.
+     * @param model             The actual SynthModel to base these generated files on.
+     */
+    private Generator(boolean full, File buildDir,
+            String packageNamePrefix, String lafName, SynthModel model) {
+        this.full = full;
+        //validate the input variables
+        if (packageNamePrefix == null) {
+            throw new IllegalArgumentException("You must specify a package name prefix");
+        }
+        if (buildDir == null) {
+            throw new IllegalArgumentException("You must specify the build directory");
+        }
+        if (model == null) {
+            throw new IllegalArgumentException("You must specify the SynthModel");
+        }
+        if (lafName == null) {
+            throw new IllegalArgumentException("You must specify the name of the look and feel");
+        }
+
+        //construct the map which is used to do variable substitution of the template
+        //files
+        variables = new HashMap<String, String>();
+        variables.put("PACKAGE", packageNamePrefix);
+        variables.put("LAF_NAME", lafName);
+
+        //generate and save references to the package-root directories.
+        //(That is, given the buildDir and srcDir, generate references to the
+        //org.mypackage.mylaf subdirectories)
+        buildPackageRoot = new File(buildDir, packageNamePrefix.replaceAll("\\.", "\\/"));
+        buildPackageRoot.mkdirs();
+
+        //save the variables
+        this.packageNamePrefix = packageNamePrefix;
+        this.lafName = lafName;
+        this.model = model;
+    }
+
+    public static void init(boolean full, File buildDir,
+            String packageNamePrefix, String lafName, SynthModel model) {
+        instance = new Generator(full, buildDir, packageNamePrefix, lafName, model);
+        model.initStyles();
+    }
+
+    public static Generator getInstance() {
+        return instance;
+    }
+
+    public static Map<String, String> getVariables() {
+        return new HashMap<String, String>(instance.variables);
+    }
+
+    public void generate() {
+        if (full) {
+            //create the LookAndFeel file
+            writeSrcFileImpl("LookAndFeel", variables, lafName + "LookAndFeel");
+
+            writeSrcFileImpl("AbstractRegionPainter", variables);
+            writeSrcFileImpl("BlendingMode", variables);
+            writeSrcFileImpl("SynthPainterImpl", variables);
+            writeSrcFileImpl("IconImpl", variables, lafName + "Icon.java");
+            writeSrcFileImpl("StyleImpl", variables, lafName + "Style.java");
+            writeSrcFileImpl("Effect", variables);
+            writeSrcFileImpl("EffectUtils", variables);
+            writeSrcFileImpl("ShadowEffect", variables);
+            writeSrcFileImpl("DropShadowEffect", variables);
+            writeSrcFileImpl("InnerShadowEffect", variables);
+            writeSrcFileImpl("InnerGlowEffect", variables);
+            writeSrcFileImpl("OuterGlowEffect", variables);
+            writeSrcFileImpl("State", variables);
+            writeSrcFileImpl("ImageCache", variables);
+            writeSrcFileImpl("ImageScalingHelper", variables);
+        }
+        //next, populate the first set of ui defaults based on what is in the
+        //various palettes of the synth model
+        StringBuilder defBuffer = new StringBuilder();
+        StringBuilder styleBuffer = new StringBuilder();
+        model.write(defBuffer, styleBuffer, packageNamePrefix);
+
+        Map<String, String> vars = getVariables();
+        vars.put("UI_DEFAULT_INIT", defBuffer.toString());
+        vars.put("STYLE_INIT", styleBuffer.toString());
+        writeSrcFile("Defaults", vars, lafName + "Defaults");
+    }
+
+    private void writeSrcFileImpl(String name, Map<String, String> variables) {
+        writeSrcFileImpl(name, variables, name);
+    }
+
+    private void writeSrcFileImpl(String templateName,
+            Map<String, String> variables, String outputName) {
+        PrintWriter out = null;
+        try {
+            InputStream stream = getClass().getResourceAsStream(
+                    "resources/" + templateName + ".template");
+            TemplateReader in = new TemplateReader(variables, stream);
+
+            out = new PrintWriter(new File(buildPackageRoot, outputName + ".java"));
+            String line = in.readLine();
+            while (line != null) {
+                out.println(line);
+                line = in.readLine();
+            }
+        } catch (IOException e) {
+            throw new RuntimeException("IOException in writer", e);
+        } finally {
+            if (out != null) out.close();
+        }
+    }
+
+    public static void writeSrcFile(String templateName,
+            Map<String, String> variables, String outputName) {
+        instance.writeSrcFileImpl(templateName, variables, outputName);
+    }
+
+    /** A BufferedReader implementation that automatically performs
+     * string replacements as needed.
+     */
+    private static final class TemplateReader extends BufferedReader {
+        private Map<String, String> variables;
+
+        TemplateReader(Map<String, String> variables, InputStream template) {
+            super(new InputStreamReader(template));
+            this.variables = variables;
+        }
+
+        @Override public String readLine() throws IOException {
+            return substituteVariables(super.readLine());
+        }
+
+        private String substituteVariables(String input) {
+            if (input == null) return null;
+            for (Map.Entry<String, String> variable : variables.entrySet()) {
+                input = input.replace("${" + variable.getKey() + "}", variable.getValue());
+            }
+            return input;
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/ObjectFactory.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import javax.xml.bind.annotation.XmlRegistry;
+
+
+/**
+ * This object contains factory methods for each
+ * Java content interface and Java element interface
+ * generated in the test package.
+ * <p>An ObjectFactory allows you to programatically
+ * construct new instances of the Java representation
+ * for XML content. The Java representation of XML
+ * content can consist of schema derived interfaces
+ * and classes representing the binding of schema
+ * type definitions, element declarations and model
+ * groups.  Factory methods for each of these are
+ * provided in this class.
+ *
+ */
+@XmlRegistry
+public class ObjectFactory {
+
+    /**
+     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: test
+     *
+     */
+    public ObjectFactory() {
+    }
+
+    /**
+     * Create an instance of {@link SynthModel }
+     *
+     */
+    public SynthModel createSynthModel() {
+        return new SynthModel();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/Paint.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import java.util.ArrayList;
+import java.util.List;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+
+public abstract class Paint {
+}
+
+class Matte extends Paint {
+    @XmlAttribute private int red;
+    @XmlAttribute private int green;
+    @XmlAttribute private int blue;
+    @XmlAttribute private int alpha;
+
+    @XmlAttribute private String uiDefaultParentName = null;
+    @XmlAttribute private float hueOffset = 0;
+    @XmlAttribute private float saturationOffset = 0;
+    @XmlAttribute private float brightnessOffset = 0;
+    @XmlAttribute private int alphaOffset = 0;
+
+    @XmlAttribute private String componentPropertyName = null;
+    public String getComponentPropertyName() { return componentPropertyName; }
+
+    @XmlAttribute private boolean uiResource = true;
+
+    public boolean isAbsolute() {
+        return uiDefaultParentName == null;
+    }
+
+    public String getDeclaration() {
+        if (isAbsolute()) {
+            return String.format("new Color(%d, %d, %d, %d)",
+                                 red, green, blue, alpha);
+        } else {
+            return String.format("decodeColor(\"%s\", %sf, %sf, %sf, %d)",
+                    uiDefaultParentName, String.valueOf(hueOffset),
+                    String.valueOf(saturationOffset),
+                    String.valueOf(brightnessOffset), alphaOffset);
+        }
+    }
+
+    public String write() {
+        if (isAbsolute()) {
+            return String.format("%s, %s, %s, %s", red, green, blue, alpha);
+        } else {
+            String s = String.format("\"%s\", %sf, %sf, %sf, %d",
+                    uiDefaultParentName, String.valueOf(hueOffset),
+                    String.valueOf(saturationOffset),
+                    String.valueOf(brightnessOffset), alphaOffset);
+            if (! uiResource) {
+                s += ", false";
+            }
+            return s;
+        }
+    }
+
+    public ComponentColor createComponentColor(String variableName) {
+        return new ComponentColor(componentPropertyName, variableName,
+                saturationOffset, brightnessOffset, alphaOffset);
+    }
+}
+
+class ComponentColor {
+    private String propertyName;
+    private String defaultColorVariableName;
+    private float saturationOffset = 0,  brightnessOffset = 0;
+    private int alphaOffset = 0;
+
+    ComponentColor(String propertyName,
+            String defaultColorVariableName,
+            float saturationOffset,
+            float brightnessOffset,
+            int alphaOffset) {
+        this.propertyName = propertyName;
+        this.defaultColorVariableName = defaultColorVariableName;
+        this.saturationOffset = saturationOffset;
+        this.brightnessOffset = brightnessOffset;
+        this.alphaOffset = alphaOffset;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        ComponentColor c = (ComponentColor) o;
+        if (alphaOffset != c.alphaOffset) {
+            return false;
+        }
+        if (Float.compare(saturationOffset, c.saturationOffset) != 0) {
+            return false;
+        }
+        if (Float.compare(brightnessOffset, c.brightnessOffset) != 0) {
+            return false;
+        }
+        if (defaultColorVariableName != null ? !defaultColorVariableName.equals(c.defaultColorVariableName) : c.defaultColorVariableName != null) {
+            return false;
+        }
+        if (propertyName != null ? !propertyName.equals(c.propertyName) : c.propertyName != null) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 5;
+        hash = 61 * hash + (this.propertyName != null ? this.propertyName.hashCode() : 0);
+        hash = 61 * hash + (this.defaultColorVariableName != null ? this.defaultColorVariableName.hashCode() : 0);
+        hash = 61 * hash + Float.floatToIntBits(this.saturationOffset);
+        hash = 61 * hash + Float.floatToIntBits(this.brightnessOffset);
+        hash = 61 * hash + this.alphaOffset;
+        return hash;
+    }
+
+    public void write(StringBuilder sb) {
+        sb.append("                     getComponentColor(c, \"").
+           append(propertyName).append("\", ").
+           append(defaultColorVariableName).append(", ").
+           append(saturationOffset).append("f, ").
+           append(brightnessOffset).append("f, ").
+           append(alphaOffset);
+    }
+}
+
+class GradientStop {
+    @XmlAttribute private float position;
+    public float getPosition() { return position; }
+
+    @XmlAttribute private float midpoint;
+    public float getMidpoint() { return midpoint; }
+
+    @XmlElement private Matte matte;
+    public Matte getColor() { return matte; }
+}
+
+class AbstractGradient extends Paint {
+    public static enum CycleMethod {
+        NO_CYCLE, REFLECT, REPEAT
+    }
+
+    @XmlElement(name="stop") private ArrayList<GradientStop> stops;
+    public List<GradientStop> getStops() { return stops; }
+}
+
+class Gradient extends AbstractGradient {
+}
+
+class RadialGradient extends AbstractGradient {
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/PainterGenerator.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,627 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+package build.tools.generatenimbus;
+
+import java.awt.geom.Point2D;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+
+/**
+ * PainterGenerator - Class for generating Painter class java source from a Canvas
+ *
+ * Following in the general theory that is used to generate a Painter file.
+ *
+ * Each Painter file represents a Region. So there is one painter file per region. In
+ * skin.laf we support Icon subregions, which are really just hacked versions of the
+ * parent region.
+ *
+ * In order to generate the most compact and efficient bytecode possible for the
+ * Painters, we actually perform the generation sequence in two steps. The first
+ * step is the analysis phase, where we walk through the SynthModel for the region
+ * and discover commonality among the different states in the region. For example,
+ * do they have common paths? Do they have common colors? Gradients? Is the painting
+ * code for the different states identical other than for colors?
+ *
+ * We gather this information up. On the second pass, we use this data to determine the
+ * methods that need to be generated, and the class variables that need to be generated.
+ * We try to keep the actual bytecode count as small as possible so that we may reduce
+ * the overall size of the look and feel significantly.
+ *
+ * @author  Richard Bair
+ * @author  Jasper Potts
+ */
+public class PainterGenerator {
+    //a handful of counters, incremented whenever the associated object type is encounted.
+    //These counters form the basis of the field and method suffixes.
+    //These are all 1 based, because I felt like it :-)
+    private int colorCounter = 1;
+    private int gradientCounter = 1;
+    private int radialCounter = 1;
+    private int pathCounter = 1;
+    private int rectCounter = 1;
+    private int roundRectCounter = 1;
+    private int ellipseCounter = 1;
+
+    private int stateTypeCounter = 1;
+
+    //during the first pass, we will construct these maps
+    private Map<String, String> colors = new HashMap<String, String>();
+    /**
+     * Code=>method name.
+     */
+    private Map<String, String> methods = new HashMap<String, String>();
+
+    //these variables hold the generated code
+    /**
+     * The source code in this variable will be used to define the various state types
+     */
+    private StringBuilder stateTypeCode = new StringBuilder();
+    /**
+     * The source code in this variable will be used to define the switch statement for painting
+     */
+    private StringBuilder switchCode = new StringBuilder();
+    /**
+     * The source code in this variable will be used to define the methods for painting each state
+     */
+    private StringBuilder paintingCode = new StringBuilder();
+    /**
+     * The source code in this variable will be used to add getExtendedCacheKeys
+     * implementation if needed.
+     */
+    private StringBuilder getExtendedCacheKeysCode = new StringBuilder();
+    /**
+     * The source code in this variable will be used to define the methods for decoding gradients
+     * and shapes.
+     */
+    private StringBuilder gradientsCode = new StringBuilder();
+    private StringBuilder colorCode = new StringBuilder();
+    private StringBuilder shapesCode = new StringBuilder();
+    /**
+     * Map of component colors keyed by state constant name
+     */
+    private Map<String, List<ComponentColor>> componentColorsMap =
+            new LinkedHashMap<String, List<ComponentColor>>();
+    /**
+     * For the current state the list of all component colors used by this
+     * painter, the index in this list is also the index in the runtime array
+     * of defaults and keys.
+     */
+    private List<ComponentColor> componentColors = null;
+
+    PainterGenerator(UIRegion r) {
+        generate(r);
+    }
+
+    private void generate(UIRegion r) {
+        for (UIState state : r.getBackgroundStates()) {
+            Canvas canvas = state.getCanvas();
+            String type = (r instanceof UIIconRegion ? r.getKey() : "Background");
+            generate(state, canvas, type);
+        }
+        for (UIState state : r.getForegroundStates()) {
+            Canvas canvas = state.getCanvas();
+            generate(state, canvas, "Foreground");
+        }
+        for (UIState state : r.getBorderStates()) {
+            Canvas canvas = state.getCanvas();
+            generate(state, canvas, "Border");
+        }
+        //now check for any uiIconRegions, since these are collapsed together.
+        for (UIRegion sub : r.getSubRegions()) {
+            if (sub instanceof UIIconRegion) {
+                generate(sub);
+            }
+        }
+        //generate all the code for component colors
+        if (!componentColorsMap.isEmpty()) {
+            getExtendedCacheKeysCode
+                    .append("    protected Object[] getExtendedCacheKeys(JComponent c) {\n")
+                    .append("        Object[] extendedCacheKeys = null;\n")
+                    .append("        switch(state) {\n");
+            for (Map.Entry<String, List<ComponentColor>> entry : componentColorsMap.entrySet()) {
+                getExtendedCacheKeysCode
+                    .append("            case ")
+                    .append(entry.getKey()).append(":\n")
+                    .append("                extendedCacheKeys = new Object[] {\n");
+                for (int i=0; i<entry.getValue().size(); i++) {
+                    ComponentColor cc = entry.getValue().get(i);
+                    cc.write(getExtendedCacheKeysCode);
+                    if (i + 1 < entry.getValue().size()) {
+                        getExtendedCacheKeysCode.append("),\n");
+                    } else {
+                        getExtendedCacheKeysCode.append(")");
+                    }
+                }
+                getExtendedCacheKeysCode.append("};\n")
+                    .append("                break;\n");
+            }
+            getExtendedCacheKeysCode
+                    .append("        }\n")
+                    .append("        return extendedCacheKeys;\n")
+                    .append("    }");
+        }
+    }
+
+    //type is background, foreground, border, upArrowIcon, etc.
+    private void generate(UIState state, Canvas canvas, String type) {
+        String states = state.getStateKeys();
+        String stateType = Utils.statesToConstantName(type + "_" + states);
+        String paintMethodName = "paint" + type + Utils.statesToClassName(states);
+        //create new array for component colors for this state
+        componentColors = new ArrayList<ComponentColor>();
+
+        stateTypeCode.append("    static final int ").append(stateType).append(" = ").append(stateTypeCounter++).append(";\n");
+
+        if (canvas.isBlank()) {
+            return;
+        }
+
+        switchCode.append("            case ").append(stateType).append(": ").append(paintMethodName).append("(g); break;\n");
+        paintingCode.append("    private void ").append(paintMethodName).append("(Graphics2D g) {\n");
+
+        //start by setting up common info needed to encode the control points
+        Insets in = canvas.getStretchingInsets();
+        float a = in.left;
+        float b = canvas.getSize().width - in.right;
+        float c = in.top;
+        float d = canvas.getSize().height - in.bottom;
+        float width = canvas.getSize().width;
+        float height = canvas.getSize().height;
+        float cw = b - a;
+        float ch = d - c;
+
+        Layer[] layers = canvas.getLayers().toArray(new Layer[0]);
+        for (int index=layers.length-1; index >= 0; index--) {
+            Layer layer = layers[index];
+
+            //shapes must be painted in reverse order
+            List<Shape> shapes = layer.getShapes();
+            for (int i=shapes.size()-1; i>=0; i--) {
+                Shape shape = shapes.get(i);
+                Paint paint = shape.getPaint();
+
+                /*
+                    We attempt to write the minimal number of bytecodes as possible when
+                    generating code. Due to the inherit complexities in determining what
+                    is extraneous, we use the following system:
+
+                    We first generate the code for the shape. Then, we check to see if
+                    this shape has already been generated. If so, then we defer to an
+                    existing method. If not, then we will create a new methods, stick
+                    the code in it, and refer to that method.
+                */
+
+                String shapeMethodName = null; // will contain the name of the method which creates the shape
+                String shapeVariable = null; // will be one of rect, roundRect, ellipse, or path.
+                String shapeMethodBody = null;
+
+                if (shape instanceof Rectangle) {
+                    Rectangle rshape = (Rectangle) shape;
+                    float x1 = encode((float)rshape.getX1(), a, b, width);
+                    float y1 = encode((float)rshape.getY1(), c, d, height);
+                    float x2 = encode((float)rshape.getX2(), a, b, width);
+                    float y2 = encode((float)rshape.getY2(), c, d, height);
+                    if (rshape.isRounded()) {
+                        //it is a rounded rectangle
+                        float rounding = (float)rshape.getRounding();
+
+                        shapeMethodBody =
+                                "        roundRect.setRoundRect(" +
+                                writeDecodeX(x1) + ", //x\n" +
+                                "                               " + writeDecodeY(y1) + ", //y\n" +
+                                "                               " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
+                                "                               " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + ", //height\n" +
+                                "                               " + rounding + "f, " + rounding + "f); //rounding";
+                        shapeVariable = "roundRect";
+                    } else {
+                        shapeMethodBody =
+                                "            rect.setRect(" +
+                                writeDecodeX(x1) + ", //x\n" +
+                                "                         " + writeDecodeY(y1) + ", //y\n" +
+                                "                         " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
+                                "                         " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + "); //height";
+                        shapeVariable = "rect";
+                    }
+                } else if (shape instanceof Ellipse) {
+                    Ellipse eshape = (Ellipse) shape;
+                    float x1 = encode((float)eshape.getX1(), a, b, width);
+                    float y1 = encode((float)eshape.getY1(), c, d, height);
+                    float x2 = encode((float)eshape.getX2(), a, b, width);
+                    float y2 = encode((float)eshape.getY2(), c, d, height);
+                    shapeMethodBody =
+                            "        ellipse.setFrame(" +
+                            writeDecodeX(x1) + ", //x\n" +
+                            "                         " + writeDecodeY(y1) + ", //y\n" +
+                            "                         " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
+                            "                         " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + "); //height";
+                    shapeVariable = "ellipse";
+                } else if (shape instanceof Path) {
+                    Path pshape = (Path) shape;
+                    List<Point> controlPoints = pshape.getControlPoints();
+                    Point first, last;
+                    first = last = controlPoints.get(0);
+                    StringBuilder buffer = new StringBuilder();
+                    buffer.append("        path.reset();\n");
+                    buffer.append("        path.moveTo(" + writeDecodeX(encode((float)first.getX(), a, b, width)) + ", " + writeDecodeY(encode((float)first.getY(), c, d, height)) + ");\n");
+                    for (int j=1; j<controlPoints.size(); j++) {
+                        Point cp = controlPoints.get(j);
+                        if (last.isP2Sharp() && cp.isP1Sharp()) {
+                            float x = encode((float)cp.getX(), a, b, width);
+                            float y = encode((float)cp.getY(), c, d, height);
+                            buffer.append("        path.lineTo(" + writeDecodeX(x) + ", " + writeDecodeY(y) + ");\n");
+                        } else {
+                            float x1 = encode((float)last.getX(), a, b, width);
+                            float y1 = encode((float)last.getY(), c, d, height);
+                            float x2 = encode((float)cp.getX(), a, b, width);
+                            float y2 = encode((float)cp.getY(), c, d, height);
+                            buffer.append(
+                                    "        path.curveTo(" + writeDecodeBezierX(x1, last.getX(), last.getCp2X()) + ", "
+                                                            + writeDecodeBezierY(y1, last.getY(), last.getCp2Y()) + ", "
+                                                            + writeDecodeBezierX(x2, cp.getX(), cp.getCp1X()) + ", "
+                                                            + writeDecodeBezierY(y2, cp.getY(), cp.getCp1Y()) + ", "
+                                                            + writeDecodeX(x2) + ", " + writeDecodeY(y2) + ");\n");
+                        }
+                        last = cp;
+                    }
+                    if (last.isP2Sharp() && first.isP1Sharp()) {
+                        float x = encode((float)first.getX(), a, b, width);
+                        float y = encode((float)first.getY(), c, d, height);
+                        buffer.append("        path.lineTo(" + writeDecodeX(x) + ", " + writeDecodeY(y) + ");\n");
+                    } else {
+                        float x1 = encode((float)last.getX(), a, b, width);
+                        float y1 = encode((float)last.getY(), c, d, height);
+                        float x2 = encode((float)first.getX(), a, b, width);
+                        float y2 = encode((float)first.getY(), c, d, height);
+                        buffer.append(
+                                "        path.curveTo(" + writeDecodeBezierX(x1, last.getX(), last.getCp2X()) + ", "
+                                                        + writeDecodeBezierY(y1, last.getY(), last.getCp2Y()) + ", "
+                                                        + writeDecodeBezierX(x2, first.getX(), first.getCp1X()) + ", "
+                                                        + writeDecodeBezierY(y2, first.getY(), first.getCp1Y()) + ", "
+                                                        + writeDecodeX(x2) + ", " + writeDecodeY(y2) + ");\n");
+                    }
+                    buffer.append("        path.closePath();");
+                    shapeMethodBody = buffer.toString();
+                    shapeVariable = "path";
+                } else {
+                    throw new RuntimeException("Cannot happen unless a new Shape has been defined");
+                }
+
+                //now that we have the shape defined in shapeMethodBody, and a shapeVariable name,
+                //look to see if such a body has been previously defined.
+                shapeMethodName = methods.get(shapeMethodBody);
+                String returnType = null;
+                if (shapeMethodName == null) {
+                    if ("rect".equals(shapeVariable)) {
+                        shapeMethodName = "decodeRect" + rectCounter++;
+                        returnType = "Rectangle2D";
+                    } else if ("roundRect".equals(shapeVariable)) {
+                        shapeMethodName = "decodeRoundRect" + roundRectCounter++;
+                        returnType = "RoundRectangle2D";
+                    } else if ("ellipse".equals(shapeVariable)) {
+                        shapeMethodName = "decodeEllipse" + ellipseCounter++;
+                        returnType = "Ellipse2D";
+                    } else {
+                        shapeMethodName = "decodePath" + pathCounter++;
+                        returnType = "Path2D";
+                    }
+                    methods.put(shapeMethodBody, shapeMethodName);
+
+                    //since the method wasn't previously defined, time to define it
+                    shapesCode.append("    private ").append(returnType).append(" ").append(shapeMethodName).append("() {\n");
+                    shapesCode.append(shapeMethodBody);
+                    shapesCode.append("\n");
+                    shapesCode.append("        return " + shapeVariable + ";\n");
+                    shapesCode.append("    }\n\n");
+                }
+
+                //now that the method has been defined, I can go on and decode the
+                //paint. After the paint is decoded, I can write the g.fill() method call,
+                //using the result of the shapeMethodName. Yay!
+
+//            if (shapeVariable != null) {
+            //first, calculate the bounds of the shape being painted and store in variables
+                paintingCode.append("        ").append(shapeVariable).append(" = ").append(shapeMethodName).append("();\n");
+
+                if (paint instanceof Matte) {
+                    String colorVariable = encodeMatte((Matte)paint);
+                    paintingCode.append("        g.setPaint(").append(colorVariable).append(");\n");
+                } else if (paint instanceof Gradient) {
+                    String gradientMethodName = encodeGradient(shape, (Gradient)paint);
+                    paintingCode.append("        g.setPaint(").append(gradientMethodName).append("(").append(shapeVariable).append("));\n");
+                } else if (paint instanceof RadialGradient) {
+                    String radialMethodName = encodeRadial(shape, (RadialGradient)paint);
+                    paintingCode.append("        g.setPaint(").append(radialMethodName).append("(").append(shapeVariable).append("));\n");
+                }
+                paintingCode.append("        g.fill(").append(shapeVariable).append(");\n");
+            }
+        }
+
+        paintingCode.append("\n    }\n\n");
+
+        //collect component colors
+        if (!componentColors.isEmpty()) {
+            componentColorsMap.put(stateType, componentColors);
+            componentColors = null;
+        }
+    }
+
+    private float encode(float x, float a, float b, float w) {
+        float r = 0;
+        if (x < a) {
+            r = (x / a);
+        } else if (x > b) {
+            r = 2 + ((x - b) / (w - b));
+        } else if (x == a && x == b) {
+            return 1.5f;
+        } else {
+            r = 1 + ((x - a) / (b - a));
+        }
+
+        if (Float.isNaN(r)) {
+            System.err.println("[Error] Encountered NaN: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
+            return 0;
+        } else if (Float.isInfinite(r)) {
+            System.err.println("[Error] Encountered Infinity: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
+            return 0;
+        } else if (r < 0) {
+            System.err.println("[Error] encoded value was less than 0: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
+            return 0;
+        } else if (r > 3) {
+            System.err.println("[Error] encoded value was greater than 3: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
+            return 3;
+        } else {
+            return r;
+        }
+    }
+
+    private String writeDecodeX(float encodedX) {
+        return "decodeX(" + encodedX + "f)";
+    }
+
+    private String writeDecodeY(float encodedY) {
+        return "decodeY(" + encodedY + "f)";
+    }
+
+    /**
+     *
+     * @param ex encoded x value
+     * @param x unencoded x value
+     * @param cpx unencoded cpx value
+     * @return
+     */
+    private static String writeDecodeBezierX(double ex, double x, double cpx) {
+        return "decodeAnchorX(" + ex + "f, " + (cpx - x) + "f)";
+    }
+
+    /**
+     *
+     * @param ey encoded y value
+     * @param y unencoded y value
+     * @param cpy unencoded cpy value
+     * @return
+     */
+    private static String writeDecodeBezierY(double ey, double y, double cpy) {
+        return "decodeAnchorY(" + ey + "f, " + (cpy - y) + "f)";
+    }
+
+    private String encodeMatte(Matte m) {
+        String declaration = m.getDeclaration();
+        String variableName = colors.get(declaration);
+        if (variableName == null) {
+            variableName = "color" + colorCounter++;
+            colors.put(declaration, variableName);
+            colorCode.append(String.format("    private Color %s = %s;\n",
+                                           variableName, declaration));
+        }
+        // handle component colors
+        if (m.getComponentPropertyName() != null) {
+            ComponentColor cc = m.createComponentColor(variableName);
+            int index = componentColors.indexOf(cc);
+            if (index == -1) {
+                index = componentColors.size();
+                componentColors.add(cc);
+            }
+            return "(Color)componentColors[" + index + "]";
+        } else {
+            return variableName;
+        }
+    }
+
+    private String encodeGradient(Shape ps, Gradient g) {
+        StringBuilder b = new StringBuilder();
+        float x1 = (float)ps.getPaintX1();
+        float y1 = (float)ps.getPaintY1();
+        float x2 = (float)ps.getPaintX2();
+        float y2 = (float)ps.getPaintY2();
+        b.append("        return decodeGradient((");
+        b.append(x1);
+        b.append("f * w) + x, (");
+        b.append(y1);
+        b.append("f * h) + y, (");
+        b.append(x2);
+        b.append("f * w) + x, (");
+        b.append(y2);
+        b.append("f * h) + y,\n");
+        encodeGradientColorsAndFractions(g,b);
+        b.append(");");
+
+        String methodBody = b.toString();
+        String methodName = methods.get(methodBody);
+        if (methodName == null) {
+            methodName = "decodeGradient" + gradientCounter++;
+            gradientsCode.append("    private Paint ").append(methodName).append("(Shape s) {\n");
+            gradientsCode.append("        Rectangle2D bounds = s.getBounds2D();\n");
+            gradientsCode.append("        float x = (float)bounds.getX();\n");
+            gradientsCode.append("        float y = (float)bounds.getY();\n");
+            gradientsCode.append("        float w = (float)bounds.getWidth();\n");
+            gradientsCode.append("        float h = (float)bounds.getHeight();\n");
+            gradientsCode.append(methodBody);
+            gradientsCode.append("\n    }\n\n");
+            methods.put(methodBody, methodName);
+        }
+        return methodName;
+    }
+
+    /**
+     * Takes a abstract gradient and creates the code for the fractions float
+     * array and the colors array that can be used in the constructors of linear
+     * and radial gradients.
+     *
+     * @param g The abstract gradient to get stops from
+     * @param b Append code string of the form "new float[]{...},
+     *          new Color[]{...}" to this StringBuilder
+     */
+    private void encodeGradientColorsAndFractions(AbstractGradient g,
+                                                    StringBuilder b) {
+        List<GradientStop> stops = g.getStops();
+        // there are stops.size() number of main stops. Between each is a
+        // fractional stop. Thus, there are: stops.size() + stops.size() - 1
+        // number of fractions and colors.
+        float[] fractions = new float[stops.size() + stops.size() - 1];
+        String[] colors = new String[fractions.length];
+        //for each stop, create the stop and it's associated fraction
+        int index = 0; // the index into fractions and colors
+        for (int i = 0; i < stops.size(); i++) {
+            GradientStop s = stops.get(i);
+            //copy over the stop's data
+            colors[index] = encodeMatte(s.getColor());
+            fractions[index] = s.getPosition();
+
+            //If this isn't the last stop, then add in the fraction
+            if (index < fractions.length - 1) {
+                float f1 = s.getPosition();
+                float f2 = stops.get(i + 1).getPosition();
+                index++;
+                fractions[index] = f1 + (f2 - f1) * s.getMidpoint();
+                colors[index] = "decodeColor("+
+                        colors[index - 1]+","+
+                        encodeMatte(stops.get(i + 1).getColor())+",0.5f)";
+            }
+            index++;
+        }
+        // Check boundry conditions
+        for (int i = 1; i < fractions.length; i++) {
+            //to avoid an error with LinearGradientPaint where two fractions
+            //are identical, bump up the fraction value by a miniscule amount
+            //if it is identical to the previous one
+            //NOTE: The <= is critical because the previous value may already
+            //have been bumped up
+            if (fractions[i] <= fractions[i - 1]) {
+                fractions[i] = fractions[i - 1] + .000001f;
+            }
+        }
+        //another boundary condition where multiple stops are all at the end. The
+        //previous loop bumped all but one of these past 1.0, which is bad.
+        //so remove any fractions (and their colors!) that are beyond 1.0
+        int outOfBoundsIndex = -1;
+        for (int i = 0; i < fractions.length; i++) {
+            if (fractions[i] > 1) {
+                outOfBoundsIndex = i;
+                break;
+            }
+        }
+        if (outOfBoundsIndex >= 0) {
+            float[] f = fractions;
+            String[] c = colors;
+            fractions = new float[outOfBoundsIndex];
+            colors = new String[outOfBoundsIndex];
+            System.arraycopy(f, 0, fractions, 0, outOfBoundsIndex);
+            System.arraycopy(c, 0, colors, 0, outOfBoundsIndex);
+        }
+        // build string
+        b.append("                new float[] { ");
+        for (int i = 0; i < fractions.length; i++) {
+            if (i>0)b.append(',');
+            b.append(fractions[i]);
+            b.append('f');
+        }
+        b.append(" },\n                new Color[] { ");
+        for (int i = 0; i < colors.length; i++) {
+            if (i>0) b.append(",\n                            ");
+            b.append(colors[i]);
+        }
+        b.append("}");
+    }
+
+    private String encodeRadial(Shape ps, RadialGradient g) {
+        float centerX1 = (float)ps.getPaintX1();
+        float centerY1 = (float)ps.getPaintY1();
+        float x2 = (float)ps.getPaintX2();
+        float y2 = (float)ps.getPaintY2();
+        float radius = (float)Point2D.distance(centerX1, centerY1, x2, y2);
+        StringBuilder b = new StringBuilder();
+
+        b.append("        return decodeRadialGradient((");
+        b.append(centerX1);
+        b.append("f * w) + x, (");
+        b.append(centerY1);
+        b.append("f * h) + y, ");
+        b.append(radius);
+        b.append("f,\n");
+        encodeGradientColorsAndFractions(g,b);
+        b.append(");");
+
+        String methodBody = b.toString();
+        String methodName = methods.get(methodBody);
+        if (methodName == null) {
+            methodName = "decodeRadial" + radialCounter++;
+            gradientsCode.append("    private Paint ").append(methodName).append("(Shape s) {\n");
+            gradientsCode.append("        Rectangle2D bounds = s.getBounds2D();\n");
+            gradientsCode.append("        float x = (float)bounds.getX();\n");
+            gradientsCode.append("        float y = (float)bounds.getY();\n");
+            gradientsCode.append("        float w = (float)bounds.getWidth();\n");
+            gradientsCode.append("        float h = (float)bounds.getHeight();\n");
+            gradientsCode.append(methodBody);
+            gradientsCode.append("\n    }\n\n");
+            methods.put(methodBody, methodName);
+        }
+        return methodName;
+    }
+
+    //note that this method is not thread-safe. In fact, none of this class is.
+    public static void writePainter(UIRegion r, String painterName) {
+        //Need only write out the stuff for this region, don't need to worry about subregions
+        //since this method will be called for each of those (and they go in their own file, anyway).
+        //The only subregion that we compound into this is the one for icons.
+        PainterGenerator gen = new PainterGenerator(r);
+        System.out.println("Generating source file: " + painterName + ".java");
+
+        Map<String, String> variables = Generator.getVariables();
+        variables.put("PAINTER_NAME", painterName);
+        variables.put("STATIC_DECL", gen.stateTypeCode.toString());
+        variables.put("COLORS_DECL", gen.colorCode.toString());
+        variables.put("DO_PAINT_SWITCH_BODY", gen.switchCode.toString());
+        variables.put("PAINTING_DECL", gen.paintingCode.toString());
+        variables.put("GET_EXTENDED_CACHE_KEYS", gen.getExtendedCacheKeysCode.toString());
+        variables.put("SHAPES_DECL", gen.shapesCode.toString());
+        variables.put("GRADIENTS_DECL", gen.gradientsCode.toString());
+
+        Generator.writeSrcFile("PainterImpl", variables, painterName);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/Shape.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import java.util.ArrayList;
+import java.util.List;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+import javax.xml.bind.annotation.XmlElements;
+
+
+public abstract class Shape {
+    @XmlElement
+    private PaintPoints paintPoints;
+    public double getPaintX1() { return paintPoints.x1; }
+    public double getPaintX2() { return paintPoints.x2; }
+    public double getPaintY1() { return paintPoints.y1; }
+    public double getPaintY2() { return paintPoints.y2; }
+
+    @XmlElements({
+        @XmlElement(name = "matte", type = Matte.class),
+        @XmlElement(name = "gradient", type = Gradient.class),
+        @XmlElement(name = "radialGradient", type = RadialGradient.class)
+    })
+    private Paint paint;
+    public Paint getPaint() { return paint; }
+
+    static class PaintPoints {
+        @XmlAttribute double x1;
+        @XmlAttribute double y1;
+        @XmlAttribute double x2;
+        @XmlAttribute double y2;
+    }
+}
+
+class Point {
+    @XmlAttribute private double x;
+    public double getX() { return x; }
+
+    @XmlAttribute private double y;
+    public double getY() { return y; }
+
+    @XmlAttribute(name="cp1x") private double cp1x;
+    public double getCp1X() { return cp1x; }
+
+    @XmlAttribute(name="cp1y") private double cp1y;
+    public double getCp1Y() { return cp1y; }
+
+    @XmlAttribute(name="cp2x") private double cp2x;
+    public double getCp2X() { return cp2x; }
+
+    @XmlAttribute(name="cp2y") private double cp2y;
+    public double getCp2Y() { return cp2y; }
+
+    public boolean isP1Sharp() {
+        return cp1x == x && cp1y == y;
+    }
+
+    public boolean isP2Sharp() {
+        return cp2x == x && cp2y == y;
+    }
+}
+
+class Path extends Shape {
+    @XmlElement(name="point")
+    @XmlElementWrapper(name="points")
+    private List<Point> controlPoints = new ArrayList<Point>();
+    public List<Point> getControlPoints() { return controlPoints; }
+}
+
+class Rectangle extends Shape {
+    @XmlAttribute private double x1;
+    public double getX1() { return x1; }
+
+    @XmlAttribute private double x2;
+    public double getX2() { return x2; }
+
+    @XmlAttribute private double y1;
+    public double getY1() { return y1; }
+
+    @XmlAttribute private double y2;
+    public double getY2() { return y2; }
+
+    @XmlAttribute
+    public double getRounding() {
+        double rounding = Math.abs(roundingX - x1) * 2;
+        return rounding > 2 ? rounding : 0;
+    }
+
+    public void setRounding(double rounding) {
+        if (rounding > 0 && rounding < 2) {
+            rounding = 0;
+        }
+        roundingX = rounding / 2d + x1;
+    }
+    private double roundingX;
+
+    public boolean isRounded() {
+        return getRounding() > 0;
+    }
+
+}
+
+class Ellipse extends Shape {
+    @XmlAttribute private double x1;
+    public double getX1() { return x1; }
+
+    @XmlAttribute private double x2;
+    public double getX2() { return x2; }
+
+    @XmlAttribute private double y1;
+    public double getY1() { return y1; }
+
+    @XmlAttribute private double y2;
+    public double getY2() { return y2; }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/SynthModel.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import java.awt.Font;
+import java.util.ArrayList;
+import java.util.List;
+import javax.xml.bind.annotation.*;
+
+
+@XmlRootElement(name="synthModel")
+public class SynthModel {
+    @XmlElement private UIStyle style;
+
+    @XmlElement(name="uiColor")
+    @XmlElementWrapper(name="colors")
+    private ArrayList<UIColor> colors;
+
+    @XmlElement(name="uiFont")
+    @XmlElementWrapper(name="fonts")
+    private ArrayList<UIFont> fonts;
+
+    @XmlElement(name="uiComponent")
+    @XmlElementWrapper(name="components")
+    private ArrayList<UIComponent> components;
+
+    public void initStyles() {
+        for (UIComponent c: components) {
+            c.initStyles(this.style);
+        }
+    }
+
+    public void write(StringBuilder defBuffer, StringBuilder styleBuffer, String packageName) {
+        defBuffer.append("        //Color palette\n");
+        for (UIColor c: colors) defBuffer.append(c.write());
+        defBuffer.append('\n');
+
+        defBuffer.append("        //Font palette\n");
+        defBuffer.append("        d.put(\"defaultFont\", new FontUIResource(defaultFont));\n");
+        for (UIFont f: fonts) defBuffer.append(f.write());
+        defBuffer.append('\n');
+
+        defBuffer.append("        //Border palette\n");
+        defBuffer.append('\n');
+
+        defBuffer.append("        //The global style definition\n");
+        defBuffer.append(style.write(""));
+        defBuffer.append('\n');
+
+        for (UIComponent c: components) {
+            String prefix = Utils.escape(c.getKey());
+            defBuffer.append("        //Initialize ").append(prefix).append("\n");
+            c.write(defBuffer, styleBuffer, c, prefix, packageName);
+            defBuffer.append('\n');
+        }
+    }
+}
+
+class Typeface {
+    public enum DeriveStyle {
+        Default, Off, On;
+
+        @Override public String toString() {
+            switch (this) {
+                default:  return "null";
+                case On:  return "true";
+                case Off: return "false";
+            }
+        }
+    }
+
+    @XmlAttribute private String uiDefaultParentName;
+    @XmlAttribute(name="family") private String name;
+    @XmlAttribute private int size;
+    @XmlAttribute private DeriveStyle bold = DeriveStyle.Default;
+    @XmlAttribute private DeriveStyle italic = DeriveStyle.Default;
+    @XmlAttribute private float sizeOffset = 1f;
+
+    public boolean isAbsolute() {
+        return uiDefaultParentName == null;
+    }
+
+    public String write() {
+        if (isAbsolute()) {
+            int style = Font.PLAIN;
+            if (bold == DeriveStyle.On) {
+                style = style | Font.BOLD;
+            }
+            if (italic == DeriveStyle.On) {
+                style = style | Font.ITALIC;
+            }
+
+            return String.format(
+                    "new javax.swing.plaf.FontUIResource(\"%s\", %d, %d)",
+                    name, style, size);
+        } else {
+            return String.format(
+                    "new DerivedFont(\"%s\", %sf, %s, %s)",
+                    uiDefaultParentName, String.valueOf(sizeOffset), bold, italic);
+        }
+    }
+}
+
+class Border {
+    enum BorderType {
+        @XmlEnumValue("empty") EMPTY,
+        @XmlEnumValue("painter") PAINTER
+    }
+    @XmlAttribute private BorderType type;
+    @XmlAttribute private String painter;
+    @XmlAttribute private int top;
+    @XmlAttribute private int left;
+    @XmlAttribute private int bottom;
+    @XmlAttribute private int right;
+
+    public String write() {
+        switch (type) {
+            case PAINTER:
+                return String.format("new PainterBorder(\"%s\", new Insets(%d, %d, %d, %d))",
+                                     painter, top, left, bottom, right);
+            case EMPTY:
+                return String.format("BorderFactory.createEmptyBorder(%d, %d, %d, %d)",
+                                     top, left, bottom, right);
+            default:
+                return "### Look, here's an unknown border! $$$";
+        }
+    }
+}
+
+class Insets {
+    @XmlAttribute int top;
+    @XmlAttribute int left;
+    @XmlAttribute int bottom;
+    @XmlAttribute int right;
+
+    public Insets() {
+        this(0, 0, 0, 0);
+    }
+
+    public Insets(int top, int left, int bottom, int right) {
+        this.top = top;
+        this.left = left;
+        this.bottom = bottom;
+        this.right = right;
+    }
+
+    public String write(boolean uiResource) {
+        String uiSuffix = (uiResource ? "UIResource" : "");
+        return String.format("new Insets%s(%d, %d, %d, %d)",
+                             uiSuffix, top, left, bottom, right);
+    }
+}
+
+class Dimension {
+    @XmlAttribute int width;
+    @XmlAttribute int height;
+
+    public String write(boolean uiResource) {
+        String uiSuffix = (uiResource ? "UIResource" : "");
+        return String.format("new Dimension%s(%d, %d)", uiSuffix, width, height);
+    }
+}
+
+class Canvas {
+    @XmlElement private Dimension size;
+    public Dimension getSize() { return size; }
+
+    @XmlElement(name="layer") private List<Layer> layers;
+    public List<Layer> getLayers() { return layers; }
+
+    @XmlElement private Insets stretchingInsets = null;
+    public Insets getStretchingInsets() { return stretchingInsets; }
+
+    public boolean isBlank() {
+        return layers.size() == 0 || (layers.size() == 1 && layers.get(0).isEmpty());
+    }
+}
+
+class Layer {
+    /** List of shapes in this layer, first shape is painted on top */
+    @XmlElements({
+        @XmlElement(name = "ellipse", type = Ellipse.class),
+        @XmlElement(name = "path", type = Path.class),
+        @XmlElement(name = "rectangle", type = Rectangle.class)
+    })
+    @XmlElementWrapper(name="shapes")
+    private List<Shape> shapes = new ArrayList<Shape>();
+    public List<Shape> getShapes() { return shapes; }
+
+    public boolean isEmpty() {
+        return shapes.isEmpty();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/UIDefault.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+
+public class UIDefault<T> {
+    @XmlAttribute private String name;
+    private T value;
+
+    public String getName() {
+        return name;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    public void setValue(T value) {
+        this.value = value;
+    }
+}
+
+class UIColor extends UIDefault<Matte> {
+
+    @XmlElement
+    public void setMatte(Matte m) {
+        setValue(m);
+    }
+
+    public String write() {
+        return String.format("        addColor(d, \"%s\", %s);\n",
+                             getName(), getValue().write());
+    }
+}
+
+class UIFont extends UIDefault<Typeface> {
+    @XmlElement
+    public void setTypeface(Typeface t) {
+        setValue(t);
+    }
+
+    public String write() {
+        return String.format("        d.put(\"%s\", %s);\n",
+                             getName(), getValue().write());
+    }
+}
+
+class UIProperty extends UIDefault<String> {
+    public static enum PropertyType {
+        BOOLEAN, INT, FLOAT, DOUBLE, STRING, FONT, COLOR, INSETS, DIMENSION, BORDER
+    }
+    @XmlAttribute private PropertyType type;
+
+    @XmlElement private Border border;
+    @XmlElement private Dimension dimension;
+    @XmlElement private Insets insets;
+    @XmlElement private Matte matte;
+    @XmlElement private Typeface typeface;
+
+    @XmlAttribute
+    @Override public void setValue(String value) {
+        super.setValue(value);
+    }
+
+    public String write(String prefix) {
+        switch (type) {
+            case BOOLEAN:
+                return String.format("        d.put(\"%s%s\", Boolean.%s);\n",
+                                     prefix, getName(), getValue().toUpperCase());  ///autobox
+            case STRING:
+                return String.format("        d.put(\"%s%s\", \"%s\");\n",
+                                     prefix, getName(), getValue());
+            case INT:
+                return String.format("        d.put(\"%s%s\", new Integer(%s));\n",
+                                     prefix, getName(), getValue());
+            case FLOAT:
+                return String.format("        d.put(\"%s%s\", new Float(%sf));\n",
+                                     prefix, getName(), getValue());
+            case DOUBLE:
+                return String.format("        d.put(\"%s%s\", new Double(%s));\n",
+                                     prefix, getName(), getValue());
+            case COLOR:
+                return String.format("        addColor(d, \"%s%s\", %s);\n",
+                                     prefix, getName(), matte.write());
+            case FONT:
+                return String.format("        d.put(\"%s%s\", %s);\n",
+                                     prefix, getName(), typeface.write());
+            case INSETS:
+                return String.format("        d.put(\"%s%s\", %s);\n",
+                                     prefix, getName(), insets.write(true));
+            case DIMENSION:
+                return String.format("        d.put(\"%s%s\", new DimensionUIResource(%d, %d));\n",
+                                     prefix, getName(), dimension.width, dimension.height);
+            case BORDER:
+                return String.format("        d.put(\"%s%s\", new BorderUIResource(%s));\n",
+                                     prefix, getName(), border.write());
+            default:
+                return "###  Look, something's wrong with UIProperty.write()  $$$";
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/UIStyle.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,399 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlElementWrapper;
+import javax.xml.bind.annotation.XmlElements;
+
+
+class UIStyle {
+    public static enum CacheMode {
+        NO_CACHING, FIXED_SIZES, NINE_SQUARE_SCALE
+    }
+
+    @XmlElement private UIColor textForeground = null;
+    @XmlElement(name="inherit-textForeground")
+    private boolean textForegroundInherited = true;
+
+    @XmlElement private UIColor textBackground = null;
+    @XmlElement(name="inherit-textBackground")
+    private boolean textBackgroundInherited = true;
+
+    @XmlElement private UIColor background = null;
+    @XmlElement(name="inherit-background")
+    private boolean backgroundInherited = true;
+
+    @XmlElement private boolean cacheSettingsInherited = true;
+    @XmlElement CacheMode cacheMode = CacheMode.FIXED_SIZES;
+    @XmlElement String maxHozCachedImgScaling = "1.0";
+    @XmlElement String maxVertCachedImgScaling = "1.0";
+
+    @XmlElement(name="uiProperty")
+    @XmlElementWrapper(name="uiproperties")
+    private List<UIProperty> uiProperties = new ArrayList<UIProperty>();
+
+    private UIStyle parentStyle = null;
+    public void setParentStyle(UIStyle parentStyle) {
+        this.parentStyle = parentStyle;
+    }
+
+    public CacheMode getCacheMode() {
+        if (cacheSettingsInherited) {
+            return (parentStyle == null ?
+                CacheMode.FIXED_SIZES : parentStyle.getCacheMode());
+        } else {
+            return cacheMode;
+        }
+    }
+
+    public String getMaxHozCachedImgScaling() {
+        if (cacheSettingsInherited) {
+            return (parentStyle == null ?
+                "1.0" : parentStyle.getMaxHozCachedImgScaling());
+        } else {
+            return maxHozCachedImgScaling;
+        }
+    }
+
+    public String getMaxVertCachedImgScaling() {
+        if (cacheSettingsInherited) {
+            return (parentStyle == null ?
+                "1.0" : parentStyle.getMaxVertCachedImgScaling());
+        } else {
+            return maxVertCachedImgScaling;
+        }
+    }
+
+    public String write(String prefix) {
+        StringBuilder sb = new StringBuilder();
+        if (! textForegroundInherited) {
+            sb.append(String.format("        addColor(d, \"%s%s\", %s);\n",
+                    prefix, "textForeground", textForeground.getValue().write()));
+        }
+        if (! textBackgroundInherited) {
+            sb.append(String.format("        addColor(d, \"%s%s\", %s);\n",
+                    prefix, "textBackground", textBackground.getValue().write()));
+        }
+        if (! backgroundInherited) {
+            sb.append(String.format("        addColor(d, \"%s%s\", %s);\n",
+                    prefix, "background", background.getValue().write()));
+        }
+        for (UIProperty property : uiProperties) {
+            sb.append(property.write(prefix));
+        }
+        return sb.toString();
+    }
+}
+
+class UIRegion {
+    @XmlAttribute protected String name;
+    @XmlAttribute protected String key;
+    @XmlAttribute private boolean opaque = false;
+
+    @XmlElement private Insets contentMargins = new Insets(0, 0, 0, 0);
+
+    @XmlElement(name="state")
+    @XmlElementWrapper(name="backgroundStates")
+    protected List<UIState> backgroundStates = new ArrayList<UIState>();
+    public List<UIState> getBackgroundStates() { return backgroundStates; }
+
+    @XmlElement(name="state")
+    @XmlElementWrapper(name="foregroundStates")
+    protected List<UIState> foregroundStates = new ArrayList<UIState>();
+    public List<UIState> getForegroundStates() { return foregroundStates; }
+
+    @XmlElement(name="state")
+    @XmlElementWrapper(name="borderStates")
+    protected List<UIState> borderStates = new ArrayList<UIState>();
+    public List<UIState> getBorderStates() { return borderStates; }
+
+    @XmlElement private UIStyle style = new UIStyle();
+
+    @XmlElements({
+        @XmlElement(name = "region", type = UIRegion.class),
+        @XmlElement(name = "uiComponent", type = UIComponent.class),
+        @XmlElement(name = "uiIconRegion", type = UIIconRegion.class)
+    })
+    @XmlElementWrapper(name="regions")
+    private List<UIRegion> subRegions = new ArrayList<UIRegion>();
+    public List<UIRegion> getSubRegions() { return subRegions; }
+
+    protected void initStyles(UIStyle parentStyle) {
+        style.setParentStyle(parentStyle);
+        for (UIState state: backgroundStates) {
+            state.getStyle().setParentStyle(this.style);
+        }
+        for (UIState state: foregroundStates) {
+            state.getStyle().setParentStyle(this.style);
+        }
+        for (UIState state: borderStates) {
+            state.getStyle().setParentStyle(this.style);
+        }
+        for (UIRegion region: subRegions) {
+            region.initStyles(this.style);
+        }
+    }
+
+    public String getKey() {
+        return key == null || "".equals(key) ? name : key;
+    }
+
+    private boolean hasCanvas() {
+        for (UIState s : backgroundStates) {
+            if (s.hasCanvas()) return true;
+        }
+        for (UIState s : borderStates) {
+            if (s.hasCanvas()) return true;
+        }
+        for (UIState s : foregroundStates) {
+            if (s.hasCanvas()) return true;
+        }
+        for (UIRegion r: subRegions) {
+            if (r.hasCanvas()) return true;
+        }
+        return false;
+    }
+
+    public void write(StringBuilder sb, StringBuilder styleBuffer,
+                      UIComponent comp, String prefix, String pkg) {
+        // write content margins
+        sb.append(String.format("        d.put(\"%s.contentMargins\", %s);\n",
+                                prefix, contentMargins.write(true)));
+        // write opaque if true
+        if (opaque) {
+            sb.append(String.format("        d.put(\"%s.opaque\", Boolean.TRUE);\n", prefix));
+        }
+
+        // register component with LAF
+        String regionCode = "Region." + Utils.regionNameToCaps(name);
+        styleBuffer.append(String.format("        register(%s, \"%s\");\n",
+                                         regionCode, prefix));
+
+        //write the State, if necessary
+        StringBuffer regString = new StringBuffer();
+        List<UIStateType> types = comp.getStateTypes();
+        if (types != null && types.size() > 0) {
+            for (UIStateType type : types) {
+                regString.append(type.getKey());
+                regString.append(",");
+            }
+            //remove the last ","
+            regString.deleteCharAt(regString.length() - 1);
+        }
+
+        if (! regString.equals("Enabled,MouseOver,Pressed,Disabled,Focused,Selected,Default") && types.size() > 0) {
+            //there were either custom states, or the normal states were in a custom order
+            //so go ahead and write out prefix.State
+            sb.append(String.format("        d.put(\"%s.States\", \"%s\");\n",
+                                    prefix, regString));
+        }
+
+        // write out any custom states, if necessary
+        for (UIStateType type : types) {
+            String synthState = type.getKey();
+            if (! "Enabled".equals(synthState) &&
+                ! "MouseOver".equals(synthState) &&
+                ! "Pressed".equals(synthState) &&
+                ! "Disabled".equals(synthState) &&
+                ! "Focused".equals(synthState) &&
+                ! "Selected".equals(synthState) &&
+                ! "Default".equals(synthState)) {
+
+                //what we have here, gentlemen, is a bona-fide custom state.
+                //if the type is not one of the standard types, then construct a name for
+                //the new type, and write out a new subclass of State.
+                String className = Utils.normalize(prefix) + synthState + "State";
+                sb.append(String.format("        d.put(\"%s.%s\", new %s());\n",
+                                        prefix, synthState, className));
+
+                String body = type.getCodeSnippet();
+                Map<String, String> variables = Generator.getVariables();
+                variables.put("STATE_NAME", className);
+                variables.put("STATE_KEY", synthState);
+                variables.put("BODY", body);
+
+                Generator.writeSrcFile("StateImpl", variables, className);
+            }
+        }
+
+        // write style
+        sb.append(style.write(prefix + '.'));
+
+        String fileName = Utils.normalize(prefix) + "Painter";
+        boolean hasCanvas = hasCanvas();
+        if (hasCanvas) {
+            PainterGenerator.writePainter(this, fileName);
+        }
+        // write states ui defaults
+        for (UIState state : backgroundStates) {
+            state.write(sb, prefix, pkg, fileName, "background");
+        }
+        for (UIState state : foregroundStates) {
+            state.write(sb, prefix, pkg, fileName, "foreground");
+        }
+        for (UIState state : borderStates) {
+            state.write(sb, prefix, pkg, fileName, "border");
+        }
+
+        // handle sub regions
+        for (UIRegion subreg : subRegions) {
+            String p = prefix;
+            if (! (subreg instanceof UIIconRegion)) {
+                p = prefix + ":" + Utils.escape(subreg.getKey());
+            }
+            UIComponent c = comp;
+            if (subreg instanceof UIComponent) {
+                c = (UIComponent) subreg;
+            }
+            subreg.write(sb, styleBuffer, c, p, pkg);
+        }
+    }
+}
+
+class UIIconRegion extends UIRegion {
+    @XmlAttribute private String basicKey;
+
+    @Override public void write(StringBuilder sb, StringBuilder styleBuffer, UIComponent comp, String prefix, String pkg) {
+        Dimension size = null;
+        String fileNamePrefix = Utils.normalize(prefix) + "Painter";
+        // write states ui defaults
+        for (UIState state : backgroundStates) {
+            Canvas canvas = state.getCanvas();
+            if (!canvas.isBlank()) {
+                state.write(sb, prefix, pkg, fileNamePrefix, getKey());
+                size = canvas.getSize();
+            }
+        }
+
+        if (size != null) {
+            // Put SynthIconImpl wrapper in UiDefaults
+            String k = (basicKey == null ? prefix + "." + getKey() : basicKey);
+            sb.append(String.format(
+                    "        d.put(\"%s\", new NimbusIcon(\"%s\", \"%sPainter\", %d, %d));\n",
+                    k, prefix, getKey(), size.width, size.height));
+        }
+    }
+}
+
+class UIComponent extends UIRegion {
+    @XmlAttribute private String componentName;
+
+    @XmlElement(name="stateType")
+    @XmlElementWrapper(name="stateTypes")
+    private List<UIStateType> stateTypes = new ArrayList<UIStateType>();
+    public List<UIStateType> getStateTypes() { return stateTypes; }
+
+    @Override public String getKey() {
+        if (key == null || "".equals(key)) {
+            if (componentName == null || "".equals(componentName)) {
+                return name;
+            } else {
+                return "\"" + componentName + "\"";
+            }
+        } else {
+            return key;
+        }
+    }
+}
+
+class UIState {
+    @XmlAttribute private String stateKeys;
+    public String getStateKeys() { return stateKeys; }
+
+    /** Indicates whether to invert the meaning of the 9-square stretching insets */
+    @XmlAttribute private boolean inverted;
+
+    /** A cached string representing the list of stateKeys deliminated with "+" */
+    private String cachedName = null;
+
+    @XmlElement private Canvas canvas;
+    public Canvas getCanvas() { return canvas; }
+
+    @XmlElement private UIStyle style;
+    public UIStyle getStyle() { return style; }
+
+    public boolean hasCanvas() {
+        return ! canvas.isBlank();
+    }
+
+    public static List<String> stringToKeys(String keysString) {
+        return Arrays.asList(keysString.split("\\+"));
+    }
+
+    public String getName() {
+        if (cachedName == null) {
+            StringBuilder buf = new StringBuilder();
+            List<String> keys = stringToKeys(stateKeys);
+            Collections.sort(keys);
+            for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
+                buf.append(iter.next());
+                if (iter.hasNext()) {
+                    buf.append('+');
+                }
+            }
+            cachedName = buf.toString();
+        }
+        return cachedName;
+    }
+
+    public void write(StringBuilder sb, String prefix, String pkg, String fileNamePrefix, String painterPrefix) {
+        String statePrefix = prefix + "[" + getName() + "]";
+        // write state style
+        sb.append(style.write(statePrefix + '.'));
+        // write painter
+        if (hasCanvas()) {
+            writeLazyPainter(sb, statePrefix, pkg, fileNamePrefix, painterPrefix);
+        }
+    }
+
+    private void writeLazyPainter(StringBuilder sb, String statePrefix, String packageNamePrefix, String fileNamePrefix, String painterPrefix) {
+        String cacheModeString = "AbstractRegionPainter.PaintContext.CacheMode." + style.getCacheMode();
+        String stateConstant = Utils.statesToConstantName(painterPrefix + "_" + stateKeys);
+        sb.append(String.format(
+                "        d.put(\"%s.%sPainter\", new LazyPainter(\"%s.%s\", %s.%s, %s, %s, %b, %s, %s, %s));\n",
+                statePrefix, painterPrefix, packageNamePrefix, fileNamePrefix,
+                fileNamePrefix, stateConstant, canvas.getStretchingInsets().write(false),
+                canvas.getSize().write(false), inverted, cacheModeString,
+                Utils.formatDouble(style.getMaxHozCachedImgScaling()),
+                Utils.formatDouble(style.getMaxVertCachedImgScaling())));
+    }
+}
+
+class UIStateType {
+    @XmlAttribute private String key;
+    public String getKey() { return key; }
+
+    @XmlElement private String codeSnippet;
+    public String getCodeSnippet() { return codeSnippet; }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/make/tools/src/build/tools/generatenimbus/Utils.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package build.tools.generatenimbus;
+
+import java.util.ArrayList;
+import java.util.List;
+import javax.swing.plaf.synth.Region;
+
+public class Utils {
+
+    public static String escape(String s) {
+        return s.replace("\"", "\\\"");
+    }
+
+    public static String normalize(String s) {
+        char[] src = s.toCharArray();
+        StringBuilder buf = new StringBuilder();
+        List<String> parts = new ArrayList<String>();
+        boolean capitalize = false;
+
+        for (int i = 0; i < src.length; i++) {
+            switch (src[i]) {
+                case '\\':
+                case '"':
+                    break;
+                case '.':
+                    capitalize = true;
+                    break;
+                case ':':
+                    parts.add(buf.toString());
+                    buf.delete(0, buf.length());
+                    capitalize = true;
+                    break;
+                default:
+                    buf.append(capitalize ? Character.toUpperCase(src[i]) : src[i]);
+                    capitalize = false;
+                    break;
+            }
+        }
+        parts.add(buf.toString());
+
+        // Try to optimize long class names by omitting repeating prefixes, e.g.
+        // SliderTrackPainter.java instead of SliderSliderTrackPainter.java
+        String result = parts.get(0);
+        for (int i = 1; i < parts.size(); i++) {
+            String part = parts.get(i);
+            if (part.startsWith(result)) {
+                result = part;
+            } else {
+                result += part;
+            }
+        }
+        return result;
+    }
+
+    public static String regionNameToCaps(String regionName) {
+        if (Region.ARROW_BUTTON.getName().equals(regionName)) {
+            return "ARROW_BUTTON";
+        } else if (Region.BUTTON.getName().equals(regionName)) {
+            return "BUTTON";
+        } else if (Region.CHECK_BOX.getName().equals(regionName)) {
+            return "CHECK_BOX";
+        } else if (Region.CHECK_BOX_MENU_ITEM.getName().equals(regionName)) {
+            return "CHECK_BOX_MENU_ITEM";
+        } else if (Region.COLOR_CHOOSER.getName().equals(regionName)) {
+            return "COLOR_CHOOSER";
+        } else if (Region.COMBO_BOX.getName().equals(regionName)) {
+            return "COMBO_BOX";
+        } else if (Region.DESKTOP_ICON.getName().equals(regionName)) {
+            return "DESKTOP_ICON";
+        } else if (Region.DESKTOP_PANE.getName().equals(regionName)) {
+            return "DESKTOP_PANE";
+        } else if (Region.EDITOR_PANE.getName().equals(regionName)) {
+            return "EDITOR_PANE";
+        } else if (Region.FILE_CHOOSER.getName().equals(regionName)) {
+            return "FILE_CHOOSER";
+        } else if (Region.FORMATTED_TEXT_FIELD.getName().equals(regionName)) {
+            return "FORMATTED_TEXT_FIELD";
+        } else if (Region.INTERNAL_FRAME.getName().equals(regionName)) {
+            return "INTERNAL_FRAME";
+        } else if (Region.INTERNAL_FRAME_TITLE_PANE.getName().equals(regionName)) {
+            return "INTERNAL_FRAME_TITLE_PANE";
+        } else if (Region.LABEL.getName().equals(regionName)) {
+            return "LABEL";
+        } else if (Region.LIST.getName().equals(regionName)) {
+            return "LIST";
+        } else if (Region.MENU.getName().equals(regionName)) {
+            return "MENU";
+        } else if (Region.MENU_BAR.getName().equals(regionName)) {
+            return "MENU_BAR";
+        } else if (Region.MENU_ITEM.getName().equals(regionName)) {
+            return "MENU_ITEM";
+        } else if (Region.MENU_ITEM_ACCELERATOR.getName().equals(regionName)) {
+            return "MENU_ITEM_ACCELERATOR";
+        } else if (Region.OPTION_PANE.getName().equals(regionName)) {
+            return "OPTION_PANE";
+        } else if (Region.PANEL.getName().equals(regionName)) {
+            return "PANEL";
+        } else if (Region.PASSWORD_FIELD.getName().equals(regionName)) {
+            return "PASSWORD_FIELD";
+        } else if (Region.POPUP_MENU.getName().equals(regionName)) {
+            return "POPUP_MENU";
+        } else if (Region.POPUP_MENU_SEPARATOR.getName().equals(regionName)) {
+            return "POPUP_MENU_SEPARATOR";
+        } else if (Region.PROGRESS_BAR.getName().equals(regionName)) {
+            return "PROGRESS_BAR";
+        } else if (Region.RADIO_BUTTON.getName().equals(regionName)) {
+            return "RADIO_BUTTON";
+        } else if (Region.RADIO_BUTTON_MENU_ITEM.getName().equals(regionName)) {
+            return "RADIO_BUTTON_MENU_ITEM";
+        } else if (Region.ROOT_PANE.getName().equals(regionName)) {
+            return "ROOT_PANE";
+        } else if (Region.SCROLL_BAR.getName().equals(regionName)) {
+            return "SCROLL_BAR";
+        } else if (Region.SCROLL_BAR_THUMB.getName().equals(regionName)) {
+            return "SCROLL_BAR_THUMB";
+        } else if (Region.SCROLL_BAR_TRACK.getName().equals(regionName)) {
+            return "SCROLL_BAR_TRACK";
+        } else if (Region.SCROLL_PANE.getName().equals(regionName)) {
+            return "SCROLL_PANE";
+        } else if (Region.SEPARATOR.getName().equals(regionName)) {
+            return "SEPARATOR";
+        } else if (Region.SLIDER.getName().equals(regionName)) {
+            return "SLIDER";
+        } else if (Region.SLIDER_THUMB.getName().equals(regionName)) {
+            return "SLIDER_THUMB";
+        } else if (Region.SLIDER_TRACK.getName().equals(regionName)) {
+            return "SLIDER_TRACK";
+        } else if (Region.SPINNER.getName().equals(regionName)) {
+            return "SPINNER";
+        } else if (Region.SPLIT_PANE.getName().equals(regionName)) {
+            return "SPLIT_PANE";
+        } else if (Region.SPLIT_PANE_DIVIDER.getName().equals(regionName)) {
+            return "SPLIT_PANE_DIVIDER";
+        } else if (Region.TABBED_PANE.getName().equals(regionName)) {
+            return "TABBED_PANE";
+        } else if (Region.TABBED_PANE_CONTENT.getName().equals(regionName)) {
+            return "TABBED_PANE_CONTENT";
+        } else if (Region.TABBED_PANE_TAB.getName().equals(regionName)) {
+            return "TABBED_PANE_TAB";
+        } else if (Region.TABBED_PANE_TAB_AREA.getName().equals(regionName)) {
+            return "TABBED_PANE_TAB_AREA";
+        } else if (Region.TABLE.getName().equals(regionName)) {
+            return "TABLE";
+        } else if (Region.TABLE_HEADER.getName().equals(regionName)) {
+            return "TABLE_HEADER";
+        } else if (Region.TEXT_AREA.getName().equals(regionName)) {
+            return "TEXT_AREA";
+        } else if (Region.TEXT_FIELD.getName().equals(regionName)) {
+            return "TEXT_FIELD";
+        } else if (Region.TEXT_PANE.getName().equals(regionName)) {
+            return "TEXT_PANE";
+        } else if (Region.TOGGLE_BUTTON.getName().equals(regionName)) {
+            return "TOGGLE_BUTTON";
+        } else if (Region.TOOL_BAR.getName().equals(regionName)) {
+            return "TOOL_BAR";
+        } else if (Region.TOOL_BAR_CONTENT.getName().equals(regionName)) {
+            return "TOOL_BAR_CONTENT";
+        } else if (Region.TOOL_BAR_DRAG_WINDOW.getName().equals(regionName)) {
+            return "TOOL_BAR_DRAG_WINDOW";
+        } else if (Region.TOOL_BAR_SEPARATOR.getName().equals(regionName)) {
+            return "TOOL_BAR_SEPARATOR";
+        } else if (Region.TOOL_TIP.getName().equals(regionName)) {
+            return "TOOL_TIP";
+        } else if (Region.TREE.getName().equals(regionName)) {
+            return "TREE";
+        } else if (Region.TREE_CELL.getName().equals(regionName)) {
+            return "TREE_CELL";
+        } else if (Region.VIEWPORT.getName().equals(regionName)) {
+            return "VIEWPORT";
+        }
+        throw new RuntimeException("Bad Region name " + regionName);
+    }
+
+    public static String statesToConstantName(String states) {
+        String s = states.replace(" ", "");
+        s = states.replace("+", "_");
+        return s.toUpperCase();
+    }
+
+    //takes a states string of the form Enabled+Foo+Bar.
+    //removes any whitespace. Replaces the + signs with And.
+    public static String statesToClassName(String states) {
+        String s = states.replace(" ", "");
+        s = states.replace("+", "And");
+        return s;
+    }
+
+    public static String formatDouble(String doubleValue) {
+        return doubleValue.replace("INF", "Double.POSITIVE_INFINITY");
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/ChangeLog	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,855 @@
+
+                ChangeLog file for zlib
+
+Changes in 1.2.3 (18 July 2005)
+- Apply security vulnerability fixes to contrib/infback9 as well
+- Clean up some text files (carriage returns, trailing space)
+- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]
+
+Changes in 1.2.2.4 (11 July 2005)
+- Add inflatePrime() function for starting inflation at bit boundary
+- Avoid some Visual C warnings in deflate.c
+- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit
+  compile
+- Fix some spelling errors in comments [Betts]
+- Correct inflateInit2() error return documentation in zlib.h
+- Added zran.c example of compressed data random access to examples
+  directory, shows use of inflatePrime()
+- Fix cast for assignments to strm->state in inflate.c and infback.c
+- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]
+- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]
+- Add cast in trees.c t avoid a warning [Oberhumer]
+- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]
+- Update make_vms.com [Zinser]
+- Initialize state->write in inflateReset() since copied in inflate_fast()
+- Be more strict on incomplete code sets in inflate_table() and increase
+  ENOUGH and MAXD -- this repairs a possible security vulnerability for
+  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for
+  discovering the vulnerability and providing test cases.
+- Add ia64 support to configure for HP-UX [Smith]
+- Add error return to gzread() for format or i/o error [Levin]
+- Use malloc.h for OS/2 [Necasek]
+
+Changes in 1.2.2.3 (27 May 2005)
+- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile
+- Typecast fread() return values in gzio.c [Vollant]
+- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)
+- Fix crc check bug in gzread() after gzungetc() [Heiner]
+- Add the deflateTune() function to adjust internal compression parameters
+- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)
+- Remove an incorrect assertion in examples/zpipe.c
+- Add C++ wrapper in infback9.h [Donais]
+- Fix bug in inflateCopy() when decoding fixed codes
+- Note in zlib.h how much deflateSetDictionary() actually uses
+- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)
+- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]
+- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]
+- Add gzdirect() function to indicate transparent reads
+- Update contrib/minizip [Vollant]
+- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]
+- Add casts in crc32.c to avoid warnings [Oberhumer]
+- Add contrib/masmx64 [Vollant]
+- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]
+
+Changes in 1.2.2.2 (30 December 2004)
+- Replace structure assignments in deflate.c and inflate.c with zmemcpy to
+  avoid implicit memcpy calls (portability for no-library compilation)
+- Increase sprintf() buffer size in gzdopen() to allow for large numbers
+- Add INFLATE_STRICT to check distances against zlib header
+- Improve WinCE errno handling and comments [Chang]
+- Remove comment about no gzip header processing in FAQ
+- Add Z_FIXED strategy option to deflateInit2() to force fixed trees
+- Add updated make_vms.com [Coghlan], update README
+- Create a new "examples" directory, move gzappend.c there, add zpipe.c,
+  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.
+- Add FAQ entry and comments in deflate.c on uninitialized memory access
+- Add Solaris 9 make options in configure [Gilbert]
+- Allow strerror() usage in gzio.c for STDC
+- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]
+- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]
+- Use z_off_t for adler32_combine() and crc32_combine() lengths
+- Make adler32() much faster for small len
+- Use OS_CODE in deflate() default gzip header
+
+Changes in 1.2.2.1 (31 October 2004)
+- Allow inflateSetDictionary() call for raw inflate
+- Fix inflate header crc check bug for file names and comments
+- Add deflateSetHeader() and gz_header structure for custom gzip headers
+- Add inflateGetheader() to retrieve gzip headers
+- Add crc32_combine() and adler32_combine() functions
+- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list
+- Use zstreamp consistently in zlib.h (inflate_back functions)
+- Remove GUNZIP condition from definition of inflate_mode in inflate.h
+  and in contrib/inflate86/inffast.S [Truta, Anderson]
+- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]
+- Update projects/README.projects and projects/visualc6 [Truta]
+- Update win32/DLL_FAQ.txt [Truta]
+- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]
+- Deprecate Z_ASCII; use Z_TEXT instead [Truta]
+- Use a new algorithm for setting strm->data_type in trees.c [Truta]
+- Do not define an exit() prototype in zutil.c unless DEBUG defined
+- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]
+- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()
+- Fix Darwin build version identification [Peterson]
+
+Changes in 1.2.2 (3 October 2004)
+- Update zlib.h comments on gzip in-memory processing
+- Set adler to 1 in inflateReset() to support Java test suite [Walles]
+- Add contrib/dotzlib [Ravn]
+- Update win32/DLL_FAQ.txt [Truta]
+- Update contrib/minizip [Vollant]
+- Move contrib/visual-basic.txt to old/ [Truta]
+- Fix assembler builds in projects/visualc6/ [Truta]
+
+Changes in 1.2.1.2 (9 September 2004)
+- Update INDEX file
+- Fix trees.c to update strm->data_type (no one ever noticed!)
+- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]
+- Add "volatile" to crc table flag declaration (for DYNAMIC_CRC_TABLE)
+- Add limited multitasking protection to DYNAMIC_CRC_TABLE
+- Add NO_vsnprintf for VMS in zutil.h [Mozilla]
+- Don't declare strerror() under VMS [Mozilla]
+- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize
+- Update contrib/ada [Anisimkov]
+- Update contrib/minizip [Vollant]
+- Fix configure to not hardcode directories for Darwin [Peterson]
+- Fix gzio.c to not return error on empty files [Brown]
+- Fix indentation; update version in contrib/delphi/ZLib.pas and
+  contrib/pascal/zlibpas.pas [Truta]
+- Update mkasm.bat in contrib/masmx86 [Truta]
+- Update contrib/untgz [Truta]
+- Add projects/README.projects [Truta]
+- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]
+- Update win32/DLL_FAQ.txt [Truta]
+- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]
+- Remove an unnecessary assignment to curr in inftrees.c [Truta]
+- Add OS/2 to exe builds in configure [Poltorak]
+- Remove err dummy parameter in zlib.h [Kientzle]
+
+Changes in 1.2.1.1 (9 January 2004)
+- Update email address in README
+- Several FAQ updates
+- Fix a big fat bug in inftrees.c that prevented decoding valid
+  dynamic blocks with only literals and no distance codes --
+  Thanks to "Hot Emu" for the bug report and sample file
+- Add a note to puff.c on no distance codes case.
+
+Changes in 1.2.1 (17 November 2003)
+- Remove a tab in contrib/gzappend/gzappend.c
+- Update some interfaces in contrib for new zlib functions
+- Update zlib version number in some contrib entries
+- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]
+- Support shared libraries on Hurd and KFreeBSD [Brown]
+- Fix error in NO_DIVIDE option of adler32.c
+
+Changes in 1.2.0.8 (4 November 2003)
+- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas
+- Add experimental NO_DIVIDE #define in adler32.c
+    - Possibly faster on some processors (let me know if it is)
+- Correct Z_BLOCK to not return on first inflate call if no wrap
+- Fix strm->data_type on inflate() return to correctly indicate EOB
+- Add deflatePrime() function for appending in the middle of a byte
+- Add contrib/gzappend for an example of appending to a stream
+- Update win32/DLL_FAQ.txt [Truta]
+- Delete Turbo C comment in README [Truta]
+- Improve some indentation in zconf.h [Truta]
+- Fix infinite loop on bad input in configure script [Church]
+- Fix gzeof() for concatenated gzip files [Johnson]
+- Add example to contrib/visual-basic.txt [Michael B.]
+- Add -p to mkdir's in Makefile.in [vda]
+- Fix configure to properly detect presence or lack of printf functions
+- Add AS400 support [Monnerat]
+- Add a little Cygwin support [Wilson]
+
+Changes in 1.2.0.7 (21 September 2003)
+- Correct some debug formats in contrib/infback9
+- Cast a type in a debug statement in trees.c
+- Change search and replace delimiter in configure from % to # [Beebe]
+- Update contrib/untgz to 0.2 with various fixes [Truta]
+- Add build support for Amiga [Nikl]
+- Remove some directories in old that have been updated to 1.2
+- Add dylib building for Mac OS X in configure and Makefile.in
+- Remove old distribution stuff from Makefile
+- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X
+- Update links in README
+
+Changes in 1.2.0.6 (13 September 2003)
+- Minor FAQ updates
+- Update contrib/minizip to 1.00 [Vollant]
+- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]
+- Update POSTINC comment for 68060 [Nikl]
+- Add contrib/infback9 with deflate64 decoding (unsupported)
+- For MVS define NO_vsnprintf and undefine FAR [van Burik]
+- Add pragma for fdopen on MVS [van Burik]
+
+Changes in 1.2.0.5 (8 September 2003)
+- Add OF to inflateBackEnd() declaration in zlib.h
+- Remember start when using gzdopen in the middle of a file
+- Use internal off_t counters in gz* functions to properly handle seeks
+- Perform more rigorous check for distance-too-far in inffast.c
+- Add Z_BLOCK flush option to return from inflate at block boundary
+- Set strm->data_type on return from inflate
+    - Indicate bits unused, if at block boundary, and if in last block
+- Replace size_t with ptrdiff_t in crc32.c, and check for correct size
+- Add condition so old NO_DEFLATE define still works for compatibility
+- FAQ update regarding the Windows DLL [Truta]
+- INDEX update: add qnx entry, remove aix entry [Truta]
+- Install zlib.3 into mandir [Wilson]
+- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]
+- Adapt the zlib interface to the new DLL convention guidelines [Truta]
+- Introduce ZLIB_WINAPI macro to allow the export of functions using
+  the WINAPI calling convention, for Visual Basic [Vollant, Truta]
+- Update msdos and win32 scripts and makefiles [Truta]
+- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]
+- Add contrib/ada [Anisimkov]
+- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]
+- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]
+- Add contrib/masm686 [Truta]
+- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm
+  [Truta, Vollant]
+- Update contrib/delphi; rename to contrib/pascal; add example [Truta]
+- Remove contrib/delphi2; add a new contrib/delphi [Truta]
+- Avoid inclusion of the nonstandard <memory.h> in contrib/iostream,
+  and fix some method prototypes [Truta]
+- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip
+  [Truta]
+- Avoid the use of backslash (\) in contrib/minizip [Vollant]
+- Fix file time handling in contrib/untgz; update makefiles [Truta]
+- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines
+  [Vollant]
+- Remove contrib/vstudio/vc15_16 [Vollant]
+- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]
+- Update README.contrib [Truta]
+- Invert the assignment order of match_head and s->prev[...] in
+  INSERT_STRING [Truta]
+- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings
+  [Truta]
+- Compare function pointers with 0, not with NULL or Z_NULL [Truta]
+- Fix prototype of syncsearch in inflate.c [Truta]
+- Introduce ASMINF macro to be enabled when using an ASM implementation
+  of inflate_fast [Truta]
+- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]
+- Modify test_gzio in example.c to take a single file name as a
+  parameter [Truta]
+- Exit the example.c program if gzopen fails [Truta]
+- Add type casts around strlen in example.c [Truta]
+- Remove casting to sizeof in minigzip.c; give a proper type
+  to the variable compared with SUFFIX_LEN [Truta]
+- Update definitions of STDC and STDC99 in zconf.h [Truta]
+- Synchronize zconf.h with the new Windows DLL interface [Truta]
+- Use SYS16BIT instead of __32BIT__ to distinguish between
+  16- and 32-bit platforms [Truta]
+- Use far memory allocators in small 16-bit memory models for
+  Turbo C [Truta]
+- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in
+  zlibCompileFlags [Truta]
+- Cygwin has vsnprintf [Wilson]
+- In Windows16, OS_CODE is 0, as in MSDOS [Truta]
+- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]
+
+Changes in 1.2.0.4 (10 August 2003)
+- Minor FAQ updates
+- Be more strict when checking inflateInit2's windowBits parameter
+- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well
+- Add gzip wrapper option to deflateInit2 using windowBits
+- Add updated QNX rule in configure and qnx directory [Bonnefoy]
+- Make inflate distance-too-far checks more rigorous
+- Clean up FAR usage in inflate
+- Add casting to sizeof() in gzio.c and minigzip.c
+
+Changes in 1.2.0.3 (19 July 2003)
+- Fix silly error in gzungetc() implementation [Vollant]
+- Update contrib/minizip and contrib/vstudio [Vollant]
+- Fix printf format in example.c
+- Correct cdecl support in zconf.in.h [Anisimkov]
+- Minor FAQ updates
+
+Changes in 1.2.0.2 (13 July 2003)
+- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons
+- Attempt to avoid warnings in crc32.c for pointer-int conversion
+- Add AIX to configure, remove aix directory [Bakker]
+- Add some casts to minigzip.c
+- Improve checking after insecure sprintf() or vsprintf() calls
+- Remove #elif's from crc32.c
+- Change leave label to inf_leave in inflate.c and infback.c to avoid
+  library conflicts
+- Remove inflate gzip decoding by default--only enable gzip decoding by
+  special request for stricter backward compatibility
+- Add zlibCompileFlags() function to return compilation information
+- More typecasting in deflate.c to avoid warnings
+- Remove leading underscore from _Capital #defines [Truta]
+- Fix configure to link shared library when testing
+- Add some Windows CE target adjustments [Mai]
+- Remove #define ZLIB_DLL in zconf.h [Vollant]
+- Add zlib.3 [Rodgers]
+- Update RFC URL in deflate.c and algorithm.txt [Mai]
+- Add zlib_dll_FAQ.txt to contrib [Truta]
+- Add UL to some constants [Truta]
+- Update minizip and vstudio [Vollant]
+- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h
+- Expand use of NO_DUMMY_DECL to avoid all dummy structures
+- Added iostream3 to contrib [Schwardt]
+- Replace rewind() with fseek() for WinCE [Truta]
+- Improve setting of zlib format compression level flags
+    - Report 0 for huffman and rle strategies and for level == 0 or 1
+    - Report 2 only for level == 6
+- Only deal with 64K limit when necessary at compile time [Truta]
+- Allow TOO_FAR check to be turned off at compile time [Truta]
+- Add gzclearerr() function [Souza]
+- Add gzungetc() function
+
+Changes in 1.2.0.1 (17 March 2003)
+- Add Z_RLE strategy for run-length encoding [Truta]
+    - When Z_RLE requested, restrict matches to distance one
+    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE
+- Correct FASTEST compilation to allow level == 0
+- Clean up what gets compiled for FASTEST
+- Incorporate changes to zconf.in.h [Vollant]
+    - Refine detection of Turbo C need for dummy returns
+    - Refine ZLIB_DLL compilation
+    - Include additional header file on VMS for off_t typedef
+- Try to use _vsnprintf where it supplants vsprintf [Vollant]
+- Add some casts in inffast.c
+- Enchance comments in zlib.h on what happens if gzprintf() tries to
+  write more than 4095 bytes before compression
+- Remove unused state from inflateBackEnd()
+- Remove exit(0) from minigzip.c, example.c
+- Get rid of all those darn tabs
+- Add "check" target to Makefile.in that does the same thing as "test"
+- Add "mostlyclean" and "maintainer-clean" targets to Makefile.in
+- Update contrib/inflate86 [Anderson]
+- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]
+- Add msdos and win32 directories with makefiles [Truta]
+- More additions and improvements to the FAQ
+
+Changes in 1.2.0 (9 March 2003)
+- New and improved inflate code
+    - About 20% faster
+    - Does not allocate 32K window unless and until needed
+    - Automatically detects and decompresses gzip streams
+    - Raw inflate no longer needs an extra dummy byte at end
+    - Added inflateBack functions using a callback interface--even faster
+      than inflate, useful for file utilities (gzip, zip)
+    - Added inflateCopy() function to record state for random access on
+      externally generated deflate streams (e.g. in gzip files)
+    - More readable code (I hope)
+- New and improved crc32()
+    - About 50% faster, thanks to suggestions from Rodney Brown
+- Add deflateBound() and compressBound() functions
+- Fix memory leak in deflateInit2()
+- Permit setting dictionary for raw deflate (for parallel deflate)
+- Fix const declaration for gzwrite()
+- Check for some malloc() failures in gzio.c
+- Fix bug in gzopen() on single-byte file 0x1f
+- Fix bug in gzread() on concatenated file with 0x1f at end of buffer
+  and next buffer doesn't start with 0x8b
+- Fix uncompress() to return Z_DATA_ERROR on truncated input
+- Free memory at end of example.c
+- Remove MAX #define in trees.c (conflicted with some libraries)
+- Fix static const's in deflate.c, gzio.c, and zutil.[ch]
+- Declare malloc() and free() in gzio.c if STDC not defined
+- Use malloc() instead of calloc() in zutil.c if int big enough
+- Define STDC for AIX
+- Add aix/ with approach for compiling shared library on AIX
+- Add HP-UX support for shared libraries in configure
+- Add OpenUNIX support for shared libraries in configure
+- Use $cc instead of gcc to build shared library
+- Make prefix directory if needed when installing
+- Correct Macintosh avoidance of typedef Byte in zconf.h
+- Correct Turbo C memory allocation when under Linux
+- Use libz.a instead of -lz in Makefile (assure use of compiled library)
+- Update configure to check for snprintf or vsnprintf functions and their
+  return value, warn during make if using an insecure function
+- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that
+  is lost when library is used--resolution is to build new zconf.h
+- Documentation improvements (in zlib.h):
+    - Document raw deflate and inflate
+    - Update RFCs URL
+    - Point out that zlib and gzip formats are different
+    - Note that Z_BUF_ERROR is not fatal
+    - Document string limit for gzprintf() and possible buffer overflow
+    - Note requirement on avail_out when flushing
+    - Note permitted values of flush parameter of inflate()
+- Add some FAQs (and even answers) to the FAQ
+- Add contrib/inflate86/ for x86 faster inflate
+- Add contrib/blast/ for PKWare Data Compression Library decompression
+- Add contrib/puff/ simple inflate for deflate format description
+
+Changes in 1.1.4 (11 March 2002)
+- ZFREE was repeated on same allocation on some error conditions.
+  This creates a security problem described in
+  http://www.zlib.org/advisory-2002-03-11.txt
+- Returned incorrect error (Z_MEM_ERROR) on some invalid data
+- Avoid accesses before window for invalid distances with inflate window
+  less than 32K.
+- force windowBits > 8 to avoid a bug in the encoder for a window size
+  of 256 bytes. (A complete fix will be available in 1.1.5).
+
+Changes in 1.1.3 (9 July 1998)
+- fix "an inflate input buffer bug that shows up on rare but persistent
+  occasions" (Mark)
+- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)
+- fix gzseek(..., SEEK_SET) in write mode
+- fix crc check after a gzeek (Frank Faubert)
+- fix miniunzip when the last entry in a zip file is itself a zip file
+  (J Lillge)
+- add contrib/asm586 and contrib/asm686 (Brian Raiter)
+  See http://www.muppetlabs.com/~breadbox/software/assembly.html
+- add support for Delphi 3 in contrib/delphi (Bob Dellaca)
+- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)
+- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)
+- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)
+- added a FAQ file
+
+- Support gzdopen on Mac with Metrowerks (Jason Linhart)
+- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)
+- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)
+- avoid some warnings with Borland C (Tom Tanner)
+- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)
+- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)
+- allow several arguments to configure (Tim Mooney, Frodo Looijaard)
+- use libdir and includedir in Makefile.in (Tim Mooney)
+- support shared libraries on OSF1 V4 (Tim Mooney)
+- remove so_locations in "make clean"  (Tim Mooney)
+- fix maketree.c compilation error (Glenn, Mark)
+- Python interface to zlib now in Python 1.5 (Jeremy Hylton)
+- new Makefile.riscos (Rich Walker)
+- initialize static descriptors in trees.c for embedded targets (Nick Smith)
+- use "foo-gz" in example.c for RISCOS and VMS (Nick Smith)
+- add the OS/2 files in Makefile.in too (Andrew Zabolotny)
+- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)
+- fix maketree.c to allow clean compilation of inffixed.h (Mark)
+- fix parameter check in deflateCopy (Gunther Nikl)
+- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)
+- Many portability patches by Christian Spieler:
+  . zutil.c, zutil.h: added "const" for zmem*
+  . Make_vms.com: fixed some typos
+  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists
+  . msdos/Makefile.msc: remove "default rtl link library" info from obj files
+  . msdos/Makefile.*: use model-dependent name for the built zlib library
+  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:
+     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)
+- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)
+- replace __far with _far for better portability (Christian Spieler, Tom Lane)
+- fix test for errno.h in configure (Tim Newsham)
+
+Changes in 1.1.2 (19 March 98)
+- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)
+  See http://www.winimage.com/zLibDll/unzip.html
+- preinitialize the inflate tables for fixed codes, to make the code
+  completely thread safe (Mark)
+- some simplifications and slight speed-up to the inflate code (Mark)
+- fix gzeof on non-compressed files (Allan Schrum)
+- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)
+- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)
+- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)
+- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)
+- do not wrap extern "C" around system includes (Tom Lane)
+- mention zlib binding for TCL in README (Andreas Kupries)
+- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)
+- allow "make install prefix=..." even after configure (Glenn Randers-Pehrson)
+- allow "configure --prefix $HOME" (Tim Mooney)
+- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)
+- move Makefile.sas to amiga/Makefile.sas
+
+Changes in 1.1.1 (27 Feb 98)
+- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)
+- remove block truncation heuristic which had very marginal effect for zlib
+  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the
+  compression ratio on some files. This also allows inlining _tr_tally for
+  matches in deflate_slow.
+- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)
+
+Changes in 1.1.0 (24 Feb 98)
+- do not return STREAM_END prematurely in inflate (John Bowler)
+- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)
+- compile with -DFASTEST to get compression code optimized for speed only
+- in minigzip, try mmap'ing the input file first (Miguel Albrecht)
+- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain
+  on Sun but significant on HP)
+
+- add a pointer to experimental unzip library in README (Gilles Vollant)
+- initialize variable gcc in configure (Chris Herborth)
+
+Changes in 1.0.9 (17 Feb 1998)
+- added gzputs and gzgets functions
+- do not clear eof flag in gzseek (Mark Diekhans)
+- fix gzseek for files in transparent mode (Mark Diekhans)
+- do not assume that vsprintf returns the number of bytes written (Jens Krinke)
+- replace EXPORT with ZEXPORT to avoid conflict with other programs
+- added compress2 in zconf.h, zlib.def, zlib.dnt
+- new asm code from Gilles Vollant in contrib/asm386
+- simplify the inflate code (Mark):
+ . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()
+ . ZALLOC the length list in inflate_trees_fixed() instead of using stack
+ . ZALLOC the value area for huft_build() instead of using stack
+ . Simplify Z_FINISH check in inflate()
+
+- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8
+- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)
+- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with
+  the declaration of FAR (Gilles VOllant)
+- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)
+- read_buf buf parameter of type Bytef* instead of charf*
+- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)
+- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)
+- fix check for presence of directories in "make install" (Ian Willis)
+
+Changes in 1.0.8 (27 Jan 1998)
+- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)
+- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)
+- added compress2() to allow setting the compression level
+- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)
+- use constant arrays for the static trees in trees.c instead of computing
+  them at run time (thanks to Ken Raeburn for this suggestion). To create
+  trees.h, compile with GEN_TREES_H and run "make test".
+- check return code of example in "make test" and display result
+- pass minigzip command line options to file_compress
+- simplifying code of inflateSync to avoid gcc 2.8 bug
+
+- support CC="gcc -Wall" in configure -s (QingLong)
+- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)
+- fix test for shared library support to avoid compiler warnings
+- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)
+- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)
+- do not use fdopen for Metrowerks on Mac (Brad Pettit))
+- add checks for gzputc and gzputc in example.c
+- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)
+- use const for the CRC table (Ken Raeburn)
+- fixed "make uninstall" for shared libraries
+- use Tracev instead of Trace in infblock.c
+- in example.c use correct compressed length for test_sync
+- suppress +vnocompatwarnings in configure for HPUX (not always supported)
+
+Changes in 1.0.7 (20 Jan 1998)
+- fix gzseek which was broken in write mode
+- return error for gzseek to negative absolute position
+- fix configure for Linux (Chun-Chung Chen)
+- increase stack space for MSC (Tim Wegner)
+- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)
+- define EXPORTVA for gzprintf (Gilles Vollant)
+- added man page zlib.3 (Rick Rodgers)
+- for contrib/untgz, fix makedir() and improve Makefile
+
+- check gzseek in write mode in example.c
+- allocate extra buffer for seeks only if gzseek is actually called
+- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)
+- add inflateSyncPoint in zconf.h
+- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def
+
+Changes in 1.0.6 (19 Jan 1998)
+- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and
+  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)
+- Fix a deflate bug occurring only with compression level 0 (thanks to
+  Andy Buckler for finding this one).
+- In minigzip, pass transparently also the first byte for .Z files.
+- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()
+- check Z_FINISH in inflate (thanks to Marc Schluper)
+- Implement deflateCopy (thanks to Adam Costello)
+- make static libraries by default in configure, add --shared option.
+- move MSDOS or Windows specific files to directory msdos
+- suppress the notion of partial flush to simplify the interface
+  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)
+- suppress history buffer provided by application to simplify the interface
+  (this feature was not implemented anyway in 1.0.4)
+- next_in and avail_in must be initialized before calling inflateInit or
+  inflateInit2
+- add EXPORT in all exported functions (for Windows DLL)
+- added Makefile.nt (thanks to Stephen Williams)
+- added the unsupported "contrib" directory:
+   contrib/asm386/ by Gilles Vollant <info@winimage.com>
+        386 asm code replacing longest_match().
+   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>
+        A C++ I/O streams interface to the zlib gz* functions
+   contrib/iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
+        Another C++ I/O streams interface
+   contrib/untgz/  by "Pedro A. Aranda Guti\irrez" <paag@tid.es>
+        A very simple tar.gz file extractor using zlib
+   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>
+        How to use compress(), uncompress() and the gz* functions from VB.
+- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression
+  level) in minigzip (thanks to Tom Lane)
+
+- use const for rommable constants in deflate
+- added test for gzseek and gztell in example.c
+- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)
+- add undocumented function zError to convert error code to string
+  (for Tim Smithers)
+- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.
+- Use default memcpy for Symantec MSDOS compiler.
+- Add EXPORT keyword for check_func (needed for Windows DLL)
+- add current directory to LD_LIBRARY_PATH for "make test"
+- create also a link for libz.so.1
+- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)
+- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)
+- added -soname for Linux in configure (Chun-Chung Chen,
+- assign numbers to the exported functions in zlib.def (for Windows DLL)
+- add advice in zlib.h for best usage of deflateSetDictionary
+- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)
+- allow compilation with ANSI keywords only enabled for TurboC in large model
+- avoid "versionString"[0] (Borland bug)
+- add NEED_DUMMY_RETURN for Borland
+- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).
+- allow compilation with CC
+- defined STDC for OS/2 (David Charlap)
+- limit external names to 8 chars for MVS (Thomas Lund)
+- in minigzip.c, use static buffers only for 16-bit systems
+- fix suffix check for "minigzip -d foo.gz"
+- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)
+- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)
+- added makelcc.bat for lcc-win32 (Tom St Denis)
+- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)
+- Avoid expanded $Id$. Use "rcs -kb" or "cvs admin -kb" to avoid Id expansion.
+- check for unistd.h in configure (for off_t)
+- remove useless check parameter in inflate_blocks_free
+- avoid useless assignment of s->check to itself in inflate_blocks_new
+- do not flush twice in gzclose (thanks to Ken Raeburn)
+- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h
+- use NO_ERRNO_H instead of enumeration of operating systems with errno.h
+- work around buggy fclose on pipes for HP/UX
+- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)
+- fix configure if CC is already equal to gcc
+
+Changes in 1.0.5 (3 Jan 98)
+- Fix inflate to terminate gracefully when fed corrupted or invalid data
+- Use const for rommable constants in inflate
+- Eliminate memory leaks on error conditions in inflate
+- Removed some vestigial code in inflate
+- Update web address in README
+
+Changes in 1.0.4 (24 Jul 96)
+- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF
+  bit, so the decompressor could decompress all the correct data but went
+  on to attempt decompressing extra garbage data. This affected minigzip too.
+- zlibVersion and gzerror return const char* (needed for DLL)
+- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)
+- use z_error only for DEBUG (avoid problem with DLLs)
+
+Changes in 1.0.3 (2 Jul 96)
+- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS
+  small and medium models; this makes the library incompatible with previous
+  versions for these models. (No effect in large model or on other systems.)
+- return OK instead of BUF_ERROR if previous deflate call returned with
+  avail_out as zero but there is nothing to do
+- added memcmp for non STDC compilers
+- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)
+- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)
+- better check for 16-bit mode MSC (avoids problem with Symantec)
+
+Changes in 1.0.2 (23 May 96)
+- added Windows DLL support
+- added a function zlibVersion (for the DLL support)
+- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)
+- Bytef is define's instead of typedef'd only for Borland C
+- avoid reading uninitialized memory in example.c
+- mention in README that the zlib format is now RFC1950
+- updated Makefile.dj2
+- added algorithm.doc
+
+Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]
+- fix array overlay in deflate.c which sometimes caused bad compressed data
+- fix inflate bug with empty stored block
+- fix MSDOS medium model which was broken in 0.99
+- fix deflateParams() which could generated bad compressed data.
+- Bytef is define'd instead of typedef'ed (work around Borland bug)
+- added an INDEX file
+- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),
+  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)
+- speed up adler32 for modern machines without auto-increment
+- added -ansi for IRIX in configure
+- static_init_done in trees.c is an int
+- define unlink as delete for VMS
+- fix configure for QNX
+- add configure branch for SCO and HPUX
+- avoid many warnings (unused variables, dead assignments, etc...)
+- no fdopen for BeOS
+- fix the Watcom fix for 32 bit mode (define FAR as empty)
+- removed redefinition of Byte for MKWERKS
+- work around an MWKERKS bug (incorrect merge of all .h files)
+
+Changes in 0.99 (27 Jan 96)
+- allow preset dictionary shared between compressor and decompressor
+- allow compression level 0 (no compression)
+- add deflateParams in zlib.h: allow dynamic change of compression level
+  and compression strategy.
+- test large buffers and deflateParams in example.c
+- add optional "configure" to build zlib as a shared library
+- suppress Makefile.qnx, use configure instead
+- fixed deflate for 64-bit systems (detected on Cray)
+- fixed inflate_blocks for 64-bit systems (detected on Alpha)
+- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)
+- always return Z_BUF_ERROR when deflate() has nothing to do
+- deflateInit and inflateInit are now macros to allow version checking
+- prefix all global functions and types with z_ with -DZ_PREFIX
+- make falloc completely reentrant (inftrees.c)
+- fixed very unlikely race condition in ct_static_init
+- free in reverse order of allocation to help memory manager
+- use zlib-1.0/* instead of zlib/* inside the tar.gz
+- make zlib warning-free with "gcc -O3 -Wall -Wwrite-strings -Wpointer-arith
+  -Wconversion -Wstrict-prototypes -Wmissing-prototypes"
+- allow gzread on concatenated .gz files
+- deflateEnd now returns Z_DATA_ERROR if it was premature
+- deflate is finally (?) fully deterministic (no matches beyond end of input)
+- Document Z_SYNC_FLUSH
+- add uninstall in Makefile
+- Check for __cpluplus in zlib.h
+- Better test in ct_align for partial flush
+- avoid harmless warnings for Borland C++
+- initialize hash_head in deflate.c
+- avoid warning on fdopen (gzio.c) for HP cc -Aa
+- include stdlib.h for STDC compilers
+- include errno.h for Cray
+- ignore error if ranlib doesn't exist
+- call ranlib twice for NeXTSTEP
+- use exec_prefix instead of prefix for libz.a
+- renamed ct_* as _tr_* to avoid conflict with applications
+- clear z->msg in inflateInit2 before any error return
+- initialize opaque in example.c, gzio.c, deflate.c and inflate.c
+- fixed typo in zconf.h (_GNUC__ => __GNUC__)
+- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)
+- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)
+- in fcalloc, normalize pointer if size > 65520 bytes
+- don't use special fcalloc for 32 bit Borland C++
+- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...
+- use Z_BINARY instead of BINARY
+- document that gzclose after gzdopen will close the file
+- allow "a" as mode in gzopen.
+- fix error checking in gzread
+- allow skipping .gz extra-field on pipes
+- added reference to Perl interface in README
+- put the crc table in FAR data (I dislike more and more the medium model :)
+- added get_crc_table
+- added a dimension to all arrays (Borland C can't count).
+- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast
+- guard against multiple inclusion of *.h (for precompiled header on Mac)
+- Watcom C pretends to be Microsoft C small model even in 32 bit mode.
+- don't use unsized arrays to avoid silly warnings by Visual C++:
+     warning C4746: 'inflate_mask' : unsized array treated as  '__far'
+     (what's wrong with far data in far model?).
+- define enum out of inflate_blocks_state to allow compilation with C++
+
+Changes in 0.95 (16 Aug 95)
+- fix MSDOS small and medium model (now easier to adapt to any compiler)
+- inlined send_bits
+- fix the final (:-) bug for deflate with flush (output was correct but
+  not completely flushed in rare occasions).
+- default window size is same for compression and decompression
+  (it's now sufficient to set MAX_WBITS in zconf.h).
+- voidp -> voidpf and voidnp -> voidp (for consistency with other
+  typedefs and because voidnp was not near in large model).
+
+Changes in 0.94 (13 Aug 95)
+- support MSDOS medium model
+- fix deflate with flush (could sometimes generate bad output)
+- fix deflateReset (zlib header was incorrectly suppressed)
+- added support for VMS
+- allow a compression level in gzopen()
+- gzflush now calls fflush
+- For deflate with flush, flush even if no more input is provided.
+- rename libgz.a as libz.a
+- avoid complex expression in infcodes.c triggering Turbo C bug
+- work around a problem with gcc on Alpha (in INSERT_STRING)
+- don't use inline functions (problem with some gcc versions)
+- allow renaming of Byte, uInt, etc... with #define.
+- avoid warning about (unused) pointer before start of array in deflate.c
+- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c
+- avoid reserved word 'new' in trees.c
+
+Changes in 0.93 (25 June 95)
+- temporarily disable inline functions
+- make deflate deterministic
+- give enough lookahead for PARTIAL_FLUSH
+- Set binary mode for stdin/stdout in minigzip.c for OS/2
+- don't even use signed char in inflate (not portable enough)
+- fix inflate memory leak for segmented architectures
+
+Changes in 0.92 (3 May 95)
+- don't assume that char is signed (problem on SGI)
+- Clear bit buffer when starting a stored block
+- no memcpy on Pyramid
+- suppressed inftest.c
+- optimized fill_window, put longest_match inline for gcc
+- optimized inflate on stored blocks.
+- untabify all sources to simplify patches
+
+Changes in 0.91 (2 May 95)
+- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h
+- Document the memory requirements in zconf.h
+- added "make install"
+- fix sync search logic in inflateSync
+- deflate(Z_FULL_FLUSH) now works even if output buffer too short
+- after inflateSync, don't scare people with just "lo world"
+- added support for DJGPP
+
+Changes in 0.9 (1 May 95)
+- don't assume that zalloc clears the allocated memory (the TurboC bug
+  was Mark's bug after all :)
+- let again gzread copy uncompressed data unchanged (was working in 0.71)
+- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented
+- added a test of inflateSync in example.c
+- moved MAX_WBITS to zconf.h because users might want to change that.
+- document explicitly that zalloc(64K) on MSDOS must return a normalized
+  pointer (zero offset)
+- added Makefiles for Microsoft C, Turbo C, Borland C++
+- faster crc32()
+
+Changes in 0.8 (29 April 95)
+- added fast inflate (inffast.c)
+- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this
+  is incompatible with previous versions of zlib which returned Z_OK.
+- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)
+  (actually that was not a compiler bug, see 0.81 above)
+- gzread no longer reads one extra byte in certain cases
+- In gzio destroy(), don't reference a freed structure
+- avoid many warnings for MSDOS
+- avoid the ERROR symbol which is used by MS Windows
+
+Changes in 0.71 (14 April 95)
+- Fixed more MSDOS compilation problems :( There is still a bug with
+  TurboC large model.
+
+Changes in 0.7 (14 April 95)
+- Added full inflate support.
+- Simplified the crc32() interface. The pre- and post-conditioning
+  (one's complement) is now done inside crc32(). WARNING: this is
+  incompatible with previous versions; see zlib.h for the new usage.
+
+Changes in 0.61 (12 April 95)
+- workaround for a bug in TurboC. example and minigzip now work on MSDOS.
+
+Changes in 0.6 (11 April 95)
+- added minigzip.c
+- added gzdopen to reopen a file descriptor as gzFile
+- added transparent reading of non-gziped files in gzread.
+- fixed bug in gzread (don't read crc as data)
+- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).
+- don't allocate big arrays in the stack (for MSDOS)
+- fix some MSDOS compilation problems
+
+Changes in 0.5:
+- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but
+  not yet Z_FULL_FLUSH.
+- support decompression but only in a single step (forced Z_FINISH)
+- added opaque object for zalloc and zfree.
+- added deflateReset and inflateReset
+- added a variable zlib_version for consistency checking.
+- renamed the 'filter' parameter of deflateInit2 as 'strategy'.
+  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.
+
+Changes in 0.4:
+- avoid "zip" everywhere, use zlib instead of ziplib.
+- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush
+  if compression method == 8.
+- added adler32 and crc32
+- renamed deflateOptions as deflateInit2, call one or the other but not both
+- added the method parameter for deflateInit2.
+- added inflateInit2
+- simplied considerably deflateInit and inflateInit by not supporting
+  user-provided history buffer. This is supported only in deflateInit2
+  and inflateInit2.
+
+Changes in 0.3:
+- prefix all macro names with Z_
+- use Z_FINISH instead of deflateEnd to finish compression.
+- added Z_HUFFMAN_ONLY
+- added gzerror()
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/README	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,125 @@
+ZLIB DATA COMPRESSION LIBRARY
+
+zlib 1.2.3 is a general purpose data compression library.  All the code is
+thread safe.  The data format used by the zlib library is described by RFCs
+(Request for Comments) 1950 to 1952 in the files
+http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)
+and rfc1952.txt (gzip format). These documents are also available in other
+formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
+
+All functions of the compression library are documented in the file zlib.h
+(volunteer to write man pages welcome, contact zlib@gzip.org). A usage example
+of the library is given in the file example.c which also tests that the library
+is working correctly. Another example is given in the file minigzip.c. The
+compression library itself is composed of all source files except example.c and
+minigzip.c.
+
+To compile all files and run the test program, follow the instructions given at
+the top of Makefile. In short "make test; make install" should work for most
+machines. For Unix: "./configure; make test; make install". For MSDOS, use one
+of the special makefiles such as Makefile.msc. For VMS, use make_vms.com.
+
+Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant
+<info@winimage.com> for the Windows DLL version. The zlib home page is
+http://www.zlib.org or http://www.gzip.org/zlib/ Before reporting a problem,
+please check this site to verify that you have the latest version of zlib;
+otherwise get the latest version and check whether the problem still exists or
+not.
+
+PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html before asking
+for help.
+
+Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997
+issue of  Dr. Dobb's Journal; a copy of the article is available in
+http://dogma.net/markn/articles/zlibtool/zlibtool.htm
+
+The changes made in version 1.2.3 are documented in the file ChangeLog.
+
+Unsupported third party contributions are provided in directory "contrib".
+
+A Java implementation of zlib is available in the Java Development Kit
+http://java.sun.com/j2se/1.4.2/docs/api/java/util/zip/package-summary.html
+See the zlib home page http://www.zlib.org for details.
+
+A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is in the
+CPAN (Comprehensive Perl Archive Network) sites
+http://www.cpan.org/modules/by-module/Compress/
+
+A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is
+available in Python 1.5 and later versions, see
+http://www.python.org/doc/lib/module-zlib.html
+
+A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com> is
+availlable at http://www.oche.de/~akupries/soft/trf/trf_zip.html
+
+An experimental package to read and write files in .zip format, written on top
+of zlib by Gilles Vollant <info@winimage.com>, is available in the
+contrib/minizip directory of zlib.
+
+
+Notes for some targets:
+
+- For Windows DLL versions, please see win32/DLL_FAQ.txt
+
+- For 64-bit Irix, deflate.c must be compiled without any optimization. With
+  -O, one libpng test fails. The test works in 32 bit mode (with the -n32
+  compiler flag). The compiler bug has been reported to SGI.
+
+- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works
+  when compiled with cc.
+
+- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is
+  necessary to get gzprintf working correctly. This is done by configure.
+
+- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with
+  other compilers. Use "make test" to check your compiler.
+
+- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.
+
+- For PalmOs, see http://palmzlib.sourceforge.net/
+
+- When building a shared, i.e. dynamic library on Mac OS X, the library must be
+  installed before testing (do "make install" before "make test"), since the
+  library location is specified in the library.
+
+
+Acknowledgments:
+
+  The deflate format used by zlib was defined by Phil Katz. The deflate
+  and zlib specifications were written by L. Peter Deutsch. Thanks to all the
+  people who reported problems and suggested various improvements in zlib;
+  they are too numerous to cite here.
+
+Copyright notice:
+
+ (C) 1995-2004 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+If you use the zlib library in a product, we would appreciate *not*
+receiving lengthy legal documents to sign. The sources are provided
+for free but without warranty of any kind.  The library has been
+entirely written by Jean-loup Gailly and Mark Adler; it does not
+include third-party code.
+
+If you redistribute modified sources, we would appreciate that you include
+in the file ChangeLog history information documenting your changes. Please
+read the FAQ for more information on the distribution of modified source
+versions.
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/compress.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,103 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* compress.c -- compress a memory buffer
+ * Copyright (C) 1995-2003 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#define ZLIB_INTERNAL
+#include "zlib.h"
+
+/* ===========================================================================
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least 0.1% larger than sourceLen plus
+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+    int level;
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+#ifdef MAXSEG_64K
+    /* Check for source > 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+#endif
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+    stream.opaque = (voidpf)0;
+
+    err = deflateInit(&stream, level);
+    if (err != Z_OK) return err;
+
+    err = deflate(&stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        deflateEnd(&stream);
+        return err == Z_OK ? Z_BUF_ERROR : err;
+    }
+    *destLen = stream.total_out;
+
+    err = deflateEnd(&stream);
+    return err;
+}
+
+/* ===========================================================================
+ */
+int ZEXPORT compress (dest, destLen, source, sourceLen)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+{
+    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
+}
+
+/* ===========================================================================
+     If the default memLevel or windowBits for deflateInit() is changed, then
+   this function needs to be updated.
+ */
+uLong ZEXPORT compressBound (sourceLen)
+    uLong sourceLen;
+{
+    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + 11;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/crc32.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,465 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* crc32.h -- tables for rapid CRC calculation
+ * Generated automatically by crc32.c
+ */
+
+local const unsigned long FAR crc_table[TBLS][256] =
+{
+  {
+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
+    0x2d02ef8dUL
+#ifdef BYFOUR
+  },
+  {
+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
+    0x9324fd72UL
+  },
+  {
+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
+    0xbe9834edUL
+  },
+  {
+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
+    0xde0506f1UL
+  },
+  {
+    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
+    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
+    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
+    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
+    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
+    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
+    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
+    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
+    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
+    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
+    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
+    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
+    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
+    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
+    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
+    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
+    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
+    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
+    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
+    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
+    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
+    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
+    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
+    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
+    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
+    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
+    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
+    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
+    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
+    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
+    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
+    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
+    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
+    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
+    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
+    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
+    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
+    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
+    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
+    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
+    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
+    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
+    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
+    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
+    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
+    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
+    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
+    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
+    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
+    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
+    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
+    0x8def022dUL
+  },
+  {
+    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
+    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
+    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
+    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
+    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
+    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
+    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
+    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
+    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
+    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
+    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
+    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
+    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
+    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
+    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
+    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
+    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
+    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
+    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
+    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
+    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
+    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
+    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
+    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
+    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
+    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
+    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
+    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
+    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
+    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
+    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
+    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
+    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
+    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
+    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
+    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
+    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
+    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
+    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
+    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
+    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
+    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
+    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
+    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
+    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
+    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
+    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
+    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
+    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
+    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
+    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
+    0x72fd2493UL
+  },
+  {
+    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
+    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
+    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
+    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
+    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
+    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
+    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
+    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
+    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
+    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
+    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
+    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
+    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
+    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
+    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
+    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
+    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
+    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
+    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
+    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
+    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
+    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
+    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
+    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
+    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
+    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
+    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
+    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
+    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
+    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
+    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
+    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
+    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
+    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
+    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
+    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
+    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
+    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
+    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
+    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
+    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
+    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
+    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
+    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
+    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
+    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
+    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
+    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
+    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
+    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
+    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
+    0xed3498beUL
+  },
+  {
+    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
+    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
+    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
+    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
+    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
+    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
+    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
+    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
+    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
+    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
+    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
+    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
+    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
+    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
+    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
+    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
+    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
+    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
+    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
+    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
+    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
+    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
+    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
+    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
+    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
+    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
+    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
+    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
+    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
+    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
+    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
+    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
+    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
+    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
+    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
+    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
+    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
+    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
+    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
+    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
+    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
+    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
+    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
+    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
+    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
+    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
+    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
+    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
+    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
+    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
+    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
+    0xf10605deUL
+#endif
+  }
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/deflate.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,1760 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin & Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
+ *      Available in http://www.ietf.org/rfc/rfc1951.txt
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* @(#) $Id$ */
+
+#include "deflate.h"
+
+const char deflate_copyright[] =
+   " deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+#ifndef FASTEST
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+#endif
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
+#ifndef FASTEST
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+#endif
+local uInt longest_match_fast OF((deflate_state *s, IPos cur_match));
+
+#ifdef DEBUG
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+#ifdef FASTEST
+local const config configuration_table[2] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
+#else
+local const config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
+#endif
+
+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+#ifndef NO_DUMMY_DECL
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+#endif
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * If this file is compiled with -DFASTEST, the compression level is forced
+ * to 1, and no hash chains are maintained.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#ifdef FASTEST
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#else
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#endif
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s->head[s->hash_size-1] = NIL; \
+    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+
+/* ========================================================================= */
+int ZEXPORT deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+                         Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm->next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int wrap = 1;
+    static const char my_version[] = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is <= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+        return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+    if (strm->zalloc == (alloc_func)0) {
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+
+#ifdef FASTEST
+    if (level != 0) level = 1;
+#else
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#endif
+
+    if (windowBits < 0) { /* suppress zlib wrapper */
+        wrap = 0;
+        windowBits = -windowBits;
+    }
+#ifdef GZIP
+    else if (windowBits > 15) {
+        wrap = 2;       /* write gzip wrapper instead */
+        windowBits -= 16;
+    }
+#endif
+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
+        strategy < 0 || strategy > Z_FIXED) {
+        return Z_STREAM_ERROR;
+    }
+    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm->state = (struct internal_state FAR *)s;
+    s->strm = strm;
+
+    s->wrap = wrap;
+    s->gzhead = Z_NULL;
+    s->w_bits = windowBits;
+    s->w_size = 1 << s->w_bits;
+    s->w_mask = s->w_size - 1;
+
+    s->hash_bits = memLevel + 7;
+    s->hash_size = 1 << s->hash_bits;
+    s->hash_mask = s->hash_size - 1;
+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+
+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+    s->pending_buf = (uchf *) overlay;
+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+
+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
+        s->pending_buf == Z_NULL) {
+        s->status = FINISH_STATE;
+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+
+    s->level = level;
+    s->strategy = strategy;
+    s->method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
+        strm->state->wrap == 2 ||
+        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
+        return Z_STREAM_ERROR;
+
+    s = strm->state;
+    if (s->wrap)
+        strm->adler = adler32(strm->adler, dictionary, dictLength);
+
+    if (length < MIN_MATCH) return Z_OK;
+    if (length > MAX_DIST(s)) {
+        length = MAX_DIST(s);
+        dictionary += dictLength - length; /* use the tail of the dictionary */
+    }
+    zmemcpy(s->window, dictionary, length);
+    s->strstart = length;
+    s->block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s->lookahead stays null, so s->ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s->ins_h = s->window[0];
+    UPDATE_HASH(s, s->ins_h, s->window[1]);
+    for (n = 0; n <= length - MIN_MATCH; n++) {
+        INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
+        return Z_STREAM_ERROR;
+    }
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->pending = 0;
+    s->pending_out = s->pending_buf;
+
+    if (s->wrap < 0) {
+        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
+    }
+    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
+    strm->adler =
+#ifdef GZIP
+        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
+#endif
+        adler32(0L, Z_NULL, 0);
+    s->last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetHeader (strm, head)
+    z_streamp strm;
+    gz_headerp head;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
+    strm->state->gzhead = head;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflatePrime (strm, bits, value)
+    z_streamp strm;
+    int bits;
+    int value;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    strm->state->bi_valid = bits;
+    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm->state;
+
+#ifdef FASTEST
+    if (level != 0) level = 1;
+#else
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#endif
+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
+        return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s->level].func;
+
+    if (func != configuration_table[level].func && strm->total_in != 0) {
+        /* Flush the last buffer: */
+        err = deflate(strm, Z_PARTIAL_FLUSH);
+    }
+    if (s->level != level) {
+        s->level = level;
+        s->max_lazy_match   = configuration_table[level].max_lazy;
+        s->good_match       = configuration_table[level].good_length;
+        s->nice_match       = configuration_table[level].nice_length;
+        s->max_chain_length = configuration_table[level].max_chain;
+    }
+    s->strategy = strategy;
+    return err;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
+    z_streamp strm;
+    int good_length;
+    int max_lazy;
+    int nice_length;
+    int max_chain;
+{
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm->state;
+    s->good_match = good_length;
+    s->max_lazy_match = max_lazy;
+    s->nice_match = nice_length;
+    s->max_chain_length = max_chain;
+    return Z_OK;
+}
+
+/* =========================================================================
+ * For the default windowBits of 15 and memLevel of 8, this function returns
+ * a close to exact, as well as small, upper bound on the compressed size.
+ * They are coded as constants here for a reason--if the #define's are
+ * changed, then this function needs to be changed as well.  The return
+ * value for 15 and 8 only works for those exact settings.
+ *
+ * For any setting other than those defaults for windowBits and memLevel,
+ * the value returned is a conservative worst case for the maximum expansion
+ * resulting from using fixed blocks instead of stored blocks, which deflate
+ * can emit on compressed data for some combinations of the parameters.
+ *
+ * This function could be more sophisticated to provide closer upper bounds
+ * for every combination of windowBits and memLevel, as well as wrap.
+ * But even the conservative upper bound of about 14% expansion does not
+ * seem onerous for output buffer allocation.
+ */
+uLong ZEXPORT deflateBound(strm, sourceLen)
+    z_streamp strm;
+    uLong sourceLen;
+{
+    deflate_state *s;
+    uLong destLen;
+
+    /* conservative upper bound */
+    destLen = sourceLen +
+              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;
+
+    /* if can't get parameters, return conservative bound */
+    if (strm == Z_NULL || strm->state == Z_NULL)
+        return destLen;
+
+    /* if not default parameters, return conservative bound */
+    s = strm->state;
+    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
+        return destLen;
+
+    /* default settings: return tight bound for that case */
+    return compressBound(sourceLen);
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b >> 8));
+    put_byte(s, (Byte)(b & 0xff));
+}
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    unsigned len = strm->state->pending;
+
+    if (len > strm->avail_out) len = strm->avail_out;
+    if (len == 0) return;
+
+    zmemcpy(strm->next_out, strm->state->pending_out, len);
+    strm->next_out  += len;
+    strm->state->pending_out  += len;
+    strm->total_out += len;
+    strm->avail_out  -= len;
+    strm->state->pending -= len;
+    if (strm->state->pending == 0) {
+        strm->state->pending_out = strm->state->pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int ZEXPORT deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        flush > Z_FINISH || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = strm->state;
+
+    if (strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
+        (s->status == FINISH_STATE && flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s->strm = strm; /* just in case */
+    old_flush = s->last_flush;
+    s->last_flush = flush;
+
+    /* Write the header */
+    if (s->status == INIT_STATE) {
+#ifdef GZIP
+        if (s->wrap == 2) {
+            strm->adler = crc32(0L, Z_NULL, 0);
+            put_byte(s, 31);
+            put_byte(s, 139);
+            put_byte(s, 8);
+            if (s->gzhead == NULL) {
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, s->level == 9 ? 2 :
+                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
+                             4 : 0));
+                put_byte(s, OS_CODE);
+                s->status = BUSY_STATE;
+            }
+            else {
+                put_byte(s, (s->gzhead->text ? 1 : 0) +
+                            (s->gzhead->hcrc ? 2 : 0) +
+                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
+                            (s->gzhead->name == Z_NULL ? 0 : 8) +
+                            (s->gzhead->comment == Z_NULL ? 0 : 16)
+                        );
+                put_byte(s, (Byte)(s->gzhead->time & 0xff));
+                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
+                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
+                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
+                put_byte(s, s->level == 9 ? 2 :
+                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
+                             4 : 0));
+                put_byte(s, s->gzhead->os & 0xff);
+                if (s->gzhead->extra != NULL) {
+                    put_byte(s, s->gzhead->extra_len & 0xff);
+                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
+                }
+                if (s->gzhead->hcrc)
+                    strm->adler = crc32(strm->adler, s->pending_buf,
+                                        s->pending);
+                s->gzindex = 0;
+                s->status = EXTRA_STATE;
+            }
+        }
+        else
+#endif
+        {
+            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+            uInt level_flags;
+
+            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
+                level_flags = 0;
+            else if (s->level < 6)
+                level_flags = 1;
+            else if (s->level == 6)
+                level_flags = 2;
+            else
+                level_flags = 3;
+            header |= (level_flags << 6);
+            if (s->strstart != 0) header |= PRESET_DICT;
+            header += 31 - (header % 31);
+
+            s->status = BUSY_STATE;
+            putShortMSB(s, header);
+
+            /* Save the adler32 of the preset dictionary: */
+            if (s->strstart != 0) {
+                putShortMSB(s, (uInt)(strm->adler >> 16));
+                putShortMSB(s, (uInt)(strm->adler & 0xffff));
+            }
+            strm->adler = adler32(0L, Z_NULL, 0);
+        }
+    }
+#ifdef GZIP
+    if (s->status == EXTRA_STATE) {
+        if (s->gzhead->extra != NULL) {
+            uInt beg = s->pending;  /* start of bytes to update crc */
+
+            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
+                if (s->pending == s->pending_buf_size) {
+                    if (s->gzhead->hcrc && s->pending > beg)
+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                            s->pending - beg);
+                    flush_pending(strm);
+                    beg = s->pending;
+                    if (s->pending == s->pending_buf_size)
+                        break;
+                }
+                put_byte(s, s->gzhead->extra[s->gzindex]);
+                s->gzindex++;
+            }
+            if (s->gzhead->hcrc && s->pending > beg)
+                strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                    s->pending - beg);
+            if (s->gzindex == s->gzhead->extra_len) {
+                s->gzindex = 0;
+                s->status = NAME_STATE;
+            }
+        }
+        else
+            s->status = NAME_STATE;
+    }
+    if (s->status == NAME_STATE) {
+        if (s->gzhead->name != NULL) {
+            uInt beg = s->pending;  /* start of bytes to update crc */
+            int val;
+
+            do {
+                if (s->pending == s->pending_buf_size) {
+                    if (s->gzhead->hcrc && s->pending > beg)
+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                            s->pending - beg);
+                    flush_pending(strm);
+                    beg = s->pending;
+                    if (s->pending == s->pending_buf_size) {
+                        val = 1;
+                        break;
+                    }
+                }
+                val = s->gzhead->name[s->gzindex++];
+                put_byte(s, val);
+            } while (val != 0);
+            if (s->gzhead->hcrc && s->pending > beg)
+                strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                    s->pending - beg);
+            if (val == 0) {
+                s->gzindex = 0;
+                s->status = COMMENT_STATE;
+            }
+        }
+        else
+            s->status = COMMENT_STATE;
+    }
+    if (s->status == COMMENT_STATE) {
+        if (s->gzhead->comment != NULL) {
+            uInt beg = s->pending;  /* start of bytes to update crc */
+            int val;
+
+            do {
+                if (s->pending == s->pending_buf_size) {
+                    if (s->gzhead->hcrc && s->pending > beg)
+                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                            s->pending - beg);
+                    flush_pending(strm);
+                    beg = s->pending;
+                    if (s->pending == s->pending_buf_size) {
+                        val = 1;
+                        break;
+                    }
+                }
+                val = s->gzhead->comment[s->gzindex++];
+                put_byte(s, val);
+            } while (val != 0);
+            if (s->gzhead->hcrc && s->pending > beg)
+                strm->adler = crc32(strm->adler, s->pending_buf + beg,
+                                    s->pending - beg);
+            if (val == 0)
+                s->status = HCRC_STATE;
+        }
+        else
+            s->status = HCRC_STATE;
+    }
+    if (s->status == HCRC_STATE) {
+        if (s->gzhead->hcrc) {
+            if (s->pending + 2 > s->pending_buf_size)
+                flush_pending(strm);
+            if (s->pending + 2 <= s->pending_buf_size) {
+                put_byte(s, (Byte)(strm->adler & 0xff));
+                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
+                strm->adler = crc32(0L, Z_NULL, 0);
+                s->status = BUSY_STATE;
+            }
+        }
+        else
+            s->status = BUSY_STATE;
+    }
+#endif
+
+    /* Flush as much pending output as possible */
+    if (s->pending != 0) {
+        flush_pending(strm);
+        if (strm->avail_out == 0) {
+            /* Since avail_out is 0, deflate will be called again with
+             * more output space, but possibly with both pending and
+             * avail_in equal to zero. There won't be anything to do,
+             * but this is not an error situation so make sure we
+             * return OK instead of BUF_ERROR at next call of deflate:
+             */
+            s->last_flush = -1;
+            return Z_OK;
+        }
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUF_ERROR.
+     */
+    } else if (strm->avail_in == 0 && flush <= old_flush &&
+               flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s->status == FINISH_STATE && strm->avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm->avail_in != 0 || s->lookahead != 0 ||
+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
+        block_state bstate;
+
+        bstate = (*(configuration_table[s->level].func))(s, flush);
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s->status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+            if (strm->avail_out == 0) {
+                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
+            }
+            return Z_OK;
+            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+             * of deflate should use the same flush parameter to make sure
+             * that the flush is complete. So we don't have to output an
+             * empty block here, this will be done at next call. This also
+             * ensures that for a very small output buffer, we emit at most
+             * one empty block.
+             */
+        }
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+            } else { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                }
+            }
+            flush_pending(strm);
+            if (strm->avail_out == 0) {
+              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+              return Z_OK;
+            }
+        }
+    }
+    Assert(strm->avail_out > 0, "bug2");
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s->wrap <= 0) return Z_STREAM_END;
+
+    /* Write the trailer */
+#ifdef GZIP
+    if (s->wrap == 2) {
+        put_byte(s, (Byte)(strm->adler & 0xff));
+        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
+        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
+        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
+        put_byte(s, (Byte)(strm->total_in & 0xff));
+        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
+        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
+        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
+    }
+    else
+#endif
+    {
+        putShortMSB(s, (uInt)(strm->adler >> 16));
+        putShortMSB(s, (uInt)(strm->adler & 0xffff));
+    }
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
+    return s->pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+
+    status = strm->state->status;
+    if (status != INIT_STATE &&
+        status != EXTRA_STATE &&
+        status != NAME_STATE &&
+        status != COMMENT_STATE &&
+        status != HCRC_STATE &&
+        status != BUSY_STATE &&
+        status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, strm->state->pending_buf);
+    TRY_FREE(strm, strm->state->head);
+    TRY_FREE(strm, strm->state->prev);
+    TRY_FREE(strm, strm->state->window);
+
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ * To simplify the source, this is not supported for 16-bit MSDOS (which
+ * doesn't have enough memory anyway to duplicate compression states).
+ */
+int ZEXPORT deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+#ifdef MAXSEG_64K
+    return Z_STREAM_ERROR;
+#else
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
+        return Z_STREAM_ERROR;
+    }
+
+    ss = source->state;
+
+    zmemcpy(dest, source, sizeof(z_stream));
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest->state = (struct internal_state FAR *) ds;
+    zmemcpy(ds, ss, sizeof(deflate_state));
+    ds->strm = dest;
+
+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+    ds->pending_buf = (uchf *) overlay;
+
+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
+        ds->pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* following zmemcpy do not work for 16-bit MSDOS */
+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+
+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+
+    ds->l_desc.dyn_tree = ds->dyn_ltree;
+    ds->d_desc.dyn_tree = ds->dyn_dtree;
+    ds->bl_desc.dyn_tree = ds->bl_tree;
+
+    return Z_OK;
+#endif /* MAXSEG_64K */
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    Bytef *buf;
+    unsigned size;
+{
+    unsigned len = strm->avail_in;
+
+    if (len > size) len = size;
+    if (len == 0) return 0;
+
+    strm->avail_in  -= len;
+
+    if (strm->state->wrap == 1) {
+        strm->adler = adler32(strm->adler, strm->next_in, len);
+    }
+#ifdef GZIP
+    else if (strm->state->wrap == 2) {
+        strm->adler = crc32(strm->adler, strm->next_in, len);
+    }
+#endif
+    zmemcpy(buf, strm->next_in, len);
+    strm->next_in  += len;
+    strm->total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s->window_size = (ulg)2L*s->w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s->max_lazy_match   = configuration_table[s->level].max_lazy;
+    s->good_match       = configuration_table[s->level].good_length;
+    s->nice_match       = configuration_table[s->level].nice_length;
+    s->max_chain_length = configuration_table[s->level].max_chain;
+
+    s->strstart = 0;
+    s->block_start = 0L;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    s->ins_h = 0;
+#ifndef FASTEST
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+#endif
+}
+
+#ifndef FASTEST
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s->prev_length;              /* best match length so far */
+    int nice_match = s->nice_match;             /* stop if match long enough */
+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
+        s->strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes <= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s->prev;
+    uInt wmask = s->w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s->prev_length >= s->good_match) {
+        chain_length >>= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    do {
+        Assert(cur_match < s->strstart, "no future");
+        match = s->window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2.  Note that the checks below
+         * for insufficient lookahead only occur occasionally for performance
+         * reasons.  Therefore uninitialized memory will be accessed, and
+         * conditional jumps will be made that depend on those values.
+         * However the length of the match is limited to the lookahead, so
+         * the output of deflate is not affected by the uninitialized values.
+         */
+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], "scan[2]?");
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 scan < strend);
+        /* The funny "do {}" generates better code on most compilers */
+
+        /* Here, scan <= window+strstart+257 */
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS >= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, "match[2]?");
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 scan < strend);
+
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len > best_len) {
+            s->match_start = cur_match;
+            best_len = len;
+            if (len >= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match & wmask]) > limit
+             && --chain_length != 0);
+
+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
+    return s->lookahead;
+}
+#endif /* ASMV */
+#endif /* FASTEST */
+
+/* ---------------------------------------------------------------------------
+ * Optimized version for level == 1 or strategy == Z_RLE only
+ */
+local uInt longest_match_fast(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    Assert(cur_match < s->strstart, "no future");
+
+    match = s->window + cur_match;
+
+    /* Return failure if the match length is less than 2:
+     */
+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS >= 8.
+     */
+    scan += 2, match += 2;
+    Assert(*scan == *match, "match[2]?");
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+    } while (*++scan == *++match && *++scan == *++match &&
+             *++scan == *++match && *++scan == *++match &&
+             *++scan == *++match && *++scan == *++match &&
+             *++scan == *++match && *++scan == *++match &&
+             scan < strend);
+
+    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+    len = MAX_MATCH - (int)(strend - scan);
+
+    if (len < MIN_MATCH) return MIN_MATCH - 1;
+
+    s->match_start = cur_match;
+    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
+}
+
+#ifdef DEBUG
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp(s->window + match,
+                s->window + start, length) != EQUAL) {
+        fprintf(stderr, " start %u, match %u, length %d\n",
+                start, match, length);
+        do {
+            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+        } while (--length != 0);
+        z_error("invalid match");
+    }
+    if (z_verbose > 1) {
+        fprintf(stderr,"\\[%d,%d]", start-match, length);
+        do { putc(s->window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif /* DEBUG */
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s->w_size;
+
+    do {
+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (sizeof(int) <= 2) {
+            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+                more = wsize;
+
+            } else if (more == (unsigned)(-1)) {
+                /* Very unlikely, but possible on 16 bit machine if
+                 * strstart == 0 && lookahead == 1 (input done a byte at time)
+                 */
+                more--;
+            }
+        }
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        if (s->strstart >= wsize+MAX_DIST(s)) {
+
+            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
+            s->match_start -= wsize;
+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            s->block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level > 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+            /* %%% avoid this when Z_RLE */
+            n = s->hash_size;
+            p = &s->head[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+            } while (--n);
+
+            n = wsize;
+#ifndef FASTEST
+            p = &s->prev[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m >= wsize ? m-wsize : NIL);
+                /* If n is not on any hash chain, prev[n] is garbage but
+                 * its value will never be used.
+                 */
+            } while (--n);
+#endif
+            more += wsize;
+        }
+        if (s->strm->avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+         *    more == window_size - lookahead - strstart
+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * => more >= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &&
+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more >= 2.
+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+         */
+        Assert(more >= 2, "more < 2");
+
+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
+        s->lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s->lookahead >= MIN_MATCH) {
+            s->ins_h = s->window[s->strstart];
+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, eof) { \
+   _tr_flush_block(s, (s->block_start >= 0L ? \
+                   (charf *)&s->window[(unsigned)s->block_start] : \
+                   (charf *)Z_NULL), \
+                (ulg)((long)s->strstart - s->block_start), \
+                (eof)); \
+   s->block_start = s->strstart; \
+   flush_pending(s->strm); \
+   Tracev((stderr,"[FLUSH]")); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, eof) { \
+   FLUSH_BLOCK_ONLY(s, eof); \
+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size > s->pending_buf_size - 5) {
+        max_block_size = s->pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s->lookahead <= 1) {
+
+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+                   s->block_start >= (long)s->w_size, "slide too late");
+
+            fill_window(s);
+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+        Assert(s->block_start >= 0L, "block gone");
+
+        s->strstart += s->lookahead;
+        s->lookahead = 0;
+
+        /* Emit a stored block if pending_buf will be full: */
+        max_start = s->block_start + max_block_size;
+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+            /* strstart == 0 is possible when wraparound on 16-bit machine */
+            s->lookahead = (uInt)(s->strstart - max_start);
+            s->strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+        }
+        /* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+        }
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL; /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         * At this point we have always match_length < MIN_MATCH
+         */
+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+#ifdef FASTEST
+            if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||
+                (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {
+                s->match_length = longest_match_fast (s, hash_head);
+            }
+#else
+            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
+                s->match_length = longest_match (s, hash_head);
+            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
+                s->match_length = longest_match_fast (s, hash_head);
+            }
+#endif
+            /* longest_match() or longest_match_fast() sets match_start */
+        }
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->match_start, s->match_length);
+
+            _tr_tally_dist(s, s->strstart - s->match_start,
+                           s->match_length - MIN_MATCH, bflush);
+
+            s->lookahead -= s->match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+#ifndef FASTEST
+            if (s->match_length <= s->max_insert_length &&
+                s->lookahead >= MIN_MATCH) {
+                s->match_length--; /* string at strstart already in table */
+                do {
+                    s->strstart++;
+                    INSERT_STRING(s, s->strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s->match_length != 0);
+                s->strstart++;
+            } else
+#endif
+            {
+                s->strstart += s->match_length;
+                s->match_length = 0;
+                s->ins_h = s->window[s->strstart];
+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            _tr_tally_lit (s, s->window[s->strstart], bflush);
+            s->lookahead--;
+            s->strstart++;
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+#ifndef FASTEST
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL;    /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         */
+        s->prev_length = s->match_length, s->prev_match = s->match_start;
+        s->match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
+            s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
+                s->match_length = longest_match (s, hash_head);
+            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
+                s->match_length = longest_match_fast (s, hash_head);
+            }
+            /* longest_match() or longest_match_fast() sets match_start */
+
+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
+#if TOO_FAR <= 32767
+                || (s->match_length == MIN_MATCH &&
+                    s->strstart - s->match_start > TOO_FAR)
+#endif
+                )) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s->match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+
+            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
+                           s->prev_length - MIN_MATCH, bflush);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s->lookahead -= s->prev_length-1;
+            s->prev_length -= 2;
+            do {
+                if (++s->strstart <= max_insert) {
+                    INSERT_STRING(s, s->strstart, hash_head);
+                }
+            } while (--s->prev_length != 0);
+            s->match_available = 0;
+            s->match_length = MIN_MATCH-1;
+            s->strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s->match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,"%c", s->window[s->strstart-1]));
+            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+            if (bflush) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s->strstart++;
+            s->lookahead--;
+            if (s->strm->avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s->match_available = 1;
+            s->strstart++;
+            s->lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, "no flush?");
+    if (s->match_available) {
+        Tracevv((stderr,"%c", s->window[s->strstart-1]));
+        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+        s->match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+#endif /* FASTEST */
+
+#if 0
+/* ===========================================================================
+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance
+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of
+ * deflate switches away from Z_RLE.)
+ */
+local block_state deflate_rle(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    int bflush;         /* set if current block must be flushed */
+    uInt run;           /* length of run */
+    uInt max;           /* maximum length of run */
+    uInt prev;          /* byte at distance one to match */
+    Bytef *scan;        /* scan for end of run */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the longest encodable run.
+         */
+        if (s->lookahead < MAX_MATCH) {
+            fill_window(s);
+            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* See how many times the previous byte repeats */
+        run = 0;
+        if (s->strstart > 0) {      /* if there is a previous byte, that is */
+            max = s->lookahead < MAX_MATCH ? s->lookahead : MAX_MATCH;
+            scan = s->window + s->strstart - 1;
+            prev = *scan++;
+            do {
+                if (*scan++ != prev)
+                    break;
+            } while (++run < max);
+        }
+
+        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
+        if (run >= MIN_MATCH) {
+            check_match(s, s->strstart, s->strstart - 1, run);
+            _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
+            s->lookahead -= run;
+            s->strstart += run;
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            _tr_tally_lit (s, s->window[s->strstart], bflush);
+            s->lookahead--;
+            s->strstart++;
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+#endif
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/deflate.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,355 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-2004 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef DEFLATE_H
+#define DEFLATE_H
+
+#include "zutil.h"
+
+/* define NO_GZIP when compiling if you want to disable gzip header and
+   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
+   the crc code when it is not needed.  For shared libraries, gzip encoding
+   should be left enabled. */
+#ifndef NO_GZIP
+#  define GZIP
+#endif
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define EXTRA_STATE   69
+#define NAME_STATE    73
+#define COMMENT_STATE 91
+#define HCRC_STATE   103
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct internal_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    uInt   pending;      /* nb of bytes in the pending buffer */
+    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
+    gz_headerp  gzhead;  /* gzip header information to write */
+    uInt   gzindex;      /* where in extra, name, or comment */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH >= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels >= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels <= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG
+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+        /* in trees.c */
+void _tr_init         OF((deflate_state *s));
+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
+void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+void _tr_align        OF((deflate_state *s));
+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+
+#define d_code(dist) \
+   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. _dist_code[256] and _dist_code[257] are never
+ * used.
+ */
+
+#ifndef DEBUG
+/* Inline versions of _tr_tally for speed: */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+  extern uch _length_code[];
+  extern uch _dist_code[];
+#else
+  extern const uch _length_code[];
+  extern const uch _dist_code[];
+#endif
+
+# define _tr_tally_lit(s, c, flush) \
+  { uch cc = (c); \
+    s->d_buf[s->last_lit] = 0; \
+    s->l_buf[s->last_lit++] = cc; \
+    s->dyn_ltree[cc].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+   }
+# define _tr_tally_dist(s, distance, length, flush) \
+  { uch len = (length); \
+    ush dist = (distance); \
+    s->d_buf[s->last_lit] = dist; \
+    s->l_buf[s->last_lit++] = len; \
+    dist--; \
+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
+    s->dyn_dtree[d_code(dist)].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+  }
+#else
+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
+# define _tr_tally_dist(s, distance, length, flush) \
+              flush = _tr_tally(s, distance, length)
+#endif
+
+#endif /* DEFLATE_H */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/gzio.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,1050 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* gzio.c -- IO on .gz files
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.
+ */
+
+/* @(#) $Id$ */
+
+#include <stdio.h>
+
+#include "zutil.h"
+
+#ifdef NO_DEFLATE       /* for compatibility with old definition */
+#  define NO_GZCOMPRESS
+#endif
+
+#ifndef NO_DUMMY_DECL
+struct internal_state {int dummy;}; /* for buggy compilers */
+#endif
+
+#ifndef Z_BUFSIZE
+#  ifdef MAXSEG_64K
+#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
+#  else
+#    define Z_BUFSIZE 16384
+#  endif
+#endif
+#ifndef Z_PRINTF_BUFSIZE
+#  define Z_PRINTF_BUFSIZE 4096
+#endif
+
+#ifdef __MVS__
+#  pragma map (fdopen , "\174\174FDOPEN")
+   FILE *fdopen(int, const char *);
+#endif
+
+#ifndef STDC
+extern voidp  malloc OF((uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+#define ALLOC(size) malloc(size)
+#define TRYFREE(p) {if (p) free(p);}
+
+static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
+#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define RESERVED     0xE0 /* bits 5..7: reserved */
+
+typedef struct gz_stream {
+    z_stream stream;
+    int      z_err;   /* error code for last stream operation */
+    int      z_eof;   /* set if end of input file */
+    FILE     *file;   /* .gz file */
+    Byte     *inbuf;  /* input buffer */
+    Byte     *outbuf; /* output buffer */
+    uLong    crc;     /* crc32 of uncompressed data */
+    char     *msg;    /* error message */
+    char     *path;   /* path name for debugging only */
+    int      transparent; /* 1 if input file is not a .gz file */
+    char     mode;    /* 'w' or 'r' */
+    z_off_t  start;   /* start of compressed data in file (header skipped) */
+    z_off_t  in;      /* bytes into deflate or inflate */
+    z_off_t  out;     /* bytes out of deflate or inflate */
+    int      back;    /* one character push-back */
+    int      last;    /* true if push-back is last character */
+} gz_stream;
+
+
+local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
+local int do_flush        OF((gzFile file, int flush));
+local int    get_byte     OF((gz_stream *s));
+local void   check_header OF((gz_stream *s));
+local int    destroy      OF((gz_stream *s));
+local void   putLong      OF((FILE *file, uLong x));
+local uLong  getLong      OF((gz_stream *s));
+
+/* ===========================================================================
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
+   or path name (if fd == -1).
+     gz_open returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).
+*/
+local gzFile gz_open (path, mode, fd)
+    const char *path;
+    const char *mode;
+    int  fd;
+{
+    int err;
+    int level = Z_DEFAULT_COMPRESSION; /* compression level */
+    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
+    char *p = (char*)mode;
+    gz_stream *s;
+    char fmode[80]; /* copy of mode, without the compression level */
+    char *m = fmode;
+
+    if (!path || !mode) return Z_NULL;
+
+    s = (gz_stream *)ALLOC(sizeof(gz_stream));
+    if (!s) return Z_NULL;
+
+    s->stream.zalloc = (alloc_func)0;
+    s->stream.zfree = (free_func)0;
+    s->stream.opaque = (voidpf)0;
+    s->stream.next_in = s->inbuf = Z_NULL;
+    s->stream.next_out = s->outbuf = Z_NULL;
+    s->stream.avail_in = s->stream.avail_out = 0;
+    s->file = NULL;
+    s->z_err = Z_OK;
+    s->z_eof = 0;
+    s->in = 0;
+    s->out = 0;
+    s->back = EOF;
+    s->crc = crc32(0L, Z_NULL, 0);
+    s->msg = NULL;
+    s->transparent = 0;
+
+    s->path = (char*)ALLOC(strlen(path)+1);
+    if (s->path == NULL) {
+        return destroy(s), (gzFile)Z_NULL;
+    }
+    strcpy(s->path, path); /* do this early for debugging */
+
+    s->mode = '\0';
+    do {
+        if (*p == 'r') s->mode = 'r';
+        if (*p == 'w' || *p == 'a') s->mode = 'w';
+        if (*p >= '0' && *p <= '9') {
+            level = *p - '0';
+        } else if (*p == 'f') {
+          strategy = Z_FILTERED;
+        } else if (*p == 'h') {
+          strategy = Z_HUFFMAN_ONLY;
+        } else if (*p == 'R') {
+          strategy = Z_RLE;
+        } else {
+            *m++ = *p; /* copy the mode */
+        }
+    } while (*p++ && m != fmode + sizeof(fmode));
+    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
+
+    if (s->mode == 'w') {
+#ifdef NO_GZCOMPRESS
+        err = Z_STREAM_ERROR;
+#else
+        err = deflateInit2(&(s->stream), level,
+                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
+        /* windowBits is passed < 0 to suppress zlib header */
+
+        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+#endif
+        if (err != Z_OK || s->outbuf == Z_NULL) {
+            return destroy(s), (gzFile)Z_NULL;
+        }
+    } else {
+        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
+
+        err = inflateInit2(&(s->stream), -MAX_WBITS);
+        /* windowBits is passed < 0 to tell that there is no zlib header.
+         * Note that in this case inflate *requires* an extra "dummy" byte
+         * after the compressed stream in order to complete decompression and
+         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
+         * present after the compressed stream.
+         */
+        if (err != Z_OK || s->inbuf == Z_NULL) {
+            return destroy(s), (gzFile)Z_NULL;
+        }
+    }
+    s->stream.avail_out = Z_BUFSIZE;
+
+    errno = 0;
+    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
+
+    if (s->file == NULL) {
+        return destroy(s), (gzFile)Z_NULL;
+    }
+    if (s->mode == 'w') {
+        /* Write a very simple .gz header:
+         */
+        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
+             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
+        s->start = 10L;
+        /* We use 10L instead of ftell(s->file) to because ftell causes an
+         * fflush on some systems. This version of the library doesn't use
+         * start anyway in write mode, so this initialization is not
+         * necessary.
+         */
+    } else {
+        check_header(s); /* skip the .gz header */
+        s->start = ftell(s->file) - s->stream.avail_in;
+    }
+
+    return (gzFile)s;
+}
+
+/* ===========================================================================
+     Opens a gzip (.gz) file for reading or writing.
+*/
+gzFile ZEXPORT gzopen (path, mode)
+    const char *path;
+    const char *mode;
+{
+    return gz_open (path, mode, -1);
+}
+
+/* ===========================================================================
+     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
+   to mimic the behavio(u)r of fdopen.
+*/
+gzFile ZEXPORT gzdopen (fd, mode)
+    int fd;
+    const char *mode;
+{
+    char name[46];      /* allow for up to 128-bit integers */
+
+    if (fd < 0) return (gzFile)Z_NULL;
+    sprintf(name, "<fd:%d>", fd); /* for debugging */
+
+    return gz_open (name, mode, fd);
+}
+
+/* ===========================================================================
+ * Update the compression level and strategy
+ */
+int ZEXPORT gzsetparams (file, level, strategy)
+    gzFile file;
+    int level;
+    int strategy;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    /* Make room to allow flushing */
+    if (s->stream.avail_out == 0) {
+
+        s->stream.next_out = s->outbuf;
+        if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
+            s->z_err = Z_ERRNO;
+        }
+        s->stream.avail_out = Z_BUFSIZE;
+    }
+
+    return deflateParams (&(s->stream), level, strategy);
+}
+
+/* ===========================================================================
+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
+   for end of file.
+   IN assertion: the stream s has been sucessfully opened for reading.
+*/
+local int get_byte(s)
+    gz_stream *s;
+{
+    if (s->z_eof) return EOF;
+    if (s->stream.avail_in == 0) {
+        errno = 0;
+        s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
+        if (s->stream.avail_in == 0) {
+            s->z_eof = 1;
+            if (ferror(s->file)) s->z_err = Z_ERRNO;
+            return EOF;
+        }
+        s->stream.next_in = s->inbuf;
+    }
+    s->stream.avail_in--;
+    return *(s->stream.next_in)++;
+}
+
+/* ===========================================================================
+      Check the gzip header of a gz_stream opened for reading. Set the stream
+    mode to transparent if the gzip magic header is not present; set s->err
+    to Z_DATA_ERROR if the magic header is present but the rest of the header
+    is incorrect.
+    IN assertion: the stream s has already been created sucessfully;
+       s->stream.avail_in is zero for the first time, but may be non-zero
+       for concatenated .gz files.
+*/
+local void check_header(s)
+    gz_stream *s;
+{
+    int method; /* method byte */
+    int flags;  /* flags byte */
+    uInt len;
+    int c;
+
+    /* Assure two bytes in the buffer so we can peek ahead -- handle case
+       where first byte of header is at the end of the buffer after the last
+       gzip segment */
+    len = s->stream.avail_in;
+    if (len < 2) {
+        if (len) s->inbuf[0] = s->stream.next_in[0];
+        errno = 0;
+        len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);
+        if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;
+        s->stream.avail_in += len;
+        s->stream.next_in = s->inbuf;
+        if (s->stream.avail_in < 2) {
+            s->transparent = s->stream.avail_in;
+            return;
+        }
+    }
+
+    /* Peek ahead to check the gzip magic header */
+    if (s->stream.next_in[0] != gz_magic[0] ||
+        s->stream.next_in[1] != gz_magic[1]) {
+        s->transparent = 1;
+        return;
+    }
+    s->stream.avail_in -= 2;
+    s->stream.next_in += 2;
+
+    /* Check the rest of the gzip header */
+    method = get_byte(s);
+    flags = get_byte(s);
+    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
+        s->z_err = Z_DATA_ERROR;
+        return;
+    }
+
+    /* Discard time, xflags and OS code: */
+    for (len = 0; len < 6; len++) (void)get_byte(s);
+
+    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
+        len  =  (uInt)get_byte(s);
+        len += ((uInt)get_byte(s))<<8;
+        /* len is garbage if EOF but the loop below will quit anyway */
+        while (len-- != 0 && get_byte(s) != EOF) ;
+    }
+    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
+        while ((c = get_byte(s)) != 0 && c != EOF) ;
+    }
+    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
+        while ((c = get_byte(s)) != 0 && c != EOF) ;
+    }
+    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
+        for (len = 0; len < 2; len++) (void)get_byte(s);
+    }
+    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
+}
+
+ /* ===========================================================================
+ * Cleanup then free the given gz_stream. Return a zlib error code.
+   Try freeing in the reverse order of allocations.
+ */
+local int destroy (s)
+    gz_stream *s;
+{
+    int err = Z_OK;
+
+    if (!s) return Z_STREAM_ERROR;
+
+    TRYFREE(s->msg);
+
+    if (s->stream.state != NULL) {
+        if (s->mode == 'w') {
+#ifdef NO_GZCOMPRESS
+            err = Z_STREAM_ERROR;
+#else
+            err = deflateEnd(&(s->stream));
+#endif
+        } else if (s->mode == 'r') {
+            err = inflateEnd(&(s->stream));
+        }
+    }
+    if (s->file != NULL && fclose(s->file)) {
+#ifdef ESPIPE
+        if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
+#endif
+            err = Z_ERRNO;
+    }
+    if (s->z_err < 0) err = s->z_err;
+
+    TRYFREE(s->inbuf);
+    TRYFREE(s->outbuf);
+    TRYFREE(s->path);
+    TRYFREE(s);
+    return err;
+}
+
+/* ===========================================================================
+     Reads the given number of uncompressed bytes from the compressed file.
+   gzread returns the number of bytes actually read (0 for end of file).
+*/
+int ZEXPORT gzread (file, buf, len)
+    gzFile file;
+    voidp buf;
+    unsigned len;
+{
+    gz_stream *s = (gz_stream*)file;
+    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
+    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
+
+    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
+
+    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
+    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
+
+    next_out = (Byte*)buf;
+    s->stream.next_out = (Bytef*)buf;
+    s->stream.avail_out = len;
+
+    if (s->stream.avail_out && s->back != EOF) {
+        *next_out++ = s->back;
+        s->stream.next_out++;
+        s->stream.avail_out--;
+        s->back = EOF;
+        s->out++;
+        start++;
+        if (s->last) {
+            s->z_err = Z_STREAM_END;
+            return 1;
+        }
+    }
+
+    while (s->stream.avail_out != 0) {
+
+        if (s->transparent) {
+            /* Copy first the lookahead bytes: */
+            uInt n = s->stream.avail_in;
+            if (n > s->stream.avail_out) n = s->stream.avail_out;
+            if (n > 0) {
+                zmemcpy(s->stream.next_out, s->stream.next_in, n);
+                next_out += n;
+                s->stream.next_out = next_out;
+                s->stream.next_in   += n;
+                s->stream.avail_out -= n;
+                s->stream.avail_in  -= n;
+            }
+            if (s->stream.avail_out > 0) {
+                s->stream.avail_out -=
+                    (uInt)fread(next_out, 1, s->stream.avail_out, s->file);
+            }
+            len -= s->stream.avail_out;
+            s->in  += len;
+            s->out += len;
+            if (len == 0) s->z_eof = 1;
+            return (int)len;
+        }
+        if (s->stream.avail_in == 0 && !s->z_eof) {
+
+            errno = 0;
+            s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
+            if (s->stream.avail_in == 0) {
+                s->z_eof = 1;
+                if (ferror(s->file)) {
+                    s->z_err = Z_ERRNO;
+                    break;
+                }
+            }
+            s->stream.next_in = s->inbuf;
+        }
+        s->in += s->stream.avail_in;
+        s->out += s->stream.avail_out;
+        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
+        s->in -= s->stream.avail_in;
+        s->out -= s->stream.avail_out;
+
+        if (s->z_err == Z_STREAM_END) {
+            /* Check CRC and original size */
+            s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+            start = s->stream.next_out;
+
+            if (getLong(s) != s->crc) {
+                s->z_err = Z_DATA_ERROR;
+            } else {
+                (void)getLong(s);
+                /* The uncompressed length returned by above getlong() may be
+                 * different from s->out in case of concatenated .gz files.
+                 * Check for such files:
+                 */
+                check_header(s);
+                if (s->z_err == Z_OK) {
+                    inflateReset(&(s->stream));
+                    s->crc = crc32(0L, Z_NULL, 0);
+                }
+            }
+        }
+        if (s->z_err != Z_OK || s->z_eof) break;
+    }
+    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+
+    if (len == s->stream.avail_out &&
+        (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))
+        return -1;
+    return (int)(len - s->stream.avail_out);
+}
+
+
+/* ===========================================================================
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+int ZEXPORT gzgetc(file)
+    gzFile file;
+{
+    unsigned char c;
+
+    return gzread(file, &c, 1) == 1 ? c : -1;
+}
+
+
+/* ===========================================================================
+      Push one byte back onto the stream.
+*/
+int ZEXPORT gzungetc(c, file)
+    int c;
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;
+    s->back = c;
+    s->out--;
+    s->last = (s->z_err == Z_STREAM_END);
+    if (s->last) s->z_err = Z_OK;
+    s->z_eof = 0;
+    return c;
+}
+
+
+/* ===========================================================================
+      Reads bytes from the compressed file until len-1 characters are
+   read, or a newline character is read and transferred to buf, or an
+   end-of-file condition is encountered.  The string is then terminated
+   with a null character.
+      gzgets returns buf, or Z_NULL in case of error.
+
+      The current implementation is not optimized at all.
+*/
+char * ZEXPORT gzgets(file, buf, len)
+    gzFile file;
+    char *buf;
+    int len;
+{
+    char *b = buf;
+    if (buf == Z_NULL || len <= 0) return Z_NULL;
+
+    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
+    *buf = '\0';
+    return b == buf && len > 0 ? Z_NULL : b;
+}
+
+
+#ifndef NO_GZCOMPRESS
+/* ===========================================================================
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of bytes actually written (0 in case of error).
+*/
+int ZEXPORT gzwrite (file, buf, len)
+    gzFile file;
+    voidpc buf;
+    unsigned len;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    s->stream.next_in = (Bytef*)buf;
+    s->stream.avail_in = len;
+
+    while (s->stream.avail_in != 0) {
+
+        if (s->stream.avail_out == 0) {
+
+            s->stream.next_out = s->outbuf;
+            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
+                s->z_err = Z_ERRNO;
+                break;
+            }
+            s->stream.avail_out = Z_BUFSIZE;
+        }
+        s->in += s->stream.avail_in;
+        s->out += s->stream.avail_out;
+        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
+        s->in -= s->stream.avail_in;
+        s->out -= s->stream.avail_out;
+        if (s->z_err != Z_OK) break;
+    }
+    s->crc = crc32(s->crc, (const Bytef *)buf, len);
+
+    return (int)(len - s->stream.avail_in);
+}
+
+
+/* ===========================================================================
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).
+*/
+#ifdef STDC
+#include <stdarg.h>
+
+int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
+{
+    char buf[Z_PRINTF_BUFSIZE];
+    va_list va;
+    int len;
+
+    buf[sizeof(buf) - 1] = 0;
+    va_start(va, format);
+#ifdef NO_vsnprintf
+#  ifdef HAS_vsprintf_void
+    (void)vsprintf(buf, format, va);
+    va_end(va);
+    for (len = 0; len < sizeof(buf); len++)
+        if (buf[len] == 0) break;
+#  else
+    len = vsprintf(buf, format, va);
+    va_end(va);
+#  endif
+#else
+#  ifdef HAS_vsnprintf_void
+    (void)vsnprintf(buf, sizeof(buf), format, va);
+    va_end(va);
+    len = strlen(buf);
+#  else
+    len = vsnprintf(buf, sizeof(buf), format, va);
+    va_end(va);
+#  endif
+#endif
+    if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)
+        return 0;
+    return gzwrite(file, buf, (unsigned)len);
+}
+#else /* not ANSI C */
+
+int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
+    gzFile file;
+    const char *format;
+    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
+{
+    char buf[Z_PRINTF_BUFSIZE];
+    int len;
+
+    buf[sizeof(buf) - 1] = 0;
+#ifdef NO_snprintf
+#  ifdef HAS_sprintf_void
+    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
+            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+    for (len = 0; len < sizeof(buf); len++)
+        if (buf[len] == 0) break;
+#  else
+    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
+                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+#  endif
+#else
+#  ifdef HAS_snprintf_void
+    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
+             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+    len = strlen(buf);
+#  else
+    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
+                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+#  endif
+#endif
+    if (len <= 0 || len >= sizeof(buf) || buf[sizeof(buf) - 1] != 0)
+        return 0;
+    return gzwrite(file, buf, len);
+}
+#endif
+
+/* ===========================================================================
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+int ZEXPORT gzputc(file, c)
+    gzFile file;
+    int c;
+{
+    unsigned char cc = (unsigned char) c; /* required for big endian systems */
+
+    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
+}
+
+
+/* ===========================================================================
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+int ZEXPORT gzputs(file, s)
+    gzFile file;
+    const char *s;
+{
+    return gzwrite(file, (char*)s, (unsigned)strlen(s));
+}
+
+
+/* ===========================================================================
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function.
+*/
+local int do_flush (file, flush)
+    gzFile file;
+    int flush;
+{
+    uInt len;
+    int done = 0;
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    s->stream.avail_in = 0; /* should be zero already anyway */
+
+    for (;;) {
+        len = Z_BUFSIZE - s->stream.avail_out;
+
+        if (len != 0) {
+            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
+                s->z_err = Z_ERRNO;
+                return Z_ERRNO;
+            }
+            s->stream.next_out = s->outbuf;
+            s->stream.avail_out = Z_BUFSIZE;
+        }
+        if (done) break;
+        s->out += s->stream.avail_out;
+        s->z_err = deflate(&(s->stream), flush);
+        s->out -= s->stream.avail_out;
+
+        /* Ignore the second of two consecutive flushes: */
+        if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
+
+        /* deflate has finished flushing only when it hasn't used up
+         * all the available space in the output buffer:
+         */
+        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
+
+        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
+    }
+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
+}
+
+int ZEXPORT gzflush (file, flush)
+     gzFile file;
+     int flush;
+{
+    gz_stream *s = (gz_stream*)file;
+    int err = do_flush (file, flush);
+
+    if (err) return err;
+    fflush(s->file);
+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
+}
+#endif /* NO_GZCOMPRESS */
+
+/* ===========================================================================
+      Sets the starting position for the next gzread or gzwrite on the given
+   compressed file. The offset represents a number of bytes in the
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error.
+      SEEK_END is not implemented, returns error.
+      In this version of the library, gzseek can be extremely slow.
+*/
+z_off_t ZEXPORT gzseek (file, offset, whence)
+    gzFile file;
+    z_off_t offset;
+    int whence;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || whence == SEEK_END ||
+        s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
+        return -1L;
+    }
+
+    if (s->mode == 'w') {
+#ifdef NO_GZCOMPRESS
+        return -1L;
+#else
+        if (whence == SEEK_SET) {
+            offset -= s->in;
+        }
+        if (offset < 0) return -1L;
+
+        /* At this point, offset is the number of zero bytes to write. */
+        if (s->inbuf == Z_NULL) {
+            s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
+            if (s->inbuf == Z_NULL) return -1L;
+            zmemzero(s->inbuf, Z_BUFSIZE);
+        }
+        while (offset > 0)  {
+            uInt size = Z_BUFSIZE;
+            if (offset < Z_BUFSIZE) size = (uInt)offset;
+
+            size = gzwrite(file, s->inbuf, size);
+            if (size == 0) return -1L;
+
+            offset -= size;
+        }
+        return s->in;
+#endif
+    }
+    /* Rest of function is for reading only */
+
+    /* compute absolute position */
+    if (whence == SEEK_CUR) {
+        offset += s->out;
+    }
+    if (offset < 0) return -1L;
+
+    if (s->transparent) {
+        /* map to fseek */
+        s->back = EOF;
+        s->stream.avail_in = 0;
+        s->stream.next_in = s->inbuf;
+        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;
+
+        s->in = s->out = offset;
+        return offset;
+    }
+
+    /* For a negative seek, rewind and use positive seek */
+    if (offset >= s->out) {
+        offset -= s->out;
+    } else if (gzrewind(file) < 0) {
+        return -1L;
+    }
+    /* offset is now the number of bytes to skip. */
+
+    if (offset != 0 && s->outbuf == Z_NULL) {
+        s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+        if (s->outbuf == Z_NULL) return -1L;
+    }
+    if (offset && s->back != EOF) {
+        s->back = EOF;
+        s->out++;
+        offset--;
+        if (s->last) s->z_err = Z_STREAM_END;
+    }
+    while (offset > 0)  {
+        int size = Z_BUFSIZE;
+        if (offset < Z_BUFSIZE) size = (int)offset;
+
+        size = gzread(file, s->outbuf, (uInt)size);
+        if (size <= 0) return -1L;
+        offset -= size;
+    }
+    return s->out;
+}
+
+/* ===========================================================================
+     Rewinds input file.
+*/
+int ZEXPORT gzrewind (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'r') return -1;
+
+    s->z_err = Z_OK;
+    s->z_eof = 0;
+    s->back = EOF;
+    s->stream.avail_in = 0;
+    s->stream.next_in = s->inbuf;
+    s->crc = crc32(0L, Z_NULL, 0);
+    if (!s->transparent) (void)inflateReset(&s->stream);
+    s->in = 0;
+    s->out = 0;
+    return fseek(s->file, s->start, SEEK_SET);
+}
+
+/* ===========================================================================
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+*/
+z_off_t ZEXPORT gztell (file)
+    gzFile file;
+{
+    return gzseek(file, 0L, SEEK_CUR);
+}
+
+/* ===========================================================================
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+int ZEXPORT gzeof (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    /* With concatenated compressed files that can have embedded
+     * crc trailers, z_eof is no longer the only/best indicator of EOF
+     * on a gz_stream. Handle end-of-stream error explicitly here.
+     */
+    if (s == NULL || s->mode != 'r') return 0;
+    if (s->z_eof) return 1;
+    return s->z_err == Z_STREAM_END;
+}
+
+/* ===========================================================================
+     Returns 1 if reading and doing so transparently, otherwise zero.
+*/
+int ZEXPORT gzdirect (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'r') return 0;
+    return s->transparent;
+}
+
+/* ===========================================================================
+   Outputs a long in LSB order to the given file
+*/
+local void putLong (file, x)
+    FILE *file;
+    uLong x;
+{
+    int n;
+    for (n = 0; n < 4; n++) {
+        fputc((int)(x & 0xff), file);
+        x >>= 8;
+    }
+}
+
+/* ===========================================================================
+   Reads a long in LSB order from the given gz_stream. Sets z_err in case
+   of error.
+*/
+local uLong getLong (s)
+    gz_stream *s;
+{
+    uLong x = (uLong)get_byte(s);
+    int c;
+
+    x += ((uLong)get_byte(s))<<8;
+    x += ((uLong)get_byte(s))<<16;
+    c = get_byte(s);
+    if (c == EOF) s->z_err = Z_DATA_ERROR;
+    x += ((uLong)c)<<24;
+    return x;
+}
+
+/* ===========================================================================
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state.
+*/
+int ZEXPORT gzclose (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL) return Z_STREAM_ERROR;
+
+    if (s->mode == 'w') {
+#ifdef NO_GZCOMPRESS
+        return Z_STREAM_ERROR;
+#else
+        if (do_flush (file, Z_FINISH) != Z_OK)
+            return destroy((gz_stream*)file);
+
+        putLong (s->file, s->crc);
+        putLong (s->file, (uLong)(s->in & 0xffffffff));
+#endif
+    }
+    return destroy((gz_stream*)file);
+}
+
+#ifdef STDC
+#  define zstrerror(errnum) strerror(errnum)
+#else
+#  define zstrerror(errnum) ""
+#endif
+
+/* ===========================================================================
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+const char * ZEXPORT gzerror (file, errnum)
+    gzFile file;
+    int *errnum;
+{
+    char *m;
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL) {
+        *errnum = Z_STREAM_ERROR;
+        return (const char*)ERR_MSG(Z_STREAM_ERROR);
+    }
+    *errnum = s->z_err;
+    if (*errnum == Z_OK) return (const char*)"";
+
+    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
+
+    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
+
+    TRYFREE(s->msg);
+    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
+    if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);
+    strcpy(s->msg, s->path);
+    strcat(s->msg, ": ");
+    strcat(s->msg, m);
+    return (const char*)s->msg;
+}
+
+/* ===========================================================================
+     Clear the error and end-of-file flags, and do the same for the real file.
+*/
+void ZEXPORT gzclearerr (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL) return;
+    if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;
+    s->z_eof = 0;
+    clearerr(s->file);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/infback.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,647 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* infback.c -- inflate using a call-back interface
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+   This code is largely copied from inflate.c.  Normally either infback.o or
+   inflate.o would be linked into an application--not both.  The interface
+   with inffast.c is retained so that optimized assembler-coded versions of
+   inflate_fast() can be used with either inflate.c or infback.c.
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "inflate.h"
+#include "inffast.h"
+
+/* function prototypes */
+local void fixedtables OF((struct inflate_state FAR *state));
+
+/*
+   strm provides memory allocation functions in zalloc and zfree, or
+   Z_NULL to use the library memory allocation functions.
+
+   windowBits is in the range 8..15, and window is a user-supplied
+   window and output buffer that is 2**windowBits bytes.
+ */
+int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
+z_streamp strm;
+int windowBits;
+unsigned char FAR *window;
+const char *version;
+int stream_size;
+{
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL || window == Z_NULL ||
+        windowBits < 8 || windowBits > 15)
+        return Z_STREAM_ERROR;
+    strm->msg = Z_NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0) {
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
+                                               sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, "inflate: allocated\n"));
+    strm->state = (struct internal_state FAR *)state;
+    state->dmax = 32768U;
+    state->wbits = windowBits;
+    state->wsize = 1U << windowBits;
+    state->window = window;
+    state->write = 0;
+    state->whave = 0;
+    return Z_OK;
+}
+
+/*
+   Return state with length and distance decoding tables and index sizes set to
+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+   If BUILDFIXED is defined, then instead this routine builds the tables the
+   first time it's called, and returns those tables the first time and
+   thereafter.  This reduces the size of the code by about 2K bytes, in
+   exchange for a little execution time.  However, BUILDFIXED should not be
+   used for threaded applications, since the rewriting of the tables and virgin
+   may not be thread-safe.
+ */
+local void fixedtables(state)
+struct inflate_state FAR *state;
+{
+#ifdef BUILDFIXED
+    static int virgin = 1;
+    static code *lenfix, *distfix;
+    static code fixed[544];
+
+    /* build fixed huffman tables if first call (may not be thread safe) */
+    if (virgin) {
+        unsigned sym, bits;
+        static code *next;
+
+        /* literal/length table */
+        sym = 0;
+        while (sym < 144) state->lens[sym++] = 8;
+        while (sym < 256) state->lens[sym++] = 9;
+        while (sym < 280) state->lens[sym++] = 7;
+        while (sym < 288) state->lens[sym++] = 8;
+        next = fixed;
+        lenfix = next;
+        bits = 9;
+        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
+
+        /* distance table */
+        sym = 0;
+        while (sym < 32) state->lens[sym++] = 5;
+        distfix = next;
+        bits = 5;
+        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
+
+        /* do this just once */
+        virgin = 0;
+    }
+#else /* !BUILDFIXED */
+#   include "inffixed.h"
+#endif /* BUILDFIXED */
+    state->lencode = lenfix;
+    state->lenbits = 9;
+    state->distcode = distfix;
+    state->distbits = 5;
+}
+
+/* Macros for inflateBack(): */
+
+/* Load returned state from inflate_fast() */
+#define LOAD() \
+    do { \
+        put = strm->next_out; \
+        left = strm->avail_out; \
+        next = strm->next_in; \
+        have = strm->avail_in; \
+        hold = state->hold; \
+        bits = state->bits; \
+    } while (0)
+
+/* Set state from registers for inflate_fast() */
+#define RESTORE() \
+    do { \
+        strm->next_out = put; \
+        strm->avail_out = left; \
+        strm->next_in = next; \
+        strm->avail_in = have; \
+        state->hold = hold; \
+        state->bits = bits; \
+    } while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+    do { \
+        hold = 0; \
+        bits = 0; \
+    } while (0)
+
+/* Assure that some input is available.  If input is requested, but denied,
+   then return a Z_BUF_ERROR from inflateBack(). */
+#define PULL() \
+    do { \
+        if (have == 0) { \
+            have = in(in_desc, &next); \
+            if (have == 0) { \
+                next = Z_NULL; \
+                ret = Z_BUF_ERROR; \
+                goto inf_leave; \
+            } \
+        } \
+    } while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflateBack()
+   with an error if there is no input available. */
+#define PULLBYTE() \
+    do { \
+        PULL(); \
+        have--; \
+        hold += (unsigned long)(*next++) << bits; \
+        bits += 8; \
+    } while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflateBack() with
+   an error. */
+#define NEEDBITS(n) \
+    do { \
+        while (bits < (unsigned)(n)) \
+            PULLBYTE(); \
+    } while (0)
+
+/* Return the low n bits of the bit accumulator (n < 16) */
+#define BITS(n) \
+    ((unsigned)hold & ((1U << (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+    do { \
+        hold >>= (n); \
+        bits -= (unsigned)(n); \
+    } while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+    do { \
+        hold >>= bits & 7; \
+        bits -= bits & 7; \
+    } while (0)
+
+/* Assure that some output space is available, by writing out the window
+   if it's full.  If the write fails, return from inflateBack() with a
+   Z_BUF_ERROR. */
+#define ROOM() \
+    do { \
+        if (left == 0) { \
+            put = state->window; \
+            left = state->wsize; \
+            state->whave = left; \
+            if (out(out_desc, put, left)) { \
+                ret = Z_BUF_ERROR; \
+                goto inf_leave; \
+            } \
+        } \
+    } while (0)
+
+/*
+   strm provides the memory allocation functions and window buffer on input,
+   and provides information on the unused input on return.  For Z_DATA_ERROR
+   returns, strm will also provide an error message.
+
+   in() and out() are the call-back input and output functions.  When
+   inflateBack() needs more input, it calls in().  When inflateBack() has
+   filled the window with output, or when it completes with data in the
+   window, it calls out() to write out the data.  The application must not
+   change the provided input until in() is called again or inflateBack()
+   returns.  The application must not change the window/output buffer until
+   inflateBack() returns.
+
+   in() and out() are called with a descriptor parameter provided in the
+   inflateBack() call.  This parameter can be a structure that provides the
+   information required to do the read or write, as well as accumulated
+   information on the input and output such as totals and check values.
+
+   in() should return zero on failure.  out() should return non-zero on
+   failure.  If either in() or out() fails, than inflateBack() returns a
+   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
+   was in() or out() that caused in the error.  Otherwise,  inflateBack()
+   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
+   error, or Z_MEM_ERROR if it could not allocate memory for the state.
+   inflateBack() can also return Z_STREAM_ERROR if the input parameters
+   are not correct, i.e. strm is Z_NULL or the state was not initialized.
+ */
+int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
+z_streamp strm;
+in_func in;
+void FAR *in_desc;
+out_func out;
+void FAR *out_desc;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code this;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    /* Check that the strm exists and that the state was initialized */
+    if (strm == Z_NULL || strm->state == Z_NULL)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* Reset the state */
+    strm->msg = Z_NULL;
+    state->mode = TYPE;
+    state->last = 0;
+    state->whave = 0;
+    next = strm->next_in;
+    have = next != Z_NULL ? strm->avail_in : 0;
+    hold = 0;
+    bits = 0;
+    put = state->window;
+    left = state->wsize;
+
+    /* Inflate until end of block marked as last */
+    for (;;)
+        switch (state->mode) {
+        case TYPE:
+            /* determine and dispatch block type */
+            if (state->last) {
+                BYTEBITS();
+                state->mode = DONE;
+                break;
+            }
+            NEEDBITS(3);
+            state->last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, "inflate:     stored block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, "inflate:     fixed codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = LEN;              /* decode codes */
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = TABLE;
+                break;
+            case 3:
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+
+        case STORED:
+            /* get and verify stored block length */
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
+                break;
+            }
+            state->length = (unsigned)hold & 0xffff;
+            Tracev((stderr, "inflate:       stored length %u\n",
+                    state->length));
+            INITBITS();
+
+            /* copy stored block from input to output */
+            while (state->length != 0) {
+                copy = state->length;
+                PULL();
+                ROOM();
+                if (copy > have) copy = have;
+                if (copy > left) copy = left;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state->length -= copy;
+            }
+            Tracev((stderr, "inflate:       stored end\n"));
+            state->mode = TYPE;
+            break;
+
+        case TABLE:
+            /* get dynamic table entries descriptor */
+            NEEDBITS(14);
+            state->nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state->ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state->ncode = BITS(4) + 4;
+            DROPBITS(4);
+#ifndef PKZIP_BUG_WORKAROUND
+            if (state->nlen > 286 || state->ndist > 30) {
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            Tracev((stderr, "inflate:       table sizes ok\n"));
+
+            /* get code length code lengths (not a typo) */
+            state->have = 0;
+            while (state->have < state->ncode) {
+                NEEDBITS(3);
+                state->lens[order[state->have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state->have < 19)
+                state->lens[order[state->have++]] = 0;
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 7;
+            ret = inflate_table(CODES, state->lens, 19, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       code lengths ok\n"));
+
+            /* get length and distance code code lengths */
+            state->have = 0;
+            while (state->have < state->nlen + state->ndist) {
+                for (;;) {
+                    this = state->lencode[BITS(state->lenbits)];
+                    if ((unsigned)(this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                if (this.val < 16) {
+                    NEEDBITS(this.bits);
+                    DROPBITS(this.bits);
+                    state->lens[state->have++] = this.val;
+                }
+                else {
+                    if (this.val == 16) {
+                        NEEDBITS(this.bits + 2);
+                        DROPBITS(this.bits);
+                        if (state->have == 0) {
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
+                            break;
+                        }
+                        len = (unsigned)(state->lens[state->have - 1]);
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (this.val == 17) {
+                        NEEDBITS(this.bits + 3);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(this.bits + 7);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state->have + copy > state->nlen + state->ndist) {
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state->lens[state->have++] = (unsigned short)len;
+                }
+            }
+
+            /* handle error breaks in while */
+            if (state->mode == BAD) break;
+
+            /* build code tables */
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 9;
+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
+                break;
+            }
+            state->distcode = (code const FAR *)(state->next);
+            state->distbits = 6;
+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
+                            &(state->next), &(state->distbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       codes ok\n"));
+            state->mode = LEN;
+
+        case LEN:
+            /* use inflate_fast() if we have enough input and output */
+            if (have >= 6 && left >= 258) {
+                RESTORE();
+                if (state->whave < state->wsize)
+                    state->whave = state->wsize - left;
+                inflate_fast(strm, state->wsize);
+                LOAD();
+                break;
+            }
+
+            /* get a literal, length, or end-of-block code */
+            for (;;) {
+                this = state->lencode[BITS(state->lenbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if (this.op && (this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->lencode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            state->length = (unsigned)this.val;
+
+            /* process literal */
+            if (this.op == 0) {
+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                        "inflate:         literal '%c'\n" :
+                        "inflate:         literal 0x%02x\n", this.val));
+                ROOM();
+                *put++ = (unsigned char)(state->length);
+                left--;
+                state->mode = LEN;
+                break;
+            }
+
+            /* process end of block */
+            if (this.op & 32) {
+                Tracevv((stderr, "inflate:         end of block\n"));
+                state->mode = TYPE;
+                break;
+            }
+
+            /* invalid code */
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
+                break;
+            }
+
+            /* length code -- get extra bits, if any */
+            state->extra = (unsigned)(this.op) & 15;
+            if (state->extra != 0) {
+                NEEDBITS(state->extra);
+                state->length += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+            Tracevv((stderr, "inflate:         length %u\n", state->length));
+
+            /* get distance code */
+            for (;;) {
+                this = state->distcode[BITS(state->distbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if ((this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->distcode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+            state->offset = (unsigned)this.val;
+
+            /* get distance extra bits, if any */
+            state->extra = (unsigned)(this.op) & 15;
+            if (state->extra != 0) {
+                NEEDBITS(state->extra);
+                state->offset += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+            if (state->offset > state->wsize - (state->whave < state->wsize ?
+                                                left : 0)) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
+
+            /* copy match from window to output */
+            do {
+                ROOM();
+                copy = state->wsize - state->offset;
+                if (copy < left) {
+                    from = put + copy;
+                    copy = left - copy;
+                }
+                else {
+                    from = put - state->offset;
+                    copy = left;
+                }
+                if (copy > state->length) copy = state->length;
+                state->length -= copy;
+                left -= copy;
+                do {
+                    *put++ = *from++;
+                } while (--copy);
+            } while (state->length != 0);
+            break;
+
+        case DONE:
+            /* inflate stream terminated properly -- write leftover output */
+            ret = Z_STREAM_END;
+            if (left < state->wsize) {
+                if (out(out_desc, state->window, state->wsize - left))
+                    ret = Z_BUF_ERROR;
+            }
+            goto inf_leave;
+
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+
+        default:                /* can't happen, but makes compilers happy */
+            ret = Z_STREAM_ERROR;
+            goto inf_leave;
+        }
+
+    /* Return unused input */
+  inf_leave:
+    strm->next_in = next;
+    strm->avail_in = have;
+    return ret;
+}
+
+int ZEXPORT inflateBackEnd(strm)
+z_streamp strm;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+    Tracev((stderr, "inflate: end\n"));
+    return Z_OK;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inffast.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,342 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inffast.c -- fast decoding
+ * Copyright (C) 1995-2004 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "inflate.h"
+#include "inffast.h"
+
+#ifndef ASMINF
+
+/* Allow machine dependent optimization for post-increment or pre-increment.
+   Based on testing to date,
+   Pre-increment preferred for:
+   - PowerPC G3 (Adler)
+   - MIPS R5000 (Randers-Pehrson)
+   Post-increment preferred for:
+   - none
+   No measurable difference:
+   - Pentium III (Anderson)
+   - M68060 (Nikl)
+ */
+#ifdef POSTINC
+#  define OFF 0
+#  define PUP(a) *(a)++
+#else
+#  define OFF 1
+#  define PUP(a) *++(a)
+#endif
+
+/*
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
+
+   Entry assumptions:
+
+        state->mode == LEN
+        strm->avail_in >= 6
+        strm->avail_out >= 258
+        start >= strm->avail_out
+        state->bits < 8
+
+   On return, state->mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
+
+   Notes:
+
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm->avail_in >= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm->avail_out >= 258 for each loop to avoid checking for
+      output space.
+ */
+void inflate_fast(strm, start)
+z_streamp strm;
+unsigned start;         /* inflate()'s starting value for strm->avail_out */
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *in;      /* local strm->next_in */
+    unsigned char FAR *last;    /* while in < last, enough input available */
+    unsigned char FAR *out;     /* local strm->next_out */
+    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
+    unsigned char FAR *end;     /* while out < end, enough space available */
+#ifdef INFLATE_STRICT
+    unsigned dmax;              /* maximum distance from zlib header */
+#endif
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned write;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
+    unsigned long hold;         /* local strm->hold */
+    unsigned bits;              /* local strm->bits */
+    code const FAR *lcode;      /* local strm->lencode */
+    code const FAR *dcode;      /* local strm->distcode */
+    unsigned lmask;             /* mask for first level of length codes */
+    unsigned dmask;             /* mask for first level of distance codes */
+    code this;                  /* retrieved table entry */
+    unsigned op;                /* code bits, operation, extra bits, or */
+                                /*  window position, window bytes to copy */
+    unsigned len;               /* match length, unused bytes */
+    unsigned dist;              /* match distance */
+    unsigned char FAR *from;    /* where to copy match from */
+
+    /* copy state to local variables */
+    state = (struct inflate_state FAR *)strm->state;
+    in = strm->next_in - OFF;
+    last = in + (strm->avail_in - 5);
+    out = strm->next_out - OFF;
+    beg = out - (start - strm->avail_out);
+    end = out + (strm->avail_out - 257);
+#ifdef INFLATE_STRICT
+    dmax = state->dmax;
+#endif
+    wsize = state->wsize;
+    whave = state->whave;
+    write = state->write;
+    window = state->window;
+    hold = state->hold;
+    bits = state->bits;
+    lcode = state->lencode;
+    dcode = state->distcode;
+    lmask = (1U << state->lenbits) - 1;
+    dmask = (1U << state->distbits) - 1;
+
+    /* decode literals and length/distances until end-of-block or not enough
+       input data or output space */
+    do {
+        if (bits < 15) {
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+        }
+        this = lcode[hold & lmask];
+      dolen:
+        op = (unsigned)(this.bits);
+        hold >>= op;
+        bits -= op;
+        op = (unsigned)(this.op);
+        if (op == 0) {                          /* literal */
+            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                    "inflate:         literal '%c'\n" :
+                    "inflate:         literal 0x%02x\n", this.val));
+            PUP(out) = (unsigned char)(this.val);
+        }
+        else if (op & 16) {                     /* length base */
+            len = (unsigned)(this.val);
+            op &= 15;                           /* number of extra bits */
+            if (op) {
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                }
+                len += (unsigned)hold & ((1U << op) - 1);
+                hold >>= op;
+                bits -= op;
+            }
+            Tracevv((stderr, "inflate:         length %u\n", len));
+            if (bits < 15) {
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+            }
+            this = dcode[hold & dmask];
+          dodist:
+            op = (unsigned)(this.bits);
+            hold >>= op;
+            bits -= op;
+            op = (unsigned)(this.op);
+            if (op & 16) {                      /* distance base */
+                dist = (unsigned)(this.val);
+                op &= 15;                       /* number of extra bits */
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                    if (bits < op) {
+                        hold += (unsigned long)(PUP(in)) << bits;
+                        bits += 8;
+                    }
+                }
+                dist += (unsigned)hold & ((1U << op) - 1);
+#ifdef INFLATE_STRICT
+                if (dist > dmax) {
+                    strm->msg = (char *)"invalid distance too far back";
+                    state->mode = BAD;
+                    break;
+                }
+#endif
+                hold >>= op;
+                bits -= op;
+                Tracevv((stderr, "inflate:         distance %u\n", dist));
+                op = (unsigned)(out - beg);     /* max distance in output */
+                if (dist > op) {                /* see if copy from window */
+                    op = dist - op;             /* distance back in window */
+                    if (op > whave) {
+                        strm->msg = (char *)"invalid distance too far back";
+                        state->mode = BAD;
+                        break;
+                    }
+                    from = window - OFF;
+                    if (write == 0) {           /* very common case */
+                        from += wsize - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    else if (write < op) {      /* wrap around window */
+                        from += wsize + write - op;
+                        op -= write;
+                        if (op < len) {         /* some from end of window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = window - OFF;
+                            if (write < len) {  /* some from start of window */
+                                op = write;
+                                len -= op;
+                                do {
+                                    PUP(out) = PUP(from);
+                                } while (--op);
+                                from = out - dist;      /* rest from output */
+                            }
+                        }
+                    }
+                    else {                      /* contiguous in window */
+                        from += write - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    while (len > 2) {
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    }
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+                else {
+                    from = out - dist;          /* copy direct from output */
+                    do {                        /* minimum length is three */
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    } while (len > 2);
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+            }
+            else if ((op & 64) == 0) {          /* 2nd level distance code */
+                this = dcode[this.val + (hold & ((1U << op) - 1))];
+                goto dodist;
+            }
+            else {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+        }
+        else if ((op & 64) == 0) {              /* 2nd level length code */
+            this = lcode[this.val + (hold & ((1U << op) - 1))];
+            goto dolen;
+        }
+        else if (op & 32) {                     /* end-of-block */
+            Tracevv((stderr, "inflate:         end of block\n"));
+            state->mode = TYPE;
+            break;
+        }
+        else {
+            strm->msg = (char *)"invalid literal/length code";
+            state->mode = BAD;
+            break;
+        }
+    } while (in < last && out < end);
+
+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
+    len = bits >> 3;
+    in -= len;
+    bits -= len << 3;
+    hold &= (1U << bits) - 1;
+
+    /* update state and return */
+    strm->next_in = in + OFF;
+    strm->next_out = out + OFF;
+    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
+    strm->avail_out = (unsigned)(out < end ?
+                                 257 + (end - out) : 257 - (out - end));
+    state->hold = hold;
+    state->bits = bits;
+    return;
+}
+
+/*
+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
+   - Using bit fields for code structure
+   - Different op definition to avoid & for extra bits (do & for table bits)
+   - Three separate decoding do-loops for direct, window, and write == 0
+   - Special case for distance > 1 copies to do overlapped load and store copy
+   - Explicit branch predictions (based on measured branch probabilities)
+   - Deferring match copy and interspersed it with decoding subsequent codes
+   - Swapping literal/length else
+   - Swapping window/direct else
+   - Larger unrolled copy loops (three is about right)
+   - Moving len -= 3 statement into middle of loop
+ */
+
+#endif /* !ASMINF */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inffast.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,35 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-2003 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+void inflate_fast OF((z_streamp strm, unsigned start));
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inffixed.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,118 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+    /* inffixed.h -- table for decoding fixed codes
+     * Generated automatically by makefixed().
+     */
+
+    /* WARNING: this file should *not* be used by applications. It
+       is part of the implementation of the compression library and
+       is subject to change. Applications should only use zlib.h.
+     */
+
+    static const code lenfix[512] = {
+        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
+        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
+        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
+        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
+        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
+        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
+        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
+        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
+        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
+        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
+        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
+        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
+        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
+        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
+        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
+        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
+        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
+        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
+        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
+        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
+        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
+        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
+        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
+        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
+        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
+        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
+        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
+        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
+        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
+        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
+        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
+        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
+        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
+        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
+        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
+        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
+        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
+        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
+        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
+        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
+        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
+        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
+        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
+        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
+        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
+        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
+        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
+        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
+        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
+        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
+        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
+        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
+        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
+        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
+        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
+        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
+        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
+        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
+        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
+        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
+        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
+        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
+        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
+        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
+        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
+        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
+        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
+        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
+        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
+        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
+        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
+        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
+        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
+        {0,9,255}
+    };
+
+    static const code distfix[32] = {
+        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
+        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
+        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
+        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
+        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
+        {22,5,193},{64,5,0}
+    };
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inflate.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,1392 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inflate.c -- zlib decompression
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ * Change history:
+ *
+ * 1.2.beta0    24 Nov 2002
+ * - First version -- complete rewrite of inflate to simplify code, avoid
+ *   creation of window when not needed, minimize use of window when it is
+ *   needed, make inffast.c even faster, implement gzip decoding, and to
+ *   improve code readability and style over the previous zlib inflate code
+ *
+ * 1.2.beta1    25 Nov 2002
+ * - Use pointers for available input and output checking in inffast.c
+ * - Remove input and output counters in inffast.c
+ * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
+ * - Remove unnecessary second byte pull from length extra in inffast.c
+ * - Unroll direct copy to three copies per loop in inffast.c
+ *
+ * 1.2.beta2    4 Dec 2002
+ * - Change external routine names to reduce potential conflicts
+ * - Correct filename to inffixed.h for fixed tables in inflate.c
+ * - Make hbuf[] unsigned char to match parameter type in inflate.c
+ * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
+ *   to avoid negation problem on Alphas (64 bit) in inflate.c
+ *
+ * 1.2.beta3    22 Dec 2002
+ * - Add comments on state->bits assertion in inffast.c
+ * - Add comments on op field in inftrees.h
+ * - Fix bug in reuse of allocated window after inflateReset()
+ * - Remove bit fields--back to byte structure for speed
+ * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
+ * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
+ * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
+ * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
+ * - Use local copies of stream next and avail values, as well as local bit
+ *   buffer and bit count in inflate()--for speed when inflate_fast() not used
+ *
+ * 1.2.beta4    1 Jan 2003
+ * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
+ * - Move a comment on output buffer sizes from inffast.c to inflate.c
+ * - Add comments in inffast.c to introduce the inflate_fast() routine
+ * - Rearrange window copies in inflate_fast() for speed and simplification
+ * - Unroll last copy for window match in inflate_fast()
+ * - Use local copies of window variables in inflate_fast() for speed
+ * - Pull out common write == 0 case for speed in inflate_fast()
+ * - Make op and len in inflate_fast() unsigned for consistency
+ * - Add FAR to lcode and dcode declarations in inflate_fast()
+ * - Simplified bad distance check in inflate_fast()
+ * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
+ *   source file infback.c to provide a call-back interface to inflate for
+ *   programs like gzip and unzip -- uses window as output buffer to avoid
+ *   window copying
+ *
+ * 1.2.beta5    1 Jan 2003
+ * - Improved inflateBack() interface to allow the caller to provide initial
+ *   input in strm.
+ * - Fixed stored blocks bug in inflateBack()
+ *
+ * 1.2.beta6    4 Jan 2003
+ * - Added comments in inffast.c on effectiveness of POSTINC
+ * - Typecasting all around to reduce compiler warnings
+ * - Changed loops from while (1) or do {} while (1) to for (;;), again to
+ *   make compilers happy
+ * - Changed type of window in inflateBackInit() to unsigned char *
+ *
+ * 1.2.beta7    27 Jan 2003
+ * - Changed many types to unsigned or unsigned short to avoid warnings
+ * - Added inflateCopy() function
+ *
+ * 1.2.0        9 Mar 2003
+ * - Changed inflateBack() interface to provide separate opaque descriptors
+ *   for the in() and out() functions
+ * - Changed inflateBack() argument and in_func typedef to swap the length
+ *   and buffer address return values for the input function
+ * - Check next_in and next_out for Z_NULL on entry to inflate()
+ *
+ * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "inflate.h"
+#include "inffast.h"
+
+#ifdef MAKEFIXED
+#  ifndef BUILDFIXED
+#    define BUILDFIXED
+#  endif
+#endif
+
+/* function prototypes */
+local void fixedtables OF((struct inflate_state FAR *state));
+local int updatewindow OF((z_streamp strm, unsigned out));
+#ifdef BUILDFIXED
+   void makefixed OF((void));
+#endif
+local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
+                              unsigned len));
+
+int ZEXPORT inflateReset(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    strm->total_in = strm->total_out = state->total = 0;
+    strm->msg = Z_NULL;
+    strm->adler = 1;        /* to support ill-conceived Java test suite */
+    state->mode = HEAD;
+    state->last = 0;
+    state->havedict = 0;
+    state->dmax = 32768U;
+    state->head = Z_NULL;
+    state->wsize = 0;
+    state->whave = 0;
+    state->write = 0;
+    state->hold = 0;
+    state->bits = 0;
+    state->lencode = state->distcode = state->next = state->codes;
+    Tracev((stderr, "inflate: reset\n"));
+    return Z_OK;
+}
+
+int ZEXPORT inflatePrime(strm, bits, value)
+z_streamp strm;
+int bits;
+int value;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
+    value &= (1L << bits) - 1;
+    state->hold += value << state->bits;
+    state->bits += bits;
+    return Z_OK;
+}
+
+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
+{
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    strm->msg = Z_NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0) {
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    state = (struct inflate_state FAR *)
+            ZALLOC(strm, 1, sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, "inflate: allocated\n"));
+    strm->state = (struct internal_state FAR *)state;
+    if (windowBits < 0) {
+        state->wrap = 0;
+        windowBits = -windowBits;
+    }
+    else {
+        state->wrap = (windowBits >> 4) + 1;
+#ifdef GUNZIP
+        if (windowBits < 48) windowBits &= 15;
+#endif
+    }
+    if (windowBits < 8 || windowBits > 15) {
+        ZFREE(strm, state);
+        strm->state = Z_NULL;
+        return Z_STREAM_ERROR;
+    }
+    state->wbits = (unsigned)windowBits;
+    state->window = Z_NULL;
+    return inflateReset(strm);
+}
+
+int ZEXPORT inflateInit_(strm, version, stream_size)
+z_streamp strm;
+const char *version;
+int stream_size;
+{
+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
+}
+
+/*
+   Return state with length and distance decoding tables and index sizes set to
+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+   If BUILDFIXED is defined, then instead this routine builds the tables the
+   first time it's called, and returns those tables the first time and
+   thereafter.  This reduces the size of the code by about 2K bytes, in
+   exchange for a little execution time.  However, BUILDFIXED should not be
+   used for threaded applications, since the rewriting of the tables and virgin
+   may not be thread-safe.
+ */
+local void fixedtables(state)
+struct inflate_state FAR *state;
+{
+#ifdef BUILDFIXED
+    static int virgin = 1;
+    static code *lenfix, *distfix;
+    static code fixed[544];
+
+    /* build fixed huffman tables if first call (may not be thread safe) */
+    if (virgin) {
+        unsigned sym, bits;
+        static code *next;
+
+        /* literal/length table */
+        sym = 0;
+        while (sym < 144) state->lens[sym++] = 8;
+        while (sym < 256) state->lens[sym++] = 9;
+        while (sym < 280) state->lens[sym++] = 7;
+        while (sym < 288) state->lens[sym++] = 8;
+        next = fixed;
+        lenfix = next;
+        bits = 9;
+        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
+
+        /* distance table */
+        sym = 0;
+        while (sym < 32) state->lens[sym++] = 5;
+        distfix = next;
+        bits = 5;
+        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
+
+        /* do this just once */
+        virgin = 0;
+    }
+#else /* !BUILDFIXED */
+#   include "inffixed.h"
+#endif /* BUILDFIXED */
+    state->lencode = lenfix;
+    state->lenbits = 9;
+    state->distcode = distfix;
+    state->distbits = 5;
+}
+
+#ifdef MAKEFIXED
+#include <stdio.h>
+
+/*
+   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
+   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
+   those tables to stdout, which would be piped to inffixed.h.  A small program
+   can simply call makefixed to do this:
+
+    void makefixed(void);
+
+    int main(void)
+    {
+        makefixed();
+        return 0;
+    }
+
+   Then that can be linked with zlib built with MAKEFIXED defined and run:
+
+    a.out > inffixed.h
+ */
+void makefixed()
+{
+    unsigned low, size;
+    struct inflate_state state;
+
+    fixedtables(&state);
+    puts("    /* inffixed.h -- table for decoding fixed codes");
+    puts("     * Generated automatically by makefixed().");
+    puts("     */");
+    puts("");
+    puts("    /* WARNING: this file should *not* be used by applications.");
+    puts("       It is part of the implementation of this library and is");
+    puts("       subject to change. Applications should only use zlib.h.");
+    puts("     */");
+    puts("");
+    size = 1U << 9;
+    printf("    static const code lenfix[%u] = {", size);
+    low = 0;
+    for (;;) {
+        if ((low % 7) == 0) printf("\n        ");
+        printf("{%u,%u,%d}", state.lencode[low].op, state.lencode[low].bits,
+               state.lencode[low].val);
+        if (++low == size) break;
+        putchar(',');
+    }
+    puts("\n    };");
+    size = 1U << 5;
+    printf("\n    static const code distfix[%u] = {", size);
+    low = 0;
+    for (;;) {
+        if ((low % 6) == 0) printf("\n        ");
+        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
+               state.distcode[low].val);
+        if (++low == size) break;
+        putchar(',');
+    }
+    puts("\n    };");
+}
+#endif /* MAKEFIXED */
+
+/*
+   Update the window with the last wsize (normally 32K) bytes written before
+   returning.  If window does not exist yet, create it.  This is only called
+   when a window is already in use, or when output has been written during this
+   inflate call, but the end of the deflate stream has not been reached yet.
+   It is also called to create a window for dictionary data when a dictionary
+   is loaded.
+
+   Providing output buffers larger than 32K to inflate() should provide a speed
+   advantage, since only the last 32K of output is copied to the sliding window
+   upon return from inflate(), and since all distances after the first 32K of
+   output will fall in the output data, making match copies simpler and faster.
+   The advantage may be dependent on the size of the processor's data caches.
+ */
+local int updatewindow(strm, out)
+z_streamp strm;
+unsigned out;
+{
+    struct inflate_state FAR *state;
+    unsigned copy, dist;
+
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* if it hasn't been done already, allocate space for the window */
+    if (state->window == Z_NULL) {
+        state->window = (unsigned char FAR *)
+                        ZALLOC(strm, 1U << state->wbits,
+                               sizeof(unsigned char));
+        if (state->window == Z_NULL) return 1;
+    }
+
+    /* if window not in use yet, initialize */
+    if (state->wsize == 0) {
+        state->wsize = 1U << state->wbits;
+        state->write = 0;
+        state->whave = 0;
+    }
+
+    /* copy state->wsize or less output bytes into the circular window */
+    copy = out - strm->avail_out;
+    if (copy >= state->wsize) {
+        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
+        state->write = 0;
+        state->whave = state->wsize;
+    }
+    else {
+        dist = state->wsize - state->write;
+        if (dist > copy) dist = copy;
+        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
+        copy -= dist;
+        if (copy) {
+            zmemcpy(state->window, strm->next_out - copy, copy);
+            state->write = copy;
+            state->whave = state->wsize;
+        }
+        else {
+            state->write += dist;
+            if (state->write == state->wsize) state->write = 0;
+            if (state->whave < state->wsize) state->whave += dist;
+        }
+    }
+    return 0;
+}
+
+/* Macros for inflate(): */
+
+/* check function to use adler32() for zlib or crc32() for gzip */
+#ifdef GUNZIP
+#  define UPDATE(check, buf, len) \
+    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
+#else
+#  define UPDATE(check, buf, len) adler32(check, buf, len)
+#endif
+
+/* check macros for header crc */
+#ifdef GUNZIP
+#  define CRC2(check, word) \
+    do { \
+        hbuf[0] = (unsigned char)(word); \
+        hbuf[1] = (unsigned char)((word) >> 8); \
+        check = crc32(check, hbuf, 2); \
+    } while (0)
+
+#  define CRC4(check, word) \
+    do { \
+        hbuf[0] = (unsigned char)(word); \
+        hbuf[1] = (unsigned char)((word) >> 8); \
+        hbuf[2] = (unsigned char)((word) >> 16); \
+        hbuf[3] = (unsigned char)((word) >> 24); \
+        check = crc32(check, hbuf, 4); \
+    } while (0)
+#endif
+
+/* Load registers with state in inflate() for speed */
+#define LOAD() \
+    do { \
+        put = strm->next_out; \
+        left = strm->avail_out; \
+        next = strm->next_in; \
+        have = strm->avail_in; \
+        hold = state->hold; \
+        bits = state->bits; \
+    } while (0)
+
+/* Restore state from registers in inflate() */
+#define RESTORE() \
+    do { \
+        strm->next_out = put; \
+        strm->avail_out = left; \
+        strm->next_in = next; \
+        strm->avail_in = have; \
+        state->hold = hold; \
+        state->bits = bits; \
+    } while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+    do { \
+        hold = 0; \
+        bits = 0; \
+    } while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflate()
+   if there is no input available. */
+#define PULLBYTE() \
+    do { \
+        if (have == 0) goto inf_leave; \
+        have--; \
+        hold += (unsigned long)(*next++) << bits; \
+        bits += 8; \
+    } while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflate(). */
+#define NEEDBITS(n) \
+    do { \
+        while (bits < (unsigned)(n)) \
+            PULLBYTE(); \
+    } while (0)
+
+/* Return the low n bits of the bit accumulator (n < 16) */
+#define BITS(n) \
+    ((unsigned)hold & ((1U << (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+    do { \
+        hold >>= (n); \
+        bits -= (unsigned)(n); \
+    } while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+    do { \
+        hold >>= bits & 7; \
+        bits -= bits & 7; \
+    } while (0)
+
+/* Reverse the bytes in a 32-bit value */
+#define REVERSE(q) \
+    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
+     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
+
+/*
+   inflate() uses a state machine to process as much input data and generate as
+   much output data as possible before returning.  The state machine is
+   structured roughly as follows:
+
+    for (;;) switch (state) {
+    ...
+    case STATEn:
+        if (not enough input data or output space to make progress)
+            return;
+        ... make progress ...
+        state = STATEm;
+        break;
+    ...
+    }
+
+   so when inflate() is called again, the same case is attempted again, and
+   if the appropriate resources are provided, the machine proceeds to the
+   next state.  The NEEDBITS() macro is usually the way the state evaluates
+   whether it can proceed or should return.  NEEDBITS() does the return if
+   the requested bits are not available.  The typical use of the BITS macros
+   is:
+
+        NEEDBITS(n);
+        ... do something with BITS(n) ...
+        DROPBITS(n);
+
+   where NEEDBITS(n) either returns from inflate() if there isn't enough
+   input left to load n bits into the accumulator, or it continues.  BITS(n)
+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
+   the low n bits off the accumulator.  INITBITS() clears the accumulator
+   and sets the number of available bits to zero.  BYTEBITS() discards just
+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
+
+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
+   if there is no input available.  The decoding of variable length codes uses
+   PULLBYTE() directly in order to pull just enough bytes to decode the next
+   code, and no more.
+
+   Some states loop until they get enough input, making sure that enough
+   state information is maintained to continue the loop where it left off
+   if NEEDBITS() returns in the loop.  For example, want, need, and keep
+   would all have to actually be part of the saved state in case NEEDBITS()
+   returns:
+
+    case STATEw:
+        while (want < need) {
+            NEEDBITS(n);
+            keep[want++] = BITS(n);
+            DROPBITS(n);
+        }
+        state = STATEx;
+    case STATEx:
+
+   As shown above, if the next state is also the next case, then the break
+   is omitted.
+
+   A state may also return if there is not enough output space available to
+   complete that state.  Those states are copying stored data, writing a
+   literal byte, and copying a matching string.
+
+   When returning, a "goto inf_leave" is used to update the total counters,
+   update the check value, and determine whether any progress has been made
+   during that inflate() call in order to return the proper return code.
+   Progress is defined as a change in either strm->avail_in or strm->avail_out.
+   When there is a window, goto inf_leave will update the window with the last
+   output written.  If a goto inf_leave occurs in the middle of decompression
+   and there is no window currently, goto inf_leave will create one and copy
+   output to the window for the next call of inflate().
+
+   In this implementation, the flush parameter of inflate() only affects the
+   return code (per zlib.h).  inflate() always writes as much as possible to
+   strm->next_out, given the space available and the provided input--the effect
+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
+   the allocation of and copying into a sliding window until necessary, which
+   provides the effect documented in zlib.h for Z_FINISH when the entire input
+   stream available.  So the only thing the flush parameter actually does is:
+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
+   will return Z_BUF_ERROR if it has not reached the end of the stream.
+ */
+
+int ZEXPORT inflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned in, out;           /* save starting available input and output */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code this;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+#ifdef GUNZIP
+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
+#endif
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0))
+        return Z_STREAM_ERROR;
+
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
+    LOAD();
+    in = have;
+    out = left;
+    ret = Z_OK;
+    for (;;)
+        switch (state->mode) {
+        case HEAD:
+            if (state->wrap == 0) {
+                state->mode = TYPEDO;
+                break;
+            }
+            NEEDBITS(16);
+#ifdef GUNZIP
+            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
+                state->check = crc32(0L, Z_NULL, 0);
+                CRC2(state->check, hold);
+                INITBITS();
+                state->mode = FLAGS;
+                break;
+            }
+            state->flags = 0;           /* expect zlib header */
+            if (state->head != Z_NULL)
+                state->head->done = -1;
+            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
+#else
+            if (
+#endif
+                ((BITS(8) << 8) + (hold >> 8)) % 31) {
+                strm->msg = (char *)"incorrect header check";
+                state->mode = BAD;
+                break;
+            }
+            if (BITS(4) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            DROPBITS(4);
+            len = BITS(4) + 8;
+            if (len > state->wbits) {
+                strm->msg = (char *)"invalid window size";
+                state->mode = BAD;
+                break;
+            }
+            state->dmax = 1U << len;
+            Tracev((stderr, "inflate:   zlib header ok\n"));
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = hold & 0x200 ? DICTID : TYPE;
+            INITBITS();
+            break;
+#ifdef GUNZIP
+        case FLAGS:
+            NEEDBITS(16);
+            state->flags = (int)(hold);
+            if ((state->flags & 0xff) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            if (state->flags & 0xe000) {
+                strm->msg = (char *)"unknown header flags set";
+                state->mode = BAD;
+                break;
+            }
+            if (state->head != Z_NULL)
+                state->head->text = (int)((hold >> 8) & 1);
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = TIME;
+        case TIME:
+            NEEDBITS(32);
+            if (state->head != Z_NULL)
+                state->head->time = hold;
+            if (state->flags & 0x0200) CRC4(state->check, hold);
+            INITBITS();
+            state->mode = OS;
+        case OS:
+            NEEDBITS(16);
+            if (state->head != Z_NULL) {
+                state->head->xflags = (int)(hold & 0xff);
+                state->head->os = (int)(hold >> 8);
+            }
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = EXLEN;
+        case EXLEN:
+            if (state->flags & 0x0400) {
+                NEEDBITS(16);
+                state->length = (unsigned)(hold);
+                if (state->head != Z_NULL)
+                    state->head->extra_len = (unsigned)hold;
+                if (state->flags & 0x0200) CRC2(state->check, hold);
+                INITBITS();
+            }
+            else if (state->head != Z_NULL)
+                state->head->extra = Z_NULL;
+            state->mode = EXTRA;
+        case EXTRA:
+            if (state->flags & 0x0400) {
+                copy = state->length;
+                if (copy > have) copy = have;
+                if (copy) {
+                    if (state->head != Z_NULL &&
+                        state->head->extra != Z_NULL) {
+                        len = state->head->extra_len - state->length;
+                        zmemcpy(state->head->extra + len, next,
+                                len + copy > state->head->extra_max ?
+                                state->head->extra_max - len : copy);
+                    }
+                    if (state->flags & 0x0200)
+                        state->check = crc32(state->check, next, copy);
+                    have -= copy;
+                    next += copy;
+                    state->length -= copy;
+                }
+                if (state->length) goto inf_leave;
+            }
+            state->length = 0;
+            state->mode = NAME;
+        case NAME:
+            if (state->flags & 0x0800) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->name != Z_NULL &&
+                            state->length < state->head->name_max)
+                        state->head->name[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->name = Z_NULL;
+            state->length = 0;
+            state->mode = COMMENT;
+        case COMMENT:
+            if (state->flags & 0x1000) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->comment != Z_NULL &&
+                            state->length < state->head->comm_max)
+                        state->head->comment[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->comment = Z_NULL;
+            state->mode = HCRC;
+        case HCRC:
+            if (state->flags & 0x0200) {
+                NEEDBITS(16);
+                if (hold != (state->check & 0xffff)) {
+                    strm->msg = (char *)"header crc mismatch";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+            }
+            if (state->head != Z_NULL) {
+                state->head->hcrc = (int)((state->flags >> 9) & 1);
+                state->head->done = 1;
+            }
+            strm->adler = state->check = crc32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+            break;
+#endif
+        case DICTID:
+            NEEDBITS(32);
+            strm->adler = state->check = REVERSE(hold);
+            INITBITS();
+            state->mode = DICT;
+        case DICT:
+            if (state->havedict == 0) {
+                RESTORE();
+                return Z_NEED_DICT;
+            }
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+        case TYPE:
+            if (flush == Z_BLOCK) goto inf_leave;
+        case TYPEDO:
+            if (state->last) {
+                BYTEBITS();
+                state->mode = CHECK;
+                break;
+            }
+            NEEDBITS(3);
+            state->last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, "inflate:     stored block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, "inflate:     fixed codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = LEN;              /* decode codes */
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = TABLE;
+                break;
+            case 3:
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+        case STORED:
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
+                break;
+            }
+            state->length = (unsigned)hold & 0xffff;
+            Tracev((stderr, "inflate:       stored length %u\n",
+                    state->length));
+            INITBITS();
+            state->mode = COPY;
+        case COPY:
+            copy = state->length;
+            if (copy) {
+                if (copy > have) copy = have;
+                if (copy > left) copy = left;
+                if (copy == 0) goto inf_leave;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state->length -= copy;
+                break;
+            }
+            Tracev((stderr, "inflate:       stored end\n"));
+            state->mode = TYPE;
+            break;
+        case TABLE:
+            NEEDBITS(14);
+            state->nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state->ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state->ncode = BITS(4) + 4;
+            DROPBITS(4);
+#ifndef PKZIP_BUG_WORKAROUND
+            if (state->nlen > 286 || state->ndist > 30) {
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            Tracev((stderr, "inflate:       table sizes ok\n"));
+            state->have = 0;
+            state->mode = LENLENS;
+        case LENLENS:
+            while (state->have < state->ncode) {
+                NEEDBITS(3);
+                state->lens[order[state->have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state->have < 19)
+                state->lens[order[state->have++]] = 0;
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 7;
+            ret = inflate_table(CODES, state->lens, 19, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       code lengths ok\n"));
+            state->have = 0;
+            state->mode = CODELENS;
+        case CODELENS:
+            while (state->have < state->nlen + state->ndist) {
+                for (;;) {
+                    this = state->lencode[BITS(state->lenbits)];
+                    if ((unsigned)(this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                if (this.val < 16) {
+                    NEEDBITS(this.bits);
+                    DROPBITS(this.bits);
+                    state->lens[state->have++] = this.val;
+                }
+                else {
+                    if (this.val == 16) {
+                        NEEDBITS(this.bits + 2);
+                        DROPBITS(this.bits);
+                        if (state->have == 0) {
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
+                            break;
+                        }
+                        len = state->lens[state->have - 1];
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (this.val == 17) {
+                        NEEDBITS(this.bits + 3);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(this.bits + 7);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state->have + copy > state->nlen + state->ndist) {
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state->lens[state->have++] = (unsigned short)len;
+                }
+            }
+
+            /* handle error breaks in while */
+            if (state->mode == BAD) break;
+
+            /* build code tables */
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 9;
+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
+                break;
+            }
+            state->distcode = (code const FAR *)(state->next);
+            state->distbits = 6;
+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
+                            &(state->next), &(state->distbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       codes ok\n"));
+            state->mode = LEN;
+        case LEN:
+            if (have >= 6 && left >= 258) {
+                RESTORE();
+                inflate_fast(strm, out);
+                LOAD();
+                break;
+            }
+            for (;;) {
+                this = state->lencode[BITS(state->lenbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if (this.op && (this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->lencode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            state->length = (unsigned)this.val;
+            if ((int)(this.op) == 0) {
+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                        "inflate:         literal '%c'\n" :
+                        "inflate:         literal 0x%02x\n", this.val));
+                state->mode = LIT;
+                break;
+            }
+            if (this.op & 32) {
+                Tracevv((stderr, "inflate:         end of block\n"));
+                state->mode = TYPE;
+                break;
+            }
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
+                break;
+            }
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = LENEXT;
+        case LENEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->length += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+            Tracevv((stderr, "inflate:         length %u\n", state->length));
+            state->mode = DIST;
+        case DIST:
+            for (;;) {
+                this = state->distcode[BITS(state->distbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if ((this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->distcode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+            state->offset = (unsigned)this.val;
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = DISTEXT;
+        case DISTEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->offset += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+#ifdef INFLATE_STRICT
+            if (state->offset > state->dmax) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            if (state->offset > state->whave + out - left) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
+            state->mode = MATCH;
+        case MATCH:
+            if (left == 0) goto inf_leave;
+            copy = out - left;
+            if (state->offset > copy) {         /* copy from window */
+                copy = state->offset - copy;
+                if (copy > state->write) {
+                    copy -= state->write;
+                    from = state->window + (state->wsize - copy);
+                }
+                else
+                    from = state->window + (state->write - copy);
+                if (copy > state->length) copy = state->length;
+            }
+            else {                              /* copy from output */
+                from = put - state->offset;
+                copy = state->length;
+            }
+            if (copy > left) copy = left;
+            left -= copy;
+            state->length -= copy;
+            do {
+                *put++ = *from++;
+            } while (--copy);
+            if (state->length == 0) state->mode = LEN;
+            break;
+        case LIT:
+            if (left == 0) goto inf_leave;
+            *put++ = (unsigned char)(state->length);
+            left--;
+            state->mode = LEN;
+            break;
+        case CHECK:
+            if (state->wrap) {
+                NEEDBITS(32);
+                out -= left;
+                strm->total_out += out;
+                state->total += out;
+                if (out)
+                    strm->adler = state->check =
+                        UPDATE(state->check, put - out, out);
+                out = left;
+                if ((
+#ifdef GUNZIP
+                     state->flags ? hold :
+#endif
+                     REVERSE(hold)) != state->check) {
+                    strm->msg = (char *)"incorrect data check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   check matches trailer\n"));
+            }
+#ifdef GUNZIP
+            state->mode = LENGTH;
+        case LENGTH:
+            if (state->wrap && state->flags) {
+                NEEDBITS(32);
+                if (hold != (state->total & 0xffffffffUL)) {
+                    strm->msg = (char *)"incorrect length check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   length matches trailer\n"));
+            }
+#endif
+            state->mode = DONE;
+        case DONE:
+            ret = Z_STREAM_END;
+            goto inf_leave;
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+        case MEM:
+            return Z_MEM_ERROR;
+        case SYNC:
+        default:
+            return Z_STREAM_ERROR;
+        }
+
+    /*
+       Return from inflate(), updating the total counts and the check value.
+       If there was no progress during the inflate() call, return a buffer
+       error.  Call updatewindow() to create and/or update the window state.
+       Note: a memory error from inflate() is non-recoverable.
+     */
+  inf_leave:
+    RESTORE();
+    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
+        if (updatewindow(strm, out)) {
+            state->mode = MEM;
+            return Z_MEM_ERROR;
+        }
+    in -= strm->avail_in;
+    out -= strm->avail_out;
+    strm->total_in += in;
+    strm->total_out += out;
+    state->total += out;
+    if (state->wrap && out)
+        strm->adler = state->check =
+            UPDATE(state->check, strm->next_out - out, out);
+    strm->data_type = state->bits + (state->last ? 64 : 0) +
+                      (state->mode == TYPE ? 128 : 0);
+    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
+        ret = Z_BUF_ERROR;
+    return ret;
+}
+
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->window != Z_NULL) ZFREE(strm, state->window);
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+    Tracev((stderr, "inflate: end\n"));
+    return Z_OK;
+}
+
+int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+const Bytef *dictionary;
+uInt dictLength;
+{
+    struct inflate_state FAR *state;
+    unsigned long id;
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->wrap != 0 && state->mode != DICT)
+        return Z_STREAM_ERROR;
+
+    /* check for correct dictionary id */
+    if (state->mode == DICT) {
+        id = adler32(0L, Z_NULL, 0);
+        id = adler32(id, dictionary, dictLength);
+        if (id != state->check)
+            return Z_DATA_ERROR;
+    }
+
+    /* copy dictionary to window */
+    if (updatewindow(strm, strm->avail_out)) {
+        state->mode = MEM;
+        return Z_MEM_ERROR;
+    }
+    if (dictLength > state->wsize) {
+        zmemcpy(state->window, dictionary + dictLength - state->wsize,
+                state->wsize);
+        state->whave = state->wsize;
+    }
+    else {
+        zmemcpy(state->window + state->wsize - dictLength, dictionary,
+                dictLength);
+        state->whave = dictLength;
+    }
+    state->havedict = 1;
+    Tracev((stderr, "inflate:   dictionary set\n"));
+    return Z_OK;
+}
+
+int ZEXPORT inflateGetHeader(strm, head)
+z_streamp strm;
+gz_headerp head;
+{
+    struct inflate_state FAR *state;
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
+
+    /* save header structure */
+    state->head = head;
+    head->done = 0;
+    return Z_OK;
+}
+
+/*
+   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
+   or when out of input.  When called, *have is the number of pattern bytes
+   found in order so far, in 0..3.  On return *have is updated to the new
+   state.  If on return *have equals four, then the pattern was found and the
+   return value is how many bytes were read including the last byte of the
+   pattern.  If *have is less than four, then the pattern has not been found
+   yet and the return value is len.  In the latter case, syncsearch() can be
+   called again with more data and the *have state.  *have is initialized to
+   zero for the first call.
+ */
+local unsigned syncsearch(have, buf, len)
+unsigned FAR *have;
+unsigned char FAR *buf;
+unsigned len;
+{
+    unsigned got;
+    unsigned next;
+
+    got = *have;
+    next = 0;
+    while (next < len && got < 4) {
+        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
+            got++;
+        else if (buf[next])
+            got = 0;
+        else
+            got = 4 - got;
+        next++;
+    }
+    *have = got;
+    return next;
+}
+
+int ZEXPORT inflateSync(strm)
+z_streamp strm;
+{
+    unsigned len;               /* number of bytes to look at or looked at */
+    long long in, out;          /* temporary to save total_in and total_out */
+    unsigned char buf[4];       /* to restore bit buffer to byte string */
+    struct inflate_state FAR *state;
+
+    /* check parameters */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
+
+    /* if first time, start search in bit buffer */
+    if (state->mode != SYNC) {
+        state->mode = SYNC;
+        state->hold <<= state->bits & 7;
+        state->bits -= state->bits & 7;
+        len = 0;
+        while (state->bits >= 8) {
+            buf[len++] = (unsigned char)(state->hold);
+            state->hold >>= 8;
+            state->bits -= 8;
+        }
+        state->have = 0;
+        syncsearch(&(state->have), buf, len);
+    }
+
+    /* search available input */
+    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
+    strm->avail_in -= len;
+    strm->next_in += len;
+    strm->total_in += len;
+
+    /* return no joy or set up to restart inflate() on a new block */
+    if (state->have != 4) return Z_DATA_ERROR;
+    in = strm->total_in;  out = strm->total_out;
+    inflateReset(strm);
+    strm->total_in = in;  strm->total_out = out;
+    state->mode = TYPE;
+    return Z_OK;
+}
+
+/*
+   Returns true if inflate is currently at the end of a block generated by
+   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
+   implementation to provide an additional safety check. PPP uses
+   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
+   block. When decompressing, PPP checks that at the end of input packet,
+   inflate is waiting for these length bytes.
+ */
+int ZEXPORT inflateSyncPoint(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    return state->mode == STORED && state->bits == 0;
+}
+
+int ZEXPORT inflateCopy(dest, source)
+z_streamp dest;
+z_streamp source;
+{
+    struct inflate_state FAR *state;
+    struct inflate_state FAR *copy;
+    unsigned char FAR *window;
+    unsigned wsize;
+
+    /* check input */
+    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
+        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)source->state;
+
+    /* allocate space */
+    copy = (struct inflate_state FAR *)
+           ZALLOC(source, 1, sizeof(struct inflate_state));
+    if (copy == Z_NULL) return Z_MEM_ERROR;
+    window = Z_NULL;
+    if (state->window != Z_NULL) {
+        window = (unsigned char FAR *)
+                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
+        if (window == Z_NULL) {
+            ZFREE(source, copy);
+            return Z_MEM_ERROR;
+        }
+    }
+
+    /* copy state */
+    zmemcpy(dest, source, sizeof(z_stream));
+    zmemcpy(copy, state, sizeof(struct inflate_state));
+    if (state->lencode >= state->codes &&
+        state->lencode <= state->codes + ENOUGH - 1) {
+        copy->lencode = copy->codes + (state->lencode - state->codes);
+        copy->distcode = copy->codes + (state->distcode - state->codes);
+    }
+    copy->next = copy->codes + (state->next - state->codes);
+    if (window != Z_NULL) {
+        wsize = 1U << state->wbits;
+        zmemcpy(window, state->window, wsize);
+    }
+    copy->window = window;
+    dest->state = (struct internal_state FAR *)copy;
+    return Z_OK;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inflate.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,139 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inflate.h -- internal inflate state definition
+ * Copyright (C) 1995-2004 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* define NO_GZIP when compiling if you want to disable gzip header and
+   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
+   the crc code when it is not needed.  For shared libraries, gzip decoding
+   should be left enabled. */
+#ifndef NO_GZIP
+#  define GUNZIP
+#endif
+
+/* Possible inflate modes between inflate() calls */
+typedef enum {
+    HEAD,       /* i: waiting for magic header */
+    FLAGS,      /* i: waiting for method and flags (gzip) */
+    TIME,       /* i: waiting for modification time (gzip) */
+    OS,         /* i: waiting for extra flags and operating system (gzip) */
+    EXLEN,      /* i: waiting for extra length (gzip) */
+    EXTRA,      /* i: waiting for extra bytes (gzip) */
+    NAME,       /* i: waiting for end of file name (gzip) */
+    COMMENT,    /* i: waiting for end of comment (gzip) */
+    HCRC,       /* i: waiting for header crc (gzip) */
+    DICTID,     /* i: waiting for dictionary check value */
+    DICT,       /* waiting for inflateSetDictionary() call */
+        TYPE,       /* i: waiting for type bits, including last-flag bit */
+        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
+        STORED,     /* i: waiting for stored size (length and complement) */
+        COPY,       /* i/o: waiting for input or output to copy stored block */
+        TABLE,      /* i: waiting for dynamic block table lengths */
+        LENLENS,    /* i: waiting for code length code lengths */
+        CODELENS,   /* i: waiting for length/lit and distance code lengths */
+            LEN,        /* i: waiting for length/lit code */
+            LENEXT,     /* i: waiting for length extra bits */
+            DIST,       /* i: waiting for distance code */
+            DISTEXT,    /* i: waiting for distance extra bits */
+            MATCH,      /* o: waiting for output space to copy string */
+            LIT,        /* o: waiting for output space to write literal */
+    CHECK,      /* i: waiting for 32-bit check value */
+    LENGTH,     /* i: waiting for 32-bit length (gzip) */
+    DONE,       /* finished check, done -- remain here until reset */
+    BAD,        /* got a data error -- remain here until reset */
+    MEM,        /* got an inflate() memory error -- remain here until reset */
+    SYNC        /* looking for synchronization bytes to restart inflate() */
+} inflate_mode;
+
+/*
+    State transitions between above modes -
+
+    (most modes can go to the BAD or MEM mode -- not shown for clarity)
+
+    Process header:
+        HEAD -> (gzip) or (zlib)
+        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
+        NAME -> COMMENT -> HCRC -> TYPE
+        (zlib) -> DICTID or TYPE
+        DICTID -> DICT -> TYPE
+    Read deflate blocks:
+            TYPE -> STORED or TABLE or LEN or CHECK
+            STORED -> COPY -> TYPE
+            TABLE -> LENLENS -> CODELENS -> LEN
+    Read deflate codes:
+                LEN -> LENEXT or LIT or TYPE
+                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
+                LIT -> LEN
+    Process trailer:
+        CHECK -> LENGTH -> DONE
+ */
+
+/* state maintained between inflate() calls.  Approximately 7K bytes. */
+struct inflate_state {
+    inflate_mode mode;          /* current inflate mode */
+    int last;                   /* true if processing last block */
+    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
+    int havedict;               /* true if dictionary provided */
+    int flags;                  /* gzip header method and flags (0 if zlib) */
+    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
+    unsigned long check;        /* protected copy of check value */
+    unsigned long total;        /* protected copy of output count */
+    gz_headerp head;            /* where to save gzip header information */
+        /* sliding window */
+    unsigned wbits;             /* log base 2 of requested window size */
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned write;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if needed */
+        /* bit accumulator */
+    unsigned long hold;         /* input bit accumulator */
+    unsigned bits;              /* number of bits in "in" */
+        /* for string and stored block copying */
+    unsigned length;            /* literal or length of data to copy */
+    unsigned offset;            /* distance back to copy string from */
+        /* for table and code decoding */
+    unsigned extra;             /* extra bits needed */
+        /* fixed and dynamic code tables */
+    code const FAR *lencode;    /* starting table for length/literal codes */
+    code const FAR *distcode;   /* starting table for distance codes */
+    unsigned lenbits;           /* index bits for lencode */
+    unsigned distbits;          /* index bits for distcode */
+        /* dynamic table building */
+    unsigned ncode;             /* number of code length code lengths */
+    unsigned nlen;              /* number of length code lengths */
+    unsigned ndist;             /* number of distance code lengths */
+    unsigned have;              /* number of code lengths in lens[] */
+    code FAR *next;             /* next available space in codes[] */
+    unsigned short lens[320];   /* temporary storage for code lengths */
+    unsigned short work[288];   /* work area for code table building */
+    code codes[ENOUGH];         /* space for code tables */
+};
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inftrees.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,353 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+
+#define MAXBITS 15
+
+const char inflate_copyright[] =
+   " inflate 1.2.3 Copyright 1995-2005 Mark Adler ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/*
+   Build a set of tables to decode the provided canonical Huffman code.
+   The code lengths are lens[0..codes-1].  The result starts at *table,
+   whose indices are 0..2^bits-1.  work is a writable array of at least
+   lens shorts, which is used as a work area.  type is the type of code
+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
+   on return points to the next available entry's address.  bits is the
+   requested root table index bits, and on return it is the actual root
+   table index bits.  It will differ if the request is greater than the
+   longest code or if it is less than the shortest code.
+ */
+int inflate_table(type, lens, codes, table, bits, work)
+codetype type;
+unsigned short FAR *lens;
+unsigned codes;
+code FAR * FAR *table;
+unsigned FAR *bits;
+unsigned short FAR *work;
+{
+    unsigned len;               /* a code's length in bits */
+    unsigned sym;               /* index of code symbols */
+    unsigned min, max;          /* minimum and maximum code lengths */
+    unsigned root;              /* number of index bits for root table */
+    unsigned curr;              /* number of index bits for current table */
+    unsigned drop;              /* code bits to drop for sub-table */
+    int left;                   /* number of prefix codes available */
+    unsigned used;              /* code entries in table used */
+    unsigned huff;              /* Huffman code */
+    unsigned incr;              /* for incrementing code, index */
+    unsigned fill;              /* index for replicating entries */
+    unsigned low;               /* low bits for current root entry */
+    unsigned mask;              /* mask for low root bits */
+    code this;                  /* table entry for duplication */
+    code FAR *next;             /* next available space in table */
+    const unsigned short FAR *base;     /* base value table to use */
+    const unsigned short FAR *extra;    /* extra bits table to use */
+    int end;                    /* use base and extra for symbol > end */
+    unsigned short count[MAXBITS+1];    /* number of codes of each length */
+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577, 0, 0};
+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+        28, 28, 29, 29, 64, 64};
+
+    /*
+       Process a set of code lengths to create a canonical Huffman code.  The
+       code lengths are lens[0..codes-1].  Each length corresponds to the
+       symbols 0..codes-1.  The Huffman code is generated by first sorting the
+       symbols by length from short to long, and retaining the symbol order
+       for codes with equal lengths.  Then the code starts with all zero bits
+       for the first code of the shortest length, and the codes are integer
+       increments for the same length, and zeros are appended as the length
+       increases.  For the deflate format, these bits are stored backwards
+       from their more natural integer increment ordering, and so when the
+       decoding tables are built in the large loop below, the integer codes
+       are incremented backwards.
+
+       This routine assumes, but does not check, that all of the entries in
+       lens[] are in the range 0..MAXBITS.  The caller must assure this.
+       1..MAXBITS is interpreted as that code length.  zero means that that
+       symbol does not occur in this code.
+
+       The codes are sorted by computing a count of codes for each length,
+       creating from that a table of starting indices for each length in the
+       sorted table, and then entering the symbols in order in the sorted
+       table.  The sorted table is work[], with that space being provided by
+       the caller.
+
+       The length counts are used for other purposes as well, i.e. finding
+       the minimum and maximum length codes, determining if there are any
+       codes at all, checking for a valid set of lengths, and looking ahead
+       at length counts to determine sub-table sizes when building the
+       decoding tables.
+     */
+
+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+    for (len = 0; len <= MAXBITS; len++)
+        count[len] = 0;
+    for (sym = 0; sym < codes; sym++)
+        count[lens[sym]]++;
+
+    /* bound code lengths, force root to be within code lengths */
+    root = *bits;
+    for (max = MAXBITS; max >= 1; max--)
+        if (count[max] != 0) break;
+    if (root > max) root = max;
+    if (max == 0) {                     /* no symbols to code at all */
+        this.op = (unsigned char)64;    /* invalid code marker */
+        this.bits = (unsigned char)1;
+        this.val = (unsigned short)0;
+        *(*table)++ = this;             /* make a table to force an error */
+        *(*table)++ = this;
+        *bits = 1;
+        return 0;     /* no symbols, but wait for decoding to report error */
+    }
+    for (min = 1; min <= MAXBITS; min++)
+        if (count[min] != 0) break;
+    if (root < min) root = min;
+
+    /* check for an over-subscribed or incomplete set of lengths */
+    left = 1;
+    for (len = 1; len <= MAXBITS; len++) {
+        left <<= 1;
+        left -= count[len];
+        if (left < 0) return -1;        /* over-subscribed */
+    }
+    if (left > 0 && (type == CODES || max != 1))
+        return -1;                      /* incomplete set */
+
+    /* generate offsets into symbol table for each length for sorting */
+    offs[1] = 0;
+    for (len = 1; len < MAXBITS; len++)
+        offs[len + 1] = offs[len] + count[len];
+
+    /* sort symbols by length, by symbol order within each length */
+    for (sym = 0; sym < codes; sym++)
+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
+
+    /*
+       Create and fill in decoding tables.  In this loop, the table being
+       filled is at next and has curr index bits.  The code being used is huff
+       with length len.  That code is converted to an index by dropping drop
+       bits off of the bottom.  For codes where len is less than drop + curr,
+       those top drop + curr - len bits are incremented through all values to
+       fill the table with replicated entries.
+
+       root is the number of index bits for the root table.  When len exceeds
+       root, sub-tables are created pointed to by the root entry with an index
+       of the low root bits of huff.  This is saved in low to check for when a
+       new sub-table should be started.  drop is zero when the root table is
+       being filled, and drop is root when sub-tables are being filled.
+
+       When a new sub-table is needed, it is necessary to look ahead in the
+       code lengths to determine what size sub-table is needed.  The length
+       counts are used for this, and so count[] is decremented as codes are
+       entered in the tables.
+
+       used keeps track of how many table entries have been allocated from the
+       provided *table space.  It is checked when a LENS table is being made
+       against the space in *table, ENOUGH, minus the maximum space needed by
+       the worst case distance code, MAXD.  This should never happen, but the
+       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
+       This assumes that when type == LENS, bits == 9.
+
+       sym increments through all symbols, and the loop terminates when
+       all codes of length max, i.e. all codes, have been processed.  This
+       routine permits incomplete codes, so another loop after this one fills
+       in the rest of the decoding tables with invalid code markers.
+     */
+
+    /* set up for code type */
+    switch (type) {
+    case CODES:
+        base = extra = work;    /* dummy value--not used */
+        end = 19;
+        break;
+    case LENS:
+        base = lbase;
+        base -= 257;
+        extra = lext;
+        extra -= 257;
+        end = 256;
+        break;
+    default:            /* DISTS */
+        base = dbase;
+        extra = dext;
+        end = -1;
+    }
+
+    /* initialize state for loop */
+    huff = 0;                   /* starting code */
+    sym = 0;                    /* starting code symbol */
+    len = min;                  /* starting code length */
+    next = *table;              /* current table to fill in */
+    curr = root;                /* current table index bits */
+    drop = 0;                   /* current bits to drop from code for index */
+    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
+    used = 1U << root;          /* use root table entries */
+    mask = used - 1;            /* mask for comparing low */
+
+    /* check available table space */
+    if (type == LENS && used >= ENOUGH - MAXD)
+        return 1;
+
+    /* process all codes and make table entries */
+    for (;;) {
+        /* create table entry */
+        this.bits = (unsigned char)(len - drop);
+        if ((int)(work[sym]) < end) {
+            this.op = (unsigned char)0;
+            this.val = work[sym];
+        }
+        else if ((int)(work[sym]) > end) {
+            this.op = (unsigned char)(extra[work[sym]]);
+            this.val = base[work[sym]];
+        }
+        else {
+            this.op = (unsigned char)(32 + 64);         /* end of block */
+            this.val = 0;
+        }
+
+        /* replicate for those indices with low len bits equal to huff */
+        incr = 1U << (len - drop);
+        fill = 1U << curr;
+        min = fill;                 /* save offset to next table */
+        do {
+            fill -= incr;
+            next[(huff >> drop) + fill] = this;
+        } while (fill != 0);
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+
+        /* go to next symbol, update count, len */
+        sym++;
+        if (--(count[len]) == 0) {
+            if (len == max) break;
+            len = lens[work[sym]];
+        }
+
+        /* create new sub-table if needed */
+        if (len > root && (huff & mask) != low) {
+            /* if first time, transition to sub-tables */
+            if (drop == 0)
+                drop = root;
+
+            /* increment past last table */
+            next += min;            /* here min is 1 << curr */
+
+            /* determine length of next table */
+            curr = len - drop;
+            left = (int)(1 << curr);
+            while (curr + drop < max) {
+                left -= count[curr + drop];
+                if (left <= 0) break;
+                curr++;
+                left <<= 1;
+            }
+
+            /* check for enough space */
+            used += 1U << curr;
+            if (type == LENS && used >= ENOUGH - MAXD)
+                return 1;
+
+            /* point entry in root table to sub-table */
+            low = huff & mask;
+            (*table)[low].op = (unsigned char)curr;
+            (*table)[low].bits = (unsigned char)root;
+            (*table)[low].val = (unsigned short)(next - *table);
+        }
+    }
+
+    /*
+       Fill in rest of table for incomplete codes.  This loop is similar to the
+       loop above in incrementing huff for table indices.  It is assumed that
+       len is equal to curr + drop, so there is no loop needed to increment
+       through high index bits.  When the current sub-table is filled, the loop
+       drops back to the root table to fill in any remaining entries there.
+     */
+    this.op = (unsigned char)64;                /* invalid code marker */
+    this.bits = (unsigned char)(len - drop);
+    this.val = (unsigned short)0;
+    while (huff != 0) {
+        /* when done with sub-table, drop back to root table */
+        if (drop != 0 && (huff & mask) != low) {
+            drop = 0;
+            len = root;
+            next = *table;
+            this.bits = (unsigned char)len;
+        }
+
+        /* put invalid code marker in table */
+        next[huff >> drop] = this;
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+    }
+
+    /* set return parameters */
+    *table += used;
+    *bits = root;
+    return 0;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/inftrees.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,79 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Structure for decoding tables.  Each entry provides either the
+   information needed to do the operation requested by the code that
+   indexed that table entry, or it provides a pointer to another
+   table that indexes more bits of the code.  op indicates whether
+   the entry is a pointer to another table, a literal, a length or
+   distance, an end-of-block, or an invalid code.  For a table
+   pointer, the low four bits of op is the number of index bits of
+   that table.  For a length or distance, the low four bits of op
+   is the number of extra bits to get after the code.  bits is
+   the number of bits in this code or part of the code to drop off
+   of the bit buffer.  val is the actual byte to output in the case
+   of a literal, the base length or distance, or the offset from
+   the current table to the next table.  Each entry is four bytes. */
+typedef struct {
+    unsigned char op;           /* operation, extra bits, table bits */
+    unsigned char bits;         /* bits in this part of the code */
+    unsigned short val;         /* offset in table or code value */
+} code;
+
+/* op values as set by inflate_table():
+    00000000 - literal
+    0000tttt - table link, tttt != 0 is the number of table index bits
+    0001eeee - length or distance, eeee is the number of extra bits
+    01100000 - end of block
+    01000000 - invalid code
+ */
+
+/* Maximum size of dynamic tree.  The maximum found in a long but non-
+   exhaustive search was 1444 code structures (852 for length/literals
+   and 592 for distances, the latter actually the result of an
+   exhaustive search).  The true maximum is not known, but the value
+   below is more than safe. */
+#define ENOUGH 2048
+#define MAXD 592
+
+/* Type of code to build for inftable() */
+typedef enum {
+    CODES,
+    LENS,
+    DISTS
+} codetype;
+
+extern int inflate_table OF((codetype type, unsigned short FAR *lens,
+                             unsigned codes, code FAR * FAR *table,
+                             unsigned FAR *bits, unsigned short FAR *work));
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/patches/ChangeLog_java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,16 @@
+(1)renamed
+   adler32.c -> zadler32.c
+   zcrc32c -> zcrc32.c
+
+(2)added _LP64 to make uLong a 32-bit int on 64-bit platform
+   zconf.h:
+   uLong -> 32-bit int
+
+(3)updated crc32.c/crc32()
+   unsigned long      -> uLong
+
+(4)updated zlib.h (to support > 4G zipfile):
+   total_in/out: uLong -> long long
+
+(5)updated upinflate.c/inflateSync()
+   unsigned long in, out; -->  long long in, out;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/patches/crc32.c.diff	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,25 @@
+--- /home/sherman/TL/zlib-1.2.3_ORG/crc32.c	Sun Jun 12 16:56:07 2005
++++ zcrc32.c	Tue Aug 25 14:22:41 2009
+@@ -216,8 +216,8 @@
+ #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
+ 
+ /* ========================================================================= */
+-unsigned long ZEXPORT crc32(crc, buf, len)
+-    unsigned long crc;
++uLong ZEXPORT crc32(crc, buf, len)
++    uLong crc;
+     const unsigned char FAR *buf;
+     unsigned len;
+ {
+@@ -234,9 +234,9 @@
+ 
+         endian = 1;
+         if (*((unsigned char *)(&endian)))
+-            return crc32_little(crc, buf, len);
++            return (uLong)crc32_little(crc, buf, len);
+         else
+-            return crc32_big(crc, buf, len);
++            return (uLong)crc32_big(crc, buf, len);
+     }
+ #endif /* BYFOUR */
+     crc = crc ^ 0xffffffffUL;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/patches/inflate.c.diff	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,11 @@
+--- /home/sherman/TL/zlib-1.2.3_ORG/inflate.c	Tue Jun 14 14:50:12 2005
++++ inflate.c	Tue Aug 25 14:22:09 2009
+@@ -1263,7 +1263,7 @@
+ z_streamp strm;
+ {
+     unsigned len;               /* number of bytes to look at or looked at */
+-    unsigned long in, out;      /* temporary to save total_in and total_out */
++    long long in, out;          /* temporary to save total_in and total_out */
+     unsigned char buf[4];       /* to restore bit buffer to byte string */
+     struct inflate_state FAR *state;
+ 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/patches/zconf.h.diff	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,24 @@
+--- /home/sherman/TL/zlib-1.2.3_ORG/zconf.h	Fri May 27 23:40:35 2005
++++ zconf.h	Tue Aug 25 14:22:28 2009
+@@ -8,6 +8,9 @@
+ #ifndef ZCONF_H
+ #define ZCONF_H
+ 
++/* for _LP64 */
++#include <sys/types.h>
++
+ /*
+  * If you *really* need a unique prefix for all types and library functions,
+  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+@@ -261,7 +264,11 @@
+ typedef unsigned char  Byte;  /* 8 bits */
+ #endif
+ typedef unsigned int   uInt;  /* 16 bits or more */
++#ifdef _LP64
++typedef unsigned int  uLong;  /* 32 bits or more */
++#else
+ typedef unsigned long  uLong; /* 32 bits or more */
++#endif
+ 
+ #ifdef SMALL_MEDIUM
+    /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/patches/zlib.h.diff	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,25 @@
+--- /home/sherman/TL/zlib-1.2.3_ORG/zlib.h	Sun Jul 17 19:26:49 2005
++++ zlib.h	Tue Aug 25 14:22:50 2009
+@@ -82,11 +82,11 @@
+ typedef struct z_stream_s {
+     Bytef    *next_in;  /* next input byte */
+     uInt     avail_in;  /* number of bytes available at next_in */
+-    uLong    total_in;  /* total nb of input bytes read so far */
++    long long total_in; /* total nb of input bytes read so far */
+ 
+     Bytef    *next_out; /* next output byte should be put there */
+     uInt     avail_out; /* remaining free space at next_out */
+-    uLong    total_out; /* total nb of bytes output so far */
++    long long total_out;/* total nb of bytes output so far */
+ 
+     char     *msg;      /* last error message, NULL if no error */
+     struct internal_state FAR *state; /* not visible by applications */
+@@ -1348,7 +1348,7 @@
+ 
+ ZEXTERN const char   * ZEXPORT zError           OF((int));
+ ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
++ZEXTERN const unsigned long FAR * ZEXPORT get_crc_table    OF((void));
+ 
+ #ifdef __cplusplus
+ }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/trees.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,1243 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-2005 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* @(#) $Id$ */
+
+/* #define GEN_TREES_H */
+
+#include "deflate.h"
+
+#ifdef DEBUG
+#  include <ctype.h>
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local const int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local const uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+/* non ANSI compilers may not accept trees.h */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+uch _dist_code[DIST_CODE_LEN];
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+uch _length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+#else
+#  include "trees.h"
+#endif /* GEN_TREES_H */
+
+struct static_tree_desc_s {
+    const ct_data *static_tree;  /* static tree or NULL */
+    const intf *extra_bits;      /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
+local void set_data_type  OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifdef GEN_TREES_H
+local void gen_trees_header OF((void));
+#endif
+
+#ifndef DEBUG
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG */
+#  define send_code(s, c, tree) \
+     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) & 0xff)); \
+    put_byte(s, (uch)((ush)(w) >> 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+#ifdef DEBUG
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr," l %2d v %4x ", length, value));
+    Assert(length > 0 && length <= 15, "invalid length");
+    s->bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s->bi_valid > (int)Buf_size - length) {
+        s->bi_buf |= (value << s->bi_valid);
+        put_short(s, s->bi_buf);
+        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_valid += length - Buf_size;
+    } else {
+        s->bi_buf |= value << s->bi_valid;
+        s->bi_valid += length;
+    }
+}
+#else /* !DEBUG */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s->bi_valid > (int)Buf_size - len) {\
+    int val = value;\
+    s->bi_buf |= (val << s->bi_valid);\
+    put_short(s, s->bi_buf);\
+    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_valid += len - Buf_size;\
+  } else {\
+    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_valid += len;\
+  }\
+}
+#endif /* DEBUG */
+
+
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+local void tr_static_init()
+{
+#if defined(GEN_TREES_H) || !defined(STDC)
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* For some embedded targets, global variables are not initialized: */
+    static_l_desc.static_tree = static_ltree;
+    static_l_desc.extra_bits = extra_lbits;
+    static_d_desc.static_tree = static_dtree;
+    static_d_desc.extra_bits = extra_dbits;
+    static_bl_desc.extra_bits = extra_blbits;
+
+    /* Initialize the mapping length (0..255) -> length code (0..28) */
+    length = 0;
+    for (code = 0; code < LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n < (1<<extra_lbits[code]); n++) {
+            _length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, "tr_static_init: length != 256");
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    _length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code < 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n < (1<<extra_dbits[code]); n++) {
+            _dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: dist != 256");
+    dist >>= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code < D_CODES; code++) {
+        base_dist[code] = dist << 7;
+        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
+            _dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n < D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+
+#  ifdef GEN_TREES_H
+    gen_trees_header();
+#  endif
+#endif /* defined(GEN_TREES_H) || !defined(STDC) */
+}
+
+/* ===========================================================================
+ * Genererate the file trees.h describing the static trees.
+ */
+#ifdef GEN_TREES_H
+#  ifndef DEBUG
+#    include <stdio.h>
+#  endif
+
+#  define SEPARATOR(i, last, width) \
+      ((i) == (last)? "\n};\n\n" :    \
+       ((i) % (width) == (width)-1 ? ",\n" : ", "))
+
+void gen_trees_header()
+{
+    FILE *header = fopen("trees.h", "w");
+    int i;
+
+    Assert (header != NULL, "Can't open trees.h");
+    fprintf(header,
+            "/* header created automatically with -DGEN_TREES_H */\n\n");
+
+    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
+    for (i = 0; i < L_CODES+2; i++) {
+        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
+                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
+    }
+
+    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
+                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
+    }
+
+    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
+    for (i = 0; i < DIST_CODE_LEN; i++) {
+        fprintf(header, "%2u%s", _dist_code[i],
+                SEPARATOR(i, DIST_CODE_LEN-1, 20));
+    }
+
+    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
+    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
+        fprintf(header, "%2u%s", _length_code[i],
+                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
+    }
+
+    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
+    for (i = 0; i < LENGTH_CODES; i++) {
+        fprintf(header, "%1u%s", base_length[i],
+                SEPARATOR(i, LENGTH_CODES-1, 20));
+    }
+
+    fprintf(header, "local const int base_dist[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+        fprintf(header, "%5u%s", base_dist[i],
+                SEPARATOR(i, D_CODES-1, 10));
+    }
+
+    fclose(header);
+}
+#endif /* GEN_TREES_H */
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s->l_desc.dyn_tree = s->dyn_ltree;
+    s->l_desc.stat_desc = &static_l_desc;
+
+    s->d_desc.dyn_tree = s->dyn_dtree;
+    s->d_desc.stat_desc = &static_d_desc;
+
+    s->bl_desc.dyn_tree = s->bl_tree;
+    s->bl_desc.stat_desc = &static_bl_desc;
+
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG
+    s->compressed_len = 0L;
+    s->bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+
+    s->dyn_ltree[END_BLOCK].Freq = 1;
+    s->opt_len = s->static_len = 0L;
+    s->last_lit = s->matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s->heap[SMALLEST]; \
+    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq < tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s->heap[k];
+    int j = k << 1;  /* left son of k */
+    while (j <= s->heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j < s->heap_len &&
+            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s->heap[j], s->depth)) break;
+
+        /* Exchange v with the smallest son */
+        s->heap[k] = s->heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j <<= 1;
+    }
+    s->heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree        = desc->dyn_tree;
+    int max_code         = desc->max_code;
+    const ct_data *stree = desc->stat_desc->static_tree;
+    const intf *extra    = desc->stat_desc->extra_bits;
+    int base             = desc->stat_desc->extra_base;
+    int max_length       = desc->stat_desc->max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+        n = s->heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits > max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n > max_code) continue; /* not a leaf node */
+
+        s->bl_count[bits]++;
+        xbits = 0;
+        if (n >= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s->opt_len += (ulg)f * (bits + xbits);
+        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,"\nbit length overflow\n"));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s->bl_count[bits] == 0) bits--;
+        s->bl_count[bits]--;      /* move one leaf down the tree */
+        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s->bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow > 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s->bl_count[bits];
+        while (n != 0) {
+            m = s->heap[--h];
+            if (m > max_code) continue;
+            if ((unsigned) tree[m].Len != (unsigned) bits) {
+                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+                s->opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits <= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+            "inconsistent bit counts");
+    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+    for (n = 0;  n <= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree         = desc->dyn_tree;
+    const ct_data *stree  = desc->stat_desc->static_tree;
+    int elems             = desc->stat_desc->elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s->heap_len = 0, s->heap_max = HEAP_SIZE;
+
+    for (n = 0; n < elems; n++) {
+        if (tree[n].Freq != 0) {
+            s->heap[++(s->heap_len)] = max_code = n;
+            s->depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s->heap_len < 2) {
+        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s->depth[node] = 0;
+        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc->max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s->heap[SMALLEST]; /* m = node of next least frequency */
+
+        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
+        s->heap[--(s->heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
+                                s->depth[n] : s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s->bl_tree) {
+            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s->heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s->heap_len >= 2);
+
+    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            s->bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+            s->bl_tree[REP_3_6].Freq++;
+        } else if (count <= 10) {
+            s->bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s->bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s->bl_tree); count--;
+            }
+            Assert(count >= 3 && count <= 6, " 3_6?");
+            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count <= 10) {
+            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
+    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
+        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+            s->opt_len, s->static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+            "too many codes");
+    Tracev((stderr, "\nbl counts: "));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank < blcodes; rank++) {
+        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void _tr_stored_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+#ifdef DEBUG
+    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len += (stored_len + 4) << 3;
+#endif
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES<<1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
+#endif
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
+        send_bits(s, STATIC_TREES<<1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+        s->compressed_len += 10L;
+#endif
+        bi_flush(s);
+    }
+    s->last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+void _tr_flush_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s->level > 0) {
+
+        /* Check if the file is binary or text */
+        if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)
+            set_data_type(s);
+
+        /* Construct the literal and distance trees */
+        build_tree(s, (tree_desc *)(&(s->l_desc)));
+        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+                s->static_len));
+
+        build_tree(s, (tree_desc *)(&(s->d_desc)));
+        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+                s->static_len));
+        /* At this point, opt_len and static_len are the total bit lengths of
+         * the compressed block data, excluding the tree representations.
+         */
+
+        /* Build the bit length tree for the above two trees, and get the index
+         * in bl_order of the last bit length code to send.
+         */
+        max_blindex = build_bl_tree(s);
+
+        /* Determine the best encoding. Compute the block lengths in bytes. */
+        opt_lenb = (s->opt_len+3+7)>>3;
+        static_lenb = (s->static_len+3+7)>>3;
+
+        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+                s->last_lit));
+
+        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, "lost buf");
+        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, eof);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb >= 0) { /* force static trees */
+#else
+    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES<<1)+eof, 3);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->static_len;
+#endif
+    } else {
+        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->opt_len;
+#endif
+    }
+    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+    /* The above check is made mod 2^32, for files larger than 512 MB
+     * and uLong implemented on 32 bits.
+     */
+    init_block(s);
+
+    if (eof) {
+        bi_windup(s);
+#ifdef DEBUG
+        s->compressed_len += 7;  /* align on byte boundary */
+#endif
+    }
+    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+           s->compressed_len-7*eof));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s->d_buf[s->last_lit] = (ush)dist;
+    s->l_buf[s->last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s->dyn_ltree[lc].Freq++;
+    } else {
+        s->matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist < (ush)MAX_DIST(s) &&
+               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
+        s->dyn_dtree[d_code(dist)].Freq++;
+    }
+
+#ifdef TRUNCATE_BLOCK
+    /* Try to guess if it is profitable to stop the current block here */
+    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s->last_lit*8L;
+        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        int dcode;
+        for (dcode = 0; dcode < D_CODES; dcode++) {
+            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length >>= 3;
+        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+               s->last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+    }
+#endif
+    return (s->last_lit == s->lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s->last_lit != 0) do {
+        dist = s->d_buf[lx];
+        lc = s->l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = _length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code < D_CODES, "bad d_code");
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
+               "pendingBuf overflow");
+
+    } while (lx < s->last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s->last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Set the data type to BINARY or TEXT, using a crude approximation:
+ * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
+ * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
+ * IN assertion: the fields Freq of dyn_ltree are set.
+ */
+local void set_data_type(s)
+    deflate_state *s;
+{
+    int n;
+
+    for (n = 0; n < 9; n++)
+        if (s->dyn_ltree[n].Freq != 0)
+            break;
+    if (n == 9)
+        for (n = 14; n < 32; n++)
+            if (s->dyn_ltree[n].Freq != 0)
+                break;
+    s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code & 1;
+        code >>= 1, res <<= 1;
+    } while (--len > 0);
+    return res >> 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s->bi_valid == 16) {
+        put_short(s, s->bi_buf);
+        s->bi_buf = 0;
+        s->bi_valid = 0;
+    } else if (s->bi_valid >= 8) {
+        put_byte(s, (Byte)s->bi_buf);
+        s->bi_buf >>= 8;
+        s->bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s->bi_valid > 8) {
+        put_short(s, s->bi_buf);
+    } else if (s->bi_valid > 0) {
+        put_byte(s, (Byte)s->bi_buf);
+    }
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+#ifdef DEBUG
+    s->bits_sent = (s->bits_sent+7) & ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);
+        put_short(s, (ush)~len);
+#ifdef DEBUG
+        s->bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG
+    s->bits_sent += (ulg)len<<3;
+#endif
+    while (len--) {
+        put_byte(s, *buf++);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/trees.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,152 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* header created automatically with -DGEN_TREES_H */
+
+local const ct_data static_ltree[L_CODES+2] = {
+{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
+{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
+{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
+{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
+{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
+{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
+{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
+{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
+{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
+{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
+{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
+{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
+{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
+{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
+{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
+{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
+{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
+{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
+{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
+{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
+{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
+{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
+{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
+{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
+{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
+{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
+{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
+{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
+{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
+{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
+{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
+{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
+{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
+{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
+{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
+{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
+{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
+{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
+{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
+{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
+{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
+{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
+{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
+{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
+{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
+{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
+{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
+{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
+{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
+{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
+{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
+{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
+{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
+{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
+{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
+{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
+{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
+{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
+};
+
+local const ct_data static_dtree[D_CODES] = {
+{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
+{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
+{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
+{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
+{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
+{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
+};
+
+const uch _dist_code[DIST_CODE_LEN] = {
+ 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
+ 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
+10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
+18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
+};
+
+const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
+ 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
+13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
+17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
+22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
+};
+
+local const int base_length[LENGTH_CODES] = {
+0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
+64, 80, 96, 112, 128, 160, 192, 224, 0
+};
+
+local const int base_dist[D_CODES] = {
+    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
+   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
+ 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
+};
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/uncompr.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,85 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* uncompr.c -- decompress a memory buffer
+ * Copyright (C) 1995-2003 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#define ZLIB_INTERNAL
+#include "zlib.h"
+
+/* ===========================================================================
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+int ZEXPORT uncompress (dest, destLen, source, sourceLen)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+    /* Check for source > 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+
+    err = inflateInit(&stream);
+    if (err != Z_OK) return err;
+
+    err = inflate(&stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        inflateEnd(&stream);
+        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
+            return Z_DATA_ERROR;
+        return err;
+    }
+    *destLen = stream.total_out;
+
+    err = inflateEnd(&stream);
+    return err;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zadler32.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,173 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-2004 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#define ZLIB_INTERNAL
+#include "zlib.h"
+
+#define BASE 65521UL    /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* use NO_DIVIDE if your processor does not do division in hardware */
+#ifdef NO_DIVIDE
+#  define MOD(a) \
+    do { \
+        if (a >= (BASE << 16)) a -= (BASE << 16); \
+        if (a >= (BASE << 15)) a -= (BASE << 15); \
+        if (a >= (BASE << 14)) a -= (BASE << 14); \
+        if (a >= (BASE << 13)) a -= (BASE << 13); \
+        if (a >= (BASE << 12)) a -= (BASE << 12); \
+        if (a >= (BASE << 11)) a -= (BASE << 11); \
+        if (a >= (BASE << 10)) a -= (BASE << 10); \
+        if (a >= (BASE << 9)) a -= (BASE << 9); \
+        if (a >= (BASE << 8)) a -= (BASE << 8); \
+        if (a >= (BASE << 7)) a -= (BASE << 7); \
+        if (a >= (BASE << 6)) a -= (BASE << 6); \
+        if (a >= (BASE << 5)) a -= (BASE << 5); \
+        if (a >= (BASE << 4)) a -= (BASE << 4); \
+        if (a >= (BASE << 3)) a -= (BASE << 3); \
+        if (a >= (BASE << 2)) a -= (BASE << 2); \
+        if (a >= (BASE << 1)) a -= (BASE << 1); \
+        if (a >= BASE) a -= BASE; \
+    } while (0)
+#  define MOD4(a) \
+    do { \
+        if (a >= (BASE << 4)) a -= (BASE << 4); \
+        if (a >= (BASE << 3)) a -= (BASE << 3); \
+        if (a >= (BASE << 2)) a -= (BASE << 2); \
+        if (a >= (BASE << 1)) a -= (BASE << 1); \
+        if (a >= BASE) a -= BASE; \
+    } while (0)
+#else
+#  define MOD(a) a %= BASE
+#  define MOD4(a) a %= BASE
+#endif
+
+/* ========================================================================= */
+uLong ZEXPORT adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long sum2;
+    unsigned n;
+
+    /* split Adler-32 into component sums */
+    sum2 = (adler >> 16) & 0xffff;
+    adler &= 0xffff;
+
+    /* in case user likes doing a byte at a time, keep it fast */
+    if (len == 1) {
+        adler += buf[0];
+        if (adler >= BASE)
+            adler -= BASE;
+        sum2 += adler;
+        if (sum2 >= BASE)
+            sum2 -= BASE;
+        return adler | (sum2 << 16);
+    }
+
+    /* initial Adler-32 value (deferred check for len == 1 speed) */
+    if (buf == Z_NULL)
+        return 1L;
+
+    /* in case short lengths are provided, keep it somewhat fast */
+    if (len < 16) {
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        if (adler >= BASE)
+            adler -= BASE;
+        MOD4(sum2);             /* only added so many BASE's */
+        return adler | (sum2 << 16);
+    }
+
+    /* do length NMAX blocks -- requires just one modulo operation */
+    while (len >= NMAX) {
+        len -= NMAX;
+        n = NMAX / 16;          /* NMAX is divisible by 16 */
+        do {
+            DO16(buf);          /* 16 sums unrolled */
+            buf += 16;
+        } while (--n);
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* do remaining bytes (less than NMAX, still just one modulo) */
+    if (len) {                  /* avoid modulos if none remaining */
+        while (len >= 16) {
+            len -= 16;
+            DO16(buf);
+            buf += 16;
+        }
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* return recombined sums */
+    return adler | (sum2 << 16);
+}
+
+/* ========================================================================= */
+uLong ZEXPORT adler32_combine(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off_t len2;
+{
+    unsigned long sum1;
+    unsigned long sum2;
+    unsigned rem;
+
+    /* the derivation of this formula is left as an exercise for the reader */
+    rem = (unsigned)(len2 % BASE);
+    sum1 = adler1 & 0xffff;
+    sum2 = rem * sum1;
+    MOD(sum2);
+    sum1 += (adler2 & 0xffff) + BASE - 1;
+    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
+    if (sum1 > BASE) sum1 -= BASE;
+    if (sum1 > BASE) sum1 -= BASE;
+    if (sum2 > (BASE << 1)) sum2 -= (BASE << 1);
+    if (sum2 > BASE) sum2 -= BASE;
+    return sum1 | (sum2 << 16);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zconf.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,363 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/* for _LP64 */
+#include <sys/types.h>
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+#ifdef _LP64
+typedef unsigned int  uLong;  /* 32 bits or more */
+#else
+typedef unsigned long  uLong; /* 32 bits or more */
+#endif
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zcrc32.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,447 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
+ * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
+ * tables for updating the shift register in one step with three exclusive-ors
+ * instead of four steps with four exclusive-ors.  This results in about a
+ * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
+ */
+
+/* @(#) $Id$ */
+
+/*
+  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
+  protection on the static variables used to control the first-use generation
+  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
+  first call get_crc_table() to initialize the tables before allowing more than
+  one thread to use crc32().
+ */
+
+#ifdef MAKECRCH
+#  include <stdio.h>
+#  ifndef DYNAMIC_CRC_TABLE
+#    define DYNAMIC_CRC_TABLE
+#  endif /* !DYNAMIC_CRC_TABLE */
+#endif /* MAKECRCH */
+
+#include "zutil.h"      /* for STDC and FAR definitions */
+
+#define local static
+
+/* Find a four-byte integer type for crc32_little() and crc32_big(). */
+#ifndef NOBYFOUR
+#  ifdef STDC           /* need ANSI C limits.h to determine sizes */
+#    include <limits.h>
+#    define BYFOUR
+#    if (UINT_MAX == 0xffffffffUL)
+       typedef unsigned int u4;
+#    else
+#      if (ULONG_MAX == 0xffffffffUL)
+         typedef unsigned long u4;
+#      else
+#        if (USHRT_MAX == 0xffffffffUL)
+           typedef unsigned short u4;
+#        else
+#          undef BYFOUR     /* can't find a four-byte integer type! */
+#        endif
+#      endif
+#    endif
+#  endif /* STDC */
+#endif /* !NOBYFOUR */
+
+/* Definitions for doing the crc four data bytes at a time. */
+#ifdef BYFOUR
+#  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \
+                (((w)&0xff00)<<8)+(((w)&0xff)<<24))
+   local unsigned long crc32_little OF((unsigned long,
+                        const unsigned char FAR *, unsigned));
+   local unsigned long crc32_big OF((unsigned long,
+                        const unsigned char FAR *, unsigned));
+#  define TBLS 8
+#else
+#  define TBLS 1
+#endif /* BYFOUR */
+
+/* Local functions for crc concatenation */
+local unsigned long gf2_matrix_times OF((unsigned long *mat,
+                                         unsigned long vec));
+local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local volatile int crc_table_empty = 1;
+local unsigned long FAR crc_table[TBLS][256];
+local void make_crc_table OF((void));
+#ifdef MAKECRCH
+   local void write_table OF((FILE *, const unsigned long FAR *));
+#endif /* MAKECRCH */
+/*
+  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The first table is simply the CRC of all possible eight bit values.  This is
+  all the information needed to generate CRCs on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.  The remaining tables
+  allow for word-at-a-time CRC calculation for both big-endian and little-
+  endian machines, where a word is four bytes.
+*/
+local void make_crc_table()
+{
+    unsigned long c;
+    int n, k;
+    unsigned long poly;                 /* polynomial exclusive-or pattern */
+    /* terms of polynomial defining this crc (except x^32): */
+    static volatile int first = 1;      /* flag to limit concurrent making */
+    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+    /* See if another task is already doing this (not thread-safe, but better
+       than nothing -- significantly reduces duration of vulnerability in
+       case the advice about DYNAMIC_CRC_TABLE is ignored) */
+    if (first) {
+        first = 0;
+
+        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
+        poly = 0UL;
+        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
+            poly |= 1UL << (31 - p[n]);
+
+        /* generate a crc for every 8-bit value */
+        for (n = 0; n < 256; n++) {
+            c = (unsigned long)n;
+            for (k = 0; k < 8; k++)
+                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+            crc_table[0][n] = c;
+        }
+
+#ifdef BYFOUR
+        /* generate crc for each value followed by one, two, and three zeros,
+           and then the byte reversal of those as well as the first table */
+        for (n = 0; n < 256; n++) {
+            c = crc_table[0][n];
+            crc_table[4][n] = REV(c);
+            for (k = 1; k < 4; k++) {
+                c = crc_table[0][c & 0xff] ^ (c >> 8);
+                crc_table[k][n] = c;
+                crc_table[k + 4][n] = REV(c);
+            }
+        }
+#endif /* BYFOUR */
+
+        crc_table_empty = 0;
+    }
+    else {      /* not first */
+        /* wait for the other guy to finish (not efficient, but rare) */
+        while (crc_table_empty)
+            ;
+    }
+
+#ifdef MAKECRCH
+    /* write out CRC tables to crc32.h */
+    {
+        FILE *out;
+
+        out = fopen("crc32.h", "w");
+        if (out == NULL) return;
+        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
+        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
+        fprintf(out, "local const unsigned long FAR ");
+        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
+        write_table(out, crc_table[0]);
+#  ifdef BYFOUR
+        fprintf(out, "#ifdef BYFOUR\n");
+        for (k = 1; k < 8; k++) {
+            fprintf(out, "  },\n  {\n");
+            write_table(out, crc_table[k]);
+        }
+        fprintf(out, "#endif\n");
+#  endif /* BYFOUR */
+        fprintf(out, "  }\n};\n");
+        fclose(out);
+    }
+#endif /* MAKECRCH */
+}
+
+#ifdef MAKECRCH
+local void write_table(out, table)
+    FILE *out;
+    const unsigned long FAR *table;
+{
+    int n;
+
+    for (n = 0; n < 256; n++)
+        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
+                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
+}
+#endif /* MAKECRCH */
+
+#else /* !DYNAMIC_CRC_TABLE */
+/* ========================================================================
+ * Tables of CRC-32s of all single-byte values, made by make_crc_table().
+ */
+#include "crc32.h"
+#endif /* DYNAMIC_CRC_TABLE */
+
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const unsigned long FAR * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+        make_crc_table();
+#endif /* DYNAMIC_CRC_TABLE */
+    return (const unsigned long FAR *)crc_table;
+}
+
+/* ========================================================================= */
+#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
+#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
+
+/* ========================================================================= */
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const unsigned char FAR *buf;
+    unsigned len;
+{
+    if (buf == Z_NULL) return 0UL;
+
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+        make_crc_table();
+#endif /* DYNAMIC_CRC_TABLE */
+
+#ifdef BYFOUR
+    if (sizeof(void *) == sizeof(ptrdiff_t)) {
+        u4 endian;
+
+        endian = 1;
+        if (*((unsigned char *)(&endian)))
+            return (uLong)crc32_little(crc, buf, len);
+        else
+            return (uLong)crc32_big(crc, buf, len);
+    }
+#endif /* BYFOUR */
+    crc = crc ^ 0xffffffffUL;
+    while (len >= 8) {
+        DO8;
+        len -= 8;
+    }
+    if (len) do {
+        DO1;
+    } while (--len);
+    return crc ^ 0xffffffffUL;
+}
+
+#ifdef BYFOUR
+
+/* ========================================================================= */
+#define DOLIT4 c ^= *buf4++; \
+        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
+            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
+#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
+
+/* ========================================================================= */
+local unsigned long crc32_little(crc, buf, len)
+    unsigned long crc;
+    const unsigned char FAR *buf;
+    unsigned len;
+{
+    register u4 c;
+    register const u4 FAR *buf4;
+
+    c = (u4)crc;
+    c = ~c;
+    while (len && ((ptrdiff_t)buf & 3)) {
+        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
+        len--;
+    }
+
+    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    while (len >= 32) {
+        DOLIT32;
+        len -= 32;
+    }
+    while (len >= 4) {
+        DOLIT4;
+        len -= 4;
+    }
+    buf = (const unsigned char FAR *)buf4;
+
+    if (len) do {
+        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
+    } while (--len);
+    c = ~c;
+    return (unsigned long)c;
+}
+
+/* ========================================================================= */
+#define DOBIG4 c ^= *++buf4; \
+        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
+            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
+#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
+
+/* ========================================================================= */
+local unsigned long crc32_big(crc, buf, len)
+    unsigned long crc;
+    const unsigned char FAR *buf;
+    unsigned len;
+{
+    register u4 c;
+    register const u4 FAR *buf4;
+
+    c = REV((u4)crc);
+    c = ~c;
+    while (len && ((ptrdiff_t)buf & 3)) {
+        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
+        len--;
+    }
+
+    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    buf4--;
+    while (len >= 32) {
+        DOBIG32;
+        len -= 32;
+    }
+    while (len >= 4) {
+        DOBIG4;
+        len -= 4;
+    }
+    buf4++;
+    buf = (const unsigned char FAR *)buf4;
+
+    if (len) do {
+        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
+    } while (--len);
+    c = ~c;
+    return (unsigned long)(REV(c));
+}
+
+#endif /* BYFOUR */
+
+#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
+
+/* ========================================================================= */
+local unsigned long gf2_matrix_times(mat, vec)
+    unsigned long *mat;
+    unsigned long vec;
+{
+    unsigned long sum;
+
+    sum = 0;
+    while (vec) {
+        if (vec & 1)
+            sum ^= *mat;
+        vec >>= 1;
+        mat++;
+    }
+    return sum;
+}
+
+/* ========================================================================= */
+local void gf2_matrix_square(square, mat)
+    unsigned long *square;
+    unsigned long *mat;
+{
+    int n;
+
+    for (n = 0; n < GF2_DIM; n++)
+        square[n] = gf2_matrix_times(mat, mat[n]);
+}
+
+/* ========================================================================= */
+uLong ZEXPORT crc32_combine(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off_t len2;
+{
+    int n;
+    unsigned long row;
+    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
+    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
+
+    /* degenerate case */
+    if (len2 == 0)
+        return crc1;
+
+    /* put operator for one zero bit in odd */
+    odd[0] = 0xedb88320L;           /* CRC-32 polynomial */
+    row = 1;
+    for (n = 1; n < GF2_DIM; n++) {
+        odd[n] = row;
+        row <<= 1;
+    }
+
+    /* put operator for two zero bits in even */
+    gf2_matrix_square(even, odd);
+
+    /* put operator for four zero bits in odd */
+    gf2_matrix_square(odd, even);
+
+    /* apply len2 zeros to crc1 (first square will put the operator for one
+       zero byte, eight zero bits, in even) */
+    do {
+        /* apply zeros operator for this bit of len2 */
+        gf2_matrix_square(even, odd);
+        if (len2 & 1)
+            crc1 = gf2_matrix_times(even, crc1);
+        len2 >>= 1;
+
+        /* if no more bits set, then done */
+        if (len2 == 0)
+            break;
+
+        /* another iteration of the loop with odd and even swapped */
+        gf2_matrix_square(odd, even);
+        if (len2 & 1)
+            crc1 = gf2_matrix_times(odd, crc1);
+        len2 >>= 1;
+
+        /* if no more bits set, then done */
+    } while (len2 != 0);
+
+    /* return combined crc */
+    crc1 ^= crc2;
+    return crc1;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zlib.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,1381 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    long long total_in; /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    long long total_out;/* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: binary or text */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+    int     text;       /* true if compressed data believed to be text */
+    uLong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uInt    extra_max;  /* space at extra (only when reading header) */
+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uInt    name_max;   /* space at name (only when reading header) */
+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uInt    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumualte before producing output, in order to
+  maximize compression.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update strm->data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.  Z_FIXED prevents the
+   use of dynamic Huffman codes, allowing for a simpler decoder for special
+   applications.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front. In addition, the
+   current implementation of deflate will use at most the window size minus
+   262 bytes of the provided dictionary.
+
+     Upon return of this function, strm->adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm->adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
+                                    int good_length,
+                                    int max_lazy,
+                                    int nice_length,
+                                    int max_chain));
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a "multi-part
+   gzip file" and give up.
+
+      If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
+   is set to null if there is no error message.  inflateInit2 does not perform
+   any decompression apart from reading the zlib header if present: this will
+   be done by inflate(). (So next_in and avail_in may be modified, but next_out
+   and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+  that this function is used to start inflating at a bit position in the
+  middle of a byte.  The provided bits will be used before any bytes are used
+  from next_in.  This function should only be used with raw inflate, and
+  should be used before the first inflate() call after inflateInit2() or
+  inflateReset().  bits must be less than or equal to 16, and that many of the
+  least significant bits of value will be inserted in the input.
+
+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head->done is zero until the header
+   is completed, at which time head->done is set to one.  If a zlib stream is
+   being decoded, then head->done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
+   force inflate() to return immediately after header processing is complete
+   and before any actual data is decompressed.
+
+      The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When
+   any of extra, name, or comment are not Z_NULL and the respective field is
+   not present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+      If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm->next_in must be initialized before
+   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+   must also be initialized, and then if strm->avail_in is not zero, input will
+   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm->next_in and strm->avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm->msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm->next_in which will be Z_NULL only if in() returned
+   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm->next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h", or 'R' for run-length encoding
+   as in "wb1R". (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
+/*
+     Returns 1 if file is being read directly without decompression, otherwise
+   zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
+                                          z_off_t len2));
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
+
+/*
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const unsigned long FAR * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zutil.c	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,342 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#include "zutil.h"
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+const char * const z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
+
+
+const char * ZEXPORT zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+uLong ZEXPORT zlibCompileFlags()
+{
+    uLong flags;
+
+    flags = 0;
+    switch (sizeof(uInt)) {
+    case 2:     break;
+    case 4:     flags += 1;     break;
+    case 8:     flags += 2;     break;
+    default:    flags += 3;
+    }
+    switch (sizeof(uLong)) {
+    case 2:     break;
+    case 4:     flags += 1 << 2;        break;
+    case 8:     flags += 2 << 2;        break;
+    default:    flags += 3 << 2;
+    }
+    switch (sizeof(voidpf)) {
+    case 2:     break;
+    case 4:     flags += 1 << 4;        break;
+    case 8:     flags += 2 << 4;        break;
+    default:    flags += 3 << 4;
+    }
+    switch (sizeof(z_off_t)) {
+    case 2:     break;
+    case 4:     flags += 1 << 6;        break;
+    case 8:     flags += 2 << 6;        break;
+    default:    flags += 3 << 6;
+    }
+#ifdef DEBUG
+    flags += 1 << 8;
+#endif
+#if defined(ASMV) || defined(ASMINF)
+    flags += 1 << 9;
+#endif
+#ifdef ZLIB_WINAPI
+    flags += 1 << 10;
+#endif
+#ifdef BUILDFIXED
+    flags += 1 << 12;
+#endif
+#ifdef DYNAMIC_CRC_TABLE
+    flags += 1 << 13;
+#endif
+#ifdef NO_GZCOMPRESS
+    flags += 1L << 16;
+#endif
+#ifdef NO_GZIP
+    flags += 1L << 17;
+#endif
+#ifdef PKZIP_BUG_WORKAROUND
+    flags += 1L << 20;
+#endif
+#ifdef FASTEST
+    flags += 1L << 21;
+#endif
+#ifdef STDC
+#  ifdef NO_vsnprintf
+        flags += 1L << 25;
+#    ifdef HAS_vsprintf_void
+        flags += 1L << 26;
+#    endif
+#  else
+#    ifdef HAS_vsnprintf_void
+        flags += 1L << 26;
+#    endif
+#  endif
+#else
+        flags += 1L << 24;
+#  ifdef NO_snprintf
+        flags += 1L << 25;
+#    ifdef HAS_sprintf_void
+        flags += 1L << 26;
+#    endif
+#  else
+#    ifdef HAS_snprintf_void
+        flags += 1L << 26;
+#    endif
+#  endif
+#endif
+    return flags;
+}
+
+#ifdef DEBUG
+
+#  ifndef verbose
+#    define verbose 0
+#  endif
+int z_verbose = verbose;
+
+void z_error (m)
+    char *m;
+{
+    fprintf(stderr, "%s\n", m);
+    exit(1);
+}
+#endif
+
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
+ */
+const char * ZEXPORT zError(err)
+    int err;
+{
+    return ERR_MSG(err);
+}
+
+#if defined(_WIN32_WCE)
+    /* The Microsoft C Run-Time Library for Windows CE doesn't have
+     * errno.  We define it as a global variable to simplify porting.
+     * Its value is always 0 and should not be used.
+     */
+    int errno = 0;
+#endif
+
+#ifndef HAVE_MEMCPY
+
+void zmemcpy(dest, source, len)
+    Bytef* dest;
+    const Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int zmemcmp(s1, s2, len)
+    const Bytef* s1;
+    const Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j < len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+    }
+    return 0;
+}
+
+void zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+
+#ifdef SYS16BIT
+
+#ifdef __TURBOC__
+/* Turbo C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize < 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
+    *(ush*)&buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&ptr != 0) { /* object < 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n < next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n < next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, "zcfree: ptr not found");
+}
+
+#endif /* __TURBOC__ */
+
+
+#ifdef M_I86
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* M_I86 */
+
+#endif /* SYS16BIT */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  malloc OF((uInt size));
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
+                              (voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/native/java/util/zip/zlib-1.2.3/zutil.h	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,293 @@
+/*
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZUTIL_H
+#define ZUTIL_H
+
+#define ZLIB_INTERNAL
+#include "zlib.h"
+
+#ifdef STDC
+#  ifndef _WIN32_WCE
+#    include <stddef.h>
+#  endif
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#ifdef NO_ERRNO_H
+#   ifdef _WIN32_WCE
+      /* The Microsoft C Run-Time Library for Windows CE doesn't have
+       * errno.  We define it as a global variable to simplify porting.
+       * Its value is always 0 and should not be used.  We rename it to
+       * avoid conflict with other libraries that use the same workaround.
+       */
+#     define errno z_errno
+#   endif
+    extern int errno;
+#else
+#  ifndef _WIN32_WCE
+#    include <errno.h>
+#  endif
+#endif
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = (char*)ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
+#  define OS_CODE  0x00
+#  if defined(__TURBOC__) || defined(__BORLANDC__)
+#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
+       /* Allow compilation with ANSI keywords only enabled */
+       void _Cdecl farfree( void *block );
+       void *_Cdecl farmalloc( unsigned long nbytes );
+#    else
+#      include <alloc.h>
+#    endif
+#  else /* MSC or DJGPP */
+#    include <malloc.h>
+#  endif
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define F_OPEN(name, mode) \
+     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#  ifdef M_I86
+     #include <malloc.h>
+#  endif
+#endif
+
+#if defined(MACOS) || defined(TARGET_OS_MAC)
+#  define OS_CODE  0x07
+#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
+#    include <unix.h> /* for fdopen */
+#  else
+#    ifndef fdopen
+#      define fdopen(fd,mode) NULL /* No fdopen() */
+#    endif
+#  endif
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#ifdef WIN32
+#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
+#    define OS_CODE  0x0b
+#  endif
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0f
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+#if (defined(_MSC_VER) && (_MSC_VER > 600))
+#  if defined(_WIN32_WCE)
+#    define fdopen(fd,mode) NULL /* No fdopen() */
+#    ifndef _PTRDIFF_T_DEFINED
+       typedef int ptrdiff_t;
+#      define _PTRDIFF_T_DEFINED
+#    endif
+#  else
+#    define fdopen(fd,type)  _fdopen(fd,type)
+#  endif
+#endif
+
+        /* common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef F_OPEN
+#  define F_OPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
+#  ifndef HAVE_VSNPRINTF
+#    define HAVE_VSNPRINTF
+#  endif
+#endif
+#if defined(__CYGWIN__)
+#  ifndef HAVE_VSNPRINTF
+#    define HAVE_VSNPRINTF
+#  endif
+#endif
+#ifndef HAVE_VSNPRINTF
+#  ifdef MSDOS
+     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
+        but for now we just assume it doesn't. */
+#    define NO_vsnprintf
+#  endif
+#  ifdef __TURBOC__
+#    define NO_vsnprintf
+#  endif
+#  ifdef WIN32
+     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
+#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
+#      define vsnprintf _vsnprintf
+#    endif
+#  endif
+#  ifdef __SASC
+#    define NO_vsnprintf
+#  endif
+#endif
+#ifdef VMS
+#  define NO_vsnprintf
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
+ /* Use our own functions for small and medium model with MSC <= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  * The __SC__ check is for Symantec.
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
+   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
+   extern void zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  include <stdio.h>
+   extern int z_verbose;
+   extern void z_error    OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void   zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* ZUTIL_H */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/com/sun/java/swing/plaf/windows/Test6824600.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+   @bug 6824600
+   @summary OOM occurs when setLookAndFeel() is executed in Windows L&F(XP style)
+   @author Pavel Porvatov
+   @run main Test6824600
+*/
+
+import com.sun.java.swing.plaf.windows.DesktopProperty;
+
+import java.awt.*;
+
+public class Test6824600 {
+    public static void main(String[] args) throws Exception {
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+
+        HackedDesktopProperty desktopProperty = new HackedDesktopProperty("Button.background", null);
+
+        // Register listener in toolkit
+        desktopProperty.getValueFromDesktop();
+
+        int length = toolkit.getPropertyChangeListeners().length;
+
+        // Make several invocations
+        desktopProperty.getValueFromDesktop();
+        desktopProperty.getValueFromDesktop();
+
+        desktopProperty.invalidate();
+
+        desktopProperty.getValueFromDesktop();
+        desktopProperty.getValueFromDesktop();
+
+        if (length != toolkit.getPropertyChangeListeners().length) {
+            throw new RuntimeException("New listeners were added into Toolkit");
+        }
+    }
+
+    public static class HackedDesktopProperty extends DesktopProperty {
+        public HackedDesktopProperty(String key, Object fallback) {
+            super(key, fallback);
+        }
+
+        // Publish the method
+        public Object getValueFromDesktop() {
+            return super.getValueFromDesktop();
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/com/sun/security/auth/callback/TextCallbackHandler/Password.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6825240
+ * @summary Password.readPassword() echos the input when System.Console is null
+ * @ignore run these by hand
+ */
+
+import com.sun.security.auth.callback.TextCallbackHandler;
+import javax.security.auth.callback.*;
+
+public class Password {
+   public static void main(String args[]) throws Exception {
+        TextCallbackHandler h = new TextCallbackHandler();
+        PasswordCallback nc = new PasswordCallback("Invisible: ", false);
+        PasswordCallback nc2 = new PasswordCallback("Visible: ", true);
+
+        System.out.println("Two passwords will be prompted for. The first one " +
+                "should have echo off, the second one on. Otherwise, this test fails");
+        Callback[] callbacks = { nc, nc2 };
+        h.handle(callbacks);
+        System.out.println("You input " + new String(nc.getPassword()) +
+                " and " + new String(nc2.getPassword()));
+   }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/io/File/SymLinks.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,380 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6595866
+ * @summary Test java.io.File operations with sym links
+ */
+
+import java.io.*;
+import java.nio.file.Path;
+import java.nio.file.attribute.*;
+import static java.nio.file.LinkOption.*;
+
+public class SymLinks {
+    final static PrintStream out = System.out;
+
+    final static File top = new File(System.getProperty("test.dir", "."));
+
+    // files used by the test
+
+    final static File file              = new File(top, "foofile");
+    final static File link2file         = new File(top, "link2file");
+    final static File link2link2file    = new File(top, "link2link2file");
+
+    final static File dir               = new File(top, "foodir");
+    final static File link2dir          = new File(top, "link2dir");
+    final static File link2link2dir     = new File(top, "link2link2dir");
+
+    final static File link2nobody       = new File(top, "link2nobody");
+    final static File link2link2nobody  = new File(top, "link2link2nobody");
+
+    /**
+     * Setup files, directories, and sym links used by test.
+     */
+    static void setup() throws IOException {
+        // link2link2file -> link2file -> foofile
+        FileOutputStream fos = new FileOutputStream(file);
+        try {
+            fos.write(new byte[16*1024]);
+        } finally {
+            fos.close();
+        }
+        mklink(link2file, file);
+        mklink(link2link2file, link2file);
+
+        // link2link2dir -> link2dir -> dir
+        assertTrue(dir.mkdir());
+        mklink(link2dir, dir);
+        mklink(link2link2dir, link2dir);
+
+        // link2link2nobody -> link2nobody -> <does-not-exist>
+        mklink(link2nobody, new File(top, "DoesNotExist"));
+        mklink(link2link2nobody, link2nobody);
+    }
+
+    /**
+     * Remove files, directories, and sym links used by test.
+     */
+    static void cleanup() throws IOException {
+        if (file != null)
+            file.delete();
+        if (link2file != null)
+            link2file.toPath().deleteIfExists();
+        if (link2link2file != null)
+            link2link2file.toPath().deleteIfExists();
+        if (dir != null)
+            dir.delete();
+        if (link2dir != null)
+            link2dir.toPath().deleteIfExists();
+        if (link2link2dir != null)
+            link2link2dir.toPath().deleteIfExists();
+        if (link2nobody != null)
+            link2nobody.toPath().deleteIfExists();
+        if (link2link2nobody != null)
+            link2link2nobody.toPath().deleteIfExists();
+    }
+
+    /**
+     * Creates a sym link source->target
+     */
+    static void mklink(File source, File target) throws IOException {
+        source.toPath().createSymbolicLink(target.toPath());
+    }
+
+    /**
+     * Returns true if the "link" exists and is a sym link.
+     */
+    static boolean isSymLink(File link) {
+         try {
+            BasicFileAttributes attrs =
+                Attributes.readBasicFileAttributes(link.toPath(), NOFOLLOW_LINKS);
+            return attrs.isSymbolicLink();
+         } catch (IOException x) {
+             return false;
+         }
+    }
+
+    /**
+     * Returns the last modified time of a sym link.
+     */
+    static long lastModifiedOfSymLink(File link) throws IOException {
+        BasicFileAttributes attrs =
+            Attributes.readBasicFileAttributes(link.toPath(), NOFOLLOW_LINKS);
+        assertTrue(attrs.isSymbolicLink());
+        return attrs.lastModifiedTime().toMillis();
+    }
+
+    /**
+     * Returns true if sym links are supported on the file system where
+     * "dir" exists.
+     */
+    static boolean supportsSymLinks(File dir) {
+        Path link = dir.toPath().resolve("link");
+        Path target = dir.toPath().resolve("target");
+        try {
+            link.createSymbolicLink(target);
+            link.delete();
+            return true;
+        } catch (UnsupportedOperationException x) {
+            return false;
+        } catch (IOException x) {
+            return false;
+        }
+    }
+
+    static void assertTrue(boolean v) {
+        if (!v) throw new RuntimeException("Test failed");
+    }
+
+    static void assertFalse(boolean v) {
+        assertTrue(!v);
+    }
+
+    static void header(String h) {
+        out.println();
+        out.println();
+        out.println("-- " + h + " --");
+    }
+
+    /**
+     * Tests go here.
+     */
+    static void go() throws IOException {
+
+        // check setup
+        assertTrue(file.isFile());
+        assertTrue(isSymLink(link2file));
+        assertTrue(isSymLink(link2link2file));
+        assertTrue(dir.isDirectory());
+        assertTrue(isSymLink(link2dir));
+        assertTrue(isSymLink(link2link2dir));
+        assertTrue(isSymLink(link2nobody));
+        assertTrue(isSymLink(link2link2nobody));
+
+        header("createNewFile");
+
+        assertFalse(file.createNewFile());
+        assertFalse(link2file.createNewFile());
+        assertFalse(link2link2file.createNewFile());
+        assertFalse(dir.createNewFile());
+        assertFalse(link2dir.createNewFile());
+        assertFalse(link2link2dir.createNewFile());
+        assertFalse(link2nobody.createNewFile());
+        assertFalse(link2link2nobody.createNewFile());
+
+        header("mkdir");
+
+        assertFalse(file.mkdir());
+        assertFalse(link2file.mkdir());
+        assertFalse(link2link2file.mkdir());
+        assertFalse(dir.mkdir());
+        assertFalse(link2dir.mkdir());
+        assertFalse(link2link2dir.mkdir());
+        assertFalse(link2nobody.mkdir());
+        assertFalse(link2link2nobody.mkdir());
+
+        header("delete");
+
+        File link = new File(top, "mylink");
+        try {
+            mklink(link, file);
+            assertTrue(link.delete());
+            assertTrue(!isSymLink(link));
+            assertTrue(file.exists());
+
+            mklink(link, link2file);
+            assertTrue(link.delete());
+            assertTrue(!isSymLink(link));
+            assertTrue(link2file.exists());
+
+            mklink(link, dir);
+            assertTrue(link.delete());
+            assertTrue(!isSymLink(link));
+            assertTrue(dir.exists());
+
+            mklink(link, link2dir);
+            assertTrue(link.delete());
+            assertTrue(!isSymLink(link));
+            assertTrue(link2dir.exists());
+
+            mklink(link, link2nobody);
+            assertTrue(link.delete());
+            assertTrue(!isSymLink(link));
+            assertTrue(isSymLink(link2nobody));
+
+        } finally {
+            link.toPath().deleteIfExists();
+        }
+
+        header("renameTo");
+
+        File newlink = new File(top, "newlink");
+        assertTrue(link2file.renameTo(newlink));
+        try {
+            assertTrue(file.exists());
+            assertTrue(isSymLink(newlink));
+            assertTrue(!isSymLink(link2file));
+        } finally {
+            newlink.renameTo(link2file);  // restore link
+        }
+
+        assertTrue(link2dir.renameTo(newlink));
+        try {
+            assertTrue(dir.exists());
+            assertTrue(isSymLink(newlink));
+            assertTrue(!isSymLink(link2dir));
+        } finally {
+            newlink.renameTo(link2dir);  // restore link
+        }
+
+        header("list");
+
+        final String name = "entry";
+        File entry = new File(dir, name);
+        try {
+            assertTrue(dir.list().length == 0);   // directory should be empty
+            assertTrue(link2dir.list().length == 0);
+            assertTrue(link2link2dir.list().length == 0);
+
+            assertTrue(entry.createNewFile());
+            assertTrue(dir.list().length == 1);
+            assertTrue(dir.list()[0].equals(name));
+
+            // access directory by following links
+            assertTrue(link2dir.list().length == 1);
+            assertTrue(link2dir.list()[0].equals(name));
+            assertTrue(link2link2dir.list().length == 1);
+            assertTrue(link2link2dir.list()[0].equals(name));
+
+            // files that are not directories
+            assertTrue(link2file.list() == null);
+            assertTrue(link2nobody.list() == null);
+
+        } finally {
+            entry.delete();
+        }
+
+        header("isXXX");
+
+        assertTrue(file.isFile());
+        assertTrue(link2file.isFile());
+        assertTrue(link2link2file.isFile());
+
+        assertTrue(dir.isDirectory());
+        assertTrue(link2dir.isDirectory());
+        assertTrue(link2link2dir.isDirectory());
+
+        // on Windows we test with the DOS hidden attribute set
+        if (System.getProperty("os.name").startsWith("Windows")) {
+            DosFileAttributeView view = file.toPath()
+                .getFileAttributeView(DosFileAttributeView.class);
+            view.setHidden(true);
+            try {
+                assertTrue(file.isHidden());
+                assertTrue(link2file.isHidden());
+                assertTrue(link2link2file.isHidden());
+            } finally {
+                view.setHidden(false);
+            }
+            assertFalse(file.isHidden());
+            assertFalse(link2file.isHidden());
+            assertFalse(link2link2file.isHidden());
+        }
+
+        header("length");
+
+        long len = file.length();
+        assertTrue(len > 0L);
+        // these tests should follow links
+        assertTrue(link2file.length() == len);
+        assertTrue(link2link2file.length() == len);
+        assertTrue(link2nobody.length() == 0L);
+
+        header("lastModified / setLastModified");
+
+        // need time to diff between link and file
+        long origLastModified = file.lastModified();
+        assertTrue(origLastModified != 0L);
+        try { Thread.sleep(2000); } catch (InterruptedException x) { }
+        file.setLastModified(System.currentTimeMillis());
+
+        long lastModified = file.lastModified();
+        assertTrue(lastModified != origLastModified);
+        assertTrue(lastModifiedOfSymLink(link2file) != lastModified);
+        assertTrue(lastModifiedOfSymLink(link2link2file) != lastModified);
+        assertTrue(link2file.lastModified() == lastModified);
+        assertTrue(link2link2file.lastModified() == lastModified);
+        assertTrue(link2nobody.lastModified() == 0L);
+
+        origLastModified = dir.lastModified();
+        assertTrue(origLastModified != 0L);
+        dir.setLastModified(0L);
+        assertTrue(dir.lastModified() == 0L);
+        assertTrue(link2dir.lastModified() == 0L);
+        assertTrue(link2link2dir.lastModified() == 0L);
+        dir.setLastModified(origLastModified);
+
+        header("setXXX / canXXX");
+
+        assertTrue(file.canRead());
+        assertTrue(file.canWrite());
+        assertTrue(link2file.canRead());
+        assertTrue(link2file.canWrite());
+        assertTrue(link2link2file.canRead());
+        assertTrue(link2link2file.canWrite());
+
+        if (file.setReadOnly()) {
+            assertFalse(file.canWrite());
+            assertFalse(link2file.canWrite());
+            assertFalse(link2link2file.canWrite());
+
+            assertTrue(file.setWritable(true));             // make writable
+            assertTrue(file.canWrite());
+            assertTrue(link2file.canWrite());
+            assertTrue(link2link2file.canWrite());
+
+            assertTrue(link2file.setReadOnly());            // make read only
+            assertFalse(file.canWrite());
+            assertFalse(link2file.canWrite());
+            assertFalse(link2link2file.canWrite());
+
+            assertTrue(link2link2file.setWritable(true));   // make writable
+            assertTrue(file.canWrite());
+            assertTrue(link2file.canWrite());
+            assertTrue(link2link2file.canWrite());
+        }
+    }
+
+    public static void main(String[] args) throws IOException {
+        if (supportsSymLinks(top)) {
+            try {
+                setup();
+                go();
+            } finally {
+                cleanup();
+            }
+        }
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/nio/channels/AsynchronousSocketChannel/DieBeforeComplete.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6842687
+ * @summary Unit test for AsynchronousSocketChannel/AsynchronousServerSocketChannel
+ */
+import java.nio.ByteBuffer;
+import java.nio.channels.*;
+import java.net.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Initiates I/O operation on a thread that terminates before the I/O completes.
+ */
+
+public class DieBeforeComplete {
+
+    public static void main(String[] args) throws Exception {
+        final AsynchronousServerSocketChannel listener =
+                AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(0));
+
+        InetAddress lh = InetAddress.getLocalHost();
+        int port = ((InetSocketAddress) (listener.getLocalAddress())).getPort();
+        final SocketAddress sa = new InetSocketAddress(lh, port);
+
+        // -- accept --
+
+        // initiate accept in a thread that dies before connection is established
+        Future<AsynchronousSocketChannel> r1 =
+                initiateAndDie(new Task<AsynchronousSocketChannel>() {
+            public Future<AsynchronousSocketChannel> run() {
+                return listener.accept();
+            }});
+
+        // establish and accept connection
+        SocketChannel peer = SocketChannel.open(sa);
+        final AsynchronousSocketChannel channel = r1.get();
+
+        // --- read --
+
+        // initiate read in a thread that dies befores bytes are available
+        final ByteBuffer dst = ByteBuffer.allocate(100);
+        Future<Integer> r2 = initiateAndDie(new Task<Integer>() {
+            public Future<Integer> run() {
+                return channel.read(dst);
+            }});
+
+        // send bytes
+        peer.write(ByteBuffer.wrap("hello".getBytes()));
+        int nread = r2.get();
+        if (nread <= 0)
+            throw new RuntimeException("Should have read at least one byte");
+
+        // -- write --
+
+        // initiate writes in threads that dies
+        boolean completedImmediately;
+        Future<Integer> r3;
+        do {
+            final ByteBuffer src = ByteBuffer.wrap(new byte[10000]);
+            r3 = initiateAndDie(new Task<Integer>() {
+                public Future<Integer> run() {
+                    return channel.write(src);
+                }});
+            try {
+                int nsent = r3.get(5, TimeUnit.SECONDS);
+                if (nsent <= 0)
+                    throw new RuntimeException("Should have wrote at least one byte");
+                completedImmediately = true;
+            } catch (TimeoutException x) {
+                completedImmediately = false;
+            }
+        } while (completedImmediately);
+
+        // drain connection
+        peer.configureBlocking(false);
+        ByteBuffer src = ByteBuffer.allocateDirect(10000);
+        do {
+            src.clear();
+            nread = peer.read(src);
+            if (nread == 0) {
+                Thread.sleep(100);
+                nread = peer.read(src);
+            }
+        } while (nread > 0);
+
+        // write should complete now
+        int nsent = r3.get();
+        if (nsent <= 0)
+            throw new RuntimeException("Should have wrote at least one byte");
+    }
+
+    static interface Task<T> {
+        Future<T> run();
+    }
+
+    static <T> Future<T> initiateAndDie(final Task<T> task) {
+        final AtomicReference<Future<T>> result = new AtomicReference<Future<T>>();
+        Runnable r = new Runnable() {
+            public void run() {
+                result.set(task.run());
+            }
+        };
+        Thread t = new Thread(r);
+        t.start();
+        while (t.isAlive()) {
+            try {
+                t.join();
+            } catch (InterruptedException x) {
+            }
+        }
+        return result.get();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/nio/file/Path/CheckPermissions.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,695 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6866804
+ * @summary Unit test for java.nio.file.Path
+ * @library ..
+ */
+
+import java.nio.ByteBuffer;
+import java.nio.file.*;
+import java.nio.file.attribute.*;
+import java.nio.channels.SeekableByteChannel;
+import java.security.Permission;
+import java.io.*;
+import java.util.*;
+
+/**
+ * Checks each method that accesses the file system does the right permission
+ * check when there is a security manager set.
+ */
+
+public class CheckPermissions {
+
+    static class Checks {
+        private List<Permission> permissionsChecked = new ArrayList<Permission>();
+        private Set<String>  propertiesChecked = new HashSet<String>();
+        private List<String> readsChecked   = new ArrayList<String>();
+        private List<String> writesChecked  = new ArrayList<String>();
+        private List<String> deletesChecked = new ArrayList<String>();
+        private List<String> execsChecked   = new ArrayList<String>();
+
+        List<Permission> permissionsChecked()  { return permissionsChecked; }
+        Set<String> propertiesChecked()        { return propertiesChecked; }
+        List<String> readsChecked()            { return readsChecked; }
+        List<String> writesChecked()           { return writesChecked; }
+        List<String> deletesChecked()          { return deletesChecked; }
+        List<String> execsChecked()            { return execsChecked; }
+    }
+
+    static ThreadLocal<Checks> myChecks =
+        new ThreadLocal<Checks>() {
+            @Override protected Checks initialValue() {
+                return null;
+            }
+        };
+
+    static void prepare() {
+        myChecks.set(new Checks());
+    }
+
+    static void assertCheckPermission(Class<? extends Permission> type,
+                                      String name)
+    {
+        for (Permission perm: myChecks.get().permissionsChecked()) {
+            if (type.isInstance(perm) && perm.getName().equals(name))
+                return;
+        }
+        throw new RuntimeException(type.getName() + "\"" + name + "\") not checked");
+    }
+
+    static void assertCheckPropertyAccess(String key) {
+        if (!myChecks.get().propertiesChecked().contains(key))
+            throw new RuntimeException("Property " + key + " not checked");
+    }
+
+    static void assertChecked(Path file, List<String> list) {
+        String s = file.toString();
+        for (String f: list) {
+            if (f.endsWith(s))
+                return;
+        }
+        throw new RuntimeException("Access not checked");
+    }
+
+    static void assertCheckRead(Path file) {
+        assertChecked(file, myChecks.get().readsChecked());
+    }
+
+    static void assertCheckWrite(Path file) {
+        assertChecked(file, myChecks.get().writesChecked());
+    }
+
+    static void assertCheckDelete(Path file) {
+        assertChecked(file, myChecks.get().deletesChecked());
+    }
+
+    static void assertCheckExec(Path file) {
+        assertChecked(file, myChecks.get().execsChecked());
+    }
+
+    static class LoggingSecurityManager extends SecurityManager {
+        static void install() {
+            System.setSecurityManager(new LoggingSecurityManager());
+        }
+
+        @Override
+        public void checkPermission(Permission perm) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.permissionsChecked().add(perm);
+        }
+
+        @Override
+        public void checkPropertyAccess(String key) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.propertiesChecked().add(key);
+        }
+
+        @Override
+        public void checkRead(String file) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.readsChecked().add(file);
+        }
+
+        @Override
+        public void checkWrite(String file) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.writesChecked().add(file);
+        }
+
+        @Override
+        public void checkDelete(String file) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.deletesChecked().add(file);
+        }
+
+        @Override
+        public void checkExec(String file) {
+            Checks checks = myChecks.get();
+            if (checks != null)
+                checks.execsChecked().add(file);
+        }
+    }
+
+    static void testBasicFileAttributeView(BasicFileAttributeView view, Path file)
+        throws IOException
+    {
+        prepare();
+        view.readAttributes();
+        assertCheckRead(file);
+
+        prepare();
+        FileTime now = FileTime.fromMillis(System.currentTimeMillis());
+        view.setTimes(null, now, now);
+        assertCheckWrite(file);
+    }
+
+    static void testPosixFileAttributeView(PosixFileAttributeView view, Path file)
+        throws IOException
+    {
+        prepare();
+        PosixFileAttributes attrs = view.readAttributes();
+        assertCheckRead(file);
+        assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+
+        prepare();
+        view.setPermissions(attrs.permissions());
+        assertCheckWrite(file);
+        assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+
+        prepare();
+        view.setOwner(attrs.owner());
+        assertCheckWrite(file);
+        assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+
+        prepare();
+        view.setOwner(attrs.owner());
+        assertCheckWrite(file);
+        assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+    }
+
+    public static void main(String[] args) throws IOException {
+        Path dir = Paths.get(System.getProperty("test.src", "."));
+        Path file = dir.resolve("file1234").createFile();
+        try {
+            LoggingSecurityManager.install();
+
+            // -- checkAccess --
+
+            prepare();
+            file.checkAccess();
+            assertCheckRead(file);
+
+            prepare();
+            file.checkAccess(AccessMode.READ);
+            assertCheckRead(file);
+
+            prepare();
+            file.checkAccess(AccessMode.WRITE);
+            assertCheckWrite(file);
+
+            prepare();
+            try {
+                file.checkAccess(AccessMode.EXECUTE);
+            } catch (AccessDeniedException x) { }
+            assertCheckExec(file);
+
+            prepare();
+            try {
+                file.checkAccess(AccessMode.READ, AccessMode.WRITE, AccessMode.EXECUTE);
+            } catch (AccessDeniedException x) { }
+            assertCheckRead(file);
+            assertCheckWrite(file);
+            assertCheckExec(file);
+
+            // -- copyTo --
+
+            Path target = dir.resolve("target1234");
+            prepare();
+            file.copyTo(target);
+            try {
+                assertCheckRead(file);
+                assertCheckWrite(target);
+            } finally {
+                target.delete();
+            }
+
+            if (TestUtil.supportsLinks(dir)) {
+                Path link = dir.resolve("link1234").createSymbolicLink(file);
+                try {
+                    prepare();
+                    link.copyTo(target, LinkOption.NOFOLLOW_LINKS);
+                    try {
+                        assertCheckRead(link);
+                        assertCheckWrite(target);
+                        assertCheckPermission(LinkPermission.class, "symbolic");
+                    } finally {
+                        target.delete();
+                    }
+                } finally {
+                    link.delete();
+                }
+            }
+
+            // -- createDirectory --
+
+            Path subdir = dir.resolve("subdir1234");
+            prepare();
+            subdir.createDirectory();
+            try {
+                assertCheckWrite(subdir);
+            } finally {
+                subdir.delete();
+            }
+
+            // -- createFile --
+
+            Path fileToCreate = dir.resolve("file7890");
+            prepare();
+            try {
+                fileToCreate.createFile();
+                assertCheckWrite(fileToCreate);
+            } finally {
+                fileToCreate.delete();
+            }
+
+            // -- createSymbolicLink --
+
+            if (TestUtil.supportsLinks(dir)) {
+                prepare();
+                Path link = dir.resolve("link1234").createSymbolicLink(file);
+                try {
+                    assertCheckWrite(link);
+                    assertCheckPermission(LinkPermission.class, "symbolic");
+                } finally {
+                    link.delete();
+                }
+            }
+
+            // -- delete/deleteIfExists --
+
+            Path fileToDelete = dir.resolve("file7890");
+
+            fileToDelete.createFile();
+            prepare();
+            fileToDelete.delete();
+            assertCheckDelete(fileToDelete);
+
+            fileToDelete.createFile();
+            prepare();
+            fileToDelete.deleteIfExists();
+            assertCheckDelete(fileToDelete);
+
+            // -- exists/notExists --
+
+            prepare();
+            file.exists();
+            assertCheckRead(file);
+
+            prepare();
+            file.notExists();
+            assertCheckRead(file);
+
+            // -- getFileStore --
+
+            prepare();
+            file.getFileStore();
+            assertCheckRead(file);
+            assertCheckPermission(RuntimePermission.class, "getFileStoreAttributes");
+
+            // -- isSameFile --
+
+            prepare();
+            file.isSameFile(dir);
+            assertCheckRead(file);
+            assertCheckRead(dir);
+
+            // -- moveTo --
+
+            Path target2 = dir.resolve("target1234");
+            prepare();
+            file.moveTo(target2);
+            try {
+                assertCheckWrite(file);
+                assertCheckWrite(target2);
+            } finally {
+                // restore file
+                target2.moveTo(file);
+            }
+
+            // -- newByteChannel --
+
+            SeekableByteChannel sbc;
+
+            prepare();
+            sbc = file.newByteChannel();
+            try {
+                assertCheckRead(file);
+            } finally {
+                sbc.close();
+            }
+            prepare();
+            sbc = file.newByteChannel(StandardOpenOption.WRITE);
+            try {
+                assertCheckWrite(file);
+            } finally {
+                sbc.close();
+            }
+            prepare();
+            sbc = file.newByteChannel(StandardOpenOption.READ, StandardOpenOption.WRITE);
+            try {
+                assertCheckRead(file);
+                assertCheckWrite(file);
+            } finally {
+                sbc.close();
+            }
+
+            prepare();
+            sbc = file.newByteChannel(StandardOpenOption.DELETE_ON_CLOSE);
+            try {
+                assertCheckRead(file);
+                assertCheckDelete(file);
+            } finally {
+                sbc.close();
+            }
+            file.createFile(); // restore file
+
+
+            // -- newInputStream/newOutptuStream --
+
+            prepare();
+            InputStream in = file.newInputStream();
+            try {
+                assertCheckRead(file);
+            } finally {
+                in.close();
+            }
+            prepare();
+            OutputStream out = file.newOutputStream();
+            try {
+                assertCheckWrite(file);
+            } finally {
+                out.close();
+            }
+
+            // -- newDirectoryStream --
+
+            prepare();
+            DirectoryStream<Path> stream = dir.newDirectoryStream();
+            try {
+                assertCheckRead(dir);
+
+                if (stream instanceof SecureDirectoryStream<?>) {
+                    Path entry;
+                    SecureDirectoryStream<Path> sds =
+                        (SecureDirectoryStream<Path>)stream;
+
+                    // newByteChannel
+                    entry = file.getName();
+                    prepare();
+                    sbc = sds.newByteChannel(entry, EnumSet.of(StandardOpenOption.READ));
+                    try {
+                        assertCheckRead(file);
+                    } finally {
+                        sbc.close();
+                    }
+                    prepare();
+                    sbc = sds.newByteChannel(entry, EnumSet.of(StandardOpenOption.WRITE));
+                    try {
+                        assertCheckWrite(file);
+                    } finally {
+                        sbc.close();
+                    }
+
+                    // deleteFile
+                    entry = file.getName();
+                    prepare();
+                    sds.deleteFile(entry);
+                    assertCheckDelete(file);
+                    dir.resolve(entry).createFile();  // restore file
+
+                    // deleteDirectory
+                    entry = Paths.get("subdir1234");
+                    dir.resolve(entry).createDirectory();
+                    prepare();
+                    sds.deleteDirectory(entry);
+                    assertCheckDelete(dir.resolve(entry));
+
+                    // move
+                    entry = Paths.get("tempname1234");
+                    prepare();
+                    sds.move(file.getName(), sds, entry);
+                    assertCheckWrite(file);
+                    assertCheckWrite(dir.resolve(entry));
+                    sds.move(entry, sds, file.getName());  // restore file
+
+                    // newDirectoryStream
+                    entry = Paths.get("subdir1234");
+                    dir.resolve(entry).createDirectory();
+                    try {
+                        prepare();
+                        sds.newDirectoryStream(entry).close();
+                        assertCheckRead(dir.resolve(entry));
+                    } finally {
+                        dir.resolve(entry).delete();
+                    }
+
+                    // getFileAttributeView to access attributes of directory
+                    testBasicFileAttributeView(sds
+                        .getFileAttributeView(BasicFileAttributeView.class), dir);
+                    testPosixFileAttributeView(sds
+                        .getFileAttributeView(PosixFileAttributeView.class), dir);
+
+                    // getFileAttributeView to access attributes of entry
+                    entry = file.getName();
+                    testBasicFileAttributeView(sds
+                        .getFileAttributeView(entry, BasicFileAttributeView.class), file);
+                    testPosixFileAttributeView(sds
+                        .getFileAttributeView(entry, PosixFileAttributeView.class), file);
+
+                } else {
+                    System.out.println("SecureDirectoryStream not tested");
+                }
+
+            } finally {
+                stream.close();
+            }
+
+            // -- toAbsolutePath --
+
+            prepare();
+            file.getName().toAbsolutePath();
+            assertCheckPropertyAccess("user.dir");
+
+            // -- toRealPath --
+
+            prepare();
+            file.toRealPath(true);
+            assertCheckRead(file);
+
+            prepare();
+            file.toRealPath(false);
+            assertCheckRead(file);
+
+            prepare();
+            Paths.get(".").toRealPath(true);
+            assertCheckPropertyAccess("user.dir");
+
+            prepare();
+            Paths.get(".").toRealPath(false);
+            assertCheckPropertyAccess("user.dir");
+
+            // -- register --
+
+            WatchService watcher = FileSystems.getDefault().newWatchService();
+            try {
+                prepare();
+                dir.register(watcher, StandardWatchEventKind.ENTRY_DELETE);
+                assertCheckRead(dir);
+            } finally {
+                watcher.close();
+            }
+
+            // -- getAttribute/setAttribute/readAttributes --
+
+            prepare();
+            file.getAttribute("size");
+            assertCheckRead(file);
+
+            prepare();
+            file.setAttribute("lastModifiedTime",
+                FileTime.fromMillis(System.currentTimeMillis()));
+            assertCheckWrite(file);
+
+            prepare();
+            file.readAttributes("*");
+            assertCheckRead(file);
+
+            // -- BasicFileAttributeView --
+            testBasicFileAttributeView(file
+                .getFileAttributeView(BasicFileAttributeView.class), file);
+
+            // -- PosixFileAttributeView --
+
+            {
+                PosixFileAttributeView view =
+                    file.getFileAttributeView(PosixFileAttributeView.class);
+                if (view != null &&
+                    file.getFileStore().supportsFileAttributeView(PosixFileAttributeView.class))
+                {
+                    testPosixFileAttributeView(view, file);
+                } else {
+                    System.out.println("PosixFileAttributeView not tested");
+                }
+            }
+
+            // -- DosFileAttributeView --
+
+            {
+                DosFileAttributeView view =
+                    file.getFileAttributeView(DosFileAttributeView.class);
+                if (view != null &&
+                    file.getFileStore().supportsFileAttributeView(DosFileAttributeView.class))
+                {
+                    prepare();
+                    view.readAttributes();
+                    assertCheckRead(file);
+
+                    prepare();
+                    view.setArchive(false);
+                    assertCheckWrite(file);
+
+                    prepare();
+                    view.setHidden(false);
+                    assertCheckWrite(file);
+
+                    prepare();
+                    view.setReadOnly(false);
+                    assertCheckWrite(file);
+
+                    prepare();
+                    view.setSystem(false);
+                    assertCheckWrite(file);
+                } else {
+                    System.out.println("DosFileAttributeView not tested");
+                }
+            }
+
+            // -- FileOwnerAttributeView --
+
+            {
+                FileOwnerAttributeView view =
+                    file.getFileAttributeView(FileOwnerAttributeView.class);
+                if (view != null &&
+                    file.getFileStore().supportsFileAttributeView(FileOwnerAttributeView.class))
+                {
+                    prepare();
+                    UserPrincipal owner = view.getOwner();
+                    assertCheckRead(file);
+                    assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+
+                    prepare();
+                    view.setOwner(owner);
+                    assertCheckWrite(file);
+                    assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+
+                } else {
+                    System.out.println("FileOwnerAttributeView not tested");
+                }
+            }
+
+            // -- UserDefinedFileAttributeView --
+
+            {
+                UserDefinedFileAttributeView view =
+                    file.getFileAttributeView(UserDefinedFileAttributeView.class);
+                if (view != null &&
+                    file.getFileStore().supportsFileAttributeView(UserDefinedFileAttributeView.class))
+                {
+                    prepare();
+                    view.write("test", ByteBuffer.wrap(new byte[100]));
+                    assertCheckWrite(file);
+                    assertCheckPermission(RuntimePermission.class,
+                                               "accessUserDefinedAttributes");
+
+                    prepare();
+                    view.read("test", ByteBuffer.allocate(100));
+                    assertCheckRead(file);
+                    assertCheckPermission(RuntimePermission.class,
+                                               "accessUserDefinedAttributes");
+
+                    prepare();
+                    view.size("test");
+                    assertCheckRead(file);
+                    assertCheckPermission(RuntimePermission.class,
+                                               "accessUserDefinedAttributes");
+
+                    prepare();
+                    view.list();
+                    assertCheckRead(file);
+                    assertCheckPermission(RuntimePermission.class,
+                                               "accessUserDefinedAttributes");
+
+                    prepare();
+                    view.delete("test");
+                    assertCheckWrite(file);
+                    assertCheckPermission(RuntimePermission.class,
+                                               "accessUserDefinedAttributes");
+                } else {
+                    System.out.println("UserDefinedFileAttributeView not tested");
+                }
+            }
+
+            // -- AclFileAttributeView --
+            {
+                AclFileAttributeView view =
+                    file.getFileAttributeView(AclFileAttributeView.class);
+                if (view != null &&
+                    file.getFileStore().supportsFileAttributeView(AclFileAttributeView.class))
+                {
+                    prepare();
+                    List<AclEntry> acl = view.getAcl();
+                    assertCheckRead(file);
+                    assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+                    prepare();
+                    view.setAcl(acl);
+                    assertCheckWrite(file);
+                    assertCheckPermission(RuntimePermission.class, "accessUserInformation");
+                } else {
+                    System.out.println("AclFileAttributeView not tested");
+                }
+            }
+
+            // -- UserPrincipalLookupService
+
+            UserPrincipalLookupService lookupService =
+                FileSystems.getDefault().getUserPrincipalLookupService();
+            UserPrincipal owner = Attributes.getOwner(file);
+
+            prepare();
+            lookupService.lookupPrincipalByName(owner.getName());
+            assertCheckPermission(RuntimePermission.class,
+                                       "lookupUserInformation");
+
+            try {
+                UserPrincipal group = Attributes.readPosixFileAttributes(file).group();
+                prepare();
+                lookupService.lookupPrincipalByGroupName(group.getName());
+                assertCheckPermission(RuntimePermission.class,
+                                           "lookupUserInformation");
+            } catch (UnsupportedOperationException ignore) {
+                System.out.println("lookupPrincipalByGroupName not tested");
+            }
+
+
+        } finally {
+            file.deleteIfExists();
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/TimeZone/ListTimeZones.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 6851214
+ * @summary Allow 24:00 as a valid end/start DST time stamp
+ * @run main ListTimeZones
+ */
+
+import java.util.*;
+
+public class ListTimeZones{
+  public static void main(String[] args){
+    Date date = new Date();
+    String TimeZoneIds[] = TimeZone.getAvailableIDs();
+    for(int i = 0; i < TimeZoneIds.length; i++){
+      TimeZone tz = TimeZone.getTimeZone(TimeZoneIds[i]);
+      Calendar calendar = new GregorianCalendar(tz);
+      String calString = calendar.toString();
+    }
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/concurrent/BlockingQueue/LastElement.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6215625
+ * @summary Check correct behavior when last element is removed.
+ * @author Martin Buchholz
+ */
+
+import java.util.*;
+import java.util.concurrent.*;
+
+public class LastElement {
+    void test(String[] args) throws Throwable {
+        testQueue(new LinkedBlockingQueue<Integer>());
+        testQueue(new LinkedBlockingDeque<Integer>());
+        testQueue(new ArrayBlockingQueue<Integer>(10, true));
+        testQueue(new ArrayBlockingQueue<Integer>(10, false));
+//         testQueue(new LinkedTransferQueue<Integer>());
+
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new Exception("Some tests failed");
+    }
+
+    void testQueue(BlockingQueue<Integer> q) throws Throwable {
+        Integer one = 1;
+        Integer two = 2;
+        Integer three = 3;
+
+        // remove(Object)
+        q.put(one);
+        q.put(two);
+        check(! q.isEmpty() && q.size() == 2);
+        check(q.remove(one));
+        check(q.remove(two));
+        check(q.isEmpty() && q.size() == 0);
+        q.put(three);
+        try {check(q.take() == three);}
+        catch (Throwable t) {unexpected(t);}
+        check(q.isEmpty() && q.size() == 0);
+
+        // iterator().remove()
+        q.clear();
+        q.put(one);
+        check(q.offer(two));
+        check(! q.isEmpty() && q.size() == 2);
+        Iterator<Integer> i = q.iterator();
+        check(i.next() == one);
+        i.remove();
+        check(i.next() == two);
+        i.remove();
+        check(q.isEmpty() && q.size() == 0);
+        q.put(three);
+        try {check(q.take() == three);}
+        catch (Throwable t) {unexpected(t);}
+        check(q.isEmpty() && q.size() == 0);
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    volatile int passed = 0, failed = 0;
+    void pass() {passed++;}
+    void fail() {failed++; Thread.dumpStack();}
+    void fail(String msg) {System.err.println(msg); fail();}
+    void unexpected(Throwable t) {failed++; t.printStackTrace();}
+    void check(boolean cond) {if (cond) pass(); else fail();}
+    void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else fail(x + " not equal to " + y);}
+    public static void main(String[] args) throws Throwable {
+        new LastElement().instanceMain(args);}
+    public void instanceMain(String[] args) throws Throwable {
+        try {test(args);} catch (Throwable t) {unexpected(t);}
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new AssertionError("Some tests failed");}
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/concurrent/ConcurrentQueues/OfferRemoveLoops.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6316155 6595669 6871697 6868712
+ * @summary Test concurrent offer vs. remove
+ * @run main OfferRemoveLoops 300
+ * @author Martin Buchholz
+ */
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+@SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
+public class OfferRemoveLoops {
+    final long testDurationMillisDefault = 10L * 1000L;
+    final long testDurationMillis;
+
+    OfferRemoveLoops(String[] args) {
+        testDurationMillis = (args.length > 0) ?
+            Long.valueOf(args[0]) : testDurationMillisDefault;
+    }
+
+    void checkNotContainsNull(Iterable it) {
+        for (Object x : it)
+            check(x != null);
+    }
+
+    void test(String[] args) throws Throwable {
+        testQueue(new LinkedBlockingQueue(10));
+        testQueue(new LinkedBlockingQueue());
+        testQueue(new LinkedBlockingDeque(10));
+        testQueue(new LinkedBlockingDeque());
+        testQueue(new ArrayBlockingQueue(10));
+        testQueue(new PriorityBlockingQueue(10));
+        testQueue(new ConcurrentLinkedQueue());
+//         testQueue(new LinkedTransferQueue());
+    }
+
+    Random getRandom() {
+        return new Random();
+        // return ThreadLocalRandom.current();
+    }
+
+    void testQueue(final Queue q) throws Throwable {
+        System.out.println(q.getClass().getSimpleName());
+        final long testDurationNanos = testDurationMillis * 1000L * 1000L;
+        final long quittingTimeNanos = System.nanoTime() + testDurationNanos;
+        final long timeoutMillis = 10L * 1000L;
+        final int maxChunkSize = 1042;
+        final int maxQueueSize = 10 * maxChunkSize;
+
+        /** Poor man's bounded buffer. */
+        final AtomicLong approximateCount = new AtomicLong(0L);
+
+        abstract class CheckedThread extends Thread {
+            CheckedThread(String name) {
+                super(name);
+                setDaemon(true);
+                start();
+            }
+            /** Polls for quitting time. */
+            protected boolean quittingTime() {
+                return System.nanoTime() - quittingTimeNanos > 0;
+            }
+            /** Polls occasionally for quitting time. */
+            protected boolean quittingTime(long i) {
+                return (i % 1024) == 0 && quittingTime();
+            }
+            abstract protected void realRun();
+            public void run() {
+                try { realRun(); } catch (Throwable t) { unexpected(t); }
+            }
+        }
+
+        Thread offerer = new CheckedThread("offerer") {
+            protected void realRun() {
+                final long chunkSize = getRandom().nextInt(maxChunkSize) + 2;
+                long c = 0;
+                for (long i = 0; ! quittingTime(i); i++) {
+                    if (q.offer(Long.valueOf(c))) {
+                        if ((++c % chunkSize) == 0) {
+                            approximateCount.getAndAdd(chunkSize);
+                            while (approximateCount.get() > maxQueueSize)
+                                Thread.yield();
+                        }
+                    } else {
+                        Thread.yield();
+                    }}}};
+
+        Thread remover = new CheckedThread("remover") {
+            protected void realRun() {
+                final long chunkSize = getRandom().nextInt(maxChunkSize) + 2;
+                long c = 0;
+                for (long i = 0; ! quittingTime(i); i++) {
+                    if (q.remove(Long.valueOf(c))) {
+                        if ((++c % chunkSize) == 0) {
+                            approximateCount.getAndAdd(-chunkSize);
+                        }
+                    } else {
+                        Thread.yield();
+                    }
+                }
+                q.clear();
+                approximateCount.set(0); // Releases waiting offerer thread
+            }};
+
+        Thread scanner = new CheckedThread("scanner") {
+            protected void realRun() {
+                final Random rnd = getRandom();
+                while (! quittingTime()) {
+                    switch (rnd.nextInt(3)) {
+                    case 0: checkNotContainsNull(q); break;
+                    case 1: q.size(); break;
+                    case 2: checkNotContainsNull
+                            (Arrays.asList(q.toArray(new Long[0])));
+                        break;
+                    }
+                    Thread.yield();
+                }}};
+
+        for (Thread thread : new Thread[] { offerer, remover, scanner }) {
+            thread.join(timeoutMillis + testDurationMillis);
+            if (thread.isAlive()) {
+                System.err.printf("Hung thread: %s%n", thread.getName());
+                failed++;
+                for (StackTraceElement e : thread.getStackTrace())
+                    System.err.println(e);
+                // Kludge alert
+                thread.stop();
+                thread.join(timeoutMillis);
+            }
+        }
+    }
+
+    //--------------------- Infrastructure ---------------------------
+    volatile int passed = 0, failed = 0;
+    void pass() {passed++;}
+    void fail() {failed++; Thread.dumpStack();}
+    void fail(String msg) {System.err.println(msg); fail();}
+    void unexpected(Throwable t) {failed++; t.printStackTrace();}
+    void check(boolean cond) {if (cond) pass(); else fail();}
+    void equal(Object x, Object y) {
+        if (x == null ? y == null : x.equals(y)) pass();
+        else fail(x + " not equal to " + y);}
+    public static void main(String[] args) throws Throwable {
+        new OfferRemoveLoops(args).instanceMain(args);}
+    public void instanceMain(String[] args) throws Throwable {
+        try {test(args);} catch (Throwable t) {unexpected(t);}
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new AssertionError("Some tests failed");}
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/CommentsInXml.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 4619564
+ * @summary XMl Comments in Preferences File lead to ClassCastException
+ * @author kladko
+ */
+
+import java.io.*;
+import java.util.prefs.*;
+
+public class CommentsInXml {
+
+    public static void main(String[] argv) throws Exception {
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+
+        bos.write(new String(
+            "<!DOCTYPE preferences SYSTEM                          " +
+            "\"http://java.sun.com/dtd/preferences.dtd\">          " +
+            "<preferences EXTERNAL_XML_VERSION=\"1.0\">            " +
+            "  <root type=\"user\">                                " +
+            "    <map>                                             " +
+            "    </map>                                            " +
+            "    <node name=\"hlrAgent\"> <!-- HLR Agent -->       " +
+            "      <map>                                           " +
+            "        <entry key=\"agentName\" value=\"HLRAgent\" />" +
+            "      </map>                                          " +
+            "    </node>                                           " +
+            "  </root>                                             " +
+            "</preferences>                                        "
+        ).getBytes());
+
+        Preferences ur = Preferences.userRoot();
+        ur.importPreferences(new ByteArrayInputStream(bos.toByteArray()));
+        ur.node("hlrAgent").removeNode(); // clean
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/ConflictInFlush.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 4703132
+ * @summary flush() throws an IllegalStateException on a removed node
+ * @author Sucheta Dambalkar
+ */
+
+import java.util.prefs.*;
+
+public final class ConflictInFlush{
+
+    public static void main(String args[]) {
+        Preferences root = Preferences.userRoot();
+        try {
+            Preferences node = root.node("1/2/3");
+            node.flush();
+            System.out.println("Node "+node+" has been created");
+            System.out.println("Removing node "+node);
+            node.removeNode();
+            node.flush();
+        }catch (BackingStoreException bse){
+            bse.printStackTrace();
+        }
+
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/ExportNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+/*
+ * @test
+ * @bug 4387136 4947349
+ * @summary Due to a bug in XMLSupport.putPreferencesInXml(...),
+ *          node's keys would not get exported.
+ * @author Konstantin Kladko
+ */
+import java.util.prefs.*;
+import java.io.*;
+
+public class ExportNode {
+    public static void main(String[] args) throws
+                                            BackingStoreException, IOException {
+            Preferences N1 = Preferences.userRoot().node("ExportNodeTest1");
+            N1.put("ExportNodeTestName1","ExportNodeTestValue1");
+            Preferences N2 = N1.node("ExportNodeTest2");
+            N2.put("ExportNodeTestName2","ExportNodeTestValue2");
+            ByteArrayOutputStream exportStream = new ByteArrayOutputStream();
+            N2.exportNode(exportStream);
+
+            // Removal of preference node should always succeed on Solaris/Linux
+            // by successfully acquiring the appropriate file lock (4947349)
+            N1.removeNode();
+
+            if (((exportStream.toString()).lastIndexOf("ExportNodeTestName2")== -1) ||
+               ((exportStream.toString()).lastIndexOf("ExportNodeTestName1")!= -1)) {
+            }
+   }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/ExportSubtree.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+/* @test
+   @bug 6203576 4700020
+   @summary checks if the output of exportSubtree() is identical to
+            the output from previous release.
+ */
+
+import java.io.*;
+import java.util.prefs.*;
+
+public class ExportSubtree {
+   public static void main(String[] args) throws Exception {
+      try
+      {
+          //File f = new File(System.getProperty("test.src", "."), "TestPrefs.xml");
+          ByteArrayInputStream bais = new ByteArrayInputStream(importPrefs.getBytes("utf-8"));
+          Preferences.importPreferences(bais);
+          ByteArrayOutputStream baos = new ByteArrayOutputStream();
+          Preferences.userRoot().node("testExportSubtree").exportSubtree(baos);
+          Preferences.userRoot().node("testExportSubtree").removeNode();
+          if (!expectedResult.equals(baos.toString())) {
+              //System.out.print(baos.toString());
+              //System.out.print(expectedResult);
+              throw new IOException("exportSubtree does not output expected result");
+          }
+      }
+      catch( Exception e ) {
+         e.printStackTrace();
+      }
+   }
+
+   static String ls = System.getProperty("line.separator");
+   static String importPrefs =
+       "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+        + "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">"
+        + "<preferences EXTERNAL_XML_VERSION=\"1.0\">"
+        + "  <root type=\"user\">"
+        + "    <map>"
+        + "      <entry key=\"key1\" value=\"value1\"/>"
+        + "    </map>"
+        + "    <node name=\"testExportSubtree\">"
+        + "      <map>"
+        + "        <entry key=\"key2\" value=\"value2\"/>"
+        + "      </map>"
+        + "      <node name=\"test\">"
+        + "        <map>"
+        + "          <entry key=\"key3\" value=\"value3\"/>"
+        + "        </map>"
+        + "      </node>"
+        + "    </node>"
+        + "  </root>"
+        + "</preferences>";
+
+   static String expectedResult =
+       "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+        + ls    +  "<!DOCTYPE preferences SYSTEM \"http://java.sun.com/dtd/preferences.dtd\">"
+        + ls    +  "<preferences EXTERNAL_XML_VERSION=\"1.0\">"
+        + ls    +  "  <root type=\"user\">"
+        + ls    +  "    <map/>"
+        + ls    +  "    <node name=\"testExportSubtree\">"
+        + ls    +  "      <map>"
+        + ls    +  "        <entry key=\"key2\" value=\"value2\"/>"
+        + ls    +  "      </map>"
+        + ls    +  "      <node name=\"test\">"
+        + ls    +  "        <map>"
+        + ls    +  "          <entry key=\"key3\" value=\"value3\"/>"
+        + ls    +  "        </map>"
+        + ls    +  "      </node>"
+        + ls    +  "    </node>"
+        + ls    +  "  </root>"
+        + ls    +  "</preferences>"     + ls;
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/PrefsSpi.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+import java.util.prefs.Preferences;
+
+/*
+ * main class used by regtest PrefsSpi.sh
+ */
+public class PrefsSpi {
+
+    public static void main (String[] args) throws Exception {
+        if (args.length != 1)
+            throw new Exception("Usage: java PrefsSpi REGEXP");
+
+        String className = Preferences.userRoot().getClass().getName();
+        System.out.printf("className=%s%n", className);
+
+        if (! className.matches(args[0]))
+            throw new Exception("Preferences class name \"" + className
+                                + "\" does not match regular expression \""
+                                + args[0] + "\".");
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/PrefsSpi.sh	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,100 @@
+#!/bin/sh
+
+#
+# Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+# @test
+# @bug 4991526 6514993
+# @summary Unit test for Preferences jar providers
+#
+# @build PrefsSpi
+# @run shell PrefsSpi.sh
+# @author Martin Buchholz
+
+# Command-line usage: sh PrefsSpi.sh /path/to/build
+
+if [ -z "$TESTJAVA" ]; then
+    if [ $# -lt 1 ]; then exit 1; fi
+    TESTJAVA="$1"; shift
+    TESTSRC="`pwd`"
+    TESTCLASSES="`pwd`"
+fi
+
+ java="$TESTJAVA/bin/java"
+javac="$TESTJAVA/bin/javac"
+  jar="$TESTJAVA/bin/jar"
+
+Die() { printf "%s\n" "$*"; exit 1; }
+
+Sys() {
+    printf "%s\n" "$*"; "$@"; rc="$?";
+    test "$rc" -eq 0 || Die "Command \"$*\" failed with exitValue $rc";
+}
+
+cat > StubPreferences.java <<'EOF'
+import java.util.prefs.*;
+
+public class StubPreferences extends AbstractPreferences {
+    public StubPreferences() { super(null, ""); }
+    public String              getSpi(String x)           { return null; }
+    public void                putSpi(String x, String y) { }
+    public void                removeSpi(String x)        { }
+    public AbstractPreferences childSpi(String x)         { return null; }
+    public void                removeNodeSpi()            { }
+    public String[]            keysSpi()                  { return null; }
+    public String[]            childrenNamesSpi()         { return null; }
+    public void                syncSpi()                  { }
+    public void                flushSpi()                 { }
+}
+EOF
+
+cat > StubPreferencesFactory.java <<'EOF'
+import java.util.prefs.*;
+
+public class StubPreferencesFactory implements PreferencesFactory {
+    public Preferences userRoot()   { return new StubPreferences(); }
+    public Preferences systemRoot() { return new StubPreferences(); }
+}
+EOF
+
+Sys rm -rf jarDir extDir
+Sys mkdir -p jarDir/META-INF/services extDir
+echo "StubPreferencesFactory" \
+  > "jarDir/META-INF/services/java.util.prefs.PreferencesFactory"
+Sys "$javac" -d jarDir StubPreferencesFactory.java StubPreferences.java
+
+(cd jarDir && "$jar" "cf" "../extDir/PrefsSpi.jar" ".")
+
+case "`uname`" in Windows*|CYGWIN* ) CPS=';';; *) CPS=':';; esac
+
+Sys "$java" "-cp" "$TESTCLASSES${CPS}extDir/PrefsSpi.jar" \
+    -Djava.util.prefs.PreferencesFactory=StubPreferencesFactory \
+    PrefsSpi "StubPreferences"
+Sys "$java" "-cp" "$TESTCLASSES" \
+    PrefsSpi "java.util.prefs.*"
+Sys "$java" "-cp" "$TESTCLASSES${CPS}extDir/PrefsSpi.jar" \
+    PrefsSpi "StubPreferences"
+Sys "$java" "-cp" "$TESTCLASSES" "-Djava.ext.dirs=extDir" \
+    PrefsSpi "StubPreferences"
+
+rm -rf jarDir extDir
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/RemoveReadOnlyNode.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+/* @test
+   @bug 6178148
+   @summary check if wrong exception gets thrown if one of the child
+            nodes is readonly on underlying filesystem when node is
+            being removed.
+ */
+
+import java.io.*;
+import java.util.prefs.*;
+
+public class RemoveReadOnlyNode {
+    public static void main(String[] args) throws Exception {
+        String osName = System.getProperty("os.name");
+        if (osName.startsWith("Windows"))
+            return;
+        Preferences root = Preferences.userRoot();
+        Preferences node1 = root.node("node1");
+        Preferences node1A = node1.node("node1A");
+        Preferences node1B = node1.node("node1B");
+        node1B.put("mykey", "myvalue");
+        node1.flush();
+        String node1BDirName = System.getProperty("user.home")
+            + "/.java/.userPrefs"
+            + "/node1/node1B";
+        File node1BDir = new File(node1BDirName);
+        node1BDir.setReadOnly();
+        try {
+            node1.removeNode();
+        }
+        catch (BackingStoreException ex) {
+            //expected exception
+        } finally {
+            Runtime.getRuntime().exec("chmod 755 " + node1BDirName).waitFor();
+            try {
+                node1.removeNode();
+            } catch (Exception e) {}
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/RemoveUnregedListener.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+/* @test
+ * @bug 4705094
+ * @summary Checks if correct exception gets thrown when removing an
+ *          unregistered NodeChangeListener .
+ */
+
+import java.util.prefs.*;
+import java.util.*;
+
+public class RemoveUnregedListener {
+    public static void main(String[] args) throws Exception {
+        Preferences userRoot = null;
+        Preferences N1 = null;
+        NodeChangeListenerTestAdd ncl = new NodeChangeListenerTestAdd();
+        NodeChangeListenerTestAdd ncl2 = new NodeChangeListenerTestAdd();
+        NodeChangeListenerTestAdd ncl3 = new NodeChangeListenerTestAdd();
+        try {
+            userRoot = Preferences.userRoot();
+            N1 = userRoot.node("N1");
+            userRoot.flush();
+
+            //add ncl nc2
+            N1.addNodeChangeListener(ncl);
+            N1.addNodeChangeListener(ncl2);
+            N1.removeNodeChangeListener(ncl3);
+            throw new RuntimeException();
+        } catch (IllegalArgumentException iae) {
+            System.out.println("Test Passed!");
+        } catch (Exception e) {
+            System.out.println("Test Failed");
+            throw e;
+        }
+    }
+
+}
+class NodeChangeListenerTestAdd implements NodeChangeListener {
+    public void childAdded(NodeChangeEvent evt) {}
+    public void childRemoved(NodeChangeEvent evt) {}
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/java/util/prefs/SerializeExceptions.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+/*
+ * @test
+ * @bug     4811356
+ * @summary Prefs exceptions were unintentionally not serializable
+ * @author  Josh Bloch
+ */
+
+import java.util.prefs.*;
+import java.io.*;
+
+public class SerializeExceptions {
+    public static void main(String args[]) throws Exception {
+        test(new BackingStoreException("Hi"));
+        test(new InvalidPreferencesFormatException("Mom!"));
+    }
+
+    static void test(Object o) throws IOException {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        ObjectOutputStream out = new ObjectOutputStream(bos);
+        out.writeObject(o);
+        out.flush();
+        out.close();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/JFileChooser/6484091/bug6484091.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6484091
+ * @summary FileSystemView leaks directory info
+ * @author Pavel Porvatov
+   @run main bug6484091
+ */
+
+import javax.swing.filechooser.FileSystemView;
+import java.io.File;
+import java.security.AccessControlException;
+
+public class bug6484091 {
+    public static void main(String[] args) {
+        File dir = FileSystemView.getFileSystemView().getDefaultDirectory();
+
+        printDirContent(dir);
+
+        System.setSecurityManager(new SecurityManager());
+
+        // The next test cases use 'dir' obtained without SecurityManager
+
+        try {
+            printDirContent(dir);
+
+            throw new RuntimeException("Dir content was derived bypass SecurityManager");
+        } catch (AccessControlException e) {
+            // It's a successful situation
+        }
+    }
+
+    private static void printDirContent(File dir) {
+        System.out.println("Files in " + dir.getAbsolutePath() + ":");
+
+        for (File file : dir.listFiles()) {
+            System.out.println(file.getName());
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/JLayer/6824395/bug6824395.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+ /*
+ * @test
+ * @summary Checks that JLayer inside JViewport works is correctly laid out
+ * @author Alexander Potochkin
+ * @run main bug6824395
+ */
+
+
+import sun.awt.SunToolkit;
+
+import javax.swing.*;
+import javax.swing.plaf.LayerUI;
+import java.awt.*;
+
+public class bug6824395 {
+
+    static JScrollPane scrollPane;
+
+    public static void main(String[] args) throws Exception {
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                JFrame frame = new JFrame("testing");
+                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+
+                JEditorPane editorPane = new JEditorPane();
+                String str = "hello\n";
+                for(int i = 0; i<5; i++) {
+                    str += str;
+                }
+
+                editorPane.setText(str);
+
+                JLayer<JEditorPane> editorPaneLayer = new JLayer<JEditorPane>(editorPane);
+                LayerUI<JComponent> layerUI = new LayerUI<JComponent>();
+                editorPaneLayer.setUI(layerUI);
+
+                scrollPane = new JScrollPane(editorPaneLayer);
+
+                scrollPane.setPreferredSize(new Dimension(200, 250));
+                frame.add(scrollPane);
+
+                frame.setSize(200, 200);
+                frame.pack();
+                frame.setVisible(true);
+            }
+        });
+        toolkit.realSync();
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                if (scrollPane.getViewportBorderBounds().width != scrollPane.getViewport().getView().getWidth()) {
+                    throw new RuntimeException("Wrong component's width!");
+                }
+            }
+        });
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/JLayer/6872503/bug6872503.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6872503
+ * @summary Checks that JLayer correctly works with its AWTEventListener
+ * @author Alexander Potochkin
+ */
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.AWTEventListener;
+import java.awt.event.AWTEventListenerProxy;
+
+public class bug6872503 {
+
+    static JLayer<Component> l1;
+    static JLayer<Component> l2;
+
+    private static void createGui() {
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+        int length = toolkit.getAWTEventListeners().length;
+
+        l1 = new JLayer<Component>();
+        l1.setLayerEventMask(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);
+
+        l2 = new JLayer<Component>();
+        l2.setLayerEventMask(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
+
+        if (isLayerEventControllerAdded()) {
+            throw new RuntimeException("Unexpected AWTEventListener was added");
+        }
+
+        JFrame frame = new JFrame();
+        frame.setLayout(new FlowLayout());
+        frame.add(l1);
+        frame.add(l2);
+
+        if (isLayerEventControllerAdded()) {
+            throw new RuntimeException("Unexpected AWTEventListener was added");
+        }
+
+        frame.pack();
+
+        if (!isLayerEventControllerAdded()) {
+            throw new RuntimeException("AWTEventListener was not added");
+        }
+
+        if (!layerEventControllerMaskEquals(l1.getLayerEventMask() | l2.getLayerEventMask())) {
+             throw new RuntimeException("Wrong mask for AWTEventListener");
+        }
+
+        frame.dispose();
+
+        if (isLayerEventControllerAdded()) {
+            throw new RuntimeException("Unexpected AWTEventListener was added");
+        }
+    }
+
+    static boolean isLayerEventControllerAdded() {
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+        AWTEventListener layerEventController = null;
+        for (AWTEventListener listener : toolkit.getAWTEventListeners()) {
+            if (listener instanceof AWTEventListenerProxy) {
+                listener = ((AWTEventListenerProxy)listener).getListener();
+
+            }
+            if ("LayerEventController".equals(listener.getClass().getSimpleName())) {
+                if (layerEventController != null) {
+                    throw new RuntimeException("Duplicated LayerEventController");
+                }
+                layerEventController = listener;
+            }
+        }
+        boolean ret = layerEventController != null;
+        if (ret) {
+            System.out.println("LayerEventController found");
+        } else {
+            System.out.println("No LayerEventController");
+        }
+        return ret;
+    }
+
+    static boolean layerEventControllerMaskEquals(long mask) {
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+        AWTEventListener layerEventController = null;
+        for (AWTEventListener listener : toolkit.getAWTEventListeners(mask)) {
+            if (listener instanceof AWTEventListenerProxy) {
+                listener = ((AWTEventListenerProxy)listener).getListener();
+
+            }
+            if ("LayerEventController".equals(listener.getClass().getSimpleName())) {
+                if (layerEventController != null) {
+                    throw new RuntimeException("Duplicated LayerEventController");
+                }
+                layerEventController = listener;
+            }
+        }
+        boolean ret = layerEventController != null;
+        if (ret) {
+            System.out.println("LayerEventController with the correct mask found");
+        } else {
+            System.out.println("No LayerEventController with the correct mask");
+        }
+        return ret;
+    }
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                bug6872503.createGui();
+            }
+        });
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/JLayer/6875153/bug6875153.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6875153
+ * @summary JLayer.isOptimizedDrawingEnabled() throws NPE for null glass pane set
+ * @author Alexander Potochkin
+ */
+
+import javax.swing.*;
+
+public class bug6875153 {
+
+    private static void createGui() {
+        JLayer layer = new JLayer();
+        layer.setGlassPane(null);
+        layer.isOptimizedDrawingEnabled();
+    }
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                bug6875153.createGui();
+            }
+        });
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/JSlider/6579827/bug6579827.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ * @bug 6579827
+ * @summary vista : JSlider on JColorchooser is not properly render or can't be seen completely
+ * @author Pavel Porvatov
+   @run main bug6579827
+ */
+
+import sun.awt.OSInfo;
+
+import javax.swing.*;
+import java.awt.*;
+
+public class bug6579827 {
+    public static void main(String[] args) throws Exception {
+        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS ||
+                OSInfo.getWindowsVersion() != OSInfo.WINDOWS_VISTA) {
+            System.out.println("This test is only for Windows Vista. Skipped.");
+
+            return;
+        }
+
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                try {
+                    UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
+                } catch (Exception e) {
+                    e.printStackTrace();
+
+                    throw new RuntimeException(e);
+                }
+
+                JSlider slider = new JSlider(JSlider.VERTICAL, 0, 100, 0);
+
+                Dimension prefferdSize = slider.getPreferredSize();
+
+                slider.setPaintTrack(false);
+                slider.putClientProperty("Slider.paintThumbArrowShape", Boolean.TRUE);
+
+                if (prefferdSize.equals(slider.getPreferredSize())) {
+                    throw new RuntimeException();
+                }
+            }
+        });
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/javax/swing/SwingUtilities/6797139/bug6797139.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+ *
+ * @bug 6797139
+ * @author Alexander Potochkin
+ * @summary tests that JButton's text is not incorrectly truncated
+ */
+import javax.swing.*;
+import javax.swing.plaf.basic.BasicButtonUI;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+
+public class bug6797139 {
+
+    private static void createGui() {
+        JButton b = new JButton("Probably");
+        b.setUI(new BasicButtonUI() {
+            protected void paintText(Graphics g, AbstractButton b, Rectangle textRect, String text) {
+                super.paintText(g, b, textRect, text);
+                if (text.endsWith("...")) {
+                    throw new RuntimeException("Text is truncated!");
+                }
+            }
+        });
+        b.setSize(b.getPreferredSize());
+        BufferedImage image = new BufferedImage(b.getWidth(), b.getHeight(),
+                BufferedImage.TYPE_INT_ARGB);
+        Graphics g = image.getGraphics();
+        b.paint(g);
+        g.dispose();
+    }
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createGui();
+            }
+        });
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/sun/security/krb5/ktab/HighestKvno.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6867665
+ * @bug 6875033
+ * @summary Problem with keytabs with multiple kvno's (key versions)
+ */
+
+import sun.security.krb5.internal.ktab.*;
+import sun.security.krb5.*;
+import java.io.File;
+import java.io.FileOutputStream;
+
+public class HighestKvno {
+
+    public static void main(String[] args) throws Exception {
+        // kt is a keytab including these entries:
+        //
+        // me@MAD.LOCAL: Type: 3, KVNO: 4
+        // me@MAD.LOCAL: Type: 23, KVNO: 4
+        // me@MAD.LOCAL: Type: 16, KVNO: 4
+        // me@MAD.LOCAL: Type: 1, KVNO: 5
+        // me@MAD.LOCAL: Type: 17, KVNO: 5
+        // me@MAD.LOCAL: Type: 18, KVNO: 5
+        // me@MAD.LOCAL: Type: 1, KVNO: 3
+        // me@MAD.LOCAL: Type: 17, KVNO: 3
+        // me@MAD.LOCAL: Type: 18, KVNO: 3
+        // he@MAD.LOCAL: Type: 1, KVNO: 1
+        // he@MAD.LOCAL: Type: 17, KVNO: 1
+        // he@MAD.LOCAL: Type: 18, KVNO: 1
+        //
+        // This file is created with these steps:
+        // 1. Modify JRE's Ktab.java so that adding new entries
+        //    does not remove the old one.
+        // 2. Run the modified Ktab to create 4 sets of keys
+        // 3. Manually hex edit the KVNO as above
+
+        byte[] kt = {
+            (byte)0x05, (byte)0x02, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x26, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x6D, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x45, (byte)0xCD, (byte)0x04,
+            (byte)0x00, (byte)0x03, (byte)0x00, (byte)0x08,
+            (byte)0xE6, (byte)0xB0, (byte)0x07, (byte)0xA8,
+            (byte)0x5B, (byte)0xF8, (byte)0x73, (byte)0xAD,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x2E,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x6D,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x45,
+            (byte)0xCD, (byte)0x04, (byte)0x00, (byte)0x17,
+            (byte)0x00, (byte)0x10, (byte)0x50, (byte)0x92,
+            (byte)0x01, (byte)0x6B, (byte)0xCF, (byte)0x5A,
+            (byte)0x2A, (byte)0x7A, (byte)0x4F, (byte)0xE8,
+            (byte)0x39, (byte)0xD9, (byte)0x90, (byte)0xB5,
+            (byte)0x9C, (byte)0xEB, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x36, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x6D, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x45, (byte)0xCD, (byte)0x04,
+            (byte)0x00, (byte)0x10, (byte)0x00, (byte)0x18,
+            (byte)0xDF, (byte)0xDF, (byte)0x62, (byte)0x86,
+            (byte)0x37, (byte)0xCE, (byte)0x29, (byte)0xBA,
+            (byte)0xBC, (byte)0x23, (byte)0x15, (byte)0xDC,
+            (byte)0x86, (byte)0x7C, (byte)0xB6, (byte)0x89,
+            (byte)0x25, (byte)0x25, (byte)0xCD, (byte)0x4A,
+            (byte)0x9B, (byte)0xCE, (byte)0xF4, (byte)0xAE,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x26,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x6D,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x4B,
+            (byte)0x5E, (byte)0x05, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x08, (byte)0xE6, (byte)0xB0,
+            (byte)0x07, (byte)0xA8, (byte)0x5B, (byte)0xF8,
+            (byte)0x73, (byte)0xAD, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x2E, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x6D, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x4B, (byte)0x5E, (byte)0x05,
+            (byte)0x00, (byte)0x11, (byte)0x00, (byte)0x10,
+            (byte)0xEA, (byte)0xF5, (byte)0xA8, (byte)0x36,
+            (byte)0xA5, (byte)0x3E, (byte)0x5F, (byte)0x5C,
+            (byte)0x26, (byte)0xE9, (byte)0xDD, (byte)0x8B,
+            (byte)0x8C, (byte)0xE8, (byte)0x92, (byte)0x9C,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x3E,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x6D,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x4B,
+            (byte)0x5E, (byte)0x05, (byte)0x00, (byte)0x12,
+            (byte)0x00, (byte)0x20, (byte)0x68, (byte)0xBE,
+            (byte)0xD4, (byte)0x17, (byte)0x3A, (byte)0x06,
+            (byte)0xE0, (byte)0x0C, (byte)0x62, (byte)0x11,
+            (byte)0xB7, (byte)0x53, (byte)0x1B, (byte)0x3E,
+            (byte)0xB2, (byte)0x6B, (byte)0x0D, (byte)0x48,
+            (byte)0xD8, (byte)0x52, (byte)0x5A, (byte)0x4C,
+            (byte)0xBE, (byte)0x24, (byte)0xBB, (byte)0x3D,
+            (byte)0xC1, (byte)0x74, (byte)0x69, (byte)0xDA,
+            (byte)0x34, (byte)0x98, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x26, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x6D, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x51, (byte)0x27, (byte)0x03,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x08,
+            (byte)0xE6, (byte)0xB0, (byte)0x07, (byte)0xA8,
+            (byte)0x5B, (byte)0xF8, (byte)0x73, (byte)0xAD,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x2E,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x6D,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x51,
+            (byte)0x27, (byte)0x03, (byte)0x00, (byte)0x11,
+            (byte)0x00, (byte)0x10, (byte)0xEA, (byte)0xF5,
+            (byte)0xA8, (byte)0x36, (byte)0xA5, (byte)0x3E,
+            (byte)0x5F, (byte)0x5C, (byte)0x26, (byte)0xE9,
+            (byte)0xDD, (byte)0x8B, (byte)0x8C, (byte)0xE8,
+            (byte)0x92, (byte)0x9C, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x3E, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x6D, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x51, (byte)0x27, (byte)0x03,
+            (byte)0x00, (byte)0x12, (byte)0x00, (byte)0x20,
+            (byte)0x68, (byte)0xBE, (byte)0xD4, (byte)0x17,
+            (byte)0x3A, (byte)0x06, (byte)0xE0, (byte)0x0C,
+            (byte)0x62, (byte)0x11, (byte)0xB7, (byte)0x53,
+            (byte)0x1B, (byte)0x3E, (byte)0xB2, (byte)0x6B,
+            (byte)0x0D, (byte)0x48, (byte)0xD8, (byte)0x52,
+            (byte)0x5A, (byte)0x4C, (byte)0xBE, (byte)0x24,
+            (byte)0xBB, (byte)0x3D, (byte)0xC1, (byte)0x74,
+            (byte)0x69, (byte)0xDA, (byte)0x34, (byte)0x98,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x26,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x68,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x54,
+            (byte)0xC7, (byte)0x01, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x08, (byte)0x85, (byte)0x5B,
+            (byte)0xE3, (byte)0x13, (byte)0x3E, (byte)0xF8,
+            (byte)0x76, (byte)0xEC, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x2E, (byte)0x00, (byte)0x01,
+            (byte)0x00, (byte)0x09, (byte)0x4D, (byte)0x41,
+            (byte)0x44, (byte)0x2E, (byte)0x4C, (byte)0x4F,
+            (byte)0x43, (byte)0x41, (byte)0x4C, (byte)0x00,
+            (byte)0x02, (byte)0x68, (byte)0x65, (byte)0x00,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x4A,
+            (byte)0x79, (byte)0x54, (byte)0xC7, (byte)0x01,
+            (byte)0x00, (byte)0x11, (byte)0x00, (byte)0x10,
+            (byte)0xEC, (byte)0xCC, (byte)0x16, (byte)0xCD,
+            (byte)0xE8, (byte)0x51, (byte)0x46, (byte)0x4C,
+            (byte)0x1B, (byte)0x57, (byte)0xAE, (byte)0x19,
+            (byte)0xC3, (byte)0xD2, (byte)0x55, (byte)0x1B,
+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x3E,
+            (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x09,
+            (byte)0x4D, (byte)0x41, (byte)0x44, (byte)0x2E,
+            (byte)0x4C, (byte)0x4F, (byte)0x43, (byte)0x41,
+            (byte)0x4C, (byte)0x00, (byte)0x02, (byte)0x68,
+            (byte)0x65, (byte)0x00, (byte)0x00, (byte)0x00,
+            (byte)0x00, (byte)0x4A, (byte)0x79, (byte)0x54,
+            (byte)0xC7, (byte)0x01, (byte)0x00, (byte)0x12,
+            (byte)0x00, (byte)0x20, (byte)0xAE, (byte)0xBA,
+            (byte)0xCB, (byte)0xF5, (byte)0xA8, (byte)0x09,
+            (byte)0xC1, (byte)0xB0, (byte)0x2C, (byte)0x2A,
+            (byte)0x3D, (byte)0x96, (byte)0x2C, (byte)0x2D,
+            (byte)0xF5, (byte)0xFE, (byte)0x65, (byte)0xEC,
+            (byte)0x75, (byte)0x72, (byte)0x5B, (byte)0x46,
+            (byte)0x84, (byte)0xD7, (byte)0x49, (byte)0x3E,
+            (byte)0xF2, (byte)0x27, (byte)0x32, (byte)0x69,
+            (byte)0x75, (byte)0x9B,
+        };
+        System.setProperty("java.security.krb5.conf",
+                new File(System.getProperty("test.src"),
+                    "../krb5.conf").getAbsolutePath());
+        FileOutputStream fout = new FileOutputStream("kt");
+        fout.write(kt);
+        fout.close();
+        KeyTab ktab = KeyTab.getInstance("kt");
+        PrincipalName pn = new PrincipalName("me@MAD.LOCAL");
+        EncryptionKey[] keys = ktab.readServiceKeys(pn);
+        if (keys[0].getKeyVersionNumber() != 5) {
+            throw new Exception("Highest not first");
+        }
+        if (ktab.readServiceKey(pn).getKeyVersionNumber() != 5) {
+            throw new Exception("Highest not chosen");
+        }
+        new File("kt").delete();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/sun/security/tools/jarsigner/nameclash.sh	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,66 @@
+#
+# Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+# @test
+# @bug 6876328
+# @summary different names for the same digest algorithms breaks jarsigner
+#
+
+if [ "${TESTJAVA}" = "" ] ; then
+  JAVAC_CMD=`which javac`
+  TESTJAVA=`dirname $JAVAC_CMD`/..
+fi
+
+# set platform-dependent variables
+OS=`uname -s`
+case "$OS" in
+  Windows_* )
+    FS="\\"
+    ;;
+  * )
+    FS="/"
+    ;;
+esac
+
+KS=nc.jks
+JFILE=nc.jar
+
+KT="$TESTJAVA${FS}bin${FS}keytool -storepass changeit -keypass changeit -keystore $KS"
+JAR=$TESTJAVA${FS}bin${FS}jar
+JARSIGNER=$TESTJAVA${FS}bin${FS}jarsigner
+
+rm $KS $JFILE
+
+$KT -alias a -dname CN=a -keyalg rsa -genkey -validity 300
+$KT -alias b -dname CN=b -keyalg rsa -genkey -validity 300
+
+echo A > A
+$JAR cvf $JFILE A
+
+$JARSIGNER -keystore $KS -storepass changeit $JFILE a -digestalg SHA1 || exit 1
+$JARSIGNER -keystore $KS -storepass changeit $JFILE b -digestalg SHA-1 || exit 2
+
+$JARSIGNER -keystore $KS -verify -debug -strict $JFILE || exit 3
+
+exit 0
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/sun/security/x509/AlgorithmId/SHA256withECDSA.java	Tue Sep 22 01:20:51 2009 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6871847
+ * @summary AlgorithmId.get("SHA256withECDSA") not available
+ */
+
+import sun.security.x509.*;
+
+public class SHA256withECDSA {
+    public static void main(String[] args) throws Exception {
+        AlgorithmId.get("SHA224withECDSA");
+        AlgorithmId.get("SHA256withECDSA");
+        AlgorithmId.get("SHA384withECDSA");
+        AlgorithmId.get("SHA512withECDSA");
+    }
+}
--- a/make/javax/swing/plaf/nimbus/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-#
-# Copyright 1998-2007 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-BUILDDIR  = ../../../..
-PACKAGE   = javax.swing.plaf.nimbus
-PRODUCT   = com
-SWING_SRC = $(SHARE_SRC)/classes/javax/swing
-include $(BUILDDIR)/common/Defs.gmk
-
-#
-# Files
-#
-NIMBUS_PKG = javax/swing/plaf/nimbus
-NIMBUS_COMPAT_PKG = com/sun/java/swing/plaf/nimbus
-NIMBUS_GENSRC_DIR = $(GENSRCDIR)/$(NIMBUS_PKG)
-NIMBUS_SKIN_FILE = $(SHARE_SRC)/classes/$(NIMBUS_PKG)/skin.laf
-NIMBUS_GENERATOR_JAR = $(BUILDTOOLJARDIR)/nimbus_generator.jar
-
-AUTO_FILES_JAVA_DIRS = $(NIMBUS_PKG) $(NIMBUS_COMPAT_PKG)
-
-
-#
-# Rules
-#
-CLASSES_INIT = $(NIMBUS_GENSRC_DIR)
-
-include $(BUILDDIR)/common/Classes.gmk
-
-$(NIMBUS_GENSRC_DIR): $(NIMBUS_SKIN_FILE) $(NIMBUS_GENERATOR_JAR)
-	@$(ECHO) "Generating Nimbus source files:"
-	$(BOOT_JAVA_CMD) -jar $(NIMBUS_GENERATOR_JAR) \
-	    -skinFile $(NIMBUS_SKIN_FILE) \
-	    -buildDir $(GENSRCDIR) -srcDir $(GENSRCDIR) \
-	    -packagePrefix $(PACKAGE) -lafName Nimbus
-	@$(ECHO) "Finished generating Nimbus source files"
-
-clean clobber::
-	$(RM) -r $(NIMBUS_GENSRC_DIR)
--- a/make/tools/swing-nimbus/Makefile	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,91 +0,0 @@
-#
-# Copyright 1998-2005 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-#
-# Makefile for building the Nimbus generator
-#
-
-BUILDDIR = ../..
-PACKAGE = org.jdesktop.synthdesigner.generator
-PRODUCT = tools
-PROGRAM = nimbus_generator
-include $(BUILDDIR)/common/Defs.gmk
-
-BUILDTOOL_SOURCE_ROOT = classes
-BUILDTOOL_MAIN        = $(PKGDIR)/Generator.java
-
-#
-# Files
-#
-
-MAIN_CLASS_FILE = $(BUILDTOOLCLASSDIR)/$(BUILDTOOL_MAIN:%.java=%.class)
-SOURCE_FILES    = $(shell $(FIND) $(BUILDTOOL_SOURCE_ROOT) -name '*.java' -print)
-
-TEMPLATE_FILES  = $(SHARE_SRC)/classes/javax/swing/plaf/nimbus/Defaults.template \
-                  $(SHARE_SRC)/classes/javax/swing/plaf/nimbus/PainterImpl.template \
-                  $(SHARE_SRC)/classes/javax/swing/plaf/nimbus/StateImpl.template
-TEMPLATE_DEST   = $(BUILDTOOLCLASSDIR)/org/jdesktop/synthdesigner/generator/resources
-
-JIBX_FILES      = $(BUILDTOOL_SOURCE_ROOT)/org/jdesktop/swingx/designer/Designer.jibx.xml \
-                  $(BUILDTOOL_SOURCE_ROOT)/org/jdesktop/synthdesigner/synthmodel/SynthModel.jibx.xml
-JIBX_LIBS_CP    = $(JIBX_LIBS_PATH)/bcel.jar$(CLASSPATH_SEPARATOR)$(JIBX_LIBS_PATH)/xpp3.jar$(CLASSPATH_SEPARATOR)$(JIBX_LIBS_PATH)/jibx-bind.jar$(CLASSPATH_SEPARATOR)$(JIBX_LIBS_PATH)/jibx-run.jar
-JIBX_LIBS_LIST  = $(subst $(CLASSPATH_SEPARATOR), ,$(JIBX_LIBS_CP))
-
-
-#
-# Rules
-#
-
-include $(BUILDDIR)/common/BuildToolJar.gmk
-
-$(MAIN_CLASS_FILE): $(SOURCE_FILES) $(JIBX_LIBS_LIST)
-	@$(MKDIR) -p $(BUILDTOOLCLASSDIR)
-	$(BOOT_JAVAC_CMD) -classpath "$(JIBX_LIBS_CP)" \
-	    -d $(BUILDTOOLCLASSDIR) -sourcepath $(BUILDTOOL_SOURCE_ROOT) \
-	    $(SOURCE_FILES)
-
-$(TEMPLATE_DEST): $(TEMPLATE_FILES)
-	$(MKDIR) -p $(TEMPLATE_DEST)
-	$(RM) $(TEMPLATE_DEST)/*.template
-	$(CP) $(TEMPLATE_FILES) $(TEMPLATE_DEST)
-
-$(BUILDTOOL_MANIFEST_FILE): $(MAIN_CLASS_FILE)
-	$(ECHO) "Main-Class: $(BUILTTOOL_MAINCLASS)" > $@
-	$(ECHO) "Class-Path: $(JIBX_LIBS_LIST:$(JIBX_LIBS_PATH)/%=%)" >> $@
-	$(CP) $(JIBX_LIBS_LIST) $(BUILDTOOLJARDIR)
-
-$(BUILDTOOL_JAR_FILE): $(MAIN_CLASS_FILE) $(TEMPLATE_DEST) \
-    $(JIBX_FILES) $(BUILDTOOL_MANIFEST_FILE)
-	@$(prep-target)
-	$(BOOT_JAVA_CMD) \
-	  -classpath "$(JIBX_LIBS_CP)$(CLASSPATH_SEPARATOR)$(BUILDTOOLCLASSDIR)" \
-	  org.jibx.binding.Compile $(JIBX_FILES)
-	$(BOOT_JAR_CMD) cfm $@ $(BUILDTOOL_MANIFEST_FILE) \
-	    -C $(BUILDTOOLCLASSDIR) org \
-	    $(BOOT_JAR_JFLAGS) || $(RM) $@
-	@$(java-vm-cleanup)
-
-clean clobber::
-	$(RM) -r $(TEMPLATE_DEST)
--- a/make/tools/swing-nimbus/classes/org/jdesktop/beans/AbstractBean.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,475 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.beans;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyChangeSupport;
-import java.beans.PropertyVetoException;
-import java.beans.VetoableChangeListener;
-import java.beans.VetoableChangeSupport;
-
-/**
- * <p>A convenience class from which to extend all non-visual AbstractBeans. It
- * manages the PropertyChange notification system, making it relatively trivial
- * to add support for property change events in getters/setters.</p>
- *
- * <p>A non-visual java bean is a Java class that conforms to the AbstractBean
- * patterns to allow visual manipulation of the bean's properties and event
- * handlers at design-time.</p>
- *
- * <p>Here is a simple example bean that contains one property, foo, and the
- * proper pattern for implementing property change notification:
- * <pre><code>
- *  public class ABean extends AbstractBean {
- *    private String foo;
- *
- *    public void setFoo(String newFoo) {
- *      String old = getFoo();
- *      this.foo = newFoo;
- *      firePropertyChange("foo", old, getFoo());
- *    }
- *
- *    public String getFoo() {
- *      return foo;
- *    }
- *  }
- * </code></pre></p>
- *
- * <p>You will notice that "getFoo()" is used in the setFoo method rather than
- * accessing "foo" directly for the gets. This is done intentionally so that if
- * a subclass overrides getFoo() to return, for instance, a constant value the
- * property change notification system will continue to work properly.</p>
- *
- * <p>The firePropertyChange method takes into account the old value and the new
- * value. Only if the two differ will it fire a property change event. So you can
- * be assured from the above code fragment that a property change event will only
- * occur if old is indeed different from getFoo()</p>
- *
- * <p><code>AbstractBean</code> also supports {@link VetoablePropertyChange} events.
- * These events are similar to <code>PropertyChange</code> events, except a special
- * exception can be used to veto changing the property. For example, perhaps the
- * property is changing from "fred" to "red", but a listener deems that "red" is
- * unexceptable. In this case, the listener can fire a veto exception and the property must
- * remain "fred". For example:
- * <pre><code>
- *  public class ABean extends AbstractBean {
- *    private String foo;
- *
- *    public void setFoo(String newFoo) throws PropertyVetoException {
- *      String old = getFoo();
- *      this.foo = newFoo;
- *      fireVetoableChange("foo", old, getFoo());
- *    }
- *
- *    public String getFoo() {
- *      return foo;
- *    }
- *  }
- *
- *  public class Tester {
- *    public static void main(String... args) {
- *      try {
- *        ABean a = new ABean();
- *        a.setFoo("fred");
- *        a.addVetoableChangeListener(new VetoableChangeListener() {
- *          public void vetoableChange(PropertyChangeEvent evt) throws PropertyVetoException {
- *            if ("red".equals(evt.getNewValue()) {
- *              throw new PropertyVetoException("Cannot be red!", evt);
- *            }
- *          }
- *        }
- *        a.setFoo("red");
- *      } catch (Exception e) {
- *        e.printStackTrace(); // this will be executed
- *      }
- *    }
- *  }
- * </code></pre></p>
- *
- * @status REVIEWED
- * @author rbair
- */
-public abstract class AbstractBean {
-    /**
-     * Helper class that manages all the property change notification machinery.
-     * PropertyChangeSupport cannot be extended directly because it requires
-     * a bean in the constructor, and the "this" argument is not valid until
-     * after super construction. Hence, delegation instead of extension
-     */
-    private transient PropertyChangeSupport pcs;
-
-    /**
-     * Helper class that manages all the veto property change notification machinery.
-     */
-    private transient VetoableChangeSupport vcs;
-
-    /** Creates a new instance of AbstractBean */
-    protected AbstractBean() {
-        pcs = new PropertyChangeSupport(this);
-        vcs = new VetoableChangeSupport(this);
-    }
-
-    /**
-     * Creates a new instance of AbstractBean, using the supplied PropertyChangeSupport and
-     * VetoableChangeSupport delegates. Neither of these may be null.
-     */
-    protected AbstractBean(PropertyChangeSupport pcs, VetoableChangeSupport vcs) {
-        if (pcs == null) {
-            throw new NullPointerException("PropertyChangeSupport must not be null");
-        }
-        if (vcs == null) {
-            throw new NullPointerException("VetoableChangeSupport must not be null");
-        }
-
-        this.pcs = pcs;
-        this.vcs = vcs;
-    }
-
-    /**
-     * Add a PropertyChangeListener to the listener list.
-     * The listener is registered for all properties.
-     * The same listener object may be added more than once, and will be called
-     * as many times as it is added.
-     * If <code>listener</code> is null, no exception is thrown and no action
-     * is taken.
-     *
-     * @param listener  The PropertyChangeListener to be added
-     */
-    public final void addPropertyChangeListener(PropertyChangeListener listener) {
-        pcs.addPropertyChangeListener(listener);
-    }
-
-    /**
-     * Remove a PropertyChangeListener from the listener list.
-     * This removes a PropertyChangeListener that was registered
-     * for all properties.
-     * If <code>listener</code> was added more than once to the same event
-     * source, it will be notified one less time after being removed.
-     * If <code>listener</code> is null, or was never added, no exception is
-     * thrown and no action is taken.
-     *
-     * @param listener  The PropertyChangeListener to be removed
-     */
-    public final void removePropertyChangeListener(PropertyChangeListener listener) {
-        pcs.removePropertyChangeListener(listener);
-    }
-
-    /**
-     * Returns an array of all the listeners that were added to the
-     * PropertyChangeSupport object with addPropertyChangeListener().
-     * <p>
-     * If some listeners have been added with a named property, then
-     * the returned array will be a mixture of PropertyChangeListeners
-     * and <code>PropertyChangeListenerProxy</code>s. If the calling
-     * method is interested in distinguishing the listeners then it must
-     * test each element to see if it's a
-     * <code>PropertyChangeListenerProxy</code>, perform the cast, and examine
-     * the parameter.
-     *
-     * <pre>
-     * PropertyChangeListener[] listeners = bean.getPropertyChangeListeners();
-     * for (int i = 0; i < listeners.length; i++) {
-     *   if (listeners[i] instanceof PropertyChangeListenerProxy) {
-     *     PropertyChangeListenerProxy proxy =
-     *                    (PropertyChangeListenerProxy)listeners[i];
-     *     if (proxy.getPropertyName().equals("foo")) {
-     *       // proxy is a PropertyChangeListener which was associated
-     *       // with the property named "foo"
-     *     }
-     *   }
-     * }
-     *</pre>
-     *
-     * @see java.beans.PropertyChangeListenerProxy
-     * @return all of the <code>PropertyChangeListeners</code> added or an
-     *         empty array if no listeners have been added
-     */
-    public final PropertyChangeListener[] getPropertyChangeListeners() {
-        return pcs.getPropertyChangeListeners();
-    }
-
-    /**
-     * Add a PropertyChangeListener for a specific property.  The listener
-     * will be invoked only when a call on firePropertyChange names that
-     * specific property.
-     * The same listener object may be added more than once.  For each
-     * property,  the listener will be invoked the number of times it was added
-     * for that property.
-     * If <code>propertyName</code> or <code>listener</code> is null, no
-     * exception is thrown and no action is taken.
-     *
-     * @param propertyName  The name of the property to listen on.
-     * @param listener  The PropertyChangeListener to be added
-     */
-    public final void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
-        pcs.addPropertyChangeListener(propertyName, listener);
-    }
-
-    /**
-     * Remove a PropertyChangeListener for a specific property.
-     * If <code>listener</code> was added more than once to the same event
-     * source for the specified property, it will be notified one less time
-     * after being removed.
-     * If <code>propertyName</code> is null,  no exception is thrown and no
-     * action is taken.
-     * If <code>listener</code> is null, or was never added for the specified
-     * property, no exception is thrown and no action is taken.
-     *
-     * @param propertyName  The name of the property that was listened on.
-     * @param listener  The PropertyChangeListener to be removed
-     */
-    public final void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
-        pcs.removePropertyChangeListener(propertyName, listener);
-    }
-
-    /**
-     * Returns an array of all the listeners which have been associated
-     * with the named property.
-     *
-     * @param propertyName  The name of the property being listened to
-     * @return all of the <code>PropertyChangeListeners</code> associated with
-     *         the named property.  If no such listeners have been added,
-     *         or if <code>propertyName</code> is null, an empty array is
-     *         returned.
-     */
-    public final PropertyChangeListener[] getPropertyChangeListeners(String propertyName) {
-            return pcs.getPropertyChangeListeners(propertyName);
-    }
-
-    /**
-     * Report a bound property update to any registered listeners.
-     * No event is fired if old and new are equal and non-null.
-     *
-     * <p>
-     * This is merely a convenience wrapper around the more general
-     * firePropertyChange method that takes {@code
-     * PropertyChangeEvent} value.
-     *
-     * @param propertyName  The programmatic name of the property
-     *                      that was changed.
-     * @param oldValue  The old value of the property.
-     * @param newValue  The new value of the property.
-     */
-    protected final void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
-        pcs.firePropertyChange(propertyName, oldValue, newValue);
-    }
-
-    /**
-     * Fire an existing PropertyChangeEvent to any registered listeners.
-     * No event is fired if the given event's old and new values are
-     * equal and non-null.
-     * @param evt  The PropertyChangeEvent object.
-     */
-    protected final void firePropertyChange(PropertyChangeEvent evt) {
-        pcs.firePropertyChange(evt);
-    }
-
-
-    /**
-     * Report a bound indexed property update to any registered
-     * listeners.
-     * <p>
-     * No event is fired if old and new values are equal
-     * and non-null.
-     *
-     * <p>
-     * This is merely a convenience wrapper around the more general
-     * firePropertyChange method that takes {@code PropertyChangeEvent} value.
-     *
-     * @param propertyName The programmatic name of the property that
-     *                     was changed.
-     * @param index        index of the property element that was changed.
-     * @param oldValue     The old value of the property.
-     * @param newValue     The new value of the property.
-     */
-    protected final void fireIndexedPropertyChange(String propertyName,
-            int index, Object oldValue, Object newValue) {
-        pcs.fireIndexedPropertyChange(propertyName, index, oldValue, newValue);
-    }
-
-    /**
-     * Check if there are any listeners for a specific property, including
-     * those registered on all properties.  If <code>propertyName</code>
-     * is null, only check for listeners registered on all properties.
-     *
-     * @param propertyName  the property name.
-     * @return true if there are one or more listeners for the given property
-     */
-    protected final boolean hasPropertyChangeListeners(String propertyName) {
-        return pcs.hasListeners(propertyName);
-    }
-
-    /**
-     * Check if there are any listeners for a specific property, including
-     * those registered on all properties.  If <code>propertyName</code>
-     * is null, only check for listeners registered on all properties.
-     *
-     * @param propertyName  the property name.
-     * @return true if there are one or more listeners for the given property
-     */
-    protected final boolean hasVetoableChangeListeners(String propertyName) {
-        return vcs.hasListeners(propertyName);
-    }
-
-    /**
-     * Add a VetoableListener to the listener list.
-     * The listener is registered for all properties.
-     * The same listener object may be added more than once, and will be called
-     * as many times as it is added.
-     * If <code>listener</code> is null, no exception is thrown and no action
-     * is taken.
-     *
-     * @param listener  The VetoableChangeListener to be added
-     */
-
-    public final void addVetoableChangeListener(VetoableChangeListener listener) {
-        vcs.addVetoableChangeListener(listener);
-    }
-
-    /**
-     * Remove a VetoableChangeListener from the listener list.
-     * This removes a VetoableChangeListener that was registered
-     * for all properties.
-     * If <code>listener</code> was added more than once to the same event
-     * source, it will be notified one less time after being removed.
-     * If <code>listener</code> is null, or was never added, no exception is
-     * thrown and no action is taken.
-     *
-     * @param listener  The VetoableChangeListener to be removed
-     */
-    public final void removeVetoableChangeListener(VetoableChangeListener listener) {
-        vcs.removeVetoableChangeListener(listener);
-    }
-
-    /**
-     * Returns the list of VetoableChangeListeners. If named vetoable change listeners
-     * were added, then VetoableChangeListenerProxy wrappers will returned
-     * <p>
-     * @return List of VetoableChangeListeners and VetoableChangeListenerProxys
-     *         if named property change listeners were added.
-     */
-    public final VetoableChangeListener[] getVetoableChangeListeners(){
-        return vcs.getVetoableChangeListeners();
-    }
-
-    /**
-     * Add a VetoableChangeListener for a specific property.  The listener
-     * will be invoked only when a call on fireVetoableChange names that
-     * specific property.
-     * The same listener object may be added more than once.  For each
-     * property,  the listener will be invoked the number of times it was added
-     * for that property.
-     * If <code>propertyName</code> or <code>listener</code> is null, no
-     * exception is thrown and no action is taken.
-     *
-     * @param propertyName  The name of the property to listen on.
-     * @param listener  The VetoableChangeListener to be added
-     */
-
-    public final void addVetoableChangeListener(String propertyName,
-                VetoableChangeListener listener) {
-        vcs.addVetoableChangeListener(propertyName, listener);
-    }
-
-    /**
-     * Remove a VetoableChangeListener for a specific property.
-     * If <code>listener</code> was added more than once to the same event
-     * source for the specified property, it will be notified one less time
-     * after being removed.
-     * If <code>propertyName</code> is null, no exception is thrown and no
-     * action is taken.
-     * If <code>listener</code> is null, or was never added for the specified
-     * property, no exception is thrown and no action is taken.
-     *
-     * @param propertyName  The name of the property that was listened on.
-     * @param listener  The VetoableChangeListener to be removed
-     */
-
-    public final void removeVetoableChangeListener(String propertyName,
-                VetoableChangeListener listener) {
-        vcs.removeVetoableChangeListener(propertyName, listener);
-    }
-
-    /**
-     * Returns an array of all the listeners which have been associated
-     * with the named property.
-     *
-     * @param propertyName  The name of the property being listened to
-     * @return all the <code>VetoableChangeListeners</code> associated with
-     *         the named property.  If no such listeners have been added,
-     *         or if <code>propertyName</code> is null, an empty array is
-     *         returned.
-     */
-    public final VetoableChangeListener[] getVetoableChangeListeners(String propertyName) {
-        return vcs.getVetoableChangeListeners(propertyName);
-    }
-
-    /**
-     * Report a vetoable property update to any registered listeners.  If
-     * anyone vetos the change, then fire a new event reverting everyone to
-     * the old value and then rethrow the PropertyVetoException.
-     * <p>
-     * No event is fired if old and new are equal and non-null.
-     *
-     * @param propertyName  The programmatic name of the property
-     *                      that is about to change..
-     * @param oldValue  The old value of the property.
-     * @param newValue  The new value of the property.
-     * @exception PropertyVetoException if the recipient wishes the property
-     *              change to be rolled back.
-     */
-    protected final void fireVetoableChange(String propertyName,
-                                            Object oldValue, Object newValue)
-                                            throws PropertyVetoException {
-         vcs.fireVetoableChange(propertyName, oldValue, newValue);
-    }
-
-    /**
-     * Fire a vetoable property update to any registered listeners.  If
-     * anyone vetos the change, then fire a new event reverting everyone to
-     * the old value and then rethrow the PropertyVetoException.
-     * <p>
-     * No event is fired if old and new are equal and non-null.
-     *
-     * @param evt  The PropertyChangeEvent to be fired.
-     * @exception PropertyVetoException if the recipient wishes the property
-     *              change to be rolled back.
-     */
-    protected final void fireVetoableChange(PropertyChangeEvent evt)
-                    throws PropertyVetoException {
-        vcs.fireVetoableChange(evt);
-    }
-
-    /**
-     * @inheritDoc
-     */
-    public Object clone() throws CloneNotSupportedException {
-        AbstractBean result = (AbstractBean) super.clone();
-        result.pcs = new PropertyChangeSupport(result);
-        result.vcs = new VetoableChangeSupport(result);
-        return result;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/BezierControlPoint.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,265 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import java.awt.BasicStroke;
-import java.awt.Graphics2D;
-import java.awt.Shape;
-import java.awt.geom.Ellipse2D;
-import java.awt.geom.GeneralPath;
-import java.awt.geom.Line2D;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * BezierControlPoint
- *
- * @author Created by Jasper Potts (May 29, 2007)
- */
-public class BezierControlPoint extends ControlPoint {
-    private HandleControlPoint cp1 = new HandleControlPoint();
-    private HandleControlPoint cp2 = new HandleControlPoint();
-    private transient boolean makingChange = false;
-    private transient PropertyChangeListener cpListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-//            if (!makingChange) {
-//                makingChange = true;
-//                if (evt.getSource() == cp1) {
-//                    double angle = Math.tan((cp1.getY() - getY())/(cp1.getX() - getX()));
-//                    double cp2len = Math.sqrt(
-//                            Math.pow(cp2.getX() - getX(),2) +
-//                            Math.pow(cp2.getY() - getY(),2)
-//                    );
-//                    double offsetX = cp2len * Math.sin(angle);
-//                    double offsetY = cp2len * Math.cos(angle);
-//                    cp2.setPosition(getX() - offsetX, getY() - offsetY);
-//                } else {
-//                    double angle = Math.tan((cp2.getY() - getY())/(cp2.getX() - getX()));
-//                    double cp1len = Math.sqrt(
-//                            Math.pow(cp1.getX() - getX(),2) +
-//                            Math.pow(cp1.getY() - getY(),2)
-//                    );
-//                    double offsetX = cp1len * Math.sin(angle);
-//                    double offsetY = cp1len * Math.cos(angle);
-//                    cp1.setPosition(getX() - offsetX, getY() - offsetY);
-//                }
-////                if (evt.getSource() == cp1) {
-////                    double offsetX = cp1.getX() - getX();
-////                    double offsetY = cp1.getY() - getY();
-////                    cp2.setPosition(getX() - offsetX, getY() - offsetY);
-////                } else {
-////                    double offsetX = cp2.getX() - getX();
-////                    double offsetY = cp2.getY() - getY();
-////                    cp1.setPosition(getX() - offsetX, getY() - offsetY);
-////                }
-//                makingChange = false;
-//                firePropertyChange("cp1", null, cp1);
-//                firePropertyChange("cp2", null, cp1);
-//            }
-            firePropertyChange("shape",null,getShape());
-        }
-    };
-
-    public BezierControlPoint() {
-        cp1.addPropertyChangeListener(cpListener);
-        cp2.addPropertyChangeListener(cpListener);
-    }
-
-    public BezierControlPoint(double x, double y) {
-        super(x, y);
-        cp1.addPropertyChangeListener(cpListener);
-        cp2.addPropertyChangeListener(cpListener);
-        cp1.setPosition(x, y);
-        cp2.setPosition(x, y);
-    }
-
-    public boolean isSharpCorner() {
-        return
-                (cp1.getX() == x.getValue()) &&
-                        (cp1.getY() == y.getValue()) &&
-                        (cp2.getX() == x.getValue()) &&
-                        (cp2.getY() == y.getValue());
-    }
-
-    public void flip(int width, int height){
-        makingChange = true;
-        if (width > 0){
-            x.setValue(width - x.getValue());
-            cp1.x.setValue(width - cp1.x.getValue());
-            cp2.x.setValue(width - cp2.x.getValue());
-        }
-        if (height > 0){
-            y.setValue(height - y.getValue());
-            cp1.y.setValue(height - cp1.y.getValue());
-            cp2.y.setValue(height - cp2.y.getValue());
-        }
-        makingChange = false;
-    }
-
-    public void convertToSharpCorner() {
-        cp1.setPosition(x.getValue(), y.getValue());
-        cp2.setPosition(x.getValue(), y.getValue());
-    }
-
-    public List<ControlPoint> getControlPoints() {
-        if (isSharpCorner()) {
-            return Collections.emptyList();
-        } else {
-            List<ControlPoint> points = new ArrayList<ControlPoint>();
-            points.add(cp1);
-            points.add(cp2);
-            return points;
-        }
-    }
-
-    public HandleControlPoint getCp1() {
-        return cp1;
-    }
-
-    public HandleControlPoint getCp2() {
-        return cp2;
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        g2.setStroke(new BasicStroke((float) pixelSize));
-        // paint control line
-        g2.setColor(GraphicsHelper.BEZIER_CONTROL_LINE);
-        g2.draw(new Line2D.Double(cp1.getX(), cp1.getY(), getX(), getY()));
-        g2.draw(new Line2D.Double(getX(), getY(), cp2.getX(), cp2.getY()));
-        // paint this control point
-        Shape s;
-        if (isSharpCorner()) {
-            double size = pixelSize * 4d;
-            GeneralPath path = new GeneralPath();
-            path.moveTo(getX() - size, getY());
-            path.lineTo(getX(), getY() + size);
-            path.lineTo(getX() + size, getY());
-            path.lineTo(getX(), getY() - size);
-            path.closePath();
-            s = path;
-        } else {
-            double size = pixelSize * 3d;
-            s = new Ellipse2D.Double(getX() - size, getY() - size,
-                    size * 2, size * 2);
-        }
-        g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_FILL);
-        g2.fill(s);
-        g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_LINE);
-        g2.draw(s);
-        // paint child control points
-        if (!isSharpCorner()) {
-            cp1.paintControls(g2, pixelSize, true);
-            cp2.paintControls(g2, pixelSize, true);
-        }
-    }
-
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        makingChange = true;
-        super.move(moveX, moveY, snapPixels);
-        cp1.move(moveX, moveY, snapPixels);
-        cp2.move(moveX, moveY, snapPixels);
-        makingChange = false;
-    }
-
-    public double getCp1X() {
-        return cp1.getX();
-    }
-
-    public void setCp1X(double v) {
-        cp1.setX(v);
-    }
-
-    public double getCp1Y() {
-        return cp1.getY();
-    }
-
-    public void setCp1Y(double v) {
-        cp1.setY(v);
-    }
-
-    public double getCp2X() {
-        return cp2.getX();
-    }
-
-    public void setCp2X(double v) {
-        cp2.setX(v);
-    }
-
-    public double getCp2Y() {
-        return cp2.getY();
-    }
-
-    public void setCp2Y(double v) {
-        cp2.setY(v);
-    }
-
-    // =================================================================================================================
-    // Bezier handle control point
-
-    public class HandleControlPoint extends ControlPoint {
-
-        public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-            if (!isSharp()){
-                double size = pixelSize * 3d;
-                Shape s = new Ellipse2D.Double(getX() - size, getY() - size,
-                        size * 2, size * 2);
-                g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_FILL);
-                g2.fill(s);
-                g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_LINE);
-                g2.draw(s);
-                g2.draw(new Rectangle2D.Double(getX() - (pixelSize / 2), getY() - (pixelSize / 2), pixelSize, pixelSize));
-            }
-        }
-
-        public boolean isHit(Point2D p, double pixelSize) {
-            return !isSharp() && super.isHit(p, pixelSize);
-        }
-
-        /**
-         * Is the line controled by this handle in or out of the parent BezierControlPoint sharp.
-         *
-         * @return <code>true</code> If this is the exact same point as the parent BezierControlPoint.
-         */
-        public boolean isSharp(){
-            return x.getValue() == BezierControlPoint.this.x.getValue() &&
-                y.getValue() == BezierControlPoint.this.y.getValue();
-        }
-
-        public void convertToSharp(){
-            setPosition(BezierControlPoint.this.x.getValue(),BezierControlPoint.this.y.getValue());
-        }
-
-        public BezierControlPoint getParentControlPoint(){
-            return BezierControlPoint.this;
-        }
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/BlendingMode.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,100 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-
-/**
- * BlendingMode - Enum of composite blending modes, setup to match photoshop as closely as possible
- *
- * @author Created by Jasper Potts (May 31, 2007)
- */
-public enum BlendingMode {
-    NORMAL,
-    // DISSOLVE, missing
-    // -----------------------------
-    DARKEN,
-    MULTIPLY,
-    COLOR_BURN,
-    LINEAR_BURN, // (SUBTRACT)
-    // -----------------------------
-    LIGHTEN,
-    SCREEN,
-    COLOR_DODGE,
-    LINEAR_DODGE, // (ADD)
-    // -----------------------------
-    OVERLAY,
-    SOFT_LIGHT,
-    HARD_LIGHT,
-    VIVID_LIGHT, // (HEAT) is close
-    LINEAR_LIGHT, // (GLOW) is close
-    //PIN_LIGHT, missing
-    //HARD_MIX, missing
-    // -----------------------------
-    DIFFERENCE,
-    EXCLUSION,
-    // -----------------------------
-    HUE, // nowhere close
-    SATURATION,
-    COLOR,
-    LUMINOSITY, // close but not exact
-    //LIGHTER_COLOR, missing
-    //DARKER_COLOR, missing
-    ;
-
-
-    // =================================================================================================================
-    // Helper methods for creating Blending Mode Combo Box
-
-    public static final Object[] BLENDING_MODES = new Object[]{
-            BlendingMode.NORMAL,
-            // DISSOLVE, missing
-            "-",
-            BlendingMode.DARKEN,
-            BlendingMode.MULTIPLY,
-            BlendingMode.COLOR_BURN,
-            BlendingMode.LINEAR_BURN, // (SUBTRACT)
-            "-",
-            BlendingMode.LIGHTEN,
-            BlendingMode.SCREEN,
-            BlendingMode.COLOR_DODGE,
-            BlendingMode.LINEAR_DODGE, // (ADD)
-            "-",
-            BlendingMode.OVERLAY,
-            BlendingMode.SOFT_LIGHT,
-            BlendingMode.HARD_LIGHT,
-            BlendingMode.VIVID_LIGHT, // (HEAT) is close
-            BlendingMode.LINEAR_LIGHT, // (GLOW) is close
-            //PIN_LIGHT, missing
-            //HARD_MIX, missing
-            "-",
-            BlendingMode.DIFFERENCE,
-            BlendingMode.EXCLUSION,
-            "-",
-            BlendingMode.HUE, // nowhere close
-            BlendingMode.SATURATION,
-            BlendingMode.COLOR,
-            BlendingMode.LUMINOSITY, // close but not exact
-    };
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/Canvas.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,308 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.utils.HasResources;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.UIDefaults;
-import java.awt.AlphaComposite;
-import java.awt.Dimension;
-import java.awt.Graphics2D;
-import java.awt.Insets;
-import java.awt.RenderingHints;
-import java.awt.image.BufferedImage;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * ComponentRegion
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public class Canvas extends AbstractBean implements LayerContainer, HasUIDefaults, HasResources {
-    private Dimension size;
-    /** list of all layers in the canvas, the first layer is painted on top */
-    private List<Layer> layers;
-    private int nextLayerNameIndex = 1;
-    private BufferedImage buffer;
-    private boolean isValid = false;
-    private Insets stretchingInsets = null;
-    private Layer workingLayer = null;
-    private PropertyChangeListener layersPropertyChangeListener;
-    private UIDefaults canvasUIDefaults = null;
-    private transient File resourcesDir;
-    private transient File imagesDir;
-    private transient File templatesDir;
-
-    // =================================================================================================================
-    // Constructor
-
-    /** Private constructor for JIBX */
-    protected Canvas() {
-        layersPropertyChangeListener = new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                isValid = false;
-                // pass on layer change
-                int index = layers.indexOf((Layer) evt.getSource());
-                if (index != -1) {
-                    firePropertyChange("layers[" + index + "]." + evt.getPropertyName(), evt.getOldValue(),
-                            evt.getNewValue());
-                }
-            }
-        };
-    }
-
-    public Canvas(int width, int height) {
-        this();
-        stretchingInsets = new Insets(1, 1, 1, 1);
-        layers = new ArrayList<Layer>();
-        setSize(new Dimension(width, height));
-        addLayer(new Layer());
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX before all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void preSet(IUnmarshallingContext context) {
-        canvasUIDefaults = (UIDefaults) context.getUserContext();
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get the UIDefaults for this canvas. The UIDefaults is used to store default pallet of colors, fonts etc.
-     *
-     * @return Canvas UIDefaults
-     */
-    public UIDefaults getUiDefaults() {
-        return canvasUIDefaults;
-    }
-
-    /**
-     * Set the UIDefaults for this canvas. The UIDefaults is used to store default pallet of colors, fonts etc.
-     *
-     * @param canvasUIDefaults Canvas UIDefaults
-     */
-    public void setUiDefaults(UIDefaults canvasUIDefaults) {
-        this.canvasUIDefaults = canvasUIDefaults;
-    }
-
-    /**
-     * Get the current working layer, is is the layer that new shapes will be drawn into
-     *
-     * @return The current working layer, may be null if there is no working layer
-     */
-    public Layer getWorkingLayer() {
-        return workingLayer;
-    }
-
-    /**
-     * Set the current working layer, is is the layer that new shapes will be drawn into
-     *
-     * @param workingLayer the new working layer, must be a child of this canvas
-     */
-    public void setWorkingLayer(Layer workingLayer) {
-        Layer old = getWorkingLayer();
-        this.workingLayer = workingLayer;
-        firePropertyChange("workingLayer", old, getWorkingLayer());
-    }
-
-    public int getNextLayerNameIndex() {
-        return nextLayerNameIndex++;
-    }
-
-    public Dimension getSize() {
-        return size;
-    }
-
-    public void setSize(Dimension size) {
-        Dimension old = getSize();
-        this.size = size;
-        buffer = new BufferedImage(this.size.width, this.size.height, BufferedImage.TYPE_INT_ARGB);
-        isValid = false;
-        firePropertyChange("size", old, getSize());
-    }
-
-
-    public Insets getStretchingInsets() {
-        return stretchingInsets;
-    }
-
-    public void setStretchingInsets(Insets stretchingInsets) {
-        Insets old = getStretchingInsets();
-        this.stretchingInsets = stretchingInsets;
-        firePropertyChange("stretchingInsets", old, getStretchingInsets());
-    }
-
-    public BufferedImage getRenderedImage() {
-        if (!isValid) {
-            Graphics2D g2 = buffer.createGraphics();
-            // clear
-            g2.setComposite(AlphaComposite.Clear);
-            g2.fillRect(0, 0, buffer.getWidth(), buffer.getHeight());
-            // paint
-            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
-            g2.setComposite(AlphaComposite.SrcOver);
-            for (int i = layers.size() - 1; i >= 0; i--) {
-                layers.get(i).paint(g2, 1);
-            }
-            g2.dispose();
-        }
-        return buffer;
-    }
-
-    /**
-     * @return true if this Canvas has not been edited.
-     *         <p/>
-     *         TODO Currently this is not a bound property, but should be. That is, when the Canvas becomes edited
-     *         (usually due to the Layer having a shape added to it), then a property change event should be fired.
-     */
-    public boolean isBlank() {
-        return layers.size() == 0 || (layers.size() == 1 && layers.get(0).isEmpty());
-    }
-
-    public File getResourcesDir() {
-        return resourcesDir;
-    }
-
-    public void setResourcesDir(File resourcesDir) {
-        File old = getResourcesDir();
-        this.resourcesDir = resourcesDir;
-        firePropertyChange("resourcesDir", old, getResourcesDir());
-    }
-
-    public File getImagesDir() {
-        return imagesDir;
-    }
-
-    public void setImagesDir(File imagesDir) {
-        File old = getImagesDir();
-        this.imagesDir = imagesDir;
-        firePropertyChange("imagesDir", old, getImagesDir());
-    }
-
-    public File getTemplatesDir() {
-        return templatesDir;
-    }
-
-    public void setTemplatesDir(File templatesDir) {
-        File old = getTemplatesDir();
-        this.templatesDir = templatesDir;
-        firePropertyChange("templatesDir", old, getTemplatesDir());
-    }
-
-    // =================================================================================================================
-    // LayerContainer Methods
-
-    public LayerContainer getParent() {
-        // we are root so null
-        return null;
-    }
-
-    public void addLayerToBottom(Layer layer) {
-        layers.add(layer);
-        layer.setParent(this);
-        layer.addPropertyChangeListener(layersPropertyChangeListener);
-        // no single layer changes so fire all changed event
-        firePropertyChange("layers", null, layers);
-    }
-
-    public void addLayer(int i, Layer layer) {
-        layers.add(i, layer);
-        layer.setParent(this);
-        layer.addPropertyChangeListener(layersPropertyChangeListener);
-        // no single layer changes so fire all changed event
-        firePropertyChange("layers", null, layers);
-    }
-
-    public void addLayer(Layer layer) {
-        layers.add(0, layer);
-        layer.setParent(this);
-        layer.addPropertyChangeListener(layersPropertyChangeListener);
-        // no single layer changes so fire all changed event
-        firePropertyChange("layers", null, layers);
-    }
-
-    public Layer getLayer(int index) {
-        return layers.get(index);
-    }
-
-    public int getLayerCount() {
-        return layers.size();
-    }
-
-    public Iterator<Layer> getLayerIterator() {
-        return Collections.unmodifiableList(layers).iterator();
-    }
-
-    public Collection<Layer> getLayers() {
-        return Collections.unmodifiableList(layers);
-    }
-
-    public int indexOfLayer(Layer layer) {
-        return layers.indexOf(layer);
-    }
-
-    public void removeLayer(Layer layer) {
-        int index = layers.indexOf(layer);
-        if (index != -1) {
-            layers.remove(layer);
-            layer.removePropertyChangeListener(layersPropertyChangeListener);
-            fireIndexedPropertyChange("layers", index, layer, null);
-        }
-    }
-
-    public Dimension getRootSize() {
-        return getSize();
-    }
-
-    // =================================================================================================================
-    // JIBX Helper Methods
-
-    /** Called by JIBX after "layers" has been filled so we can set parents and listeners */
-    private void setupLayers() {
-        for (Layer layer : layers) {
-            layer.setParent(this);
-            layer.addPropertyChangeListener(layersPropertyChangeListener);
-        }
-        // no single layer changes so fire all changed event
-        firePropertyChange("layers", null, layers);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/ControlPoint.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,157 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import java.awt.BasicStroke;
-import java.awt.Color;
-import java.awt.Graphics2D;
-import java.awt.Shape;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * ControlPoint
- *
- * @author Created by Jasper Potts (May 24, 2007)
- */
-public class ControlPoint extends SimpleShape {
-    protected Color fillColor;
-    protected Color lineColor;
-    protected DoubleBean x, y;
-
-    public ControlPoint() {
-        this(new DoubleBean(), new DoubleBean());
-    }
-
-    public ControlPoint(Color fillColor, Color lineColor) {
-        this(new DoubleBean(), new DoubleBean(), fillColor, lineColor);
-    }
-
-    public ControlPoint(double x, double y) {
-        this(new DoubleBean(x), new DoubleBean(y));
-    }
-
-    public ControlPoint(DoubleBean x, DoubleBean y) {
-        this(x, y, GraphicsHelper.CONTROL_POINT_FILL, GraphicsHelper.CONTROL_POINT_LINE);
-    }
-
-    public ControlPoint(DoubleBean x, DoubleBean y, Color fillColor, Color lineColor) {
-        this.x = x;
-        this.y = y;
-        this.fillColor = fillColor;
-        this.lineColor = lineColor;
-        x.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("position",
-                        new Point2D.Double((Double) evt.getOldValue(), getY()),
-                        getPosition());
-            }
-        });
-        y.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("position",
-                        new Point2D.Double(getX(), (Double) evt.getOldValue()),
-                        getPosition());
-            }
-        });
-    }
-
-    public double getX() {
-        return x.getValue();
-    }
-
-    public double getY() {
-        return y.getValue();
-    }
-
-    public void setX(double x) {
-        this.x.setValue(x);
-    }
-
-    public void setY(double y) {
-        this.y.setValue(y);
-    }
-
-    public void setPosition(Point2D position) {
-        x.setValue(position.getX());
-        y.setValue(position.getY());
-    }
-
-    public void setPosition(double x, double y) {
-        setPosition(new Point2D.Double(x, y));
-    }
-
-    public Point2D getPosition() {
-        return new Point2D.Double(getX(), getY());
-    }
-
-    public Rectangle2D getBounds(double pixelSize) {
-        double size = pixelSize * 4d;
-        return new Rectangle2D.Double(getX() - size, getY() - size,
-                size * 2, size * 2);
-    }
-
-    public boolean isHit(Point2D p, double pixelSize) {
-        return getBounds(pixelSize).contains(p);
-    }
-
-
-    public Shape getShape() {
-        return getBounds(0);
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        g2.setStroke(new BasicStroke((float) pixelSize));
-        Shape s = getBounds(pixelSize);
-        g2.setColor(fillColor);
-        g2.fill(s);
-        g2.setColor(lineColor);
-        g2.draw(s);
-    }
-
-    public List<ControlPoint> getControlPoints() {
-        return Collections.emptyList();
-    }
-
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        if (snapPixels) {
-            setPosition(
-                    Math.round(x.getValue() + moveX),
-                    Math.round(y.getValue() + moveY));
-        } else {
-            setPosition(x.getValue() + moveX, y.getValue() + moveY);
-        }
-    }
-
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/Designer.jibx.xml	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,173 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
- Copyright 1998-2004 Sun Microsystems, Inc.  All Rights Reserved.
- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
- This code is free software; you can redistribute it and/or modify it
- under the terms of the GNU General Public License version 2 only, as
- published by the Free Software Foundation.  Sun designates this
- particular file as subject to the "Classpath" exception as provided
- by Sun in the LICENSE file that accompanied this code.
-
- This code is distributed in the hope that it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- version 2 for more details (a copy is included in the LICENSE file that
- accompanied this code).
-
- You should have received a copy of the GNU General Public License version
- 2 along with this work; if not, write to the Free Software Foundation,
- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
- Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- CA 95054 USA or visit www.sun.com if you need additional information or
- have any questions.
--->
-
-<!DOCTYPE binding SYSTEM "http://jibx.sourceforge.net">
-<binding>
-    <!-- == PAINTS =========================================================================================== -->
-    <mapping class="java.awt.Color"
-             marshaller="org.jdesktop.swingx.designer.jibxhelpers.ColorMapper"
-             unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.ColorMapper"/>
-    <mapping name="matte" class="org.jdesktop.swingx.designer.paint.Matte" post-set="postSet">
-        <value name="red" field="red" style="attribute"/>
-        <value name="green" field="green" style="attribute"/>
-        <value name="blue" field="blue" style="attribute"/>
-        <value name="alpha" field="alpha" style="attribute"/>
-        <value name="uiDefaultParentName" field="uiDefaultParentName" style="attribute" usage="optional"/>
-        <value name="componentPropertyName" field="componentPropertyName" style="attribute" usage="optional"/>
-        <value name="hueOffset" field="hueOffset" style="attribute"/>
-        <value name="saturationOffset" field="saturationOffset" style="attribute"/>
-        <value name="brightnessOffset" field="brightnessOffset" style="attribute"/>
-        <value name="alphaOffset" field="alphaOffset" style="attribute"/>
-        <value name="uiResource" field="uiResource" style="attribute" usage="optional" default="true"/>
-    </mapping>
-    <mapping class="org.jdesktop.swingx.designer.paint.AbstractGradient" abstract="true">
-        <value name="cycleMethod" field="cycleMethod" style="attribute"/>
-        <collection field="stops" set-method="setStops" pre-set="clear" create-type="java.util.ArrayList">
-            <structure name="stop" type="org.jdesktop.swingx.designer.paint.GradientStop">
-                <value name="position" field="position" style="attribute"/>
-                <value name="midpoint" field="midpoint" style="attribute"/>
-                <structure field="color" set-method="setColor"/>
-            </structure>
-        </collection>
-    </mapping>
-    <mapping name="gradient" class="org.jdesktop.swingx.designer.paint.Gradient"
-             extends="org.jdesktop.swingx.designer.paint.AbstractGradient">
-        <structure map-as="org.jdesktop.swingx.designer.paint.AbstractGradient"/>
-    </mapping>
-    <mapping name="radialGradient" class="org.jdesktop.swingx.designer.paint.RadialGradient"
-             extends="org.jdesktop.swingx.designer.paint.AbstractGradient">
-        <structure map-as="org.jdesktop.swingx.designer.paint.AbstractGradient"/>
-    </mapping>
-    <!-- == SHAPES =========================================================================================== -->
-    <mapping class="org.jdesktop.swingx.designer.SimpleShape" abstract="true">
-        <!--protected AffineTransform transform = new AffineTransform();-->
-    </mapping>
-    <mapping class="org.jdesktop.swingx.designer.PaintedShape" abstract="true"
-             extends="org.jdesktop.swingx.designer.SimpleShape">
-        <structure map-as="org.jdesktop.swingx.designer.SimpleShape"/>
-        <structure field="paint"/>
-        <structure name="paintPoints">
-            <value name="x1" get-method="getPaintX1" set-method="setPaintX1" style="attribute"/>
-            <value name="y1" get-method="getPaintY1" set-method="setPaintY1" style="attribute"/>
-            <value name="x2" get-method="getPaintX2" set-method="setPaintX2" style="attribute"/>
-            <value name="y2" get-method="getPaintY2" set-method="setPaintY2" style="attribute"/>
-        </structure>
-    </mapping>
-    <mapping name="rectangle" class="org.jdesktop.swingx.designer.RectangleShape"
-             extends="org.jdesktop.swingx.designer.PaintedShape">
-        <structure map-as="org.jdesktop.swingx.designer.PaintedShape"/>
-        <value name="x1" get-method="getX1" set-method="setX1" style="attribute"/>
-        <value name="x2" get-method="getX2" set-method="setX2" style="attribute"/>
-        <value name="y1" get-method="getY1" set-method="setY1" style="attribute"/>
-        <value name="y2" get-method="getY2" set-method="setY2" style="attribute"/>
-        <value name="rounding" get-method="getRounding" set-method="setRounding" style="attribute"/>
-    </mapping>
-    <mapping name="ellipse" class="org.jdesktop.swingx.designer.EllipseShape"
-             extends="org.jdesktop.swingx.designer.PaintedShape">
-        <structure map-as="org.jdesktop.swingx.designer.PaintedShape"/>
-        <value name="x1" get-method="getX1" set-method="setX1" style="attribute"/>
-        <value name="x2" get-method="getX2" set-method="setX2" style="attribute"/>
-        <value name="y1" get-method="getY1" set-method="setY1" style="attribute"/>
-        <value name="y2" get-method="getY2" set-method="setY2" style="attribute"/>
-    </mapping>
-    <mapping name="path" class="org.jdesktop.swingx.designer.PathShape"
-             extends="org.jdesktop.swingx.designer.PaintedShape">
-        <structure map-as="org.jdesktop.swingx.designer.PaintedShape"/>
-        <collection name="points" get-method="getBezierControlPoints"
-                    set-method="setControlPoints" create-type="java.util.ArrayList">
-            <structure name="point" type="org.jdesktop.swingx.designer.BezierControlPoint">
-                <value name="x" get-method="getX" set-method="setX" style="attribute"/>
-                <value name="y" get-method="getY" set-method="setY" style="attribute"/>
-                <value name="cp1x" get-method="getCp1X" set-method="setCp1X" style="attribute"/>
-                <value name="cp1y" get-method="getCp1Y" set-method="setCp1Y" style="attribute"/>
-                <value name="cp2x" get-method="getCp2X" set-method="setCp2X" style="attribute"/>
-                <value name="cp2y" get-method="getCp2Y" set-method="setCp2Y" style="attribute"/>
-            </structure>
-        </collection>
-    </mapping>
-    <!-- == EFFECTS =========================================================================================== -->
-    <mapping class="org.jdesktop.swingx.designer.effects.ShadowEffect" abstract="true">
-        <structure field="color"/>
-        <value name="blendingMode" field="blendingMode" style="attribute"/>
-        <value name="opacity" field="opacity" style="attribute"/>
-        <value name="angle" field="angle" style="attribute"/>
-        <value name="distance" field="distance" style="attribute"/>
-        <value name="spread" field="spread" style="attribute"/>
-        <value name="size" field="size" style="attribute"/>
-    </mapping>
-    <mapping name="dropShadow" class="org.jdesktop.swingx.designer.effects.DropShadowEffect"
-             extends="org.jdesktop.swingx.designer.effects.ShadowEffect">
-        <structure map-as="org.jdesktop.swingx.designer.effects.ShadowEffect"/>
-    </mapping>
-    <mapping name="innerShadow" class="org.jdesktop.swingx.designer.effects.InnerShadowEffect"
-             extends="org.jdesktop.swingx.designer.effects.ShadowEffect">
-        <structure map-as="org.jdesktop.swingx.designer.effects.ShadowEffect"/>
-    </mapping>
-    <mapping name="innerGlow" class="org.jdesktop.swingx.designer.effects.InnerGlowEffect"
-             extends="org.jdesktop.swingx.designer.effects.ShadowEffect">
-        <structure map-as="org.jdesktop.swingx.designer.effects.ShadowEffect"/>
-    </mapping>
-    <mapping name="outerGlow" class="org.jdesktop.swingx.designer.effects.OuterGlowEffect"
-             extends="org.jdesktop.swingx.designer.effects.ShadowEffect">
-        <structure map-as="org.jdesktop.swingx.designer.effects.ShadowEffect"/>
-    </mapping>
-    <!-- == TEMPLATE LAYER ================================================================================== -->
-    <mapping name="templateLayer" class="org.jdesktop.swingx.designer.TemplateLayer"
-             extends="org.jdesktop.swingx.designer.Layer" post-set="postInit">
-        <structure map-as="org.jdesktop.swingx.designer.Layer"/>
-        <value name="fileName" field="fileName" style="attribute"/>
-    </mapping>
-    <!-- == LAYER =========================================================================================== -->
-    <mapping name="layer" class="org.jdesktop.swingx.designer.Layer"
-             extends="org.jdesktop.swingx.designer.SimpleShape" post-set="postInit">
-        <structure map-as="org.jdesktop.swingx.designer.SimpleShape"/>
-        <value name="name" field="name" style="attribute"/>
-        <value name="type" field="type" style="attribute" default="standard"/>
-        <value name="opacity" field="opacity"/>
-        <value name="fillOpacity" field="fillOpacity"/>
-        <value name="blendingMode" field="blendingMode"/>
-        <value name="locked" field="locked"/>
-        <value name="visible" field="visible"/>
-        <structure name="shapes">
-            <collection field="shapes" create-type="java.util.ArrayList"/>
-        </structure>
-        <structure name="effects">
-            <collection field="effects" create-type="java.util.ArrayList"/>
-        </structure>
-    </mapping>
-    <!-- == CANVAS =========================================================================================== -->
-    <mapping name="canvas" class="org.jdesktop.swingx.designer.Canvas" pre-set="preSet" post-set="setupLayers">
-        <structure name="size" get-method="getSize" set-method="setSize"
-                   marshaller="org.jdesktop.swingx.designer.jibxhelpers.DimensionMapper"
-                   unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.DimensionMapper"/>
-        <value name="nextLayerNameIndex" field="nextLayerNameIndex"/>
-        <structure name="stretchingInsets" field="stretchingInsets"
-                   marshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"
-                   unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"/>
-        <collection field="layers" create-type="java.util.ArrayList"/>
-    </mapping>
-</binding>
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/DoubleBean.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.beans.AbstractBean;
-
-/**
- * DoubleBean - Simple bean for a observable double value
- *
- * @author Created by Jasper Potts (May 25, 2007)
- */
-public class DoubleBean extends AbstractBean {
-    private double value = 0;
-
-    public DoubleBean() {}
-
-    public DoubleBean(double value) {
-        this.value = value;
-    }
-
-    public double getValue() {
-        return value;
-    }
-
-    public void setValue(double value) {
-        double old = this.value;
-        this.value = value;
-        firePropertyChange("value", old, this.value);
-    }
-
-
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        DoubleBean that = (DoubleBean) o;
-
-        if (Double.compare(that.value, value) != 0) return false;
-
-        return true;
-    }
-
-    public int hashCode() {
-        long temp = value != +0.0d ? Double.doubleToLongBits(value) : 0L;
-        return (int) (temp ^ (temp >>> 32));
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/EllipseShape.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,189 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import javax.swing.*;
-import java.awt.*;
-import java.awt.geom.Ellipse2D;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * EllipseShape
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public class EllipseShape extends PaintedShape {
-
-    private DoubleBean x1 = new DoubleBean();
-    private DoubleBean x2 = new DoubleBean();
-    private DoubleBean y1 = new DoubleBean();
-    private DoubleBean y2 = new DoubleBean();
-    private ControlPoint tl = new ControlPoint(x1, y1);
-    private ControlPoint tr = new ControlPoint(x2, y1);
-    private ControlPoint bl = new ControlPoint(x1, y2);
-    private ControlPoint br = new ControlPoint(x2, y2);
-
-    // =================================================================================================================
-    // Constructors
-
-    /** private noargs constructor for JIBX */
-    private EllipseShape() {
-        this(null);
-    }
-
-    public EllipseShape(UIDefaults canvasUiDefaults) {
-        super(canvasUiDefaults);
-        PropertyChangeListener listener = new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("bounds", null, getBounds(0));
-            }
-        };
-        x1.addPropertyChangeListener(listener);
-        y1.addPropertyChangeListener(listener);
-        x2.addPropertyChangeListener(listener);
-        y2.addPropertyChangeListener(listener);
-    }
-
-    public EllipseShape(double x, double y, double w, double h) {
-        this();
-        x1.setValue(x);
-        y1.setValue(y);
-        x2.setValue(x + w);
-        y2.setValue(y + h);
-    }
-
-    public Rectangle2D getBounds(double pixelSize) {
-        double left = Math.min(x1.getValue(), x2.getValue());
-        double right = Math.max(x1.getValue(), x2.getValue());
-        double top = Math.min(y1.getValue(), y2.getValue());
-        double bottom = Math.max(y1.getValue(), y2.getValue());
-        return new Rectangle2D.Double(left, top, right - left, bottom - top);
-    }
-
-    public Ellipse2D getShape() {
-        double left = Math.min(x1.getValue(), x2.getValue());
-        double right = Math.max(x1.getValue(), x2.getValue());
-        double top = Math.min(y1.getValue(), y2.getValue());
-        double bottom = Math.max(y1.getValue(), y2.getValue());
-        return new Ellipse2D.Double(left, top, right - left, bottom - top);
-    }
-
-    public boolean isHit(Point2D p, double pixelSize) {
-        return getBounds(pixelSize).contains(p);
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-        g2.setPaint(getPaint());
-        g2.fill(getShape());
-    }
-
-    public void setFrame(double x1, double y1, double x2, double y2) {
-        this.x1.setValue(x1);
-        this.y1.setValue(y1);
-        this.x2.setValue(x2);
-        this.y2.setValue(y2);
-    }
-
-    @Override
-    public String toString() {
-        Rectangle2D bounds = getBounds(0);
-        return "ELLIPSE { x=" +  bounds.getX() + ", y=" + bounds.getY() + ", w=" + bounds.getWidth() + ", h=" + bounds.getHeight() + " }";
-    }
-
-    public List<ControlPoint> getControlPoints() {
-        List<ControlPoint> points = new ArrayList<ControlPoint>();
-        points.addAll(super.getControlPoints());
-        points.add(tl);
-        points.add(tr);
-        points.add(bl);
-        points.add(br);
-        return points;
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        if (paintControlLines) {
-            g2.setStroke(new BasicStroke((float) pixelSize));
-            g2.setColor(GraphicsHelper.CONTROL_LINE);
-            g2.draw(getShape());
-        }
-        tl.paintControls(g2, pixelSize, true);
-        tr.paintControls(g2, pixelSize, true);
-        bl.paintControls(g2, pixelSize, true);
-        br.paintControls(g2, pixelSize, true);
-//        super.paintControls(g2, pixelSize, paintControlLines);
-    }
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        if (snapPixels) {
-            x1.setValue(Math.round(x1.getValue() + moveX));
-            x2.setValue(Math.round(x2.getValue() + moveX));
-            y1.setValue(Math.round(y1.getValue() + moveY));
-            y2.setValue(Math.round(y2.getValue() + moveY));
-        } else {
-            x1.setValue(x1.getValue() + moveX);
-            x2.setValue(x2.getValue() + moveX);
-            y1.setValue(y1.getValue() + moveY);
-            y2.setValue(y2.getValue() + moveY);
-        }
-    }
-
-    public double getX1() {
-        return x1.getValue();
-    }
-
-    public void setX1(double x1) {
-        this.x1.setValue(x1);
-    }
-
-    public double getX2() {
-        return x2.getValue();
-    }
-
-    public void setX2(double x2) {
-        this.x2.setValue(x2);
-    }
-
-    public double getY1() {
-        return y1.getValue();
-    }
-
-    public void setY1(double y1) {
-        this.y1.setValue(y1);
-    }
-
-    public double getY2() {
-        return y2.getValue();
-    }
-
-    public void setY2(double y2) {
-        this.y2.setValue(y2);
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/GraphicsHelper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import java.awt.Color;
-
-/**
- * GraphicsHelper
- *
- * @author Created by Jasper Potts (May 29, 2007)
- */
-public class GraphicsHelper {
-    public static final Color FILL_LINE = Color.BLUE;
-    public static final Color FILL_CP_LINE = Color.BLUE;
-    public static final Color FILL_CP_FILL = Color.WHITE;
-    public static final Color CONTROL_LINE = Color.RED;
-    public static final Color CONTROL_POINT_LINE = Color.RED;
-    public static final Color CONTROL_POINT_FILL = Color.WHITE;
-    public static final Color BEZIER_CONTROL_POINT_LINE = CONTROL_POINT_LINE;
-    public static final Color BEZIER_CONTROL_POINT_FILL = CONTROL_POINT_FILL;
-    public static final Color BEZIER_CONTROL_LINE = Color.DARK_GRAY;
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/Layer.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,443 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.swingx.designer.effects.Effect;
-
-import java.awt.Dimension;
-import java.awt.Graphics2D;
-import java.awt.Shape;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.awt.image.BufferedImage;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Layer
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public class Layer extends SimpleShape implements Iterable<SimpleShape>, LayerContainer {
-    public static enum LayerType {
-        standard, template
-    }
-
-    private String name;
-    protected LayerType type = LayerType.standard;
-    /** List of shapes in this layer, first shape is painted on top */
-    private List<SimpleShape> shapes = new ArrayList<SimpleShape>();
-    private List<Effect> effects = new ArrayList<Effect>();
-    private double opacity = 1;
-    private double fillOpacity = 1;
-    private BlendingMode blendingMode = BlendingMode.NORMAL;
-    private boolean locked = false;
-    private boolean visible = true;
-    private PropertyChangeListener shapeChangeListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            int index = shapes.indexOf((SimpleShape) evt.getSource());
-            firePropertyChange("shapes[" + index + "]." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-    private PropertyChangeListener effectChangeListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            int index = effects.indexOf((Effect) evt.getSource());
-            System.out.println(
-                    "Layer.propertyChange EFFECT PROPERTY CHANGED " + evt.getSource() + " -- " + evt.getPropertyName());
-            firePropertyChange("effects[" + index + "]." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-    private BufferedImage buffer = null;
-    // =================================================================================================================
-    // Constructors
-
-    public Layer() {
-    }
-
-    public Layer(String name) {
-        this();
-        this.name = name;
-    }
-
-    /** Called by JIBX after populating this layer so we can add listeners to children */
-    protected void postInit() {
-        for (SimpleShape shape : shapes) {
-            shape.addPropertyChangeListener(shapeChangeListener);
-            shape.setParent(this);
-        }
-        for (Effect effect : effects) {
-            effect.addPropertyChangeListener(effectChangeListener);
-        }
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    public LayerType getType() {
-        return type;
-    }
-
-    public boolean isLocked() {
-        return locked;
-    }
-
-    public void setLocked(boolean locked) {
-        boolean old = isLocked();
-        this.locked = locked;
-        firePropertyChange("locked", old, isLocked());
-    }
-
-    public boolean isVisible() {
-        return visible;
-    }
-
-    public void setVisible(boolean visible) {
-        boolean old = isVisible();
-        this.visible = visible;
-        firePropertyChange("visible", old, isVisible());
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        String old = getName();
-        this.name = name;
-        firePropertyChange("name", old, getName());
-    }
-
-    public void setParent(LayerContainer parent) {
-        super.setParent(parent);
-        // generate a name if null
-        if (name == null) {
-            Canvas c = null;
-            LayerContainer p = parent;
-            while (true) {
-                if (p instanceof Canvas) {
-                    c = (Canvas) p;
-                    break;
-                } else if (p == null) {
-                    break;
-                }
-                p = p.getParent();
-            }
-            if (c != null) {
-                setName("Layer " + c.getNextLayerNameIndex());
-            }
-        }
-    }
-
-    /**
-     * Add shape to top of layer so it paints above all other shapes
-     *
-     * @param shape The shape to add
-     */
-    public void add(SimpleShape shape) {
-        shapes.add(0, shape);
-        shape.setParent(this);
-        shape.addPropertyChangeListener(shapeChangeListener);
-        fireIndexedPropertyChange("shapes", 0, null, shape);
-    }
-
-    public void remove(SimpleShape shape) {
-        int index = shapes.indexOf(shape);
-        if (index != -1) {
-            shapes.remove(shape);
-            shape.setParent(null);
-            fireIndexedPropertyChange("shapes", index, shape, null);
-        }
-    }
-
-    /**
-     * Returns an unmodifianle iterator over a set of elements of type SimpleShape.
-     *
-     * @return an Iterator.
-     */
-    public Iterator<SimpleShape> iterator() {
-        return Collections.unmodifiableList(shapes).iterator();
-    }
-
-
-    public List<Effect> getEffects() {
-        return Collections.unmodifiableList(effects);
-    }
-
-    public void addEffect(Effect effect) {
-        int index = effects.size();
-        effects.add(effect);
-        effect.addPropertyChangeListener(effectChangeListener);
-        fireIndexedPropertyChange("effects", index, null, effects);
-    }
-
-    public void removeEffect(Effect effect) {
-        int index = effects.indexOf(effect);
-        if (index != -1) {
-            effects.remove(effect);
-            effect.removePropertyChangeListener(effectChangeListener);
-            fireIndexedPropertyChange("effects", index, effect, null);
-        }
-    }
-
-    public double getOpacity() {
-        return opacity;
-    }
-
-    public void setOpacity(double opacity) {
-        if (opacity < 0 || opacity > 1) return;
-        double old = getOpacity();
-        this.opacity = opacity;
-        firePropertyChange("opacity", old, getOpacity());
-    }
-
-    public double getFillOpacity() {
-        return fillOpacity;
-    }
-
-    public void setFillOpacity(double fillOpacity) {
-        if (fillOpacity < 0 || fillOpacity > 1) return;
-        double old = getFillOpacity();
-        this.fillOpacity = fillOpacity;
-        firePropertyChange("fillOpacity", old, getFillOpacity());
-    }
-
-    public BlendingMode getBlendingMode() {
-        return blendingMode;
-    }
-
-    public void setBlendingMode(BlendingMode blendingMode) {
-        BlendingMode old = getBlendingMode();
-        this.blendingMode = blendingMode;
-        firePropertyChange("blendingMode", old, getBlendingMode());
-    }
-
-    // =================================================================================================================
-    // Layer Methods
-
-    /**
-     * Get the parent canvas that contains this layer
-     *
-     * @return Parant canvas, or null if the layer is not in a canvas
-     */
-    public Canvas getCanvas() {
-        LayerContainer lc = this;
-        while (lc != null) {
-            if (lc instanceof Canvas) return (Canvas) lc;
-            lc = lc.getParent();
-        }
-        return null;
-    }
-
-    public List<SimpleShape> getShapes() {
-        return new ArrayList<SimpleShape>(shapes);
-    }
-
-    public List<SimpleShape> getIntersectingShapes(Point2D p, double pixelSize) {
-        if (isLocked() || !isVisible()) return Collections.emptyList();
-        List<SimpleShape> intersectingShapes = new ArrayList<SimpleShape>();
-        for (SimpleShape shape : shapes) {
-            if (shape instanceof Layer) {
-                intersectingShapes.addAll(((Layer) shape).getIntersectingShapes(p, pixelSize));
-            } else {
-                if (shape.isHit(p, pixelSize)) intersectingShapes.add(shape);
-            }
-        }
-        return intersectingShapes;
-    }
-
-    public List<SimpleShape> getIntersectingShapes(Rectangle2D rect, double pixelSize) {
-        if (isLocked() || !isVisible()) return Collections.emptyList();
-        List<SimpleShape> intersectingShapes = new ArrayList<SimpleShape>();
-        for (SimpleShape shape : shapes) {
-            if (shape instanceof Layer) {
-                intersectingShapes.addAll(((Layer) shape).getIntersectingShapes(rect, pixelSize));
-            } else {
-                if (shape.intersects(rect, pixelSize)) intersectingShapes.add(shape);
-            }
-        }
-        return intersectingShapes;
-
-    }
-
-    public boolean isEmpty() {
-        return shapes.isEmpty();
-    }
-
-    // =================================================================================================================
-    // SimpleShape Methods
-
-    public Rectangle2D getBounds(double pixelSize) {
-        Rectangle2D.Double rect = new Rectangle2D.Double();
-        for (SimpleShape shape : shapes) {
-            rect.add(shape.getBounds(pixelSize));
-        }
-        return rect;
-    }
-
-
-    public Shape getShape() {
-        return getBounds(0);
-    }
-
-    public boolean isHit(Point2D p, double pixelSize) {
-        if (isLocked() || !isVisible()) return false;
-        for (SimpleShape shape : shapes) {
-            if (shape.isHit(p, pixelSize)) return true;
-        }
-        return false;
-    }
-
-    public boolean intersects(Rectangle2D rect, double pixelSize) {
-        if (isLocked() || !isVisible()) return false;
-        for (SimpleShape shape : shapes) {
-            if (shape.intersects(rect, pixelSize)) return true;
-        }
-        return false;
-    }
-
-    public List<ControlPoint> getControlPoints() {
-        return Collections.emptyList();
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-
-    }
-
-    public String toString() {
-        return getName();
-    }
-
-    // =================================================================================================================
-    // LayerContainer Methods
-
-    public void addLayer(int i, Layer layer) {
-        // get existing layer at index i
-        Layer existingLayer = getLayer(i);
-        if (existingLayer == null) {
-            addLayer(layer);
-        } else {
-            int index = indexOfLayer(existingLayer);
-            shapes.add(index, layer);
-            layer.setParent(this);
-            layer.addPropertyChangeListener(shapeChangeListener);
-            fireIndexedPropertyChange("layers", index, null, layer);
-        }
-    }
-
-    public void addLayer(Layer layer) {
-        shapes.add(layer);
-        layer.setParent(this);
-        layer.addPropertyChangeListener(shapeChangeListener);
-        int index = indexOfLayer(layer);
-        fireIndexedPropertyChange("layers", index, null, layer);
-    }
-
-    public Layer getLayer(int index) {
-        int i = -1;
-        for (SimpleShape shape : shapes) {
-            if (shape instanceof Layer) i++;
-            if (i == index) return (Layer) shape;
-        }
-        return null;
-    }
-
-    public int getLayerCount() {
-        int count = 0;
-        for (SimpleShape shape : shapes) {
-            if (shape instanceof Layer) count++;
-        }
-        return count;
-    }
-
-
-    public Collection<Layer> getLayers() {
-        List<Layer> layers = new ArrayList<Layer>();
-        for (SimpleShape shape : shapes) {
-            if (shape instanceof Layer) layers.add((Layer) shape);
-        }
-        return Collections.unmodifiableList(layers);
-    }
-
-    public Iterator<Layer> getLayerIterator() {
-        return new Iterator<Layer>() {
-            private int index = 0;
-
-            public boolean hasNext() {
-                for (int i = index; i < shapes.size(); i++) {
-                    if (shapes.get(i) instanceof Layer) {
-                        return true;
-                    }
-                }
-                return false;
-            }
-
-            public Layer next() {
-                for (; index < shapes.size(); index++) {
-                    if (shapes.get(index) instanceof Layer) {
-                        Layer nextLayer = (Layer) shapes.get(index);
-                        index++; // increment index so we don't find the same one again
-                        return nextLayer;
-                    }
-                }
-                return null;
-            }
-
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        };
-    }
-
-    public int indexOfLayer(Layer layer) {
-        int i = -1;
-        for (SimpleShape s : shapes) {
-            if (s instanceof Layer) i++;
-            if (s == layer) return i;
-        }
-        return -1;
-    }
-
-    public void removeLayer(Layer layer) {
-        int index = indexOfLayer(layer);
-        if (index != -1) {
-            shapes.remove(layer);
-            layer.removePropertyChangeListener(shapeChangeListener);
-            fireIndexedPropertyChange("layers", index, layer, null);
-        }
-    }
-
-
-    public Dimension getRootSize() {
-        return getParent().getRootSize();
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/LayerContainer.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,67 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import java.awt.Dimension;
-import java.beans.PropertyChangeListener;
-import java.util.Collection;
-import java.util.Iterator;
-
-/**
- * LayerContainer
- *
- * @author Created by Jasper Potts (May 31, 2007)
- */
-public interface LayerContainer {
-    public void addPropertyChangeListener(PropertyChangeListener listener);
-
-    public void removePropertyChangeListener(PropertyChangeListener listener);
-
-    public LayerContainer getParent();
-
-    public void addLayer(Layer layer);
-
-    public void addLayer(int i, Layer layer);
-
-    public void removeLayer(Layer layer);
-
-    public int getLayerCount();
-
-    public Layer getLayer(int index);
-
-    public int indexOfLayer(Layer layer);
-
-    public Iterator<Layer> getLayerIterator();
-
-    public Collection<Layer> getLayers();
-
-    /**
-     * Get the size in pixels of the root of the layer tree, this is usualy a canvas
-     *
-     * @return The size of the whole layer tree
-     */
-    public Dimension getRootSize();
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/PaintedShape.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,289 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-import org.jdesktop.swingx.designer.paint.PaintModel;
-
-import javax.swing.UIDefaults;
-import java.awt.BasicStroke;
-import java.awt.Color;
-import java.awt.GradientPaint;
-import java.awt.Graphics2D;
-import java.awt.LinearGradientPaint;
-import java.awt.Paint;
-import java.awt.RadialGradientPaint;
-import java.awt.Shape;
-import java.awt.geom.Ellipse2D;
-import java.awt.geom.Line2D;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * PaintedShape
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public abstract class PaintedShape extends SimpleShape {
-
-    private PaintModel paint;
-    // control points for paint control types
-    private DoubleBean px1 = new DoubleBean(0.25);
-    private DoubleBean px2 = new DoubleBean(0.75);
-    private DoubleBean py1 = new DoubleBean(0);
-    private DoubleBean py2 = new DoubleBean(1);
-    private ControlPoint ptl = new PaintControlPoint(px1, py1);
-    private ControlPoint ptr = new PaintControlPoint(px2, py1);
-    private ControlPoint pbl = new PaintControlPoint(px1, py2);
-    private ControlPoint pbr = new PaintControlPoint(px2, py2);
-    private PropertyChangeListener paintListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            firePropertyChange("paint." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-
-    protected PaintedShape() {
-        px1.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("x1", evt.getOldValue(), evt.getNewValue());
-            }
-        });
-        py1.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("y1", evt.getOldValue(), evt.getNewValue());
-            }
-        });
-        px2.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("x2", evt.getOldValue(), evt.getNewValue());
-            }
-        });
-        py2.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("y2", evt.getOldValue(), evt.getNewValue());
-            }
-        });
-    }
-
-    protected PaintedShape(UIDefaults canvasUiDefaults) {
-        this();
-        setPaintModel(new Matte(Color.ORANGE, canvasUiDefaults));
-    }
-
-    public PaintModel getPaintModel() {
-        return paint;
-    }
-
-    public void setPaintModel(PaintModel paint) {
-        PaintModel old = getPaintModel();
-        if (old != null) old.removePropertyChangeListener(paintListener);
-        this.paint = paint;
-        this.paint.addPropertyChangeListener(paintListener);
-        firePropertyChange("paintModel", old, getPaintModel());
-    }
-
-    public Paint getPaint() {
-        Paint p = getPaintModel().getPaint();
-        if (p instanceof Color) {
-            return p;
-        }
-        //resize p as necessary to fit the bounds of this PaintedShape
-        Rectangle2D bounds = getBounds(0);
-        if (p instanceof LinearGradientPaint) {
-            LinearGradientPaint lgp = (LinearGradientPaint) p;
-            return new LinearGradientPaint(
-                    convertLocalPoint(ptl.getPosition(), bounds),
-                    convertLocalPoint(pbr.getPosition(), bounds),
-                    lgp.getFractions(),
-                    lgp.getColors());
-        } else if (p instanceof RadialGradientPaint) {
-            RadialGradientPaint rgp = (RadialGradientPaint) p;
-            Point2D outer = convertLocalPoint(ptl.getPosition(), bounds);
-            Point2D center = convertLocalPoint(pbr.getPosition(), bounds);
-            double deltaX = Math.abs(center.getX() - outer.getX());
-            double deltaY = Math.abs(center.getY() - outer.getY());
-            float radius = (float) Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));
-            return new RadialGradientPaint(
-                    center,
-                    radius,
-                    rgp.getFractions(),
-                    rgp.getColors());
-        } else {
-            return p;
-        }
-    }
-
-    public List<? extends ControlPoint> getControlPoints() {
-        switch (paint.getPaintControlType()) {
-            case control_line:
-                return Arrays.asList(ptl, pbr);
-            case control_rect:
-                return Arrays.asList(ptl, ptr, pbl, pbr);
-            default:
-                return Collections.emptyList();
-        }
-    }
-
-    public void paintFillControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        switch (paint.getPaintControlType()) {
-            case control_line:
-                Point2D p1 = convertLocalPoint(ptl.getPosition(), PaintedShape.this.getBounds(0));
-                Point2D p2 = convertLocalPoint(pbr.getPosition(), PaintedShape.this.getBounds(0));
-                g2.setStroke(new BasicStroke((float) pixelSize));
-                g2.setColor(GraphicsHelper.FILL_LINE);
-                g2.draw(new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY()));
-                ptl.paintControls(g2, pixelSize, true);
-                pbr.paintControls(g2, pixelSize, true);
-                break;
-            case control_rect:
-                g2.setStroke(new BasicStroke((float) pixelSize));
-                g2.setColor(GraphicsHelper.FILL_LINE);
-                g2.draw(new Rectangle2D.Double(
-                        px1.getValue(),
-                        py1.getValue(),
-                        px2.getValue() - px1.getValue(),
-                        py2.getValue() - py1.getValue()));
-                ptl.paintControls(g2, pixelSize, true);
-                ptr.paintControls(g2, pixelSize, true);
-                pbl.paintControls(g2, pixelSize, true);
-                pbr.paintControls(g2, pixelSize, true);
-                break;
-        }
-    }
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        for (ControlPoint controlPoint : getControlPoints()) {
-            if (!(controlPoint instanceof PaintControlPoint)) controlPoint.move(moveX, moveY, snapPixels);
-        }
-    }
-
-    public double getPaintX1() {
-        return px1.getValue();
-    }
-
-    public void setPaintX1(double x1) {
-        this.px1.setValue(x1);
-    }
-
-    public double getPaintX2() {
-        return px2.getValue();
-    }
-
-    public void setPaintX2(double x2) {
-        this.px2.setValue(x2);
-    }
-
-    public double getPaintY1() {
-        return py1.getValue();
-    }
-
-    public void setPaintY1(double y1) {
-        this.py1.setValue(y1);
-    }
-
-    public double getPaintY2() {
-        return py2.getValue();
-    }
-
-    public void setPaintY2(double y2) {
-        this.py2.setValue(y2);
-    }
-
-    // =================================================================================================================
-    // Private helper methods
-
-    private Point2D convertLocalPoint(Point2D point, Rectangle2D bounds) {
-        point.setLocation(
-                bounds.getX() + (point.getX() * bounds.getWidth()),
-                bounds.getY() + (point.getY() * bounds.getHeight())
-        );
-        return point;
-    }
-
-    private Point2D convertScreenPoint(Point2D point, Rectangle2D bounds) {
-        return new Point2D.Double(
-                (point.getX() - bounds.getX()) / bounds.getWidth(),
-                (point.getY() - bounds.getY()) / bounds.getHeight()
-        );
-    }
-
-    // =================================================================================================================
-    // Gradient ControlPoint
-
-    /**
-     * A Special ControlPoint thats internal values are in coordinates relative to the shapes bounds. With 0,0 being the
-     * top left of the shape and 1.0X == shape width and 1.0Y == shapes height.
-     */
-    public class PaintControlPoint extends ControlPoint {
-        public PaintControlPoint() {
-            super(GraphicsHelper.FILL_CP_FILL, GraphicsHelper.FILL_CP_LINE);
-        }
-
-        public PaintControlPoint(DoubleBean x, DoubleBean y) {
-            super(x, y, GraphicsHelper.FILL_CP_FILL, GraphicsHelper.FILL_CP_LINE);
-        }
-
-        public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-            Point2D p = convertLocalPoint(getPosition(), PaintedShape.this.getBounds(0));
-            g2.setStroke(new BasicStroke((float) pixelSize));
-            double size = pixelSize * 4d;
-            Shape s = new Ellipse2D.Double(p.getX() - size, p.getY() - size,
-                    size * 2, size * 2);
-            g2.setPaint(new GradientPaint(
-                    (float) p.getX(), (float) (p.getY() - size), Color.CYAN,
-                    (float) p.getX(), (float) (p.getY() + size), Color.WHITE
-            ));
-            g2.fill(s);
-            g2.setColor(GraphicsHelper.FILL_CP_LINE);
-            g2.draw(s);
-        }
-
-        public void move(double moveX, double moveY, boolean snapPixels) {
-            Rectangle2D bounds = PaintedShape.this.getBounds(0);
-            moveX = moveX / bounds.getWidth();
-            moveY = moveY / bounds.getHeight();
-            if (snapPixels) {
-                // snap to neareast 0.5
-                double newX = Math.round((x.getValue() + moveX) * 2d) / 2d;
-                double newY = Math.round((y.getValue() + moveY) * 2d) / 2d;
-                setPosition(newX, newY);
-            } else {
-                setPosition(x.getValue() + moveX, y.getValue() + moveY);
-            }
-        }
-
-        public Rectangle2D getBounds(double pixelSize) {
-            Point2D p = convertLocalPoint(getPosition(), PaintedShape.this.getBounds(0));
-            double size = pixelSize * 4d;
-            return new Rectangle2D.Double(p.getX() - size, p.getY() - size,
-                    size * 2, size * 2);
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/PathShape.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,194 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import javax.swing.*;
-import java.awt.*;
-import java.awt.geom.GeneralPath;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * PathShape
- *
- * @author Created by Jasper Potts (May 29, 2007)
- */
-public class PathShape extends PaintedShape {
-
-    private Shape cachedShape = null;
-    private List<BezierControlPoint> controlPoints = new ArrayList<BezierControlPoint>();
-    private PropertyChangeListener cpListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            rebuildShape();
-        }
-    };
-
-    // =================================================================================================================
-    // Constructors
-
-    /** private noargs constructor for JIBX */
-    private PathShape() {
-        this(null);
-    }
-
-    public PathShape(UIDefaults canvasUiDefaults) {
-        super(canvasUiDefaults);
-    }
-
-    public BezierControlPoint addPoint(double x, double y) {
-        BezierControlPoint cp = new BezierControlPoint(x, y);
-        controlPoints.add(cp);
-        cp.addPropertyChangeListener(cpListener);
-        // update shape
-        rebuildShape();
-        // return new control point
-        return cp;
-    }
-
-    public Shape getShape() {
-        if (cachedShape == null) {
-            rebuildShape();
-        }
-        return cachedShape;
-    }
-
-    private void rebuildShape() {
-        GeneralPath path = new GeneralPath();
-        BezierControlPoint first, last;
-        first = last = controlPoints.get(0);
-        path.moveTo((float) first.getX(), (float) first.getY());
-        for (int i = 0; i < controlPoints.size(); i++) {
-            BezierControlPoint controlPoint = controlPoints.get(i);
-            if (last.getCp2().isSharp() && controlPoint.getCp1().isSharp()) {
-                path.lineTo(controlPoint.getX(), controlPoint.getY());
-            } else {
-                path.curveTo(
-                        (float) last.getCp2().getX(), (float) last.getCp2().getY(),
-                        (float) controlPoint.getCp1().getX(), (float) controlPoint.getCp1().getY(),
-                        (float) controlPoint.getX(), (float) controlPoint.getY()
-                );
-            }
-            last = controlPoint;
-        }
-        // close path
-        if (last.getCp2().isSharp() && first.getCp1().isSharp()) {
-            path.lineTo(first.getX(), first.getY());
-        } else {
-            path.curveTo(
-                    (float) last.getCp2().getX(), (float) last.getCp2().getY(),
-                    (float) first.getCp1().getX(), (float) first.getCp1().getY(),
-                    (float) first.getX(), (float) first.getY()
-            );
-        }
-        path.closePath();
-        // fire change
-        cachedShape = path;
-        firePropertyChange("shape", null, cachedShape);
-    }
-
-    @Override
-    public String toString() {
-        String p = "PATH {\n";
-        BezierControlPoint first, last;
-        first = last = controlPoints.get(0);
-        p += "   path.moveTo(" + first.getX() + "," + first.getY() + ");";
-        for (int i = 0; i < controlPoints.size(); i++) {
-            BezierControlPoint controlPoint = controlPoints.get(i);
-            p += "   path.curveTo(" +
-                    (float) last.getCp2().getX() + "," + (float) last.getCp2().getY() + "," +
-                    (float) controlPoint.getCp1().getX() + "," + (float) controlPoint.getCp1().getY() + "," +
-                    (float) controlPoint.getX() + "," + (float) controlPoint.getY() +
-                    ");\n";
-            last = controlPoint;
-        }
-        // close path
-        p += "   path.curveTo(" +
-                (float) last.getCp2().getX() + "," + (float) last.getCp2().getY() + "," +
-                (float) first.getCp1().getX() + "," + (float) first.getCp1().getY() + "," +
-                (float) first.getX() + "," + (float) first.getY() +
-                ");\n";
-        p += "}\n";
-        return p;
-    }
-
-    // =================================================================================================================
-    // Shape Methods
-
-    public Rectangle2D getBounds(double pixelSize) {
-        return getShape().getBounds2D();
-    }
-
-    public List<? extends ControlPoint> getControlPoints() {
-        List<ControlPoint> pts = new ArrayList<ControlPoint>();
-        for (BezierControlPoint controlPoint : controlPoints) {
-            pts.add(controlPoint);
-        }
-        for (ControlPoint controlPoint : super.getControlPoints()) {
-            pts.add(controlPoint);
-        }
-        return pts;
-    }
-
-    public void setControlPoints(List<BezierControlPoint> controlPoints) {
-        List<BezierControlPoint> old = this.controlPoints;
-        for (BezierControlPoint cp : old) {
-            cp.removePropertyChangeListener(cpListener);
-        }
-        this.controlPoints = controlPoints;
-        for (BezierControlPoint cp : this.controlPoints) {
-            cp.addPropertyChangeListener(cpListener);
-        }
-        // update shape
-        rebuildShape();
-    }
-
-    public boolean isHit(Point2D p, double pixelSize) {
-        return getShape().contains(p);
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-        g2.setPaint(getPaint());
-        g2.fill(getShape());
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        if (paintControlLines) {
-            g2.setStroke(new BasicStroke((float) pixelSize));
-            g2.setColor(GraphicsHelper.CONTROL_LINE);
-            g2.draw(getShape());
-        }
-        for (BezierControlPoint controlPoint : controlPoints) {
-            if (!controlPoint.isSharpCorner()) controlPoint.paintControls(g2, pixelSize, true);
-        }
-    }
-
-    public List<BezierControlPoint> getBezierControlPoints() {
-        return controlPoints;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/RectangleShape.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,266 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import javax.swing.*;
-import java.awt.*;
-import java.awt.geom.Ellipse2D;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.awt.geom.RoundRectangle2D;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * RectangleShape
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public class RectangleShape extends PaintedShape {
-
-    private DoubleBean x1 = new DoubleBean();
-    private DoubleBean x2 = new DoubleBean();
-    private DoubleBean y1 = new DoubleBean();
-    private DoubleBean y2 = new DoubleBean();
-    private ControlPoint tl = new ControlPoint(x1, y1);
-    private ControlPoint tr = new ControlPoint(x2, y1);
-    private ControlPoint bl = new ControlPoint(x1, y2);
-    private ControlPoint br = new ControlPoint(x2, y2);
-    private DoubleBean roundingX = new DoubleBean() {
-        public void setValue(double value) {
-            // contrain y = y1 and x is between x1+1 and (x2-x1)/2
-            boolean x1isLess = x1.getValue() < x2.getValue();
-            double min = x1isLess ? x1.getValue() + 1 : x1.getValue() - 1;
-            double max = x1isLess ? x1.getValue() + ((x2.getValue() - x1.getValue()) / 2) :
-                    x2.getValue() + ((x1.getValue() - x2.getValue()) / 2);
-            double newX = value;
-            if (newX < min) newX = min;
-            if (newX > max) newX = max;
-            super.setValue(newX);
-        }
-    };
-    private ControlPoint rounding = new ControlPoint(roundingX, y1) {
-        public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-            double size = pixelSize * 3d;
-            Shape s = new Ellipse2D.Double(getX() - size, getY() - size,
-                    size * 2, size * 2);
-            g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_FILL);
-            g2.fill(s);
-            g2.setColor(GraphicsHelper.BEZIER_CONTROL_POINT_LINE);
-            g2.draw(s);
-        }
-
-        public void setPosition(Point2D position) {
-            // only alow X to change
-            x.setValue(position.getX());
-        }
-
-    };
-
-    // =================================================================================================================
-    // Constructors
-
-    /** private noargs constructor for JIBX */
-    private RectangleShape() {
-        this(null);
-    }
-
-    public RectangleShape(UIDefaults canvasUiDefaults) {
-        super(canvasUiDefaults);
-        x1.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                // keep rounding point in sync
-                roundingX.setValue(roundingX.getValue() +
-                        ((Double) evt.getNewValue() - (Double) evt.getOldValue()));
-                firePropertyChange("bounds", null, getBounds(0));
-            }
-        });
-        x2.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                // keep rounding point in sync
-                double distanceFromX1 = Math.abs(roundingX.getValue() - x1.getValue());
-                roundingX.setValue(
-                        (x1.getValue() < x2.getValue()) ? x1.getValue() + distanceFromX1 :
-                                x1.getValue() - distanceFromX1
-                );
-                firePropertyChange("bounds", null, getBounds(0));
-            }
-        });
-        PropertyChangeListener listener = new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("bounds", null, getBounds(0));
-            }
-        };
-        y1.addPropertyChangeListener(listener);
-        y2.addPropertyChangeListener(listener);
-        rounding.addPropertyChangeListener(listener);
-    }
-
-    public RectangleShape(double x, double y, double w, double h) {
-        this();
-        x1.setValue(x);
-        y1.setValue(y);
-        x2.setValue(x + w);
-        y2.setValue(y + h);
-    }
-
-    public Shape getShape() {
-        double rounding = getRounding();
-        double left = Math.min(x1.getValue(), x2.getValue());
-        double right = Math.max(x1.getValue(), x2.getValue());
-        double top = Math.min(y1.getValue(), y2.getValue());
-        double bottom = Math.max(y1.getValue(), y2.getValue());
-        if (rounding > 0) {
-            return new RoundRectangle2D.Double(
-                    left, top, right - left, bottom - top, rounding, rounding
-            );
-        } else {
-            return new Rectangle2D.Double(left, top, right - left, bottom - top);
-        }
-    }
-
-    public double getRounding() {
-        double rounding = Math.abs(roundingX.getValue() - x1.getValue()) * 2;
-        return rounding > 2 ? rounding : 0;
-    }
-
-    public void setRounding(double rounding) {
-        if (rounding > 0 && rounding < 2) rounding = 0;
-        roundingX.setValue((rounding / 2d) + x1.getValue());
-    }
-
-    public boolean isRounded() {
-        return getRounding() > 0;
-    }
-
-    public double getX1() {
-        return x1.getValue();
-    }
-
-    public void setX1(double x1) {
-        this.x1.setValue(x1);
-    }
-
-    public double getX2() {
-        return x2.getValue();
-    }
-
-    public void setX2(double x2) {
-        this.x2.setValue(x2);
-    }
-
-    public double getY1() {
-        return y1.getValue();
-    }
-
-    public void setY1(double y1) {
-        this.y1.setValue(y1);
-    }
-
-    public double getY2() {
-        return y2.getValue();
-    }
-
-    public void setY2(double y2) {
-        this.y2.setValue(y2);
-    }
-
-    // =================================================================================================================
-    // SimpleShape Methods
-
-    public Rectangle2D getBounds(double pixelSize) {
-        double left = Math.min(x1.getValue(), x2.getValue());
-        double right = Math.max(x1.getValue(), x2.getValue());
-        double top = Math.min(y1.getValue(), y2.getValue());
-        double bottom = Math.max(y1.getValue(), y2.getValue());
-        return new Rectangle2D.Double(left, top, right - left, bottom - top);
-    }
-
-    public boolean isHit(Point2D p, double pixelSize) {
-        return getShape().contains(p);
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-        g2.setPaint(getPaint());
-        g2.fill(getShape());
-    }
-
-    public void setFrame(double x1, double y1, double x2, double y2) {
-        this.x1.setValue(x1);
-        this.y1.setValue(y1);
-        this.x2.setValue(x2);
-        this.y2.setValue(y2);
-    }
-
-    @Override
-    public String toString() {
-        Rectangle2D bounds = getBounds(0);
-        if (isRounded()) {
-            return "ROUND RECT { x=" +  bounds.getX() + ", y=" + bounds.getY() + ", w=" + bounds.getWidth() + ", h=" + bounds.getHeight() + ", rounding=" + getRounding() + " }";
-        } else {
-            return "ROUND RECT { x=" +  bounds.getX() + ", y=" + bounds.getY() + ", w=" + bounds.getWidth() + ", h=" + bounds.getHeight() + " }";
-        }
-    }
-
-    public List<ControlPoint> getControlPoints() {
-        List<ControlPoint> points = new ArrayList<ControlPoint>();
-        points.addAll(super.getControlPoints());
-        points.add(tl);
-        points.add(tr);
-        points.add(bl);
-        points.add(br);
-        points.add(rounding);
-        return points;
-    }
-
-    public void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines) {
-        if (paintControlLines) {
-            g2.setStroke(new BasicStroke((float) pixelSize));
-            g2.setColor(GraphicsHelper.CONTROL_LINE);
-            g2.draw(getShape());
-        }
-        tl.paintControls(g2, pixelSize, true);
-        tr.paintControls(g2, pixelSize, true);
-        bl.paintControls(g2, pixelSize, true);
-        br.paintControls(g2, pixelSize, true);
-        rounding.paintControls(g2, pixelSize, true);
-    }
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        if (snapPixels) {
-            x1.setValue(Math.round(x1.getValue() + moveX));
-            x2.setValue(Math.round(x2.getValue() + moveX));
-            y1.setValue(Math.round(y1.getValue() + moveY));
-            y2.setValue(Math.round(y2.getValue() + moveY));
-        } else {
-            x1.setValue(x1.getValue() + moveX);
-            x2.setValue(x2.getValue() + moveX);
-            y1.setValue(y1.getValue() + moveY);
-            y2.setValue(y2.getValue() + moveY);
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/SimpleShape.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.beans.AbstractBean;
-
-import java.awt.Graphics2D;
-import java.awt.Shape;
-import java.awt.geom.AffineTransform;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.util.List;
-
-/**
- * SimpleShape
- *
- * @author Created by Jasper Potts (May 22, 2007)
- */
-public abstract class SimpleShape extends AbstractBean {
-
-    protected AffineTransform transform = new AffineTransform();
-    protected LayerContainer parent = null;
-
-    public void applyTransform(AffineTransform t) {
-        transform.concatenate(t);
-    }
-
-    public abstract Rectangle2D getBounds(double pixelSize);
-
-    public abstract void paint(Graphics2D g2, double pixelSize);
-
-    public abstract boolean isHit(Point2D p, double pixelSize);
-
-    public boolean intersects(Rectangle2D rect, double pixelSize) {
-        return getBounds(pixelSize).intersects(rect);
-    }
-
-    public abstract List<? extends ControlPoint> getControlPoints();
-
-    public abstract void paintControls(Graphics2D g2, double pixelSize, boolean paintControlLines);
-
-    public void move(double moveX, double moveY, boolean snapPixels) {
-        for (ControlPoint controlPoint : getControlPoints()) {
-            controlPoint.move(moveX, moveY, snapPixels);
-        }
-    }
-
-    public LayerContainer getParent() {
-        return parent;
-    }
-
-    public void setParent(LayerContainer parent) {
-        LayerContainer old = getParent();
-        this.parent = parent;
-        firePropertyChange("parent", old, getParent());
-    }
-
-    public abstract Shape getShape();
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/TemplateLayer.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,142 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer;
-
-import org.jdesktop.swingx.designer.effects.Effect;
-
-import javax.imageio.ImageIO;
-import javax.swing.JOptionPane;
-import javax.swing.SwingUtilities;
-import java.awt.Color;
-import java.awt.FontMetrics;
-import java.awt.Graphics2D;
-import java.awt.GraphicsConfiguration;
-import java.awt.Image;
-import java.awt.geom.Rectangle2D;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.IOException;
-import java.lang.ref.SoftReference;
-
-/**
- * TemplateLayer
- *
- * @author Created by Jasper Potts (Jul 2, 2007)
- */
-public class TemplateLayer extends Layer {
-
-    private String fileName;
-    private transient SoftReference<BufferedImage> imgRef = null;
-
-    public TemplateLayer() {
-        type = LayerType.template;
-    }
-
-    public TemplateLayer(String fileName, BufferedImage templateImage) {
-        super("Template");
-        this.fileName = fileName;
-        type = LayerType.template;
-        if (templateImage != null) {
-            imgRef = new SoftReference<BufferedImage>(templateImage);
-        }
-    }
-
-    // =================================================================================================================
-    // Methods
-
-    public String getName() {
-        return super.getName();
-    }
-
-    /**
-     * template layers are always locked
-     *
-     * @return <code>true</code>
-     */
-    public boolean isLocked() {
-        return true;
-    }
-
-    public void add(SimpleShape shape) {
-        throw new IllegalStateException("Template layers can't contain shapes");
-    }
-
-    public void addEffect(Effect effect) {
-        throw new IllegalStateException("Template layers can't contain effects");
-    }
-
-    public void addLayer(int i, Layer layer) {
-        throw new IllegalStateException("Template layers can't contain sub layers");
-    }
-
-    public void addLayer(Layer layer) {
-        throw new IllegalStateException("Template layers can't contain sub layers");
-    }
-
-    public void paint(Graphics2D g2, double pixelSize) {
-        if (isVisible()) {
-            BufferedImage img = getTemplateImage();
-            if (img != null) g2.drawImage(img, 0, 0, null);
-        }
-    }
-
-
-    public Image getBuffer(GraphicsConfiguration graphicsConfiguration) {
-        return getTemplateImage();
-    }
-
-    public BufferedImage getTemplateImage() {
-        BufferedImage img = null;
-        if (imgRef == null || (img = imgRef.get()) == null) {
-
-            // can not access canvas
-            final File templateImgFile = new File(getCanvas().getTemplatesDir(), fileName);
-            System.out.println("templateImgFile = " + templateImgFile.getAbsolutePath());
-            System.out.println("templateImgFile.exists = " + templateImgFile.exists());
-            try {
-                img = ImageIO.read(templateImgFile);
-                imgRef = new SoftReference<BufferedImage>(img);
-            } catch (IOException e) {
-                e.printStackTrace();
-                // create error image
-                img = new BufferedImage(getCanvas().getSize().width, getCanvas().getSize().height,
-                        BufferedImage.TYPE_INT_RGB);
-                Graphics2D g2 = img.createGraphics();
-                g2.setColor(Color.RED);
-                g2.fillRect(0, 0, img.getWidth(), img.getHeight());
-                g2.setColor(Color.WHITE);
-                g2.setFont(g2.getFont().deriveFont(8f));
-                FontMetrics fontMetrics = g2.getFontMetrics();
-                Rectangle2D stringBounds = fontMetrics.getStringBounds("Missing Image", g2);
-                int offsetX = (int) ((img.getWidth() - stringBounds.getWidth()) / 2d);
-                int offsetY = (int) (((img.getHeight() - stringBounds.getHeight()) / 2d) - stringBounds.getY());
-                g2.drawString("Missing Image", offsetX, offsetY);
-                g2.dispose();
-                imgRef = new SoftReference<BufferedImage>(img);
-            }
-        }
-        return img;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/DropShadowEffect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,137 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-import java.awt.image.BufferedImage;
-import java.awt.image.Raster;
-import java.awt.image.WritableRaster;
-import java.util.Arrays;
-
-/**
- * DropShadowEffect
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public class DropShadowEffect extends ShadowEffect {
-
-    protected DropShadowEffect() {}
-
-    ;
-
-    public DropShadowEffect(UIDefaults uiDefaults) {
-        color = new Matte(Color.BLACK, uiDefaults);
-    }
-
-    // =================================================================================================================
-    // Effect Methods
-
-    /**
-     * Get the display name for this effect
-     *
-     * @return The user displayable name
-     */
-    public String getDisplayName() {
-        return "Drop Shadow";
-    }
-
-    /**
-     * Get the type of this effect, one of UNDER,BLENDED,OVER. UNDER means the result of apply effect should be painted
-     * under the src image. BLENDED means the result of apply sffect contains a modified src image so just it should be
-     * painted. OVER means the result of apply effect should be painted over the src image.
-     *
-     * @return The effect type
-     */
-    public EffectType getEffectType() {
-        return EffectType.UNDER;
-    }
-
-    /**
-     * Apply the effect to the src image generating the result . The result image may or may not contain the source
-     * image depending on what the effect type is.
-     *
-     * @param src The source image for applying the effect to
-     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created
-     * @param w   The width of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @param h   The height of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @return The result of appl
-     */
-    public BufferedImage applyEffect(BufferedImage src, BufferedImage dst, int w, int h) {
-        // calculate offset
-        double trangleAngle = Math.toRadians(angle - 90);
-        int offsetX = (int) (Math.sin(trangleAngle) * distance);
-        int offsetY = (int) (Math.cos(trangleAngle) * distance);
-        // clac expanded size
-        int tmpOffX = offsetX + size;
-        int tmpOffY = offsetY + size;
-        int tmpW = w + offsetX + size + size;
-        int tmpH = h + offsetY + size + size;
-        // create tmp buffers
-        int[] lineBuf = getTmpIntArray(w);
-        byte[] tmpBuf1 = getTmpByteArray1(tmpW * tmpH);
-        Arrays.fill(tmpBuf1, (byte) 0x00);
-        byte[] tmpBuf2 = getTmpByteArray2(tmpW * tmpH);
-        // extract src image alpha channel and inverse and offset
-        Raster srcRaster = src.getRaster();
-        for (int y = 0; y < h; y++) {
-            int dy = (y + tmpOffY);
-            int offset = dy * tmpW;
-            srcRaster.getDataElements(0, y, w, 1, lineBuf);
-            for (int x = 0; x < w; x++) {
-                int dx = x + tmpOffX;
-                tmpBuf1[offset + dx] = (byte) ((lineBuf[x] & 0xFF000000) >>> 24);
-            }
-        }
-        // blur
-        float[] kernel = EffectUtils.createGaussianKernel(size);
-        EffectUtils.blur(tmpBuf1, tmpBuf2, tmpW, tmpH, kernel, size); // horizontal pass
-        EffectUtils.blur(tmpBuf2, tmpBuf1, tmpH, tmpW, kernel, size);// vertical pass
-        //rescale
-        float spread = Math.min(1 / (1 - (0.01f * this.spread)), 255);
-        for (int i = 0; i < tmpBuf1.length; i++) {
-            int val = (int) (((int) tmpBuf1[i] & 0xFF) * spread);
-            tmpBuf1[i] = (val > 255) ? (byte) 0xFF : (byte) val;
-        }
-        // create color image with shadow color and greyscale image as alpha
-        if (dst == null) dst = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
-        WritableRaster shadowRaster = dst.getRaster();
-        int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();
-        for (int y = 0; y < h; y++) {
-            int srcY = y + tmpOffY;
-            int shadowOffset = (srcY - offsetY) * tmpW;
-            for (int x = 0; x < w; x++) {
-                int srcX = x + tmpOffX;
-                lineBuf[x] = tmpBuf1[shadowOffset + (srcX - offsetX)] << 24 | red << 16 | green << 8 | blue;
-            }
-            shadowRaster.setDataElements(0, y, w, 1, lineBuf);
-        }
-        return dst;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/Effect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,153 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.BlendingMode;
-
-import java.awt.image.BufferedImage;
-import java.lang.ref.SoftReference;
-
-/**
- * Effect
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public abstract class Effect extends AbstractBean {
-    protected boolean visible = true;
-
-    public enum EffectType {
-        UNDER, BLENDED, OVER
-    }
-
-    public boolean isVisible() {
-        return visible;
-    }
-
-    public void setVisible(boolean visible) {
-        boolean old = isVisible();
-        this.visible = visible;
-        firePropertyChange("visible", old, isVisible());
-    }
-
-    public String toString() {
-        return getDisplayName();
-    }
-
-    // =================================================================================================================
-    // Abstract Methods
-
-    /**
-     * Get the display name for this effect
-     *
-     * @return The user displayable name
-     */
-    public abstract String getDisplayName();
-
-    /**
-     * Get the type of this effect, one of UNDER,BLENDED,OVER. UNDER means the result of apply effect should be painted
-     * under the src image. BLENDED means the result of apply sffect contains a modified src image so just it should be
-     * painted. OVER means the result of apply effect should be painted over the src image.
-     *
-     * @return The effect type
-     */
-    public abstract EffectType getEffectType();
-
-    /**
-     * Get the blending mode to use to paint the result effected image if the EffectType is UNDER or OVER.
-     *
-     * @return The blending mode for the effect
-     */
-    public abstract BlendingMode getBlendingMode();
-
-    /**
-     * Get the opacity to use to paint the result effected image if the EffectType is UNDER or OVER.
-     *
-     * @return The opactity for the effect, 0.0f -> 1.0f
-     */
-    public abstract float getOpacity();
-
-    /**
-     * Apply the effect to the src image generating the result . The result image may or may not contain the source
-     * image depending on what the effect type is.
-     *
-     * @param src The source image for applying the effect to
-     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created
-     * @param w   The width of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @param h   The height of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @return The result of appl
-     */
-    public abstract BufferedImage applyEffect(BufferedImage src, BufferedImage dst, int w, int h);
-
-    // =================================================================================================================
-    // Static data cache
-
-    private static SoftReference<int[]> tmpIntArray = null;
-    private static SoftReference<byte[]> tmpByteArray1 = null;
-    private static SoftReference<byte[]> tmpByteArray2 = null;
-    private static SoftReference<byte[]> tmpByteArray3 = null;
-
-    protected static int[] getTmpIntArray(int size) {
-        int[] tmp;
-        if (tmpIntArray == null || (tmp = tmpIntArray.get()) == null || tmp.length < size) {
-            // create new array
-            tmp = new int[size];
-            tmpIntArray = new SoftReference<int[]>(tmp);
-        }
-        return tmp;
-    }
-
-    protected static byte[] getTmpByteArray1(int size) {
-        byte[] tmp;
-        if (tmpByteArray1 == null || (tmp = tmpByteArray1.get()) == null || tmp.length < size) {
-            // create new array
-            tmp = new byte[size];
-            tmpByteArray1 = new SoftReference<byte[]>(tmp);
-        }
-        return tmp;
-    }
-
-    protected static byte[] getTmpByteArray2(int size) {
-        byte[] tmp;
-        if (tmpByteArray2 == null || (tmp = tmpByteArray2.get()) == null || tmp.length < size) {
-            // create new array
-            tmp = new byte[size];
-            tmpByteArray2 = new SoftReference<byte[]>(tmp);
-        }
-        return tmp;
-    }
-
-    protected static byte[] getTmpByteArray3(int size) {
-        byte[] tmp;
-        if (tmpByteArray3 == null || (tmp = tmpByteArray3.get()) == null || tmp.length < size) {
-            // create new array
-            tmp = new byte[size];
-            tmpByteArray3 = new SoftReference<byte[]>(tmp);
-        }
-        return tmp;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/EffectUtils.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,99 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-
-/**
- * EffectUtils
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public class EffectUtils {
-
-    /**
-     * <p>Blurs the source pixels into the destination pixels. The force of the blur is specified by the radius which
-     * must be greater than 0.</p> <p>The source and destination pixels arrays are expected to be in the BYTE_GREY
-     * format.</p> <p>After this method is executed, dstPixels contains a transposed and filtered copy of
-     * srcPixels.</p>
-     *
-     * @param srcPixels the source pixels
-     * @param dstPixels the destination pixels
-     * @param width     the width of the source picture
-     * @param height    the height of the source picture
-     * @param kernel    the kernel of the blur effect
-     * @param radius    the radius of the blur effect
-     */
-    public static void blur(byte[] srcPixels, byte[] dstPixels,
-                            int width, int height,
-                            float[] kernel, int radius) {
-        float p;
-        int cp;
-        for (int y = 0; y < height; y++) {
-            int index = y;
-            int offset = y * width;
-            for (int x = 0; x < width; x++) {
-                p = 0.0f;
-                for (int i = -radius; i <= radius; i++) {
-                    int subOffset = x + i;
-                    if (subOffset < 0 || subOffset >= width) {
-                        subOffset = (x + width) % width;
-                    }
-                    int pixel = srcPixels[offset + subOffset] & 0xFF;
-                    float blurFactor = kernel[radius + i];
-                    p += blurFactor * pixel;
-                }
-                cp = (int) (p + 0.5f);
-                dstPixels[index] = (byte) (cp > 255 ? 255 : cp);
-                index += height;
-            }
-        }
-    }
-
-    public static float[] createGaussianKernel(int radius) {
-        if (radius < 1) {
-            throw new IllegalArgumentException("Radius must be >= 1");
-        }
-
-        float[] data = new float[radius * 2 + 1];
-
-        float sigma = radius / 3.0f;
-        float twoSigmaSquare = 2.0f * sigma * sigma;
-        float sigmaRoot = (float) Math.sqrt(twoSigmaSquare * Math.PI);
-        float total = 0.0f;
-
-        for (int i = -radius; i <= radius; i++) {
-            float distance = i * i;
-            int index = i + radius;
-            data[index] = (float) Math.exp(-distance / twoSigmaSquare) / sigmaRoot;
-            total += data[index];
-        }
-
-        for (int i = 0; i < data.length; i++) {
-            data[i] /= total;
-        }
-
-        return data;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/EffectUtilsTemp.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,82 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import java.awt.Composite;
-import java.awt.CompositeContext;
-import java.awt.Graphics2D;
-import java.awt.RenderingHints;
-import java.awt.image.BufferedImage;
-import java.awt.image.ColorModel;
-import java.awt.image.Raster;
-import java.awt.image.WritableRaster;
-
-/**
- * EffectUtilsTemp - effect utils methods that are not being used for now but we might want later
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public class EffectUtilsTemp {
-
-    /**
-     * Extract the alpha channel of a image into new greyscale buffered image
-     *
-     * @param src Must but INT_ARGB buffered image
-     * @return new TYPE_BYTE_GRAY image of just the alpha channel
-     */
-    public static BufferedImage extractAlpha(BufferedImage src) {
-        int w = src.getWidth();
-        int h = src.getHeight();
-        // extract image alpha channel as greyscale image
-        final BufferedImage greyImg = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_GRAY);
-        Graphics2D g2 = greyImg.createGraphics();
-        g2.setComposite(new Composite() {
-            public CompositeContext createContext(ColorModel srcColorModel, ColorModel dstColorModel,
-                                                  RenderingHints hints) {
-                return new CompositeContext() {
-                    public void dispose() {}
-
-                    public void compose(Raster src, Raster dstIn, WritableRaster dstOut) {
-                        int width = Math.min(src.getWidth(), dstIn.getWidth());
-                        int height = Math.min(src.getHeight(), dstIn.getHeight());
-                        int[] srcPixels = new int[width];
-                        byte[] dstPixels = new byte[width];
-                        for (int y = 0; y < height; y++) {
-                            src.getDataElements(0, y, width, 1, srcPixels);
-                            for (int x = 0; x < width; x++) {
-                                dstPixels[x] = (byte) ((srcPixels[x] & 0xFF000000) >>> 24);
-                            }
-                            dstOut.setDataElements(0, y, width, 1, dstPixels);
-                        }
-                    }
-                };
-            }
-        });
-        g2.drawImage(src, 0, 0, null);
-        g2.dispose();
-        return greyImg;
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/InnerGlowEffect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-
-/**
- * InnerGlowEffect
- *
- * @author Created by Jasper Potts (Jun 21, 2007)
- */
-public class InnerGlowEffect extends InnerShadowEffect {
-
-    protected InnerGlowEffect() {
-        distance = 0;
-    }
-
-    public InnerGlowEffect(UIDefaults uiDefaults) {
-        color = new Matte(new Color(255, 255, 211), uiDefaults);
-    }
-
-    /**
-     * Get the display name for this effect
-     *
-     * @return The user displayable name
-     */
-    public String getDisplayName() {
-        return "Inner Glow";
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/InnerShadowEffect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,142 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-import java.awt.image.BufferedImage;
-import java.awt.image.Raster;
-import java.awt.image.WritableRaster;
-import java.util.Arrays;
-
-/**
- * InnerShadowEffect
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public class InnerShadowEffect extends ShadowEffect {
-
-    protected InnerShadowEffect() {}
-
-    ;
-
-    public InnerShadowEffect(UIDefaults uiDefaults) {
-        color = new Matte(Color.BLACK, uiDefaults);
-    }
-
-    // =================================================================================================================
-    // Effect Methods
-
-    /**
-     * Get the display name for this effect
-     *
-     * @return The user displayable name
-     */
-    public String getDisplayName() {
-        return "Inner Shadow";
-    }
-
-    /**
-     * Get the type of this effect, one of UNDER,BLENDED,OVER. UNDER means the result of apply effect should be painted
-     * under the src image. BLENDED means the result of apply sffect contains a modified src image so just it should be
-     * painted. OVER means the result of apply effect should be painted over the src image.
-     *
-     * @return The effect type
-     */
-    public Effect.EffectType getEffectType() {
-        return Effect.EffectType.OVER;
-    }
-
-    /**
-     * Apply the effect to the src image generating the result . The result image may or may not contain the source
-     * image depending on what the effect type is.
-     *
-     * @param src The source image for applying the effect to
-     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created
-     * @param w   The width of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @param h   The height of the src image to apply effect to, this allow the src and dst buffers to be bigger than
-     *            the area the need effect applied to it
-     * @return The result of appl
-     */
-    public BufferedImage applyEffect(BufferedImage src, BufferedImage dst, int w, int h) {
-        // calculate offset
-        double trangleAngle = Math.toRadians(angle - 90);
-        int offsetX = (int) (Math.sin(trangleAngle) * distance);
-        int offsetY = (int) (Math.cos(trangleAngle) * distance);
-        // clac expanded size
-        int tmpOffX = offsetX + size;
-        int tmpOffY = offsetY + size;
-        int tmpW = w + offsetX + size + size;
-        int tmpH = h + offsetY + size + size;
-        // create tmp buffers
-        int[] lineBuf = getTmpIntArray(w);
-        byte[] srcAlphaBuf = getTmpByteArray1(tmpW * tmpH);
-        Arrays.fill(srcAlphaBuf, (byte) 0xFF);
-        byte[] tmpBuf1 = getTmpByteArray2(tmpW * tmpH);
-        byte[] tmpBuf2 = getTmpByteArray3(tmpW * tmpH);
-        // extract src image alpha channel and inverse and offset
-        Raster srcRaster = src.getRaster();
-        for (int y = 0; y < h; y++) {
-            int dy = (y + tmpOffY);
-            int offset = dy * tmpW;
-            srcRaster.getDataElements(0, y, w, 1, lineBuf);
-            for (int x = 0; x < w; x++) {
-                int dx = x + tmpOffX;
-                srcAlphaBuf[offset + dx] = (byte) ((255 - ((lineBuf[x] & 0xFF000000) >>> 24)) & 0xFF);
-            }
-        }
-        // blur
-        float[] kernel = EffectUtils.createGaussianKernel(size * 2);
-        EffectUtils.blur(srcAlphaBuf, tmpBuf2, tmpW, tmpH, kernel, size * 2); // horizontal pass
-        EffectUtils.blur(tmpBuf2, tmpBuf1, tmpH, tmpW, kernel, size * 2);// vertical pass
-        //rescale
-        float spread = Math.min(1 / (1 - (0.01f * this.spread)), 255);
-        for (int i = 0; i < tmpBuf1.length; i++) {
-            int val = (int) (((int) tmpBuf1[i] & 0xFF) * spread);
-            tmpBuf1[i] = (val > 255) ? (byte) 0xFF : (byte) val;
-        }
-        // create color image with shadow color and greyscale image as alpha
-        if (dst == null) dst = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
-        WritableRaster shadowRaster = dst.getRaster();
-        int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();
-        for (int y = 0; y < h; y++) {
-            int srcY = y + tmpOffY;
-            int offset = srcY * tmpW;
-            int shadowOffset = (srcY - offsetY) * tmpW;
-            for (int x = 0; x < w; x++) {
-                int srcX = x + tmpOffX;
-                int origianlAlphaVal = 255 - ((int) srcAlphaBuf[offset + srcX] & 0xFF);
-                int shadowVal = (int) tmpBuf1[shadowOffset + (srcX - offsetX)] & 0xFF;
-                int alphaVal = Math.min(origianlAlphaVal, shadowVal);
-                lineBuf[x] = ((byte) alphaVal & 0xFF) << 24 | red << 16 | green << 8 | blue;
-            }
-            shadowRaster.setDataElements(0, y, w, 1, lineBuf);
-        }
-        return dst;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/OuterGlowEffect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-
-/**
- * OuterGlowEffect
- *
- * @author Created by Jasper Potts (Jun 21, 2007)
- */
-public class OuterGlowEffect extends DropShadowEffect {
-
-    protected OuterGlowEffect() {
-        distance = 0;
-    }
-
-    public OuterGlowEffect(UIDefaults uiDefaults) {
-        color = new Matte(new Color(255, 255, 211), uiDefaults);
-    }
-
-    /**
-     * Get the display name for this effect
-     *
-     * @return The user displayable name
-     */
-    public String getDisplayName() {
-        return "Outer Glow";
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/effects/ShadowEffect.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,132 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.effects;
-
-import org.jdesktop.swingx.designer.BlendingMode;
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-
-/**
- * ShadowEffect - base class with all the standard properties for shadow effects
- *
- * @author Created by Jasper Potts (Jun 18, 2007)
- */
-public abstract class ShadowEffect extends Effect {
-    protected Matte color;
-    protected BlendingMode blendingMode = BlendingMode.NORMAL;
-    /** Opacity a float 0-1 for percentage */
-    protected float opacity = 0.75f;
-    /** Angle in degrees between 0-360 */
-    protected int angle = 135;
-    /** Distance in pixels */
-    protected int distance = 5;
-    /** The shadow spread between 0-100 % */
-    protected int spread = 0;
-    /** Size in pixels */
-    protected int size = 5;
-
-    protected ShadowEffect() {}
-
-    ;
-
-    public ShadowEffect(UIDefaults uiDefaults) {
-        color = new Matte(Color.BLACK, uiDefaults);
-    }
-
-    // =================================================================================================================
-    // Bean methods
-
-    public Matte getColor() {
-        return color;
-    }
-
-    public void setColor(Matte color) {
-        Matte old = getColor();
-        this.color = color;
-        firePropertyChange("color", old, getColor());
-    }
-
-    public BlendingMode getBlendingMode() {
-        return blendingMode;
-    }
-
-    public void setBlendingMode(BlendingMode blendingMode) {
-        BlendingMode old = getBlendingMode();
-        this.blendingMode = blendingMode;
-        firePropertyChange("blendingMode", old, getBlendingMode());
-    }
-
-    public float getOpacity() {
-        return opacity;
-    }
-
-    public void setOpacity(float opacity) {
-        float old = getOpacity();
-        this.opacity = opacity;
-        firePropertyChange("opacity", old, getOpacity());
-    }
-
-    public int getAngle() {
-        return angle;
-    }
-
-    public void setAngle(int angle) {
-        int old = getAngle();
-        this.angle = angle;
-        firePropertyChange("angle", old, getAngle());
-    }
-
-    public int getDistance() {
-        return distance;
-    }
-
-    public void setDistance(int distance) {
-        int old = getDistance();
-        this.distance = distance;
-        firePropertyChange("distance", old, getDistance());
-    }
-
-    public int getSpread() {
-        return spread;
-    }
-
-    public void setSpread(int spread) {
-        int old = getSpread();
-        this.spread = spread;
-        firePropertyChange("spread", old, getSpread());
-    }
-
-    public int getSize() {
-        return size;
-    }
-
-    public void setSize(int size) {
-        int old = getSize();
-        this.size = size;
-        firePropertyChange("size", old, getSize());
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/font/Typeface.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,484 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.font;
-
-import java.awt.Font;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import javax.swing.UIDefaults;
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-/**
- * I don't think the name is technically correct (ie: a typeface is not a font),
- * but I wanted something besides "font" so, here it is.
- *
- * This is a mutable font, much like Matte is a mutable color. Also like Matte,
- * Typeface can be derived.
- *
- * @author rbair
- */
-public class Typeface extends AbstractBean {
-    //specifies whether to derive bold, or italic.
-    //Default means, get my value from my parent.
-    //Off means, leave bold/italic off.
-    //On means, make bold/italic on.
-    public enum DeriveStyle { Default, Off, On }
-
-    private String uiDefaultParentName;
-    /** This is a local UIDefaults that contains all the UIDefaults in the Model. */
-    private transient UIDefaults uiDefaults = new UIDefaults();
-    private PropertyChangeListener uiDefaultsChangeListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            if (uiDefaultParentName != null && uiDefaultParentName.equals(evt.getPropertyName())) {
-                updateFontFromOffsets();
-            }
-        }
-    };
-
-    /**
-     * The name of the font. If uiDefaultParentName is specified, then this name
-     * will be set to be equal to the name of the parent font.
-     */
-    private String name;
-    /**
-     * The size of the font. If uiDefaultParentName is set, then this value is
-     * updated to reflect the size of the parent font * the sizeOffset.
-     */
-    private int size;
-
-    //this field is not publically accessible. Rather, it is updated based on
-    //"bold" and "italic" as necessary.
-    private int style = Font.PLAIN;
-    private DeriveStyle bold = DeriveStyle.Default;
-    private DeriveStyle italic = DeriveStyle.Default;
-
-    /**
-     * The size offset. Only used if uiDefaultParentName is specified. This offset
-     * will be multiplied with the parent font's size to determine the size of this
-     * typeface. The offset is specified as a percentage, either positive or negative.
-     *
-     * The reason a percentage was used, was so that things would look correctly
-     * when scaled, such as with high DPI situations.
-     */
-    private float sizeOffset;
-
-    /**
-     * Create a new Typeface. Note that, without specifying the uiDefaults,
-     * you cannot have font derivation. Thus, this constructor should never
-     * be called, except for the XML binding stuff.
-     */
-    public Typeface() { }
-
-    /**
-     * Creates a new Typeface.
-     *
-     * @param f The font from which to get the font name, size, and style to use
-     * to initialize this typeface. Note that this font is not used as a parent
-     * font for derivation purposes. Rather, it is used as a source from which to
-     * copy initial settings.
-     *
-     * @param uiDefaults The uiDefaults to use for font derivation purposes.
-     * When the uiDefaultParentName is specified, then this Typeface will inspect
-     * the given UIDefaults for that parent <em>font</em>. Note that the UIDefaults
-     * should be populated with a font, and not with a typeface.
-     */
-    public Typeface(Font f, UIDefaults uiDefaults) {
-        if (f != null) {
-            this.name = f.getName();
-            this.size = f.getSize();
-            this.style = f.getStyle();
-        }
-        setUiDefaults(uiDefaults);
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    protected void postSet(IUnmarshallingContext context) {
-        // walk up till we get synth model
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIDefaults) {
-                UIDefaults uiDefaults = ((HasUIDefaults) context.getStackObject(i)).getUiDefaults();
-                if (uiDefaults != null) {
-                    setUiDefaults(uiDefaults);
-                    break;
-                }
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // Typeface methods
-
-    /**
-     * Is the Typeface an absolute Font not derived from a parent ui default
-     *
-     * @return <code>true</code> if this is a absolute not uidefault derived font
-     */
-    public boolean isAbsolute() {
-        return uiDefaultParentName == null;
-    }
-
-    /**
-     * Set all properties of this Typeface to be the same as <code>src</code> and fire all the change events
-     *
-     * @param src the Typeface to copy properties from
-     */
-    public void copy(Typeface src) {
-        // keep old values
-        Font oldFont = getFont();
-        String oldParentName = uiDefaultParentName;
-        String oldName = name;
-        int oldSize = size;
-        float oldSizeOffset = sizeOffset;
-        DeriveStyle oldBold = bold, oldItalic = italic;
-
-        style = src.style;
-
-        //Note, I don't just call the setters here, because I want to make
-        //sure the "font" PCE is only fired once, at the end.
-        name = src.name;
-        firePropertyChange("name", oldName, name);
-        size = src.size;
-        firePropertyChange("size", oldSize, size);
-        bold = src.bold;
-        firePropertyChange("bold", oldBold, bold);
-        italic = src.italic;
-        firePropertyChange("italic", oldItalic, italic);
-        sizeOffset = src.sizeOffset;
-        firePropertyChange("sizeOffset", oldSizeOffset, sizeOffset);
-        uiDefaultParentName = src.uiDefaultParentName;
-        firePropertyChange("uiDefaultParentName", oldParentName, uiDefaultParentName);
-        setUiDefaults(src.uiDefaults);
-        firePropertyChange("font", oldFont, getFont());
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in the Model.
-     *
-     * @return The UIDefaults for the model that contains this Typeface, can be null if this Typeface is not part of a bigger
-     *         model
-     */
-    public UIDefaults getUiDefaults() {
-        return uiDefaults;
-    }
-
-    /**
-     * Set the local UIDefaults that contains all the UIDefaults in the Model.
-     *
-     * @param uiDefaults The UIDefaults for the model that contains this Typeface, can be null if this Typeface is not part of
-     *                   a bigger model
-     */
-    public void setUiDefaults(UIDefaults uiDefaults) {
-        if (uiDefaults != this.uiDefaults) {
-            UIDefaults old = getUiDefaults();
-            if (old != null) old.removePropertyChangeListener(uiDefaultsChangeListener);
-            this.uiDefaults = uiDefaults;
-            if (uiDefaults != null) this.uiDefaults.addPropertyChangeListener(uiDefaultsChangeListener);
-            firePropertyChange("uiDefaults", old, getUiDefaults());
-        }
-    }
-
-    /**
-     * Get the name if the uidefault font that is the parent that this Typeface is derived from. If null then this is a
-     * absolute font.
-     *
-     * @return Parent font ui default name
-     */
-    public String getUiDefaultParentName() {
-        return uiDefaultParentName;
-    }
-
-    /**
-     * Set the name if the uidefault font that is the parent that this Typeface is derived from. If null then this is a
-     * absolute font.
-     *
-     * @param uiDefaultParentName Parent font ui default name
-     */
-    public void setUiDefaultParentName(String uiDefaultParentName) {
-        String old = getUiDefaultParentName();
-        this.uiDefaultParentName = uiDefaultParentName;
-        firePropertyChange("uiDefaultParentName", old, getUiDefaultParentName());
-        if (isAbsolute()) {
-            // reset offsets
-            float oldSizeOffset = sizeOffset;
-            sizeOffset = 0;
-            firePropertyChange("sizeOffset", oldSizeOffset, sizeOffset);
-        } else {
-            updateFontFromOffsets();
-        }
-    }
-
-    /**
-     * @return Gets the name of the font
-     */
-    public final String getName() {
-        return name;
-    }
-
-    /**
-     * Sets the name of the font. This method call <em>only</em> works if
-     * <code>isAbsolute</code> returns true. Otherwise, it is ignored.
-     * @param name the name of the font
-     */
-    public void setName(String name) {
-        if (isAbsolute()) {
-            String old = this.name;
-            Font oldF = getFont();
-            this.name = name;
-            firePropertyChange("name", old, this.name);
-            firePropertyChange("font", oldF, getFont());
-        }
-    }
-
-    /**
-     * @return gets the size of the font.
-     */
-    public final int getSize() {
-        return size;
-    }
-
-    /**
-     * <p>Sets the size of the font. THis method call will work whether
-     * <code>isAbsolute</code> returns true or false. If this is an absolute
-     * typeface, then the size is set directly. Otherwise, if this is a
-     * derived typeface, then the sizeOffset will be updated to reflect the
-     * proper offset based on this size, and the size of the parent font.</p>
-     *
-     * <p>For example, if the parent font's size was 12, and the sizeOffset was
-     * -2 (thus yielding as size on this typeface of 10), and you call setSize
-     * passing in "14" as the size, then the sizeOffset will be updated to be
-     * equal to "2".</p>
-     *
-     * @param size the new size for this typeface.
-     */
-    public void setSize(int size) {
-        int old = this.size;
-        Font oldF = getFont();
-        this.size = size;
-        firePropertyChange("size", old, this.size);
-        firePropertyChange("font", oldF, getFont());
-        updateOffsetsFromFont();
-    }
-
-    /**
-     * @return the size offset
-     */
-    public final float getSizeOffset() {
-        return sizeOffset;
-    }
-
-    /**
-     * Sets the percentage by which the size of this font should be different
-     * from its parent font. This property is kept in synch with the size property.
-     *
-     * @param sizeOffset the size offset. May be any float. The value "1" means,
-     * 100%. -1 means "-100%". 2 means "200%", and so on.
-     */
-    public void setSizeOffset(float sizeOffset) {
-        float old = this.sizeOffset;
-        Font oldF = getFont();
-        this.sizeOffset = sizeOffset;
-        firePropertyChange("sizeOffset", old, this.sizeOffset);
-        firePropertyChange("font", oldF, getFont());
-        updateFontFromOffsets();
-    }
-
-    public DeriveStyle getBold() {
-        return bold;
-    }
-
-    public void setBold(DeriveStyle bold) {
-        DeriveStyle old = this.bold;
-        this.bold = bold == null ? DeriveStyle.Default : bold;
-        firePropertyChange("bold", old, this.bold);
-        updateFontFromOffsets();
-    }
-
-    public DeriveStyle getItalic() {
-        return italic;
-    }
-
-    public void setItalic(DeriveStyle italic) {
-        DeriveStyle old = this.italic;
-        this.italic = italic == null ? DeriveStyle.Default : italic;
-        firePropertyChange("italic", old, this.italic);
-        updateFontFromOffsets();
-    }
-
-    /**
-     * @return whether or not the font represented by this typeface is supported
-     * on this operating system platform.
-     */
-    public boolean isFontSupported() {
-        return true;//Font.getFont(name) != null;
-    }
-
-    /**
-     * @return Gets the font associated with this Typeface. If font derivation is
-     * being used, then the Font returned is the result of that derivation.
-     */
-    public Font getFont() {
-        return new Font(name, style, size);
-    }
-
-    /**
-     * Sets the font from which this Typeface should extract the font name, style,
-     * and size. If font derivation is being used, then the font name will be ignored,
-     * the style will be used (and always override the parent font), and the size
-     * will be set and the sizeOffset updated appropriately.
-     *
-     * @param f the Font
-     */
-    public void setFont(Font f) {
-        Font oldFont = getFont();
-        String oldName = name;
-        int oldSize = size;
-        DeriveStyle oldBold = bold, oldItalic = italic;
-        name = f.getName();
-        size = f.getSize();
-        style = f.getStyle();
-        updateOffsetsFromFont();
-        firePropertyChange("name", oldName, name);
-        firePropertyChange("size", oldSize, size);
-        firePropertyChange("bold", oldBold, bold);
-        firePropertyChange("italic", oldItalic, italic);
-        firePropertyChange("font", oldFont, getFont());
-    }
-
-    /**
-     * @inheritDoc
-     *
-     * @return A formatted string representing this Typeface. This String should
-     * not be considered public API, as it may change in a future release.
-     */
-    @Override public String toString() {
-        Font f = getFont();
-        String  strStyle;
-        if (f.isBold()) {
-            strStyle = f.isItalic() ? "bolditalic" : "bold";
-        } else {
-            strStyle = f.isItalic() ? "italic" : "plain";
-        }
-
-        if (isAbsolute()) {
-            return Typeface.class.getName() + "[name=" + name + ", size=" + size + ", style=" + strStyle + "]";
-        } else {
-            return Typeface.class.getName() + "[base=" + uiDefaultParentName +
-                    ", name=" + name + ", size=" + size + "(offset " + sizeOffset + ")" +
-                    ", style=" + strStyle + "]";
-        }
-    }
-
-    @Override public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        Typeface typeface = (Typeface) o;
-        if (!typeface.name.equals(name)) return false;
-        if (size != typeface.size) return false;
-        if (bold != typeface.bold) return false;
-        if (italic != typeface.italic) return false;
-        if (sizeOffset != typeface.sizeOffset) return false;
-        if (uiDefaultParentName != null ? !uiDefaultParentName.equals(typeface.uiDefaultParentName) :
-                typeface.uiDefaultParentName != null) return false;
-        return true;
-    }
-
-    @Override public int hashCode() {
-        int result;
-        result = name.hashCode();
-        result = 31 * result + size;
-        result = 31 * result + bold.ordinal();
-        result = 31 * result + italic.ordinal();
-        result = 31 * result + (int)(sizeOffset*100);
-        result = 31 * result + (uiDefaultParentName != null ? uiDefaultParentName.hashCode() : 0);
-        return result;
-    }
-
-    @Override public Typeface clone() {
-        Typeface clone = new Typeface();
-        clone.name = name;
-        clone.size = size;
-        clone.style = style;
-        clone.bold = bold;
-        clone.italic = italic;
-        clone.sizeOffset = sizeOffset;
-        clone.uiDefaultParentName = uiDefaultParentName;
-        clone.setUiDefaults(uiDefaults);
-        return clone;
-    }
-
-    // =================================================================================================================
-    // Private Helper Methods
-
-    private void updateOffsetsFromFont() {
-        if (!isAbsolute()) {
-            float oldSizeOffset = sizeOffset;
-            Font parentFont = uiDefaults.getFont(uiDefaultParentName);
-            if (parentFont != null) {
-                float s = size;
-                float p = parentFont.getSize();
-                sizeOffset = (s/p) - 1f;
-                firePropertyChange("sizeOffset", oldSizeOffset, sizeOffset);
-            }
-        }
-    }
-
-    private void updateFontFromOffsets() {
-        if (!isAbsolute()) {
-            Font oldFont = getFont();
-            // get parent font data
-            Font parentFont = uiDefaults.getFont(uiDefaultParentName);
-            if (parentFont != null) {
-                String oldName = name;
-                int oldSize = size;
-
-                name = parentFont.getName();
-                size = Math.round(parentFont.getSize() * (1f + sizeOffset));
-
-                boolean isBold = (bold == DeriveStyle.Default && parentFont.isBold()) || bold == DeriveStyle.On;
-                boolean isItalic = (italic == DeriveStyle.Default && parentFont.isItalic()) || italic == DeriveStyle.On;
-                style = Font.PLAIN;
-                if (isBold) style = style | Font.BOLD;
-                if (isItalic) style = style | Font.ITALIC;
-
-                // update fire events
-                firePropertyChange("name", oldName, name);
-                firePropertyChange("size", oldSize, size);
-                firePropertyChange("font", oldFont, getFont());
-            }
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/jibxhelpers/CanvasMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,123 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.jibxhelpers;
-
-import org.jdesktop.swingx.designer.Canvas;
-import org.jdesktop.swingx.designer.utils.HasPath;
-import org.jdesktop.swingx.designer.utils.HasResources;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.BindingDirectory;
-import org.jibx.runtime.IBindingFactory;
-import org.jibx.runtime.IMarshallable;
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-import javax.swing.UIDefaults;
-import java.io.File;
-
-/**
- * CanvasMapper
- *
- * @author Created by Jasper Potts (Jun 12, 2007)
- */
-public class CanvasMapper implements IMarshaller, IUnmarshaller {
-    private static final String ELEMENT_NAME = "canvas";
-    private IBindingFactory bindingFactory;
-
-
-    public CanvasMapper() {
-        try {
-            bindingFactory = BindingDirectory.getFactory(Canvas.class);
-        } catch (JiBXException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(null, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Canvas)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            // version found, create marshaller for the associated binding
-//            IBindingFactory bindingFactory = BindingDirectory.getFactory(object.getClass());
-            MarshallingContext context = (MarshallingContext) bindingFactory.createMarshallingContext();
-            // configure marshaller for writing document
-            context.setXmlWriter(iMarshallingContext.getXmlWriter());
-            // output object as document
-            ((IMarshallable) object).marshal(context);
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(null, ELEMENT_NAME)) {
-            ctx.throwStartTagNameError(null, ELEMENT_NAME);
-        }
-
-//        IBindingFactory bindingFactory = BindingDirectory.getFactory(Canvas.class);
-        UnmarshallingContext uctx = (UnmarshallingContext) bindingFactory.createUnmarshallingContext();
-        uctx.setFromContext(ctx);
-        // get the uiDefaults from SynthModel and set them as user context
-        UIDefaults uiDefaults = ((HasUIDefaults) ctx.getStackObject(ctx.getStackDepth() - 1)).getUiDefaults();
-        uctx.setUserContext(uiDefaults);
-        // get has resources
-        HasResources hasResources = (HasResources) ctx.getStackObject(ctx.getStackDepth() - 1);
-        // get path
-        HasPath hasPath = null;
-        for (int i = 0; i < ctx.getStackDepth(); i++) {
-            if (ctx.getStackObject(i) instanceof HasPath) {
-                hasPath = (HasPath) ctx.getStackObject(i);
-                break;
-            }
-        }
-        // Unmarshal the Canvas
-        Canvas canvas = (Canvas) uctx.unmarshalElement();
-        // set canvas's ui defaults
-        canvas.setUiDefaults(uiDefaults);
-        // get canvas path
-        String canvasPath = hasPath.getPath();
-        // calc and set resources
-        canvas.setResourcesDir(new File(hasResources.getResourcesDir(), canvasPath));
-        canvas.setTemplatesDir(new File(hasResources.getTemplatesDir(), canvasPath));
-        canvas.setImagesDir(new File(hasResources.getImagesDir(), canvasPath));
-        // return canvas
-        return canvas;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/jibxhelpers/ColorMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,89 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.jibxhelpers;
-
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-import java.awt.Color;
-
-/**
- * ColorMapper
- *
- * @author Created by Jasper Potts (Jun 8, 2007)
- */
-public class ColorMapper implements IMarshaller, IUnmarshaller {
-    private static final String ELEMENT_NAME = "color";
-    private static final String RED_NAME = "red";
-    private static final String GREEN_NAME = "green";
-    private static final String BLUE_NAME = "blue";
-    private static final String ALPHA_NAME = "alpha";
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(null, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Color)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            Color color = (Color) object;
-            ctx.startTagAttributes(0, ELEMENT_NAME).
-                    attribute(0, RED_NAME, color.getRed()).
-                    attribute(0, GREEN_NAME, color.getGreen()).
-                    attribute(0, BLUE_NAME, color.getBlue()).
-                    attribute(0, ALPHA_NAME, color.getAlpha()).
-                    closeStartEmpty();
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(null, ELEMENT_NAME)) {
-            ctx.throwStartTagNameError(null, ELEMENT_NAME);
-        }
-        // get values
-        int red = ctx.attributeInt(null, RED_NAME, 0);
-        int green = ctx.attributeInt(null, GREEN_NAME, 0);
-        int blue = ctx.attributeInt(null, BLUE_NAME, 0);
-        int alpha = ctx.attributeInt(null, ALPHA_NAME, 0);
-        ctx.parsePastEndTag(null, ELEMENT_NAME);
-        // create
-        return new Color(red, green, blue, alpha);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/jibxhelpers/DimensionMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,101 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.jibxhelpers;
-
-import org.jibx.runtime.IAliasable;
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-import java.awt.Dimension;
-
-/**
- * DimensionMapper
- *
- * @author Created by Jasper Potts (Jun 12, 2007)
- */
-public class DimensionMapper implements IMarshaller, IUnmarshaller, IAliasable {
-    private static final String ELEMENT_NAME = "dimension";
-    private static final String WIDTH_NAME = "width";
-    private static final String HEIGHT_NAME = "height";
-
-    private String uri;
-    private int index;
-    private String name;
-
-    public DimensionMapper() {
-        uri = null;
-        index = 0;
-        name = ELEMENT_NAME;
-    }
-
-    public DimensionMapper(String uri, int index, String name) {
-        this.uri = uri;
-        this.index = index;
-        this.name = name;
-    }
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(uri, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Dimension)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            Dimension dimension = (Dimension) object;
-            ctx.startTagAttributes(index, name).
-                    attribute(index, WIDTH_NAME, dimension.width).
-                    attribute(index, HEIGHT_NAME, dimension.height).
-                    closeStartEmpty();
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(uri, name)) {
-            ctx.throwStartTagNameError(uri, name);
-        }
-        // get values
-        int width = ctx.attributeInt(uri, WIDTH_NAME, index);
-        int height = ctx.attributeInt(uri, HEIGHT_NAME, index);
-        // state finished parsing
-        ctx.parsePastEndTag(uri, name);
-        // create
-        return new Dimension(width, height);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/jibxhelpers/InsetsMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,117 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.jibxhelpers;
-
-import org.jibx.runtime.IAliasable;
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-import java.awt.Insets;
-
-/**
- * InsetsMapper
- *
- * @author Created by Jasper Potts (Jun 8, 2007)
- */
-public class InsetsMapper implements IMarshaller, IUnmarshaller, IAliasable {
-    private static final String ELEMENT_NAME = "insets";
-    private static final String TOP_NAME = "top";
-    private static final String BOTTOM_NAME = "bottom";
-    private static final String LEFT_NAME = "left";
-    private static final String RIGHT_NAME = "right";
-
-    private String uri;
-    private int index;
-    private String name;
-
-    public InsetsMapper() {
-        uri = null;
-        index = 0;
-        name = ELEMENT_NAME;
-    }
-
-    public InsetsMapper(String uri, int index, String name) {
-        this.uri = uri;
-        this.index = index;
-        this.name = name;
-//        System.out.println("InsetsMapper.CONSTRCUTED with uri="+uri+" index="+index+" name="+name);
-    }
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(uri, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Insets)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-//            System.out.println("InsetsMapper.marshal name="+name);
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            Insets insets = (Insets) object;
-            ctx.startTagAttributes(index, name).
-                    attribute(index, TOP_NAME, insets.top).
-                    attribute(index, BOTTOM_NAME, insets.bottom).
-                    attribute(index, LEFT_NAME, insets.left).
-                    attribute(index, RIGHT_NAME, insets.right).
-                    closeStartEmpty();
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(uri, name)) {
-//            System.out.println("InsetsMapper.unmarshal name="+name+" uri="+uri+" currentNode="+ctx.getName());
-            ctx.throwStartTagNameError(uri, name);
-        } else {
-//        System.out.println("InsetsMapper.unmarshal name="+name+" uri="+uri+" currentNode="+ctx.getName());
-        }
-        // get values
-        int top = ctx.attributeInt(uri, TOP_NAME, index);
-        int bottom = ctx.attributeInt(uri, BOTTOM_NAME, index);
-        int left = ctx.attributeInt(uri, LEFT_NAME, index);
-        int right = ctx.attributeInt(uri, RIGHT_NAME, index);
-        // create new hashmap if needed
-        Insets insets = (Insets) object;
-        if (insets == null) {
-            insets = new Insets(top, left, bottom, right);
-        } else {
-            insets.set(top, left, bottom, right);
-        }
-        ctx.parsePastEndTag(uri, name);
-        return insets;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/AbstractGradient.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,280 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import java.awt.Color;
-import java.awt.MultipleGradientPaint.CycleMethod;
-import java.awt.Paint;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
-/** @author rbair */
-public abstract class AbstractGradient extends PaintModel {
-    private final Comparator<GradientStop> sorter = new Comparator<GradientStop>() {
-        public int compare(GradientStop s1, GradientStop s2) {
-            //since a float value may be -.001 or .001, and since casting
-            //this to an int will round off to 0, I have to do a more direct
-            //comparison
-            float v = s1.getPosition() - s2.getPosition();
-
-            if (v < 0) return -1;
-            else if (v == 0) return 0;
-            else return 1;
-        }
-    };
-    private PropertyChangeListener stopListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            if (evt.getPropertyName().equals("position")) {
-                if (stops.contains((GradientStop) evt.getSource())) {
-                    resortModel(true);
-                } else {
-                    System.err.println("[WARNING] The position of an orphaned stop was changed.");
-                }
-            } else {
-                firePropertyChange("paint", null, getPaint());
-            }
-        }
-    };
-
-    private List<GradientStop> stops = new ArrayList<GradientStop>();
-    private List<GradientStop> unmodifiable;
-    private CycleMethod cycleMethod;
-
-    protected AbstractGradient() {
-        unmodifiable = Collections.unmodifiableList(stops);
-        cycleMethod = CycleMethod.NO_CYCLE;
-        setStops(new GradientStop(0, new Matte(Color.BLUE, null)),
-                new GradientStop(1, new Matte(Color.WHITE, null)));
-    }
-
-    /**
-     * Copy stops and cycleMethod from src to dst
-     *
-     * @param dst The gradient to update to same stops and cycle method as this gradient
-     */
-    protected void copyTo(AbstractGradient dst) {
-        dst.stops.clear();
-        List<GradientStop> stops = new ArrayList<GradientStop>();
-        for (GradientStop stop : this.stops) {
-            stops.add(stop.clone());
-        }
-        dst.setStops(stops);
-        dst.cycleMethod = this.cycleMethod;
-    }
-
-
-    public PaintControlType getPaintControlType() {
-        return PaintControlType.control_line;
-    }
-
-    public void setCycleMethod(CycleMethod method) {
-        CycleMethod old = cycleMethod;
-        Paint oldp = getPaint();
-        cycleMethod = method == null ? CycleMethod.NO_CYCLE : method;
-        firePropertyChange("cycleMethod", old, cycleMethod);
-        firePropertyChange("paint", oldp, getPaint());
-    }
-
-    public final CycleMethod getCycleMethod() {
-        return cycleMethod;
-    }
-
-    public void setStops(GradientStop... stops) {
-        if (stops == null || stops.length < 1) {
-            throw new IllegalArgumentException("Must have more than one stop");
-        }
-        List<GradientStop> old = new ArrayList<GradientStop>(this.stops);
-        for (GradientStop stop : old) {
-            stop.removePropertyChangeListener(stopListener);
-        }
-        Paint oldp = getPaint();
-        this.stops.clear();
-        Collections.addAll(this.stops, stops);
-        for (GradientStop stop : this.stops) {
-            stop.addPropertyChangeListener(stopListener);
-        }
-        resortModel(false);
-        firePropertyChange("stops", old, getStops());
-        firePropertyChange("paint", oldp, getPaint());
-    }
-
-    public final void setStops(List<GradientStop> stops) {
-        setStops(stops == null ? null : stops.toArray(new GradientStop[0]));
-    }
-
-    public final List<GradientStop> getStops() {
-        return unmodifiable;
-    }
-
-    private void resortModel(boolean fireEvent) {
-        Collections.sort(this.stops, sorter);
-        if (fireEvent) {
-            Paint oldp = getPaint();
-            firePropertyChange("stops", null, getStops());
-            firePropertyChange("paint", oldp, getPaint());
-        }
-    }
-
-    //adds a new stop, and interoplates the proper color to use based on
-    //its position
-    public GradientStop addStop(float position) {
-        GradientStop prevStop = null;
-        GradientStop nextStop = null;
-        for (GradientStop stop : stops) {
-            if (stop.getPosition() <= position) {
-                prevStop = stop;
-            } else if (stop.getPosition() >= position) {
-                nextStop = stop;
-            }
-        }
-
-        Matte c = null;
-        if (prevStop != null && nextStop != null) {
-            //interpolate the value of c
-            c = interpolate(prevStop.getColor(), nextStop.getColor(),
-                    position / (nextStop.getPosition() - prevStop.getPosition()));
-        } else if (prevStop != null) {
-            c = prevStop.getColor().clone();
-        } else if (nextStop != null) {
-            c = nextStop.getColor().clone();
-        }
-
-        return addStop(position, c);
-    }
-
-    public GradientStop addStop(float position, Matte color) {
-        GradientStop s = new GradientStop(position, color);
-        s.addPropertyChangeListener(stopListener);
-        List<GradientStop> old = new ArrayList<GradientStop>(stops);
-        Paint oldp = getPaint();
-        stops.add(s);
-        resortModel(false);
-        firePropertyChange("stops", old, getStops());
-        firePropertyChange("paint", oldp, getPaint());
-
-        return s;
-    }
-
-    public GradientStop removeStop(GradientStop s) {
-        List<GradientStop> old = new ArrayList<GradientStop>(stops);
-        Paint oldp = getPaint();
-        stops.remove(s);
-        s.removePropertyChangeListener(stopListener);
-        resortModel(false);
-        firePropertyChange("stops", old, getStops());
-        firePropertyChange("paint", oldp, getPaint());
-        return s;
-    }
-
-    @Override public Paint getPaint() {
-        if (stops.size() == 0) {
-            return null;
-        }
-
-        //there are stops.size() number of main stops. Between each is
-        //a fractional stop. Thus, there are:
-        //stops.size() + stops.size() - 1
-        //number of fractions and colors.
-
-        float[] fractions = new float[stops.size() + stops.size() - 1];
-        Matte[] colors = new Matte[fractions.length];
-
-        //for each stop, create the stop and it's associated fraction
-        int index = 0; // the index into fractions and colors
-        for (int i = 0; i < stops.size(); i++) {
-            GradientStop s = stops.get(i);
-            //copy over the stop's data
-            colors[index] = s.getColor();
-            fractions[index] = s.getPosition();
-
-            //If this isn't the last stop, then add in the fraction
-            if (index < fractions.length - 1) {
-                float f1 = s.getPosition();
-                float f2 = stops.get(i + 1).getPosition();
-
-                index++;
-                fractions[index] = f1 + (f2 - f1) * s.getMidpoint();
-                colors[index] = interpolate(colors[index - 1], stops.get(i + 1).getColor(), .5f);
-            }
-
-            index++;
-        }
-
-        for (int i = 1; i < fractions.length; i++) {
-            //to avoid an error with LinearGradientPaint where two fractions
-            //are identical, bump up the fraction value by a miniscule amount
-            //if it is identical to the previous one
-            //NOTE: The <= is critical because the previous value may already
-            //have been bumped up
-            if (fractions[i] <= fractions[i - 1]) {
-                fractions[i] = fractions[i - 1] + .000001f;
-            }
-        }
-
-        //another boundary condition where multiple stops are all at the end. The
-        //previous loop bumped all but one of these past 1.0, which is bad.
-        //so remove any fractions (and their colors!) that are beyond 1.0
-        int outOfBoundsIndex = -1;
-        for (int i = 0; i < fractions.length; i++) {
-            if (fractions[i] > 1) {
-                outOfBoundsIndex = i;
-                break;
-            }
-        }
-
-        if (outOfBoundsIndex >= 0) {
-            float[] f = fractions;
-            Matte[] c = colors;
-            fractions = new float[outOfBoundsIndex];
-            colors = new Matte[outOfBoundsIndex];
-            System.arraycopy(f, 0, fractions, 0, outOfBoundsIndex);
-            System.arraycopy(c, 0, colors, 0, outOfBoundsIndex);
-        }
-
-        return createPaint(fractions, colors, cycleMethod);
-    }
-
-    protected abstract Paint createPaint(float[] fractions, Matte[] colors, CycleMethod method);
-
-    protected static Matte interpolate(Matte v0, Matte v1, float fraction) {
-        return new Matte(interpolate(v0.getColor(), v1.getColor(), fraction), v0.getUiDefaults());
-    }
-
-    protected static Color interpolate(Color v0, Color v1, float fraction) {
-        int r = v0.getRed() +
-                (int) ((v1.getRed() - v0.getRed()) * fraction + 0.5f);
-        int g = v0.getGreen() +
-                (int) ((v1.getGreen() - v0.getGreen()) * fraction + 0.5f);
-        int b = v0.getBlue() +
-                (int) ((v1.getBlue() - v0.getBlue()) * fraction + 0.5f);
-        int a = v0.getAlpha() +
-                (int) ((v1.getAlpha() - v0.getAlpha()) * fraction + 0.5f);
-        return new Color(r, g, b, a);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/Gradient.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import java.awt.Color;
-import java.awt.LinearGradientPaint;
-import java.awt.MultipleGradientPaint.CycleMethod;
-import java.awt.Paint;
-
-/**
- * Represents a GradientPaint or LinearGradientPaint.
- *
- * @author rbair
- */
-public class Gradient extends AbstractGradient implements Cloneable {
-    protected Paint createPaint(float[] fractions, Matte[] mattes, CycleMethod method) {
-        Color[] colors = new Color[mattes.length];
-        for (int i = 0; i < colors.length; i++) {
-            colors[i] = mattes[i].getColor();
-        }
-        return new LinearGradientPaint(0, 0, 1, 0, fractions, colors, method);
-    }
-
-    @Override public Gradient clone() {
-        Gradient gradient = new Gradient();
-        copyTo(gradient);
-        return gradient;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/GradientStop.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,123 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import org.jdesktop.beans.AbstractBean;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-
-/** Each stop is defined linearly, at positions between 0 and 1. */
-public final class GradientStop extends AbstractBean implements Cloneable {
-    private float position;
-    private Matte color;
-    private PropertyChangeListener matteListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            firePropertyChange("color", null, color);
-        }
-    };
-
-    /**
-     * The midpoint to the right of the stop. Must be 0 &lt;= midpoint &lt;= 1. The midpoint value of the last Stop is
-     * ignored.
-     */
-    private float midpoint;
-
-    public GradientStop() {}
-
-    public GradientStop(float position, Matte color) {
-        if (color == null) {
-            throw new IllegalArgumentException("Color must not be null");
-        }
-
-        this.position = clamp(0, 1, position);
-        this.color = color;
-        this.midpoint = .5f;
-
-        if (this.color != null) {
-            this.color.addPropertyChangeListener("color", matteListener);
-        }
-    }
-
-
-    public GradientStop clone() {
-        GradientStop clone = new GradientStop(this.position, this.color.clone());
-        clone.midpoint = midpoint;
-        return clone;
-    }
-
-    public final float getPosition() {
-        return position;
-    }
-
-    public final void setPosition(float position) {
-        float old = this.position;
-        this.position = clamp(0, 1, position);
-        firePropertyChange("position", old, this.position);
-    }
-
-    public final Matte getColor() {
-        return color;
-    }
-
-    public final void setColor(Matte c) {
-        if (c == null) throw new IllegalArgumentException("Color must not be null");
-        Matte old = this.color;
-        if (old != null) old.removePropertyChangeListener(matteListener);
-        this.color = c;
-        if (this.color != null) this.color.addPropertyChangeListener(matteListener);
-        firePropertyChange("color", old, c);
-    }
-
-    public final void setOpacity(int opacity) {
-        int old = getOpacity();
-        color.setAlpha(opacity);
-        firePropertyChange("opacity", old, getOpacity());
-    }
-
-    public final int getOpacity() {
-        return color.getAlpha();
-    }
-
-    public final float getMidpoint() {
-        return midpoint;
-    }
-
-    public final void setMidpoint(float midpoint) {
-        float old = this.midpoint;
-        this.midpoint = clamp(0, 1, midpoint);
-        firePropertyChange("midpoint", old, this.midpoint);
-    }
-
-    private float clamp(float lo, float hi, float value) {
-        if (value < lo) {
-            return lo;
-        } else if (value > hi) {
-            return hi;
-        } else {
-            return value;
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/Matte.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,610 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-import java.awt.Paint;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-
-/**
- * Representing a single uniform color. Basically, it represents the java.awt.Color. It can either be absolute or
- * derived from a UIDefault color.
- *
- * @author rbair & jasper potts
- */
-public class Matte extends PaintModel implements HasUIDefaults {
-    private float[] tmpf1 = new float[3];
-    private float[] tmpf2 = new float[3];
-
-    private int red;
-    private int green;
-    private int blue;
-    private int alpha;
-    private Color cached = null;
-
-    /**
-     * The name of the ui default key to derive this color from.
-     */
-    private String uiDefaultParentName = null;
-    /**
-     * The name of the bean property, or client property, on this component
-     * from which to extract a color used for painting. So for example the color
-     * used in a painter could be the background of the component.
-     */
-    private String componentPropertyName = null;
-    private float hueOffset = 0, saturationOffset = 0, brightnessOffset = 0;
-    private int alphaOffset = 0;
-    /**
-     * When true this color will become a UIResource in the UIManager defaults
-     * table. If false, then it will not be a UIResource. This is sometimes
-     * required, such as with colors installed on renderers.
-     */
-    private boolean uiResource = true;
-
-    /** This is a local UIDefaults that contains all the UIDefaults in the Model. */
-    private transient UIDefaults uiDefaults = new UIDefaults();
-    private PropertyChangeListener uiDefaultsChangeListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            if (uiDefaultParentName != null && uiDefaultParentName.equals(evt.getPropertyName())) {
-                updateARGBFromOffsets();
-            }
-        }
-    };
-
-    // =================================================================================================================
-    // Constructors
-
-    /** propected constructor for JIBX */
-    protected Matte() {}
-
-    public Matte(Color c, UIDefaults uiDefaults) {
-        if (c != null) {
-            this.red = c.getRed();
-            this.green = c.getGreen();
-            this.blue = c.getBlue();
-            this.alpha = c.getAlpha();
-        }
-        setUiDefaults(uiDefaults);
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    protected void postSet(IUnmarshallingContext context) {
-        // walk up till we get synth model
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIDefaults) {
-                UIDefaults uiDefaults = ((HasUIDefaults) context.getStackObject(i)).getUiDefaults();
-                if (uiDefaults != null) {
-                    setUiDefaults(uiDefaults);
-                    break;
-                }
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // Matte methods
-
-    /**
-     * Is the matte an absolute color ot derived from a parent ui default
-     *
-     * @return <code>true</code> if this is a absolute not uidefault derived color
-     */
-    public boolean isAbsolute() {
-        return uiDefaultParentName == null;
-    }
-
-    /**
-     * Set all properties of this matte to be the same as <code>srcMatte</code> and fire all the change events
-     *
-     * @param srcMatte the matte to copy properties from
-     */
-    public void copy(Matte srcMatte) {
-        // keep old values
-        Color oldColor = getColor();
-        String oldParentName = uiDefaultParentName;
-        String oldComponentPropertyName = componentPropertyName;
-        boolean oldUiResource = uiResource;
-        int oldR = red, oldG = green, oldB = blue, oldA = alpha;
-        float oldH = hueOffset, oldS = saturationOffset, oldBr = brightnessOffset;
-        // set properties
-        if (uiResource != srcMatte.uiResource) {
-            uiResource = srcMatte.uiResource;
-            firePropertyChange("uiResource", oldUiResource, isUiResource());
-        }
-        if (red != srcMatte.red) {
-            red = srcMatte.red;
-            firePropertyChange("red", oldR, getRed());
-        }
-        if (green != srcMatte.green) {
-            green = srcMatte.green;
-            firePropertyChange("green", oldG, getGreen());
-        }
-        if (blue != srcMatte.blue) {
-            blue = srcMatte.blue;
-            firePropertyChange("blue", oldB, getBlue());
-        }
-        if (alpha != srcMatte.alpha) {
-            alpha = srcMatte.alpha;
-            firePropertyChange("alpha", oldA, getAlpha());
-        }
-        if (hueOffset != srcMatte.hueOffset) {
-            hueOffset = srcMatte.hueOffset;
-            firePropertyChange("hueOffset", oldH, getHueOffset());
-        }
-        if (saturationOffset != srcMatte.saturationOffset) {
-            saturationOffset = srcMatte.saturationOffset;
-            firePropertyChange("saturationOffset", oldS, getSaturationOffset());
-        }
-        if (brightnessOffset != srcMatte.brightnessOffset) {
-            brightnessOffset = srcMatte.brightnessOffset;
-            firePropertyChange("brightnessOffset", oldBr, getBrightnessOffset());
-        }
-        if (alphaOffset != srcMatte.alphaOffset) {
-            alphaOffset = srcMatte.alphaOffset;
-            firePropertyChange("alphaOffset", oldA, getAlphaOffset());
-        }
-        if (uiDefaultParentName != srcMatte.uiDefaultParentName) {
-            uiDefaultParentName = srcMatte.uiDefaultParentName;
-            firePropertyChange("uiDefaultParentName", oldParentName, getUiDefaultParentName());
-        }
-        if (componentPropertyName != srcMatte.componentPropertyName) {
-            componentPropertyName = srcMatte.componentPropertyName;
-            firePropertyChange("componentPropertyName", oldComponentPropertyName, getComponentPropertyName());
-        }
-        if (uiDefaults != srcMatte.uiDefaults) {
-            setUiDefaults(srcMatte.uiDefaults);
-        }
-        if (!oldColor.equals(srcMatte.getColor())) {
-            firePropertyChange("paint", oldColor, getColor());
-            firePropertyChange("color", oldColor, getColor());
-            fireHSBChange(oldR, oldG, oldB);
-        }
-    }
-
-    // =================================================================================================================
-    // PaintModel methods
-
-    public PaintControlType getPaintControlType() {
-        return PaintControlType.none;
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in the Model.
-     *
-     * @return The UIDefaults for the model that contains this Matte, can be null if this Matte is not part of a bigger
-     *         model
-     */
-    public UIDefaults getUiDefaults() {
-        return uiDefaults;
-    }
-
-    /**
-     * Set the local UIDefaults that contains all the UIDefaults in the Model.
-     *
-     * @param uiDefaults The UIDefaults for the model that contains this Matte, can be null if this Matte is not part of
-     *                   a bigger model
-     */
-    public void setUiDefaults(UIDefaults uiDefaults) {
-        if (uiDefaults != this.uiDefaults) {
-            UIDefaults old = getUiDefaults();
-            if (old != null) old.removePropertyChangeListener(uiDefaultsChangeListener);
-            this.uiDefaults = uiDefaults;
-            if (uiDefaults != null) this.uiDefaults.addPropertyChangeListener(uiDefaultsChangeListener);
-            firePropertyChange("uiDefaults", old, getUiDefaults());
-        }
-    }
-
-    /**
-     * Get the name if the uidefault color that is the parent that this matte is derived from. If null then this is a
-     * absolute color.
-     *
-     * @return Parent color ui default name
-     */
-    public String getUiDefaultParentName() {
-        return uiDefaultParentName;
-    }
-
-    /**
-     * Set the name if the uidefault color that is the parent that this matte is derived from. If null then this is a
-     * absolute color.
-     *
-     * @param uiDefaultParentName Parent color ui default name
-     */
-    public void setUiDefaultParentName(String uiDefaultParentName) {
-        String old = getUiDefaultParentName();
-        this.uiDefaultParentName = uiDefaultParentName;
-        firePropertyChange("uiDefaultParentName", old, getUiDefaultParentName());
-        if (isAbsolute()) {
-            // reset offsets
-            float oldH = hueOffset, oldS = saturationOffset, oldB = brightnessOffset;
-            int oldA = alphaOffset;
-            hueOffset = 0;
-            saturationOffset = 0;
-            brightnessOffset = 0;
-            alphaOffset = 0;
-            firePropertyChange("hueOffset", oldH, getHueOffset());
-            firePropertyChange("saturationOffset", oldS, getSaturationOffset());
-            firePropertyChange("brightnessOffset", oldB, getBrightnessOffset());
-            firePropertyChange("alphaOffset", oldA, getAlphaOffset());
-        }
-        updateARGBFromOffsets();
-    }
-
-    /**
-     * Sets the property to use for extracting the color for whatever component
-     * is passed to the painter. Can be a key in client properties. Can be null.
-     * @param name
-     */
-    public void setComponentPropertyName(String name) {
-        String old = componentPropertyName;
-        firePropertyChange("componentPropertyName", old, componentPropertyName = name);
-    }
-
-    /**
-     * Gets the name of the bean property, or client property, on this component
-     * from which to extract a color used for painting. So for example the color
-     * used in a painter could be the background of the component.
-     *
-     * @return
-     */
-    public String getComponentPropertyName() {
-        return componentPropertyName;
-    }
-
-    /**
-     * Sets whether this color should be represented as a UIResource in UIDefaults
-     * @param b true if the color should be a ui resource
-     */
-    public void setUiResource(boolean b) {
-        boolean old = uiResource;
-        firePropertyChange("uiResource", old, uiResource = b);
-    }
-
-    /**
-     * When false this color will become a non-UIResource in the UIManager defaults
-     * table. This is sometimes required to force swing to use the given color,
-     * such as with renderers.
-     * @return false if the color should not be a uiresource
-     */
-    public boolean isUiResource() {
-        return uiResource;
-    }
-
-    public float getHueOffset() {
-        return hueOffset;
-    }
-
-    public void setHueOffset(float hueOffset) {
-        float old = getHueOffset();
-        this.hueOffset = hueOffset;
-        firePropertyChange("hueOffset", old, getHueOffset());
-        updateARGBFromOffsets();
-    }
-
-    public float getSaturationOffset() {
-        return saturationOffset;
-    }
-
-    public void setSaturationOffset(float satOffset) {
-        float old = getSaturationOffset();
-        this.saturationOffset = satOffset;
-        firePropertyChange("saturationOffset", old, getSaturationOffset());
-        updateARGBFromOffsets();
-    }
-
-    public float getBrightnessOffset() {
-        return brightnessOffset;
-    }
-
-    public void setBrightnessOffset(float brightOffset) {
-        float old = getBrightnessOffset();
-        this.brightnessOffset = brightOffset;
-        firePropertyChange("brightnessOffset", old, getBrightnessOffset());
-        updateARGBFromOffsets();
-    }
-
-    public int getAlphaOffset() {
-        return alphaOffset;
-    }
-
-    public void setAlphaOffset(int alphaOffset) {
-        int old = getAlphaOffset();
-        this.alphaOffset = alphaOffset;
-        firePropertyChange("alphaOffset", old, alphaOffset);
-        updateARGBFromOffsets();
-    }
-
-
-    public void setRed(int red) {
-        red = clamp(red);
-        if (this.red != red) {
-            Color old = getColor();
-            int oldr = this.red;
-            this.red = red;
-            firePropertyChange("paint", old, getColor());
-            firePropertyChange("color", old, getColor());
-            firePropertyChange("red", oldr, red);
-            fireHSBChange(oldr, green, blue);
-            updateOffsetsFromARGB();
-        }
-    }
-
-    public final int getRed() {
-        return red;
-    }
-
-    public void setGreen(int green) {
-        green = clamp(green);
-        if (this.green != green) {
-            Color old = getColor();
-            int oldg = this.green;
-            this.green = green;
-            firePropertyChange("paint", old, getColor());
-            firePropertyChange("color", old, getColor());
-            firePropertyChange("green", oldg, green);
-            fireHSBChange(red, oldg, blue);
-            updateOffsetsFromARGB();
-        }
-    }
-
-    public final int getGreen() {
-        return green;
-    }
-
-    public void setBlue(int blue) {
-        blue = clamp(blue);
-        if (this.blue != blue) {
-            Color old = getColor();
-            int oldb = this.blue;
-            this.blue = blue;
-            firePropertyChange("paint", old, getColor());
-            firePropertyChange("color", old, getColor());
-            firePropertyChange("blue", oldb, blue);
-            fireHSBChange(red, green, oldb);
-            updateOffsetsFromARGB();
-        }
-    }
-
-    public final int getBlue() {
-        return blue;
-    }
-
-    public void setAlpha(int alpha) {
-        alpha = clamp(alpha);
-        if (this.alpha != alpha) {
-            int old = getAlpha();
-            this.alpha = alpha;
-            firePropertyChange("alpha", old, alpha);
-            firePropertyChange("paint", old, getColor());
-            firePropertyChange("color", old, getColor());
-            updateOffsetsFromARGB();
-        }
-    }
-
-    public final int getAlpha() {
-        return alpha;
-    }
-
-    public Color getColor() {
-        if (cached == null || red != cached.getRed() || green != cached.getGreen() ||
-                blue != cached.getBlue() || alpha != cached.getAlpha()) {
-            cached = new Color(red, green, blue, alpha);
-        }
-        return cached;
-    }
-
-    public void setColor(Color c) {
-        setColor(c, false);
-    }
-
-    public void setColor(Color c, boolean dontSetAlpha) {
-        Color oldColor = getColor();
-        int oldR = red, oldG = green, oldB = blue, oldA = alpha;
-        cached = c;
-        red = c.getRed();
-        green = c.getGreen();
-        blue = c.getBlue();
-        if (!dontSetAlpha) alpha = c.getAlpha();
-        updateOffsetsFromARGB();
-        firePropertyChange("red", oldR, getRed());
-        firePropertyChange("green", oldG, getGreen());
-        firePropertyChange("blue", oldB, getBlue());
-        fireHSBChange(oldR, oldG, oldB);
-        if (!dontSetAlpha) firePropertyChange("alpha", oldA, getAlpha());
-        firePropertyChange("paint", oldColor, getColor());
-        firePropertyChange("color", oldColor, getColor());
-    }
-
-    @Override public Paint getPaint() {
-        return getColor();
-    }
-
-
-    @Override public String toString() {
-        if (isAbsolute()) {
-            return Matte.class.getName() + "[r=" + red + ", g=" + green + ", b=" + blue + ", a=" + alpha + "]";
-        } else {
-            return Matte.class.getName() + "[base=" + uiDefaultParentName + ", H+" + hueOffset +
-                    ", S+" + saturationOffset + ", B+" + brightnessOffset + ", A+" + alphaOffset + "]";
-        }
-    }
-
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        Matte matte = (Matte) o;
-        if (alpha != matte.alpha) return false;
-        if (alphaOffset != matte.alphaOffset) return false;
-        if (Float.compare(matte.alpha, alpha) != 0) return false;
-        if (blue != matte.blue) return false;
-        if (Float.compare(matte.brightnessOffset, brightnessOffset) != 0)
-            return false;
-        if (green != matte.green) return false;
-        if (Float.compare(matte.hueOffset, hueOffset) != 0) return false;
-        if (red != matte.red) return false;
-        if (uiResource != matte.uiResource) return false;
-        if (Float.compare(matte.saturationOffset, saturationOffset) != 0)
-            return false;
-        if (componentPropertyName != null ?
-                !componentPropertyName.equals(componentPropertyName) :
-                matte.componentPropertyName != null) return false;
-
-        if (uiDefaultParentName != null ?
-                !uiDefaultParentName.equals(matte.uiDefaultParentName) :
-                matte.uiDefaultParentName != null) return false;
-        return true;
-    }
-
-    public int hashCode() {
-        int result;
-        result = red;
-        result = 31 * result + green;
-        result = 31 * result + blue;
-        result = 31 * result + alpha;
-        result = 31 * result + (uiDefaultParentName != null ?
-            uiDefaultParentName.hashCode() : 0);
-        result = 31 * result + (componentPropertyName != null ?
-            componentPropertyName.hashCode() : 0);
-        result = 31 * result + hueOffset != +0.0f ?
-            Float.floatToIntBits(hueOffset) : 0;
-        result = 31 * result + saturationOffset != +0.0f ?
-            Float.floatToIntBits(saturationOffset) : 0;
-        result = 31 * result + brightnessOffset != +0.0f ?
-            Float.floatToIntBits(brightnessOffset) : 0;
-        result = 31 * result + (uiResource ? 1 : 0);
-        return result;
-    }
-
-    @Override public Matte clone() {
-        Matte m = new Matte();
-        m.red = red;
-        m.green = green;
-        m.blue = blue;
-        m.alpha = alpha;
-        m.brightnessOffset = brightnessOffset;
-        m.hueOffset = hueOffset;
-        m.saturationOffset = saturationOffset;
-        m.alphaOffset = alphaOffset;
-        m.uiDefaultParentName = uiDefaultParentName;
-        m.componentPropertyName = componentPropertyName;
-        m.uiResource = uiResource;
-        m.setUiDefaults(uiDefaults);
-        return m;
-    }
-
-    // =================================================================================================================
-    // Private Helper Methods
-
-    private void updateOffsetsFromARGB() {
-        if (!isAbsolute()) {
-            tmpf1 = Color.RGBtoHSB(red, green, blue, tmpf1);
-            Color parentColor = uiDefaults.getColor(uiDefaultParentName);
-            tmpf2 = Color.RGBtoHSB(parentColor.getRed(), parentColor.getGreen(), parentColor.getBlue(), tmpf2);
-            // update offset properties and fire events
-            float oldH = hueOffset, oldS = saturationOffset, oldB = brightnessOffset;
-            int oldA = alphaOffset;
-            hueOffset = tmpf1[0] - tmpf2[0];
-            saturationOffset = tmpf1[1] - tmpf2[1];
-            brightnessOffset = tmpf1[2] - tmpf2[2];
-            alphaOffset = alpha - parentColor.getAlpha();
-            firePropertyChange("hueOffset", oldH, getHueOffset());
-            firePropertyChange("saturationOffset", oldS, getSaturationOffset());
-            firePropertyChange("brightnessOffset", oldB, getBrightnessOffset());
-            firePropertyChange("alphaOffset", oldA, getAlphaOffset());
-        }
-    }
-
-    private void updateARGBFromOffsets() {
-        if (!isAbsolute()) {
-            Color oldColor = getColor();
-            // get parent color HSB
-            Color parentColor = uiDefaults.getColor(uiDefaultParentName);
-            tmpf1 = Color.RGBtoHSB(parentColor.getRed(), parentColor.getGreen(), parentColor.getBlue(), tmpf1);
-            // apply offsets
-            tmpf1[0] = clamp(tmpf1[0] + hueOffset);
-            tmpf1[1] = clamp(tmpf1[1] + saturationOffset);
-            tmpf1[2] = clamp(tmpf1[2] + brightnessOffset);
-            int oldA = getAlpha();
-            alpha = clamp(parentColor.getAlpha() + alphaOffset);
-            updateRGB(tmpf1);
-            // update fire events
-            firePropertyChange("alpha", oldA, getAlpha());
-            firePropertyChange("paint", oldColor, getColor());
-            firePropertyChange("color", oldColor, getColor());
-        }
-    }
-
-    private void updateRGB(float[] hsb) {
-        int oldR = red, oldG = green, oldB = blue;
-        int rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);
-        red = (rgb >> 16) & 0xFF;
-        green = (rgb >> 8) & 0xFF;
-        blue = rgb & 0xFF;
-        firePropertyChange("red", oldR, getRed());
-        firePropertyChange("green", oldG, getGreen());
-        firePropertyChange("blue", oldB, getBlue());
-    }
-
-    private void fireHSBChange(int oldR, int oldG, int oldB) {
-        tmpf1 = Color.RGBtoHSB(oldR, oldG, oldB, tmpf1);
-        tmpf2 = Color.RGBtoHSB(red, green, blue, tmpf2);
-        firePropertyChange("hue", tmpf1[0], tmpf2[0]);
-        firePropertyChange("saturation", tmpf1[1], tmpf2[1]);
-        firePropertyChange("brightness", tmpf1[2], tmpf2[2]);
-    }
-
-    private float clamp(float value) {
-        if (value < 0) {
-            value = 0;
-        } else if (value > 1) {
-            value = 1;
-        }
-        return value;
-    }
-
-    private int clamp(int value) {
-        if (value < 0) {
-            value = 0;
-        } else if (value > 255) {
-            value = 255;
-        }
-        return value;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/PaintModel.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,64 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import org.jdesktop.beans.AbstractBean;
-
-import java.awt.Paint;
-
-/**
- * I'd have just called it Paint, but sadly, that name was already taken, and would have been too confusing.
- * <p/>
- * Whenever size or position values are required (for example with Texture or Gradient), they are specified in the unit
- * square: that is, between 0 and 1 inclusive. They can then later be scaled as necessary by any painting code.
- *
- * @author rbair
- */
-public abstract class PaintModel extends AbstractBean implements Cloneable {
-    public static enum PaintControlType {
-        none, control_line, control_rect
-    }
-
-    protected PaintModel() { }
-
-    /**
-     * @return an instance of Paint that is represented by this PaintModel. This is often not a reversable operation,
-     *         and hence there is no "setPaint" method. Rather, tweaking the exposed properties of the PaintModel fires,
-     *         when necessary, property change events for the "paint" property, and results in different values returned
-     *         from this method.
-     */
-    public abstract Paint getPaint();
-
-    /**
-     * Get the type of controls for this paint model
-     *
-     * @return The type of paint controls, one of PaintControlType.none, PaintControlType.control_line or
-     *         PaintControlType.control_rect
-     */
-    public abstract PaintControlType getPaintControlType();
-
-
-    public abstract PaintModel clone();
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/RadialGradient.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import java.awt.Color;
-import java.awt.MultipleGradientPaint.CycleMethod;
-import java.awt.Paint;
-import java.awt.RadialGradientPaint;
-
-/**
- * Represents a RadialGradientPaint.
- *
- * @author rbair
- */
-public class RadialGradient extends AbstractGradient {
-    protected Paint createPaint(float[] fractions, Matte[] mattes, CycleMethod method) {
-        Color[] colors = new Color[mattes.length];
-        for (int i = 0; i < colors.length; i++) {
-            colors[i] = mattes[i].getColor();
-        }
-        return new RadialGradientPaint(.5f, .5f, 1, fractions, colors, method);
-    }
-
-    @Override public RadialGradient clone() {
-        RadialGradient gradient = new RadialGradient();
-        copyTo(gradient);
-        return gradient;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/paint/Texture.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.paint;
-
-import java.awt.Paint;
-import java.awt.TexturePaint;
-import java.awt.geom.Rectangle2D;
-import java.awt.image.BufferedImage;
-
-/**
- * Represents a TexturePaint.
- *
- * @author rbair
- */
-public class Texture extends PaintModel {
-    private static final Rectangle2D RECT = new Rectangle2D.Double(0, 0, 1, 1);
-    private BufferedImage img;
-
-    public Texture() {
-    }
-
-    public PaintControlType getPaintControlType() {
-        return PaintControlType.control_rect;
-    }
-
-    public void setImage(BufferedImage img) {
-        BufferedImage old = this.img;
-        this.img = img;
-        firePropertyChange("paint", old, this.img);
-        firePropertyChange("image", old, this.img);
-    }
-
-    public final BufferedImage getImage() {
-        return img;
-    }
-
-    public Paint getPaint() {
-        return new TexturePaint(img, RECT);
-    }
-
-
-    public Texture clone() {
-        Texture newTexture = new Texture();
-        newTexture.img = this.img;
-        return newTexture;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/utils/HasPath.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,34 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.utils;
-
-/**
- * HasPath - interface for model nodes that can provide there path in the tree
- *
- * @author Created by Jasper Potts (Jul 2, 2007)
- */
-public interface HasPath {
-    public String getPath();
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/utils/HasResources.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,42 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.utils;
-
-import java.io.File;
-
-/**
- * HasResources - interface for model nodes that have resources
- *
- * @author Created by Jasper Potts (Jul 2, 2007)
- */
-public interface HasResources {
-
-    public File getResourcesDir();
-
-    public File getImagesDir();
-
-    public File getTemplatesDir();
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/swingx/designer/utils/HasUIDefaults.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,36 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.swingx.designer.utils;
-
-import javax.swing.UIDefaults;
-
-/**
- * HasUIDefaults - A tagging interface for any class that has UIDefaults
- *
- * @author Created by Jasper Potts (Jun 22, 2007)
- */
-public interface HasUIDefaults {
-    public UIDefaults getUiDefaults();
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/DefaultsGenerator.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,726 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import org.jdesktop.swingx.designer.Canvas;
-import org.jdesktop.swingx.designer.font.Typeface;
-import org.jdesktop.swingx.designer.paint.Matte;
-import org.jdesktop.swingx.designer.paint.PaintModel;
-import static org.jdesktop.synthdesigner.generator.GeneratorUtils.makePretty;
-import static org.jdesktop.synthdesigner.generator.GeneratorUtils.toConstantName;
-import static org.jdesktop.synthdesigner.generator.ObjectCodeConvertors.convert;
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.read;
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.writeSrcFile;
-import org.jdesktop.synthdesigner.synthmodel.SynthModel;
-import org.jdesktop.synthdesigner.synthmodel.UIComponent;
-import org.jdesktop.synthdesigner.synthmodel.UIFont;
-import org.jdesktop.synthdesigner.synthmodel.UIIconRegion;
-import org.jdesktop.synthdesigner.synthmodel.UIPaint;
-import org.jdesktop.synthdesigner.synthmodel.UIProperty;
-import org.jdesktop.synthdesigner.synthmodel.UIRegion;
-import org.jdesktop.synthdesigner.synthmodel.UIState;
-import org.jdesktop.synthdesigner.synthmodel.UIStateType;
-import org.jdesktop.synthdesigner.synthmodel.UIStyle;
-
-import javax.swing.border.BevelBorder;
-import javax.swing.border.Border;
-import javax.swing.border.CompoundBorder;
-import javax.swing.border.EmptyBorder;
-import javax.swing.border.EtchedBorder;
-import javax.swing.border.LineBorder;
-import javax.swing.border.MatteBorder;
-import java.awt.Dimension;
-import java.awt.Font;
-import java.awt.Insets;
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-import org.jdesktop.synthdesigner.synthmodel.PainterBorder;
-
-/**
- * DefaultsGenerator
- * <p/>
- * There are two main sets of defaults that must be configured. The first is
- * the actual UI defaults tree. The second is a map of components + regions, which
- * are used to decide what SynthStyle to use.
- *
- * @author Jasper Potts
- * @author Richard Bair
- */
-public class DefaultsGenerator {
-    private static String stateTypeImplTemplate;
-
-    private static String getStateTypeTemplate() {
-        if (stateTypeImplTemplate == null) {
-            //load the painter template file into an in-memory string to improve performance
-            //when generating a lot of classes
-            try {
-                stateTypeImplTemplate = read("resources/StateImpl.template");
-            } catch (IOException e) {
-                System.err.println("Failed to read template files.");
-                throw new RuntimeException(e);
-            }
-        }
-        return stateTypeImplTemplate;
-    }
-
-    /**
-     * Generate the defaults file and all painter files for a SynthModel. This method
-     * is the main entry point, called by the Generator class.
-     *
-     * @param uiDefaultInit      The buffer to write ui default put methods of the form <code>d.put("activeCaption", new
-     *                           ColorUIResource(123, 45, 200));</code>
-     * @param styleInit          The buffer to write out code to generate Synth Style populating the styles map <code>m
-     *                           = new HashMap<Key, LazyStyle>()</code>
-     * @param model              The Synth Model we are writing out defaults class for
-     * @param variables          The variables map pre populated with "PACKAGE" and "LAF_NAME"
-     * @param packageNamePrefix  The package name associated with this synth look and feel. For example,
-     *                           org.mypackage.mylaf
-     * @param painterPackageRoot The directory to write painters out to
-     */
-    public static void generateDefaults(StringBuilder uiDefaultInit, StringBuilder styleInit, SynthModel model,
-                                        Map<String, String> variables, String packageNamePrefix,
-                                        File painterPackageRoot) {
-        // write color palette
-        uiDefaultInit.append("        //Color palette\n");
-        writeColorPalette(uiDefaultInit, model.getColorPalette());
-        uiDefaultInit.append("\n");
-        // write fonts palette
-        uiDefaultInit.append("        //Font palette\n");
-        uiDefaultInit.append("        d.put(\"defaultFont\", new FontUIResource(defaultFont));\n");
-        writeFontPalette(uiDefaultInit, model.getFontPalette());
-        uiDefaultInit.append("\n");
-        // TODO: Other palettes
-        uiDefaultInit.append("        //Border palette\n");
-        uiDefaultInit.append("\n");
-        // write global style
-        uiDefaultInit.append("        //The global style definition\n");
-        writeStyle(model.getStyle(), uiDefaultInit, "");
-        uiDefaultInit.append("\n");
-        // write components
-        for (UIComponent c : model.getComponents()) {
-            String prefix = escape(c.getKey());
-            uiDefaultInit.append("        //Initialize ").append(prefix)
-                    .append("\n");
-            writeRegion(c, c, prefix, uiDefaultInit,
-                    styleInit, variables, packageNamePrefix, painterPackageRoot);
-            uiDefaultInit.append("\n");
-        }
-    }
-
-    private static void writeColorPalette(StringBuilder uiDefaultInit, List<UIPaint> colors) {
-        for (UIPaint color : colors) {
-            uiDefaultInit.append("        d.put(\"")
-                    .append(color.getName())
-                    .append("\",")
-                    .append(convertPaint(color.getValue()))
-                    .append(");\n");
-        }
-    }
-
-    private static void writeFontPalette(StringBuilder uiDefaultInit, List<UIFont> fonts) {
-        for (UIFont font : fonts) {
-            // We have no way of doing CSS style font lists yet so will just
-            // just the first font
-            if (!font.getFonts().isEmpty()){
-                Typeface t = font.getFonts().get(0);
-                if (t.isAbsolute()){
-                    Font f = t.getFont();
-                    uiDefaultInit.append("        d.put(\"")
-                        .append(font.getName())
-                        .append("\", new javax.swing.plaf.FontUIResource(\"")
-                        .append(f.getName())
-                        .append("\", ")
-                        .append(f.getStyle())
-                        .append(", ")
-                        .append(f.getSize())
-                        .append("));\n");
-                } else {
-                    uiDefaultInit.append("        d.put(\"")
-                        .append(font.getName())
-                        .append("\", new DerivedFont(\"")
-                        .append(t.getUiDefaultParentName())
-                        .append("\", ")
-                        .append(t.getSizeOffset())
-                        .append("f, ");
-                    switch (t.getBold()){
-                        case Default:
-                            uiDefaultInit.append("null");
-                            break;
-                        case On:
-                            uiDefaultInit.append("true");
-                            break;
-                        case Off:
-                            uiDefaultInit.append("false");
-                            break;
-                    }
-                    uiDefaultInit.append(", ");
-                    switch (t.getItalic()){
-                        case Default:
-                            uiDefaultInit.append("null");
-                            break;
-                        case On:
-                            uiDefaultInit.append("true");
-                            break;
-                        case Off:
-                            uiDefaultInit.append("false");
-                            break;
-                    }
-                    uiDefaultInit.append("));\n");
-                }
-            }
-        }
-    }
-
-    /**
-     * Write out the UIDefaults entries for a style
-     *
-     * @param style         The style to write defaults entries for
-     * @param uiDefaultInit The buffer to write ui default put methods of the form <code>d.put("activeCaption", new
-     *                      ColorUIResource(123, 45, 200));</code>
-     * @param prefix        The prefix for the style property names, for the model path where the style is from, should
-     *                      end with a "."
-     */
-    private static void writeStyle(UIStyle style, StringBuilder uiDefaultInit, String prefix) {
-        if (!style.isTextForegroundInherited()) writeMatte(prefix + "textForeground", style.getTextForeground(), uiDefaultInit);
-        if (!style.isTextBackgroundInherited()) writeMatte(prefix + "textBackground", style.getTextBackground(), uiDefaultInit);
-        if (!style.isBackgroundInherited()) writeMatte(prefix + "background", style.getBackground(), uiDefaultInit);
-        if (!style.isFontInherited()) writeTypeFace(prefix + "font", style.getFont(), uiDefaultInit);
-        for (UIProperty property : style.getUiProperties()) {
-            switch (property.getType()) {
-                case BOOLEAN:
-                    Boolean b = ((Boolean)property.getValue());
-                    if (b != null) {
-                        uiDefaultInit.append("        d.put(\"")
-                                .append(prefix)
-                                .append(property.getName())
-                                .append("\", ")
-                                .append(b ? "Boolean.TRUE" : "Boolean.FALSE")
-                                .append(");\n");
-                    }
-                    break;
-                case STRING:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", \"")
-                            .append(property.getValue().toString())
-                            .append("\");\n");
-                    break;
-                case INT:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new Integer(")
-                            .append(((Integer) property.getValue()).intValue())
-                            .append("));\n");
-                    break;
-                case FLOAT:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new Float(")
-                            .append(((Float) property.getValue()).floatValue())
-                            .append("f));\n");
-                    break;
-                case DOUBLE:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new Double(")
-                            .append(((Double) property.getValue()).doubleValue())
-                            .append("));\n");
-                    break;
-                case COLOR:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", ")
-                            .append(convertPaint((Matte)property.getValue()))
-                            .append(");\n");
-                    break;
-                case FONT:
-                    writeTypeFace(prefix.replace("\"", "\\\"") + property.getName(),
-                            (Typeface) property.getValue(), uiDefaultInit);
-                    break;
-                case INSETS:
-                    Insets i = (Insets) property.getValue();
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new InsetsUIResource(")
-                            .append(i.top).append(", ").append(i.left).append(", ").append(i.bottom).append(", ")
-                            .append(i.right)
-                            .append("));\n");
-                    break;
-                case DIMENSION:
-                    Dimension d = (Dimension) property.getValue();
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new DimensionUIResource(")
-                            .append(d.width).append(", ").append(d.height)
-                            .append("));\n");
-                    break;
-                case BORDER:
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(property.getName())
-                            .append("\", new BorderUIResource(");
-                    uiDefaultInit.append(convertBorder(
-                            (Border)property.getValue()));
-                    uiDefaultInit.append("));\n");
-                    break;
-            }
-        }
-    }
-
-    private static void writeMatte(String propertyName, Matte matte, StringBuilder uiDefaultInit) {
-        if (matte==null) System.err.println("Error matte is NULL for ["+propertyName+"]");
-        uiDefaultInit.append("        d.put(\"")
-                    .append(propertyName)
-                    .append("\", ")
-                    .append(convertPaint(matte))
-                    .append(");\n");
-    }
-
-    private static void writeTypeFace(String propertyName, Typeface typeface, StringBuilder uiDefaultInit) {
-        uiDefaultInit.append("        d.put(\"")
-                .append(propertyName)
-                .append("\", new DerivedFont(\"")
-                .append(typeface.getUiDefaultParentName())
-                .append("\", ")
-                .append(typeface.getSizeOffset())
-                .append("f, ");
-        switch (typeface.getBold()) {
-            case Default:
-                uiDefaultInit.append("null,");
-                break;
-            case Off:
-                uiDefaultInit.append("Boolean.FALSE,");
-                break;
-            case On:
-                uiDefaultInit.append("Boolean.TRUE,");
-                break;
-        }
-        switch (typeface.getItalic()) {
-            case Default:
-                uiDefaultInit.append("null");
-                break;
-            case Off:
-                uiDefaultInit.append("Boolean.FALSE");
-                break;
-            case On:
-                uiDefaultInit.append("Boolean.TRUE");
-                break;
-        }
-        uiDefaultInit.append("));\n");
-    }
-
-
-    /**
-     * Write out code for a Component or Region
-     *
-     * @param comp               This may be the same as the region <code>reg</code> or is the parent component
-     *                           containing the region
-     * @param region             The region we are writing out
-     * @param prefix             This is dot sperated path of component and sub regions to and including the region
-     *                           <code>reg</code> of the form [Comp].[Region]......[Region] path
-     * @param uiDefaultInit      This is for inserting into org.mypackage.mylaf.MyDefaults#getDefaults() method
-     * @param styleInit          This is for inserting into org.mypackage.mylaf.MyDefaults#initialize() method
-     * @param variables          The variables map pre populated with "PACKAGE" and "LAF_NAME"
-     * @param packageNamePrefix  The package name associated with this synth look and feel. For example,
-     *                           org.mypackage.mylaf
-     * @param painterPackageRoot The directory to write painters out to
-     */
-    private static void writeRegion(UIComponent comp, UIRegion region, String prefix, StringBuilder uiDefaultInit,
-                                    StringBuilder styleInit, Map<String, String> variables,
-                                    String packageNamePrefix, File painterPackageRoot) {
-        // register component with LAF
-        String regionCode = GeneratorUtils.getRegionNameCaps(region.getName());
-        if (regionCode == null) {
-            throw new IllegalStateException("We were asked to encode a region we know nothing about: " + region.getName());
-        } else {
-            regionCode = "Region." + regionCode;
-        }
-
-        //construct the list of States that accompany this registration.
-        StringBuffer regString = new StringBuffer(); //like: Enabled,Disabled,Foo,Default,Etc
-        List<UIStateType> types = comp.getStateTypes(); //state types are only defined on the UIComponent level
-        if (types != null && types.size() > 0) {
-            for (UIStateType type : types) {
-                regString.append(type.getKey());
-                regString.append(",");
-            }
-            //remove the last ","
-            regString.deleteCharAt(regString.length()-1);
-        }
-
-        styleInit.append("        register(")
-                .append(regionCode)
-                .append(", \"")
-                .append(prefix);
-        styleInit.append("\"");
-        styleInit.append(");\n");
-
-        // write content margins
-        Insets i = (Insets) region.getContentMargins();
-        uiDefaultInit.append("        d.put(\"")
-                .append(prefix)
-                .append(".contentMargins")
-                .append("\", new InsetsUIResource(")
-                .append(i.top).append(", ").append(i.left).append(", ").append(i.bottom).append(", ").append(i.right)
-                .append("));\n");
-        // write opaque if true
-        if (region instanceof UIComponent && ((UIComponent)region).isOpaque()) {
-            uiDefaultInit.append("        d.put(\"")
-                    .append(prefix)
-                    .append(".opaque")
-                    .append("\", Boolean.TRUE);\n");
-        }
-        //write the State, if necessary
-        if (!regString.equals("Enabled,MouseOver,Pressed,Disabled,Focused,Selected,Default") && types.size() > 0) {
-            //there were either custom states, or the normal states were in a custom order
-            //so go ahead and write out prefix.State
-            uiDefaultInit.append("        d.put(\"")
-                    .append(prefix)
-                    .append(".States")
-                    .append("\", \"")
-                    .append(regString)
-                    .append("\");\n");
-        }
-        //write out any custom states, if necessary
-        for (UIStateType type : types) {
-            String synthState = type.getKey();
-            if (!"Enabled".equals(synthState) &&
-                !"MouseOver".equals(synthState) &&
-                !"Pressed".equals(synthState) &&
-                !"Disabled".equals(synthState) &&
-                !"Focused".equals(synthState) &&
-                !"Selected".equals(synthState) &&
-                !"Default".equals(synthState)) {
-                //what we have here, gentlemen, is a bona-fide custom state.
-                try {
-                    //if the type is not one of the standard types, then construct a name for
-                    //the new type, and write out a new subclass of State.
-                    java.lang.String className = makePretty(prefix) + synthState + "State";
-                    java.lang.String body = type.getCodeSnippet();
-                    variables.put("STATE_NAME", className);
-                    variables.put("STATE_KEY", synthState);
-                    variables.put("BODY", body);
-
-                    writeSrcFile(getStateTypeTemplate(), variables, new java.io.File(painterPackageRoot, className + ".java"));
-
-                    variables.remove("STATE_NAME");
-                    variables.remove("STATE_KEY");
-                    variables.remove("BODY");
-
-                    uiDefaultInit.append("        d.put(\"")
-                            .append(prefix)
-                            .append(".")
-                            .append(synthState)
-                            .append("\", new ")
-                            .append(className)
-                            .append("());\n");
-                } catch (IOException ex) {
-                    ex.printStackTrace();
-                }
-            }
-        }
-        // write region style
-        writeStyle(region.getStyle(), uiDefaultInit, prefix + ".");
-
-        try {
-            boolean hasCanvas = hasCanvas(region);
-            if (hasCanvas) {
-                PainterGenerator.writePainter(region, variables, painterPackageRoot, prefix);
-            }
-            String fileNamePrefix = makePretty(prefix) + "Painter";
-            // write states ui defaults
-            for (UIState state : region.getBackgroundStates()) {
-                String statePrefix = prefix + "[" + state.getName() + "]";
-                // write state style
-                writeStyle(state.getStyle(), uiDefaultInit, statePrefix + ".");
-                // write painter
-                if (hasCanvas) {
-                    writeLazyPainter(state, uiDefaultInit, statePrefix, packageNamePrefix, fileNamePrefix, "background");
-                }
-            }
-            for (UIState state : region.getForegroundStates()) {
-                String statePrefix = prefix + "[" + state.getName() + "]";
-                // write state style
-                writeStyle(state.getStyle(), uiDefaultInit, statePrefix + ".");
-                // write painter
-                if (hasCanvas) {
-                    writeLazyPainter(state, uiDefaultInit, statePrefix, packageNamePrefix, fileNamePrefix, "foreground");
-                }
-            }
-            for (UIState state : region.getBorderStates()) {
-                String statePrefix = prefix + "[" + state.getName() + "]";
-                // write state style
-                writeStyle(state.getStyle(), uiDefaultInit, statePrefix + ".");
-                // write painter
-                if (hasCanvas) {
-                    writeLazyPainter(state, uiDefaultInit, statePrefix, packageNamePrefix, fileNamePrefix, "border");
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        // handle sub regions
-        for (UIRegion subRegion : region.getSubRegions()) {
-            String subregionName = prefix + ":" + escape(subRegion.getKey());
-            if (subRegion instanceof UIIconRegion) {
-                writeIconRegion(comp, (UIIconRegion) subRegion, prefix, uiDefaultInit,
-                        variables, packageNamePrefix, painterPackageRoot);
-            } else if (subRegion instanceof UIComponent) {
-                // inner named component
-                UIComponent subComponent = (UIComponent) subRegion;
-                writeRegion(subComponent, subRegion, subregionName,
-                        uiDefaultInit, styleInit, variables, packageNamePrefix, painterPackageRoot);
-            } else {
-                writeRegion(comp, subRegion, subregionName, uiDefaultInit, styleInit, variables,
-                        packageNamePrefix, painterPackageRoot);
-            }
-        }
-    }
-
-    private static void writeLazyPainter(UIState state, StringBuilder uiDefaultInit, String statePrefix, String packageNamePrefix, String fileNamePrefix, String painterSuffix) {
-        Canvas canvas = state.getCanvas();
-        if (!canvas.isBlank()) {
-            Insets si = canvas.getStretchingInsets();
-            boolean inverted = state.isInverted();
-            UIStyle.CacheMode cache = state.getStyle().getCacheMode();
-            String cacheModeString = null;
-            switch (cache) {
-                case NO_CACHING: cacheModeString = "AbstractRegionPainter.PaintContext.CacheMode.NO_CACHING"; break;
-                case FIXED_SIZES: cacheModeString = "AbstractRegionPainter.PaintContext.CacheMode.FIXED_SIZES"; break;
-                case NINE_SQUARE_SCALE: cacheModeString = "AbstractRegionPainter.PaintContext.CacheMode.NINE_SQUARE_SCALE"; break;
-            }
-            double maxH = state.getStyle().getMaxHozCachedImgScaling();
-            double maxV = state.getStyle().getMaxVertCachedImgScaling();
-            String stateConstant = toConstantName(painterSuffix + "_" + UIState.keysToString(state.getStateKeys()));
-
-            uiDefaultInit.append("        d.put(\"")
-                    .append(statePrefix)
-                    .append(".").append(painterSuffix).append("Painter\", new LazyPainter(\"")
-                    .append(packageNamePrefix).append(".").append(fileNamePrefix)
-                    .append("\", ")
-                    .append(fileNamePrefix).append(".").append(stateConstant).append(", ")
-                    .append(convert(si)).append(", ")
-                    .append(convert(canvas.getSize())).append(", ")
-                    .append(inverted).append(", ")
-                    .append(cacheModeString).append(", ")
-                    .append(maxH == Double.POSITIVE_INFINITY ? "Double.POSITIVE_INFINITY" : maxH).append(", ")
-                    .append(maxV == Double.POSITIVE_INFINITY ? "Double.POSITIVE_INFINITY" : maxV).append("));\n");
-        }
-    }
-
-
-    /**
-     * Write out code for a IconRegion
-     *
-     * @param comp               This may be the same as the region <code>region</code> or is the parent component
-     *                           containing the region
-     * @param region             The region we are writing out
-     * @param prefix             This is [Comp][Region]......[Region] path
-     * @param key                The key for this icon.
-     * @param uiDefaultInit      This is for inserting into org.mypackage.mylaf.MyDefaults#getDefaults() method
-     * @param variables          The variables map pre populated with "PACKAGE" and "LAF_NAME"
-     * @param packageNamePrefix  The package name associated with this synth look and feel. For example,
-     *                           org.mypackage.mylaf
-     * @param painterPackageRoot The directory to write painters out to
-     */
-    private static void writeIconRegion(UIComponent comp, UIIconRegion region, String prefix,
-                                        StringBuilder uiDefaultInit, Map<String, String> variables,
-                                        String packageNamePrefix, File painterPackageRoot) {
-
-        Dimension size = null;
-        String fileNamePrefix = makePretty(prefix) + "Painter";
-        // write states ui defaults
-        for (UIState state : region.getBackgroundStates()) {// TODO: Handle Background,Foreground and Borders States Lists? Actually not sure that IconRegions need support borders or foregrounds
-            Canvas canvas = state.getCanvas();
-            if (!canvas.isBlank()) {
-                String statePrefix = prefix + "[" + state.getName() + "]";
-                // Put Painter in UiDefaults
-                writeLazyPainter(state, uiDefaultInit, statePrefix, packageNamePrefix, fileNamePrefix, region.getKey());
-                size = canvas.getSize();
-            }
-        }
-
-        if (size != null) {
-            // Put SynthIconImpl wrapper in UiDefaults
-            String key = region.getBasicKey() == null ? prefix + "." + region.getKey() : region.getBasicKey();
-            uiDefaultInit.append("        d.put(\"")
-                    .append(key)
-                    .append("\", new NimbusIcon(\"") //TODO should this be wrapped in an IconUIResource?
-                    .append(prefix)
-                    .append("\", \"")
-                    .append(region.getKey())
-                    .append("Painter")
-                    .append("\", ")
-                    .append(size.width)
-                    .append(", ")
-                    .append(size.height)
-                    .append("));\n");
-        }
-
-        // handle sub regions
-        if (region.getSubRegions().length > 0) {
-            // there is no meaning to a sub region inside a IconRegion
-            throw new IllegalStateException("You can not have sub regions inside UiIconRegions. \"" +
-                    comp.getSubRegions()[0].getName() + "\" is inside \""
-                    + prefix.substring(0, prefix.length() - 1) + "\"");
-        }
-    }
-
-    /**
-     * Utility method for escaping all double quotes with backslash double-quote.
-     */
-    private static String escape(String s) {
-        return s.replace("\"", "\\\"");
-    }
-
-    private static String convertPaint(PaintModel paint){
-        if (paint instanceof Matte){
-            Matte matte = (Matte)paint;
-            if (matte.isAbsolute()){
-                String colorParams = convert(matte.getColor());
-                if (matte.isUiResource()) {
-                    return "new ColorUIResource(" + colorParams + ")";
-                } else {
-                    return colorParams;
-                }
-            } else {
-                String s = "getDerivedColor(\"" +
-                            matte.getUiDefaultParentName()+"\","+
-                            matte.getHueOffset()+"f,"+matte.getSaturationOffset()+
-                            "f,"+matte.getBrightnessOffset()+"f,"+
-                            matte.getAlphaOffset();
-                if (matte.isUiResource()) {
-                    return s + ")";
-                } else {
-                    return s + ",false)";
-                }
-            }
-        } else {
-            //TODO: What about gradients etc here?
-            System.err.println("Error: Could not write paint in " +
-                    "DefaultsGenerator as it was not a Matte. = "+
-                    paint.getClass().getName());
-            return "";
-        }
-    }
-
-    private static String convertBorder(Border val) {
-        StringBuilder uiDefaultInit = new StringBuilder();
-        Insets i;
-        if (val instanceof PainterBorder) {
-            PainterBorder pb = (PainterBorder) val;
-            i = pb.getBorderInsets();
-            uiDefaultInit.append("new PainterBorder(\"")
-                    .append(pb.getPainterName())
-                    .append("\", new Insets(")
-                    .append(i.top).append(", ")
-                    .append(i.left).append(", ")
-                    .append(i.bottom).append(", ")
-                    .append(i.right)
-                    .append("))");
-        } else if (val instanceof EmptyBorder) {
-            i = ((EmptyBorder) val).getBorderInsets();
-            uiDefaultInit.append("BorderFactory.createEmptyBorder(")
-                    .append(i.top).append(", ")
-                    .append(i.left).append(", ")
-                    .append(i.bottom).append(", ")
-                    .append(i.right)
-                    .append(")");
-        } else if (val instanceof LineBorder) {
-            LineBorder border = (LineBorder) val;
-            uiDefaultInit.append("BorderFactory.createLineBorder(")
-                    .append(convert(border.getLineColor()))
-                    .append(",")
-                    .append(border.getThickness())
-                    .append(")");
-        } else if (val instanceof EtchedBorder) {
-            EtchedBorder border = (EtchedBorder) val;
-            uiDefaultInit.append("BorderFactory.createEtchedBorder(")
-                    .append(border.getEtchType())
-                    .append(",")
-                    .append(convert(border.getHighlightColor()))
-                    .append(",")
-                    .append(convert(border.getShadowColor()))
-                    .append(")");
-        } else if (val instanceof BevelBorder) {
-            BevelBorder border = (BevelBorder) val;
-            uiDefaultInit.append("BorderFactory.createEtchedBorder(")
-                    .append(border.getBevelType())
-                    .append(",")
-                    .append(convert(border.getHighlightOuterColor()))
-                    .append(",")
-                    .append(convert(border.getHighlightInnerColor()))
-                    .append(",")
-                    .append(convert(border.getShadowOuterColor()))
-                    .append(",")
-                    .append(convert(border.getShadowInnerColor()))
-                    .append(")");
-        } else if (val instanceof MatteBorder) {
-            MatteBorder border = (MatteBorder) val;
-            i = border.getBorderInsets();
-            uiDefaultInit.append("BorderFactory.createEmptyBorder(")
-                    .append(i.top).append(", ")
-                    .append(i.left).append(", ")
-                    .append(i.bottom).append(", ")
-                    .append(i.right).append(", ")
-                    .append(convert(border.getMatteColor()))
-                    .append(")");
-        } else if (val instanceof CompoundBorder) {
-            CompoundBorder border = (CompoundBorder) val;
-            uiDefaultInit.append("BorderFactory.createEmptyBorder(")
-                    .append(convertBorder(border.getOutsideBorder()))
-                    .append(",")
-                    .append(convertBorder(border.getInsideBorder()))
-                    .append(")");
-        }
-        return uiDefaultInit.toString();
-    }
-
-    private static boolean hasCanvas(UIRegion region) {
-        for (UIState s : region.getBackgroundStates()) {
-            if (!s.getCanvas().isBlank()) return true;
-        }
-        for (UIState s : region.getBorderStates()) {
-            if (!s.getCanvas().isBlank()) return true;
-        }
-        for (UIState s : region.getForegroundStates()) {
-            if (!s.getCanvas().isBlank()) return true;
-        }
-        for (UIRegion subregion : region.getSubRegions()) {
-            if (hasCanvas(subregion)) return true;
-        }
-        return false;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/Generator.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,289 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.read;
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.writeSrcFile;
-import org.jdesktop.synthdesigner.synthmodel.SynthModel;
-import org.jibx.runtime.BindingDirectory;
-import org.jibx.runtime.IBindingFactory;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Generates the various Java artifacts based on a SynthModel.
- * <p/>
- * Generated source files are split up among two different locations. There are those source files that are meant to be
- * edited (generally, only the LookAndFeel class itself) and those that are autogenerated (everything else).
- * <p/>
- * All autogenerated files are placed in "buildPackageRoot" and are package private. A LAF author (one who has access to
- * the generated sources) will be able to access any of the generated classes. Those referencing the library, however,
- * will only be able to access the main LookAndFeel class itself (since everything else is package private).
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class Generator {
-    /** A map of variables that are used for variable substitution in the template files. */
-    private Map<String, String> variables;
-
-    private boolean full = false;
-    private File buildPackageRoot;
-    private File srcPackageRoot;
-    private String packageNamePrefix;
-    private String lafName;
-    private SynthModel model;
-
-    /**
-     * MAIN APPLICATION
-     * <p/>
-     * This is for using the generator as part of the java build process
-     *
-     * @param args The commandline arguments
-     */
-    public static void main(String[] args) {
-        if (args.length == 0 || (args.length % 2) != 0) {
-            System.out.println("Usage: generator [-options]\n" +
-                    "    -full <true|false>     True if we should build the whole LAF or false for building just states and painters.\n" +
-                    "    -skinFile <value>      Path to the skin.laf file for the LAF to be generated from.\n" +
-                    "    -buildDir <value>      The directory beneath which the build-controlled artifacts (such as the Painters) should\n" +
-                    "                           be placed. This is the root directory beneath which the necessary packages and source\n" +
-                    "                           files will be created.\n" +
-                    "    -srcDir <value>        The directory beneath which the normal user-controlled artifacts (such as the core\n" +
-                    "                           LookAndFeel file) should be placed. These are one-time generated files. This is the root\n" +
-                    "                           directory beneath which the necessary packages and source files will be created.\n" +
-                    "    -resourcesDir <value>  The resources directory containing templates and images.\n" +
-                    "    -packagePrefix <value> The package name associated with this synth look and feel. For example,\n" +
-                    "                           \"org.mypackage.mylaf\"\n" +
-                    "    -lafName <value>       The name of the laf, such as \"MyLAF\".\n");
-        } else {
-            boolean full = false;
-            File skinFile = new File(System.getProperty("user.dir"));
-            File buildDir = new File(System.getProperty("user.dir"));
-            File srcDir = new File(System.getProperty("user.dir"));
-            File resourcesDir = new File(System.getProperty("user.dir"));
-            String packagePrefix = "org.mypackage.mylaf";
-            String lafName = "MyLAF";
-            for (int i = 0; i < args.length; i += 2) {
-                String key = args[i].trim().toLowerCase();
-                String value = args[i + 1].trim();
-                if ("-full".equals(key)) {
-                    full = Boolean.parseBoolean(value);
-                } else if ("-skinfile".equals(key)) {
-                    skinFile = new File(value);
-                } else if ("-builddir".equals(key)) {
-                    buildDir = new File(value);
-                } else if ("-srcdir".equals(key)) {
-                    srcDir = new File(value);
-                } else if ("-resourcesdir".equals(key)) {
-                    resourcesDir = new File(value);
-                } else if ("-packageprefix".equals(key)) {
-                    packagePrefix = value;
-                } else if ("-lafname".equals(key)) {
-                    lafName = value;
-                }
-            }
-            System.out.println("### GENERATING LAF CODE ################################");
-            System.out.println("   full          :" + full);
-            System.out.println("   skinFile      :" + skinFile.getAbsolutePath());
-            System.out.println("   buildDir      :" + buildDir.getAbsolutePath());
-            System.out.println("   srcDir        :" + srcDir.getAbsolutePath());
-            System.out.println("   resourcesDir  :" + resourcesDir.getAbsolutePath());
-            System.out.println("   packagePrefix :" +packagePrefix);
-            System.out.println("   lafName       :" +lafName);
-            try {
-                // LOAD SKIN MODEL
-                IBindingFactory bindingFactory = BindingDirectory.getFactory(SynthModel.class);
-                IUnmarshallingContext mctx = bindingFactory.createUnmarshallingContext();
-                mctx.setDocument(new FileInputStream(skinFile), "UTF-8");
-                // pass resources directory in as user context so it can be used in SynthModel preSet
-                mctx.setUserContext(resourcesDir);
-                SynthModel model = (SynthModel) mctx.unmarshalElement();
-                // create and run generator
-                Generator generator = new Generator(full, buildDir, srcDir, packagePrefix, lafName, model);
-                generator.generate();
-            } catch (Exception e) {
-                System.err.println("Error loading skin and generating java src:");
-                e.printStackTrace();
-            }
-        }
-    }
-
-    /**
-     * Creates a new Generator, capable of outputting the source code artifacts related to a given SynthModel. It is
-     * capable of generating the one-time artifacts in addition to the regeneration of build-controlled artifacts.
-     *
-     * @param full              True if we should build the whole LAF or false for building just states and painters.
-     * @param buildDir          The directory beneath which the build-controlled artifacts (such as the Painters) should
-     *                          be placed. This is the root directory beneath which the necessary packages and source
-     *                          files will be created.
-     * @param srcDir            The directory beneath which the normal user-controlled artifacts (such as the core
-     *                          LookAndFeel file) should be placed. These are one-time generated files. This is the root
-     *                          directory beneath which the necessary packages and source files will be created.
-     * @param packageNamePrefix The package name associated with this synth look and feel. For example,
-     *                          org.mypackage.mylaf
-     * @param lafName           The name of the laf, such as MyLAF.
-     * @param model             The actual SynthModel to base these generated files on.
-     */
-    public Generator(boolean full, File buildDir, File srcDir, String packageNamePrefix, String lafName,
-                     SynthModel model) {
-        this.full = full;
-        //validate the input variables
-        if (packageNamePrefix == null) {
-            throw new IllegalArgumentException("You must specify a package name prefix");
-        }
-        if (buildDir == null) {
-            throw new IllegalArgumentException("You must specify the build directory");
-        }
-        if (srcDir == null) {
-            throw new IllegalArgumentException("You must specify the source directory");
-        }
-        if (model == null) {
-            throw new IllegalArgumentException("You must specify the SynthModel");
-        }
-        if (lafName == null) {
-            throw new IllegalArgumentException("You must specify the name of the look and feel");
-        }
-
-        //construct the map which is used to do variable substitution of the template
-        //files
-        variables = new HashMap<String, String>();
-        variables.put("PACKAGE", packageNamePrefix);
-        variables.put("LAF_NAME", lafName);
-
-        //generate and save references to the package-root directories.
-        //(That is, given the buildDir and srcDir, generate references to the
-        //org.mypackage.mylaf subdirectories)
-        buildPackageRoot = new File(buildDir, packageNamePrefix.replaceAll("\\.", "\\/"));
-        buildPackageRoot.mkdirs();
-        srcPackageRoot = new File(srcDir, packageNamePrefix.replaceAll("\\.", "\\/"));
-        srcPackageRoot.mkdirs();
-
-        //save the variables
-        this.packageNamePrefix = packageNamePrefix;
-        this.lafName = lafName;
-        this.model = model;
-    }
-
-    public void generate() {
-        //Generate the one-time files. If these files already exist, skip the
-        //ones that exist and create the missing ones. Register warnings for the
-        //already existing files.
-
-        //TODO Skip existing files, send warnings, etc.
-        if (full) {
-            try {
-                //create the LookAndFeel file
-                String template = read("resources/LookAndFeel.template");
-                writeSrcFile(template, variables, new File(srcPackageRoot, lafName + "LookAndFeel.java"));
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-        //create the painters and such.
-        regenerate();
-    }
-
-    public void regenerate() {
-        try {
-            if (full) {
-                //first, create the AbstractRegionPainter.java file.
-                String template = read("resources/AbstractRegionPainter.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "AbstractRegionPainter.java"));
-
-                //write out BlendingMode.java
-                template = read("resources/BlendingMode.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "BlendingMode.java"));
-
-                //create the SynthPainterImpl class
-                template = read("resources/SynthPainterImpl.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "SynthPainterImpl.java"));
-
-                //create the IconImpl class
-                template = read("resources/IconImpl.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, lafName + "Icon.java"));
-
-                //create the StyleImpl class
-                template = read("resources/StyleImpl.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, lafName + "Style.java"));
-
-                //write out Effect.java
-                template = read("resources/Effect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "Effect.java"));
-
-                //write out EffectUtils.java
-                template = read("resources/EffectUtils.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "EffectUtils.java"));
-
-                //write out ShadowEffect.java
-                template = read("resources/ShadowEffect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "ShadowEffect.java"));
-
-                //write out DropShadowEffect.java
-                template = read("resources/DropShadowEffect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "DropShadowEffect.java"));
-
-                //write out InnerShadowEffect.java
-                template = read("resources/InnerShadowEffect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "InnerShadowEffect.java"));
-
-                //write out InnerGlowEffect.java
-                template = read("resources/InnerGlowEffect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "InnerGlowEffect.java"));
-
-                //write out OuterGlowEffect.java
-                template = read("resources/OuterGlowEffect.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "OuterGlowEffect.java"));
-
-                //write out State.java
-                template = read("resources/State.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "State.java"));
-
-                template = read("resources/ImageCache.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "ImageCache.java"));
-
-                template = read("resources/ImageScalingHelper.template");
-                writeSrcFile(template, variables, new File(buildPackageRoot, "ImageScalingHelper.java"));
-            }
-            //next, populate the first set of ui defaults based on what is in the
-            //various palettes of the synth model
-            StringBuilder uiDefaultInit = new StringBuilder();
-            StringBuilder styleInit = new StringBuilder();
-            DefaultsGenerator.generateDefaults(uiDefaultInit, styleInit, model, variables, packageNamePrefix,
-                    buildPackageRoot);
-            variables.put("UI_DEFAULT_INIT", uiDefaultInit.toString());
-            variables.put("STYLE_INIT", styleInit.toString());
-            writeSrcFile(read("resources/Defaults.template"), variables,
-                    new File(buildPackageRoot, lafName + "Defaults.java"));
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/GeneratorUtils.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,295 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import javax.swing.plaf.synth.Region;
-import javax.swing.plaf.synth.SynthConstants;
-
-/**
- * GeneratorUtils
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-class GeneratorUtils {
-    private GeneratorUtils() {}
-
-    /**
-     * Given a synth state, create the appropriate name as it would be used for a ui default key.
-     * <p/>
-     * For example:
-     * <p/>
-     * enabled enabled+over enabled+over+selected
-     */
-    static String toUIDefaultKey(int state) {
-        StringBuffer buffer = new StringBuffer();
-        if ((state & SynthConstants.DEFAULT) == SynthConstants.DEFAULT) {
-            buffer.append("default");
-        }
-        if ((state & SynthConstants.DISABLED) == SynthConstants.DISABLED) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("disabled");
-        }
-        if ((state & SynthConstants.ENABLED) == SynthConstants.ENABLED) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("enabled");
-        }
-        if ((state & SynthConstants.FOCUSED) == SynthConstants.FOCUSED) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("focused");
-        }
-        if ((state & SynthConstants.MOUSE_OVER) == SynthConstants.MOUSE_OVER) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("over");
-        }
-        if ((state & SynthConstants.PRESSED) == SynthConstants.PRESSED) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("down");
-        }
-        if ((state & SynthConstants.SELECTED) == SynthConstants.SELECTED) {
-            if (buffer.length() > 0) buffer.append("+");
-            buffer.append("selected");
-        }
-        return buffer.toString();
-    }
-
-    //takes a states string of the form Enabled+Foo+Bar.
-    //removes any whitespace. Replaces the + signs with And.
-    static String toClassName(String states) {
-        String s = states.replace(" ", "");
-        s = states.replace("+", "And");
-        return s;
-    }
-
-    //takes a states string of the form Enabled+Foo+Bar.
-    //removes any whitespace. Replaces the + signs with _.
-    //capitalizes the whole lot
-    static String toConstantName(String states) {
-        String s = states.replace(" ", "");
-        s = states.replace("+", "_");
-        return s.toUpperCase();
-    }
-
-    /**
-     * Given a string "s" of the form:
-     *
-     * A.\"A.a\".B
-     *
-     * Make it such that:
-     *
-     * AAAB
-     *
-     * For example, ComboBox.\"ComboBox.arrowButton\" would become
-     * ComboBoxComboBoxArrowButton
-     *
-     * @param s
-     * @return
-     */
-    static String makePretty(String s) {
-        char[] src = s.toCharArray();
-        char[] dst = new char[src.length];
-        int dstIndex = 0;
-        for (int i=0; i<src.length; i++) {
-            //if the src char is a period and there is a following character,
-            //make sure the character is capitalized.
-            if ((src[i] == '.' || src[i] == ':') && i < src.length -1) {
-                src[i+1] = Character.toUpperCase(src[i+1]);
-                continue;
-            }
-            //if the src char is one that is to be removed, skip it.
-            if (src[i] == '.' || src[i] == ':' || src[i] == '\\' || src[i] == '"') {
-                continue;
-            }
-            //copy over the current char.
-            dst[dstIndex++] = src[i];
-        }
-        //at this point, dstIndex is 1 greater than the last valid index position in dst
-        //or in other words it represents the count.
-        return new String(dst, 0, dstIndex);
-    }
-
-    /**
-     * Encodes the given synth state as if it were specified in java code, such as
-     * <p/>
-     * SynthConstants.ENABLED | SynthConstants.MOUSE_OVER
-     */
-    static String toJavaList(int state) {
-        StringBuffer buffer = new StringBuffer();
-        if ((state & SynthConstants.DEFAULT) == SynthConstants.DEFAULT) {
-            buffer.append("SynthConstants.DEFAULT");
-        }
-        if ((state & SynthConstants.DISABLED) == SynthConstants.DISABLED) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.DISABLED");
-        }
-        if ((state & SynthConstants.ENABLED) == SynthConstants.ENABLED) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.ENABLED");
-        }
-        if ((state & SynthConstants.FOCUSED) == SynthConstants.FOCUSED) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.FOCUSED");
-        }
-        if ((state & SynthConstants.MOUSE_OVER) == SynthConstants.MOUSE_OVER) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.MOUSE_OVER");
-        }
-        if ((state & SynthConstants.PRESSED) == SynthConstants.PRESSED) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.PRESSED");
-        }
-        if ((state & SynthConstants.SELECTED) == SynthConstants.SELECTED) {
-            if (buffer.length() > 0) buffer.append(" | ");
-            buffer.append("SynthConstants.SELECTED");
-        }
-        return buffer.toString();
-    }
-
-    /**
-     * Checks the given region name to discover if it is one of the standard synth regions. If so, return the name in
-     * caps and such. Otherwise, return a big fat null.
-     * <p/>
-     * I have to do this because, unfortunately, synth's Region doesn't implement equals.
-     */
-    static String getRegionNameCaps(String regionName) {
-        if (Region.ARROW_BUTTON.getName().equals(regionName)) {
-            return "ARROW_BUTTON";
-        } else if (Region.BUTTON.getName().equals(regionName)) {
-            return "BUTTON";
-        } else if (Region.CHECK_BOX.getName().equals(regionName)) {
-            return "CHECK_BOX";
-        } else if (Region.CHECK_BOX_MENU_ITEM.getName().equals(regionName)) {
-            return "CHECK_BOX_MENU_ITEM";
-        } else if (Region.COLOR_CHOOSER.getName().equals(regionName)) {
-            return "COLOR_CHOOSER";
-        } else if (Region.COMBO_BOX.getName().equals(regionName)) {
-            return "COMBO_BOX";
-        } else if (Region.DESKTOP_ICON.getName().equals(regionName)) {
-            return "DESKTOP_ICON";
-        } else if (Region.DESKTOP_PANE.getName().equals(regionName)) {
-            return "DESKTOP_PANE";
-        } else if (Region.EDITOR_PANE.getName().equals(regionName)) {
-            return "EDITOR_PANE";
-        } else if (Region.FILE_CHOOSER.getName().equals(regionName)) {
-            return "FILE_CHOOSER";
-        } else if (Region.FORMATTED_TEXT_FIELD.getName().equals(regionName)) {
-            return "FORMATTED_TEXT_FIELD";
-        } else if (Region.INTERNAL_FRAME.getName().equals(regionName)) {
-            return "INTERNAL_FRAME";
-        } else if (Region.INTERNAL_FRAME_TITLE_PANE.getName().equals(regionName)) {
-            return "INTERNAL_FRAME_TITLE_PANE";
-        } else if (Region.LABEL.getName().equals(regionName)) {
-            return "LABEL";
-        } else if (Region.LIST.getName().equals(regionName)) {
-            return "LIST";
-        } else if (Region.MENU.getName().equals(regionName)) {
-            return "MENU";
-        } else if (Region.MENU_BAR.getName().equals(regionName)) {
-            return "MENU_BAR";
-        } else if (Region.MENU_ITEM.getName().equals(regionName)) {
-            return "MENU_ITEM";
-        } else if (Region.MENU_ITEM_ACCELERATOR.getName().equals(regionName)) {
-            return "MENU_ITEM_ACCELERATOR";
-        } else if (Region.OPTION_PANE.getName().equals(regionName)) {
-            return "OPTION_PANE";
-        } else if (Region.PANEL.getName().equals(regionName)) {
-            return "PANEL";
-        } else if (Region.PASSWORD_FIELD.getName().equals(regionName)) {
-            return "PASSWORD_FIELD";
-        } else if (Region.POPUP_MENU.getName().equals(regionName)) {
-            return "POPUP_MENU";
-        } else if (Region.POPUP_MENU_SEPARATOR.getName().equals(regionName)) {
-            return "POPUP_MENU_SEPARATOR";
-        } else if (Region.PROGRESS_BAR.getName().equals(regionName)) {
-            return "PROGRESS_BAR";
-        } else if (Region.RADIO_BUTTON.getName().equals(regionName)) {
-            return "RADIO_BUTTON";
-        } else if (Region.RADIO_BUTTON_MENU_ITEM.getName().equals(regionName)) {
-            return "RADIO_BUTTON_MENU_ITEM";
-        } else if (Region.ROOT_PANE.getName().equals(regionName)) {
-            return "ROOT_PANE";
-        } else if (Region.SCROLL_BAR.getName().equals(regionName)) {
-            return "SCROLL_BAR";
-        } else if (Region.SCROLL_BAR_THUMB.getName().equals(regionName)) {
-            return "SCROLL_BAR_THUMB";
-        } else if (Region.SCROLL_BAR_TRACK.getName().equals(regionName)) {
-            return "SCROLL_BAR_TRACK";
-        } else if (Region.SCROLL_PANE.getName().equals(regionName)) {
-            return "SCROLL_PANE";
-        } else if (Region.SEPARATOR.getName().equals(regionName)) {
-            return "SEPARATOR";
-        } else if (Region.SLIDER.getName().equals(regionName)) {
-            return "SLIDER";
-        } else if (Region.SLIDER_THUMB.getName().equals(regionName)) {
-            return "SLIDER_THUMB";
-        } else if (Region.SLIDER_TRACK.getName().equals(regionName)) {
-            return "SLIDER_TRACK";
-        } else if (Region.SPINNER.getName().equals(regionName)) {
-            return "SPINNER";
-        } else if (Region.SPLIT_PANE.getName().equals(regionName)) {
-            return "SPLIT_PANE";
-        } else if (Region.SPLIT_PANE_DIVIDER.getName().equals(regionName)) {
-            return "SPLIT_PANE_DIVIDER";
-        } else if (Region.TABBED_PANE.getName().equals(regionName)) {
-            return "TABBED_PANE";
-        } else if (Region.TABBED_PANE_CONTENT.getName().equals(regionName)) {
-            return "TABBED_PANE_CONTENT";
-        } else if (Region.TABBED_PANE_TAB.getName().equals(regionName)) {
-            return "TABBED_PANE_TAB";
-        } else if (Region.TABBED_PANE_TAB_AREA.getName().equals(regionName)) {
-            return "TABBED_PANE_TAB_AREA";
-        } else if (Region.TABLE.getName().equals(regionName)) {
-            return "TABLE";
-        } else if (Region.TABLE_HEADER.getName().equals(regionName)) {
-            return "TABLE_HEADER";
-        } else if (Region.TEXT_AREA.getName().equals(regionName)) {
-            return "TEXT_AREA";
-        } else if (Region.TEXT_FIELD.getName().equals(regionName)) {
-            return "TEXT_FIELD";
-        } else if (Region.TEXT_PANE.getName().equals(regionName)) {
-            return "TEXT_PANE";
-        } else if (Region.TOGGLE_BUTTON.getName().equals(regionName)) {
-            return "TOGGLE_BUTTON";
-        } else if (Region.TOOL_BAR.getName().equals(regionName)) {
-            return "TOOL_BAR";
-        } else if (Region.TOOL_BAR_CONTENT.getName().equals(regionName)) {
-            return "TOOL_BAR_CONTENT";
-        } else if (Region.TOOL_BAR_DRAG_WINDOW.getName().equals(regionName)) {
-            return "TOOL_BAR_DRAG_WINDOW";
-        } else if (Region.TOOL_BAR_SEPARATOR.getName().equals(regionName)) {
-            return "TOOL_BAR_SEPARATOR";
-        } else if (Region.TOOL_TIP.getName().equals(regionName)) {
-            return "TOOL_TIP";
-        } else if (Region.TREE.getName().equals(regionName)) {
-            return "TREE";
-        } else if (Region.TREE_CELL.getName().equals(regionName)) {
-            return "TREE_CELL";
-        } else if (Region.VIEWPORT.getName().equals(regionName)) {
-            return "VIEWPORT";
-        }
-        System.err.println("[Info] Couldn't find a Region for " + regionName);
-        return null;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/ObjectCodeConvertors.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,108 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import java.awt.*;
-
-/**
- * ObjectCodeConvertors
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class ObjectCodeConvertors {
-    static java.math.MathContext ctx = new java.math.MathContext(3);
-
-    /**
-     * Given a value (x), encode it such that 0 -> 1 is to the left of a, 1 -> 2 is between a and b, and 2 -> 3
-     * is to the right of b.
-     *
-     * @param w width in the case of the x axis, height in the case of the y axis.
-     */
-    static float encode(float x, float a, float b, float w) {
-        float r = 0;
-        if (x < a) {
-            r = (x / a);
-        } else if (x > b) {
-            r = 2 + ((x - b) / (w - b));
-        } else if (x == a && x == b) {
-            return 1.5f;
-        } else {
-            r = 1 + ((x - a) / (b - a));
-        }
-
-        if (Float.isNaN(r)) {
-            System.err.println("[Error] Encountered NaN: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
-            return 0;
-        } else if (Float.isInfinite(r)) {
-            System.err.println("[Error] Encountered Infinity: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
-            return 0;
-        } else if (r < 0) {
-            System.err.println("[Error] encoded value was less than 0: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
-            return 0;
-        } else if (r > 3) {
-            System.err.println("[Error] encoded value was greater than 3: encode(" + x + ", " + a + ", " + b + ", " + w + ")");
-            return 3;
-        } else {
-            //for prettyness sake (and since we aren't really going to miss
-            //any accuracy here) I'm rounding this to 3 decimal places
-//                return java.math.BigDecimal.valueOf(r).round(ctx).doubleValue();
-            return r;
-        }
-    }
-
-    static String convert(Paint paint) {
-        //TODO need to support writing out other Paints, such as gradients
-        if (paint instanceof Color) {
-            return convert((Color) paint);
-        } else {
-            System.err.println("[WARNING] Unable to encode a paint in the encode(Paint) method: " + paint);
-            return "null";
-        }
-    }
-
-    /**
-     * Given a Color, write out the java code required to create a new Color.
-     *
-     * @param color The color to convert
-     * @return String of the code for the color
-     */
-    static String convert(Color color) {
-        return "new Color(" +
-                color.getRed() + ", " +
-                color.getGreen() + ", " +
-                color.getBlue() + ", " +
-                color.getAlpha() + ")";
-    }
-
-    static String convert(Insets i) {
-        return "new Insets(" + i.top + ", " + i.left + ", " + i.bottom + ", " + i.right + ")";
-    }
-
-    static String convert(Dimension d) {
-        return "new Dimension(" + d.width + ", " + d.height + ")";
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/PainterGenerator.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,758 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import org.jdesktop.swingx.designer.BezierControlPoint;
-import org.jdesktop.swingx.designer.Canvas;
-import org.jdesktop.swingx.designer.EllipseShape;
-import org.jdesktop.swingx.designer.Layer;
-import org.jdesktop.swingx.designer.PaintedShape;
-import org.jdesktop.swingx.designer.PathShape;
-import org.jdesktop.swingx.designer.RectangleShape;
-import org.jdesktop.swingx.designer.SimpleShape;
-import org.jdesktop.swingx.designer.TemplateLayer;
-import org.jdesktop.swingx.designer.paint.Gradient;
-import org.jdesktop.swingx.designer.paint.Matte;
-import org.jdesktop.swingx.designer.paint.PaintModel;
-import org.jdesktop.swingx.designer.paint.RadialGradient;
-import org.jdesktop.swingx.designer.paint.GradientStop;
-import org.jdesktop.swingx.designer.paint.AbstractGradient;
-import static org.jdesktop.synthdesigner.generator.GeneratorUtils.makePretty;
-import static org.jdesktop.synthdesigner.generator.GeneratorUtils.toClassName;
-import static org.jdesktop.synthdesigner.generator.GeneratorUtils.toConstantName;
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.read;
-import static org.jdesktop.synthdesigner.generator.TemplateWriter.writeSrcFile;
-import org.jdesktop.synthdesigner.synthmodel.UIIconRegion;
-import org.jdesktop.synthdesigner.synthmodel.UIRegion;
-import org.jdesktop.synthdesigner.synthmodel.UIState;
-
-import java.awt.*;
-import java.awt.geom.Point2D;
-import java.beans.Beans;
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.swing.JComponent;
-import javax.swing.SwingUtilities;
-import javax.swing.JList;
-import javax.swing.JTable;
-import javax.swing.text.JTextComponent;
-
-/**
- * PainterGenerator - Class for generating Painter class java source from a Canvas
- *
- * Following in the general theory that is used to generate a Painter file.
- *
- * Each Painter file represents a Region. So there is one painter file per region. In
- * skin.laf we support Icon subregions, which are really just hacked versions of the
- * parent region.
- *
- * In order to generate the most compact and efficient bytecode possible for the
- * Painters, we actually perform the generation sequence in two steps. The first
- * step is the analysis phase, where we walk through the SynthModel for the region
- * and discover commonality among the different states in the region. For example,
- * do they have common paths? Do they have common colors? Gradients? Is the painting
- * code for the different states identical other than for colors?
- *
- * We gather this information up. On the second pass, we use this data to determine the
- * methods that need to be generated, and the class variables that need to be generated.
- * We try to keep the actual bytecode count as small as possible so that we may reduce
- * the overall size of the look and feel significantly.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class PainterGenerator {
-    private static String painterImplTemplate;
-    private static String getPainterImplTemplate() {
-        if (painterImplTemplate == null) {
-            //load the painter template file into an in-memory string to improve performance
-            //when generating a lot of classes
-            try {
-                painterImplTemplate = read("resources/PainterImpl.template");
-            } catch (IOException e) {
-                System.err.println("Failed to read template files.");
-                throw new RuntimeException(e);
-            }
-        }
-        return painterImplTemplate;
-    }
-
-
-    //a handful of counters, incremented whenever the associated object type is encounted.
-    //These counters form the basis of the field and method suffixes.
-    //These are all 1 based, because I felt like it :-)
-    private int colorCounter = 1;
-    private int gradientCounter = 1;
-    private int radialCounter = 1;
-    private int pathCounter = 1;
-    private int rectCounter = 1;
-    private int roundRectCounter = 1;
-    private int ellipseCounter = 1;
-
-    private int stateTypeCounter = 1;
-
-    //during the first pass, we will construct these maps
-    private Map<String, String> colors = new HashMap<String, String>();
-    /**
-     * Code=>method name.
-     */
-    private Map<String, String> methods = new HashMap<String, String>();
-
-    //these variables hold the generated code
-    /**
-     * The source code in this variable will be used to define the various state types
-     */
-    private StringBuilder stateTypeCode = new StringBuilder();
-    /**
-     * The source code in this variable will be used to define the switch statement for painting
-     */
-    private StringBuilder switchCode = new StringBuilder();
-    /**
-     * The source code in this variable will be used to define the methods for painting each state
-     */
-    private StringBuilder paintingCode = new StringBuilder();
-    /**
-     * The source code in this variable will be used to add getExtendedCacheKeys
-     * implementation if needed.
-     */
-    private StringBuilder getExtendedCacheKeysCode = new StringBuilder();
-    /**
-     * The source code in this variable will be used to define the methods for decoding gradients
-     * and shapes.
-     */
-    private StringBuilder gradientsCode = new StringBuilder();
-    private StringBuilder colorCode = new StringBuilder();
-    private StringBuilder shapesCode = new StringBuilder();
-    /**
-     * Map of component colors keyed by state constant name
-     */
-    private Map<String, List<ComponentColor>> componentColorsMap =
-            new LinkedHashMap<String, List<ComponentColor>>();
-    /**
-     * For the current state the list of all component colors used by this
-     * painter, the index in this list is also the index in the runtime array
-     * of defaults and keys.
-     */
-    private List<ComponentColor> componentColors = null;
-
-    PainterGenerator(UIRegion r) {
-        generate(r);
-    }
-
-    private void generate(UIRegion r) {
-        for (UIState state : r.getBackgroundStates()) {
-            System.out.println("------>" + state.getName());
-
-            Canvas canvas = state.getCanvas();
-            String type = r instanceof UIIconRegion ? ((UIIconRegion)r).getKey() : "Background";
-            generate(state, canvas, type);
-        }
-        for (UIState state : r.getForegroundStates()) {
-            Canvas canvas = state.getCanvas();
-            generate(state, canvas, "Foreground");
-        }
-        for (UIState state : r.getBorderStates()) {
-            Canvas canvas = state.getCanvas();
-            generate(state, canvas, "Border");
-        }
-        //now check for any uiIconRegions, since these are collapsed together.
-        for (UIRegion sub : r.getSubRegions()) {
-            if (sub instanceof UIIconRegion) {
-                generate(sub);
-            }
-        }
-        //generate all the code for component colors
-        if (!componentColorsMap.isEmpty()) {
-            getExtendedCacheKeysCode
-                    .append("    protected Object[] getExtendedCacheKeys(JComponent c) {\n")
-                    .append("        Object[] extendedCacheKeys = null;\n")
-                    .append("        switch(state) {\n");
-            for (Map.Entry<String, List<ComponentColor>> entry : componentColorsMap.entrySet()) {
-                getExtendedCacheKeysCode
-                    .append("            case ")
-                    .append(entry.getKey()).append(":\n")
-                    .append("                extendedCacheKeys = new Object[] {\n");
-                for (int i=0; i<entry.getValue().size(); i++) {
-                    ComponentColor cc = entry.getValue().get(i);
-                    getExtendedCacheKeysCode
-                    .append("                     getComponentColor(c, \"")
-                    .append(cc.propertyName).append("\", ")
-                    .append(cc.defaultColorVariableName).append(", ")
-                    .append(cc.saturationOffset).append("f, ")
-                    .append(cc.brightnessOffset).append("f, ")
-                    .append(cc.alphaOffset);
-                    if (i + 1 < entry.getValue().size()) {
-                        getExtendedCacheKeysCode.append("),\n");
-                    } else {
-                        getExtendedCacheKeysCode.append(")");
-                    }
-                }
-                getExtendedCacheKeysCode.append("};\n")
-                    .append("                break;\n");
-            }
-            getExtendedCacheKeysCode
-                    .append("        }\n")
-                    .append("        return extendedCacheKeys;\n")
-                    .append("    }");
-        }
-    }
-
-    //type is background, foreground, border, upArrowIcon, etc.
-    private void generate(UIState state, Canvas canvas, String type) {
-        String states = UIState.keysToString(state.getStateKeys());
-        String stateType = toConstantName(type + "_" + states);
-        String paintMethodName = "paint" + type + toClassName(states);
-        //create new array for component colors for this state
-        componentColors = new ArrayList<ComponentColor>();
-
-        stateTypeCode.append("    static final int ").append(stateType).append(" = ").append(stateTypeCounter++).append(";\n");
-
-        if (canvas.isBlank()) {
-            return;
-        }
-
-        switchCode.append("            case ").append(stateType).append(": ").append(paintMethodName).append("(g); break;\n");
-        paintingCode.append("    private void ").append(paintMethodName).append("(Graphics2D g) {\n");
-
-        //start by setting up common info needed to encode the control points
-        Insets in = canvas.getStretchingInsets();
-        float a = in.left;
-        float b = canvas.getSize().width - in.right;
-        float c = in.top;
-        float d = canvas.getSize().height - in.bottom;
-        float width = canvas.getSize().width;
-        float height = canvas.getSize().height;
-        float cw = b - a;
-        float ch = d - c;
-
-        Layer[] layers = canvas.getLayers().toArray(new Layer[0]);
-        for (int index=layers.length-1; index >= 0; index--) {
-            Layer layer = layers[index];
-            if (layer instanceof TemplateLayer) {
-                continue;
-            }
-            //shapes must be painted in reverse order
-            List<SimpleShape> shapes = layer.getShapes();
-            for (int i=shapes.size()-1; i>=0; i--) {
-                SimpleShape s = shapes.get(i);
-                if (s instanceof PaintedShape) {
-                    PaintedShape shape = (PaintedShape)s;
-                    PaintModel paint = shape.getPaintModel();
-
-                    /*
-                        We attempt to write the minimal number of bytecodes as possible when
-                        generating code. Due to the inherit complexities in determining what
-                        is extraneous, we use the following system:
-
-                        We first generate the code for the shape. Then, we check to see if
-                        this shape has already been generated. If so, then we defer to an
-                        existing method. If not, then we will create a new methods, stick
-                        the code in it, and refer to that method.
-                    */
-
-                    String shapeMethodName = null; // will contain the name of the method which creates the shape
-                    String shapeVariable = null; // will be one of rect, roundRect, ellipse, or path.
-                    String shapeMethodBody = null;
-
-                    if (shape instanceof RectangleShape) {
-                        RectangleShape rshape = (RectangleShape) shape;
-                        float x1 = encode((float)rshape.getX1(), a, b, width);
-                        float y1 = encode((float)rshape.getY1(), c, d, height);
-                        float x2 = encode((float)rshape.getX2(), a, b, width);
-                        float y2 = encode((float)rshape.getY2(), c, d, height);
-                        if (rshape.isRounded()) {
-                            //it is a rounded rectangle
-                            float rounding = (float)rshape.getRounding();
-
-                            shapeMethodBody =
-                                    "        roundRect.setRoundRect(" +
-                                    writeDecodeX(x1) + ", //x\n" +
-                                    "                               " + writeDecodeY(y1) + ", //y\n" +
-                                    "                               " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
-                                    "                               " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + ", //height\n" +
-                                    "                               " + rounding + "f, " + rounding + "f); //rounding";
-                            shapeVariable = "roundRect";
-                        } else {
-                            shapeMethodBody =
-                                    "            rect.setRect(" +
-                                    writeDecodeX(x1) + ", //x\n" +
-                                    "                         " + writeDecodeY(y1) + ", //y\n" +
-                                    "                         " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
-                                    "                         " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + "); //height";
-                            shapeVariable = "rect";
-                        }
-                    } else if (shape instanceof EllipseShape) {
-                        EllipseShape eshape = (EllipseShape) shape;
-                        float x1 = encode((float)eshape.getX1(), a, b, width);
-                        float y1 = encode((float)eshape.getY1(), c, d, height);
-                        float x2 = encode((float)eshape.getX2(), a, b, width);
-                        float y2 = encode((float)eshape.getY2(), c, d, height);
-                        shapeMethodBody =
-                                "        ellipse.setFrame(" +
-                                writeDecodeX(x1) + ", //x\n" +
-                                "                         " + writeDecodeY(y1) + ", //y\n" +
-                                "                         " + writeDecodeX(x2) + " - " + writeDecodeX(x1) + ", //width\n" +
-                                "                         " + writeDecodeY(y2) + " - " + writeDecodeY(y1) + "); //height";
-                        shapeVariable = "ellipse";
-                    } else if (shape instanceof PathShape) {
-                        PathShape pshape = (PathShape) shape;
-                        List<BezierControlPoint> controlPoints = pshape.getBezierControlPoints();
-                        BezierControlPoint first, last;
-                        first = last = controlPoints.get(0);
-                        StringBuilder buffer = new StringBuilder();
-                        buffer.append("        path.reset();\n");
-                        buffer.append("        path.moveTo(" + writeDecodeX(encode((float)first.getX(), a, b, width)) + ", " + writeDecodeY(encode((float)first.getY(), c, d, height)) + ");\n");
-                        for (int j=1; j<controlPoints.size(); j++) {
-                            BezierControlPoint cp = controlPoints.get(j);
-                            if (last.getCp2().isSharp() && cp.getCp1().isSharp()) {
-                                float x = encode((float)cp.getX(), a, b, width);
-                                float y = encode((float)cp.getY(), c, d, height);
-                                buffer.append("        path.lineTo(" + writeDecodeX(x) + ", " + writeDecodeY(y) + ");\n");
-                            } else {
-                                float x1 = encode((float)last.getX(), a, b, width);
-                                float y1 = encode((float)last.getY(), c, d, height);
-                                float x2 = encode((float)cp.getX(), a, b, width);
-                                float y2 = encode((float)cp.getY(), c, d, height);
-                                buffer.append(
-                                        "        path.curveTo(" + writeDecodeBezierX(x1, last.getX(), last.getCp2X()) + ", "
-                                                                + writeDecodeBezierY(y1, last.getY(), last.getCp2Y()) + ", "
-                                                                + writeDecodeBezierX(x2, cp.getX(), cp.getCp1X()) + ", "
-                                                                + writeDecodeBezierY(y2, cp.getY(), cp.getCp1Y()) + ", "
-                                                                + writeDecodeX(x2) + ", " + writeDecodeY(y2) + ");\n");
-                            }
-                            last = cp;
-                        }
-                        if (last.getCp2().isSharp() && first.getCp1().isSharp()) {
-                            float x = encode((float)first.getX(), a, b, width);
-                            float y = encode((float)first.getY(), c, d, height);
-                            buffer.append("        path.lineTo(" + writeDecodeX(x) + ", " + writeDecodeY(y) + ");\n");
-                        } else {
-                            float x1 = encode((float)last.getX(), a, b, width);
-                            float y1 = encode((float)last.getY(), c, d, height);
-                            float x2 = encode((float)first.getX(), a, b, width);
-                            float y2 = encode((float)first.getY(), c, d, height);
-                            buffer.append(
-                                    "        path.curveTo(" + writeDecodeBezierX(x1, last.getX(), last.getCp2X()) + ", "
-                                                            + writeDecodeBezierY(y1, last.getY(), last.getCp2Y()) + ", "
-                                                            + writeDecodeBezierX(x2, first.getX(), first.getCp1X()) + ", "
-                                                            + writeDecodeBezierY(y2, first.getY(), first.getCp1Y()) + ", "
-                                                            + writeDecodeX(x2) + ", " + writeDecodeY(y2) + ");\n");
-                        }
-                        buffer.append("        path.closePath();");
-                        shapeMethodBody = buffer.toString();
-                        shapeVariable = "path";
-                    } else {
-                        throw new RuntimeException("Cannot happen unless a new Shape has been defined");
-                    }
-
-                    //now that we have the shape defined in shapeMethodBody, and a shapeVariable name,
-                    //look to see if such a body has been previously defined.
-                    shapeMethodName = methods.get(shapeMethodBody);
-                    String returnType = null;
-                    if (shapeMethodName == null) {
-                        if ("rect".equals(shapeVariable)) {
-                            shapeMethodName = "decodeRect" + rectCounter++;
-                            returnType = "Rectangle2D";
-                        } else if ("roundRect".equals(shapeVariable)) {
-                            shapeMethodName = "decodeRoundRect" + roundRectCounter++;
-                            returnType = "RoundRectangle2D";
-                        } else if ("ellipse".equals(shapeVariable)) {
-                            shapeMethodName = "decodeEllipse" + ellipseCounter++;
-                            returnType = "Ellipse2D";
-                        } else {
-                            shapeMethodName = "decodePath" + pathCounter++;
-                            returnType = "Path2D";
-                        }
-                        methods.put(shapeMethodBody, shapeMethodName);
-
-                        //since the method wasn't previously defined, time to define it
-                        shapesCode.append("    private ").append(returnType).append(" ").append(shapeMethodName).append("() {\n");
-                        shapesCode.append(shapeMethodBody);
-                        shapesCode.append("\n");
-                        shapesCode.append("        return " + shapeVariable + ";\n");
-                        shapesCode.append("    }\n\n");
-                    }
-
-                    //now that the method has been defined, I can go on and decode the
-                    //paint. After the paint is decoded, I can write the g.fill() method call,
-                    //using the result of the shapeMethodName. Yay!
-
-//            if (shapeVariable != null) {
-                //first, calculate the bounds of the shape being painted and store in variables
-                    paintingCode.append("        ").append(shapeVariable).append(" = ").append(shapeMethodName).append("();\n");
-
-                    if (paint instanceof Matte) {
-                        String colorVariable = encodeMatte((Matte)paint);
-                        paintingCode.append("        g.setPaint(").append(colorVariable).append(");\n");
-                    } else if (paint instanceof Gradient) {
-                        String gradientMethodName = encodeGradient(shape, (Gradient)paint);
-                        paintingCode.append("        g.setPaint(").append(gradientMethodName).append("(").append(shapeVariable).append("));\n");
-                    } else if (paint instanceof RadialGradient) {
-                        String radialMethodName = encodeRadial(shape, (RadialGradient)paint);
-                        paintingCode.append("        g.setPaint(").append(radialMethodName).append("(").append(shapeVariable).append("));\n");
-                    }
-                    paintingCode.append("        g.fill(").append(shapeVariable).append(");\n");
-                }
-            }
-        }
-
-        paintingCode.append("\n    }\n\n");
-
-        //collect component colors
-        if (!componentColors.isEmpty()) {
-            componentColorsMap.put(stateType, componentColors);
-            componentColors = null;
-        }
-    }
-
-    private float encode(float x, float a, float b, float width) {
-        return ObjectCodeConvertors.encode(x, a, b, width);
-    }
-
-    private String writeDecodeX(float encodedX) {
-        return "decodeX(" + encodedX + "f)";
-    }
-
-    private String writeDecodeY(float encodedY) {
-        return "decodeY(" + encodedY + "f)";
-    }
-
-    /**
-     *
-     * @param ex encoded x value
-     * @param x unencoded x value
-     * @param cpx unencoded cpx value
-     * @return
-     */
-    private static String writeDecodeBezierX(double ex, double x, double cpx) {
-        return "decodeAnchorX(" + ex + "f, " + (cpx - x) + "f)";
-    }
-
-    /**
-     *
-     * @param ey encoded y value
-     * @param y unencoded y value
-     * @param cpy unencoded cpy value
-     * @return
-     */
-    private static String writeDecodeBezierY(double ey, double y, double cpy) {
-        return "decodeAnchorY(" + ey + "f, " + (cpy - y) + "f)";
-    }
-
-    private String encodeMatte(Matte m) {
-        String declaration = null;
-        if (m.isAbsolute()) {
-            Color c = m.getColor();
-            declaration = ObjectCodeConvertors.convert(c);
-        } else {
-            declaration = "decodeColor(\"" + m.getUiDefaultParentName() +
-                          "\", " + m.getHueOffset() + "f, " +
-                          m.getSaturationOffset() + "f, " +
-                          m.getBrightnessOffset() + "f, " +
-                          m.getAlphaOffset() + ")";
-        }
-
-        String variableName = colors.get(declaration);
-        if (variableName == null) {
-            variableName = "color" + colorCounter++;
-            colors.put(declaration, variableName);
-            colorCode.append("    private Color ").append(variableName).append(" = ");
-            colorCode.append(declaration).append(";\n");
-        }
-        // handle component colors
-        if (m.getComponentPropertyName() != null) {
-            ComponentColor cc = new ComponentColor(m.getComponentPropertyName(),
-                    variableName, m.getSaturationOffset(),
-                    m.getBrightnessOffset(), m.getAlphaOffset());
-            int index = componentColors.indexOf(cc);
-            if (index == -1) {
-                index = componentColors.size();
-                componentColors.add(cc);
-            }
-            return "(Color)componentColors[" + index + "]";
-        } else {
-            return variableName;
-        }
-    }
-
-    private String encodeColor(Color c) {
-        String declaration = ObjectCodeConvertors.convert(c);
-        String variableName = colors.get(declaration);
-        if (variableName == null) {
-            variableName = "color" + colorCounter++;
-            colors.put(declaration, variableName);
-            colorCode.append("    private Color ").append(variableName).append(" = ");
-            colorCode.append(declaration).append(";\n");
-        }
-
-        return variableName;
-    }
-
-    private String encodeGradient(PaintedShape ps, Gradient g) {
-        StringBuilder b = new StringBuilder();
-        float x1 = (float)ps.getPaintX1();
-        float y1 = (float)ps.getPaintY1();
-        float x2 = (float)ps.getPaintX2();
-        float y2 = (float)ps.getPaintY2();
-        b.append("        return decodeGradient((");
-        b.append(x1);
-        b.append("f * w) + x, (");
-        b.append(y1);
-        b.append("f * h) + y, (");
-        b.append(x2);
-        b.append("f * w) + x, (");
-        b.append(y2);
-        b.append("f * h) + y,\n");
-        encodeGradientColorsAndFractions(g,b);
-        b.append(");");
-
-        String methodBody = b.toString();
-        String methodName = methods.get(methodBody);
-        if (methodName == null) {
-            methodName = "decodeGradient" + gradientCounter++;
-            gradientsCode.append("    private Paint ").append(methodName).append("(Shape s) {\n");
-            gradientsCode.append("        Rectangle2D bounds = s.getBounds2D();\n");
-            gradientsCode.append("        float x = (float)bounds.getX();\n");
-            gradientsCode.append("        float y = (float)bounds.getY();\n");
-            gradientsCode.append("        float w = (float)bounds.getWidth();\n");
-            gradientsCode.append("        float h = (float)bounds.getHeight();\n");
-            gradientsCode.append(methodBody);
-            gradientsCode.append("\n    }\n\n");
-            methods.put(methodBody, methodName);
-        }
-        return methodName;
-    }
-
-    /**
-     * Takes a abstract gradient and creates the code for the fractions float
-     * array and the colors array that can be used in the constructors of linear
-     * and radial gradients.
-     *
-     * @param g The abstract gradient to get stops from
-     * @param b Append code string of the form "new float[]{...},
-     *          new Color[]{...}" to this StringBuilder
-     */
-    private void encodeGradientColorsAndFractions(AbstractGradient g,
-                                                    StringBuilder b) {
-        List<GradientStop> stops = g.getStops();
-        // there are stops.size() number of main stops. Between each is a
-        // fractional stop. Thus, there are: stops.size() + stops.size() - 1
-        // number of fractions and colors.
-        float[] fractions = new float[stops.size() + stops.size() - 1];
-        String[] colors = new String[fractions.length];
-        //for each stop, create the stop and it's associated fraction
-        int index = 0; // the index into fractions and colors
-        for (int i = 0; i < stops.size(); i++) {
-            GradientStop s = stops.get(i);
-            //copy over the stop's data
-            colors[index] = encodeMatte(s.getColor());
-            fractions[index] = s.getPosition();
-
-            //If this isn't the last stop, then add in the fraction
-            if (index < fractions.length - 1) {
-                float f1 = s.getPosition();
-                float f2 = stops.get(i + 1).getPosition();
-                index++;
-                fractions[index] = f1 + (f2 - f1) * s.getMidpoint();
-                colors[index] = "decodeColor("+
-                        colors[index - 1]+","+
-                        encodeMatte(stops.get(i + 1).getColor())+",0.5f)";
-            }
-            index++;
-        }
-        // Check boundry conditions
-        for (int i = 1; i < fractions.length; i++) {
-            //to avoid an error with LinearGradientPaint where two fractions
-            //are identical, bump up the fraction value by a miniscule amount
-            //if it is identical to the previous one
-            //NOTE: The <= is critical because the previous value may already
-            //have been bumped up
-            if (fractions[i] <= fractions[i - 1]) {
-                fractions[i] = fractions[i - 1] + .000001f;
-            }
-        }
-        //another boundary condition where multiple stops are all at the end. The
-        //previous loop bumped all but one of these past 1.0, which is bad.
-        //so remove any fractions (and their colors!) that are beyond 1.0
-        int outOfBoundsIndex = -1;
-        for (int i = 0; i < fractions.length; i++) {
-            if (fractions[i] > 1) {
-                outOfBoundsIndex = i;
-                break;
-            }
-        }
-        if (outOfBoundsIndex >= 0) {
-            float[] f = fractions;
-            String[] c = colors;
-            fractions = new float[outOfBoundsIndex];
-            colors = new String[outOfBoundsIndex];
-            System.arraycopy(f, 0, fractions, 0, outOfBoundsIndex);
-            System.arraycopy(c, 0, colors, 0, outOfBoundsIndex);
-        }
-        // build string
-        b.append("                new float[] { ");
-        for (int i = 0; i < fractions.length; i++) {
-            if (i>0)b.append(',');
-            b.append(fractions[i]);
-            b.append('f');
-        }
-        b.append(" },\n                new Color[] { ");
-        for (int i = 0; i < colors.length; i++) {
-            if (i>0) b.append(",\n                            ");
-            b.append(colors[i]);
-        }
-        b.append("}");
-    }
-
-    private String encodeRadial(PaintedShape ps, RadialGradient g) {
-        float centerX1 = (float)ps.getPaintX1();
-        float centerY1 = (float)ps.getPaintY1();
-        float x2 = (float)ps.getPaintX2();
-        float y2 = (float)ps.getPaintY2();
-        float radius = (float)Point2D.distance(centerX1, centerY1, x2, y2);
-        StringBuilder b = new StringBuilder();
-
-        b.append("        return decodeRadialGradient((");
-        b.append(centerX1);
-        b.append("f * w) + x, (");
-        b.append(centerY1);
-        b.append("f * h) + y, ");
-        b.append(radius);
-        b.append("f,\n");
-        encodeGradientColorsAndFractions(g,b);
-        b.append(");");
-
-        String methodBody = b.toString();
-        String methodName = methods.get(methodBody);
-        if (methodName == null) {
-            methodName = "decodeRadial" + radialCounter++;
-            gradientsCode.append("    private Paint ").append(methodName).append("(Shape s) {\n");
-            gradientsCode.append("        Rectangle2D bounds = s.getBounds2D();\n");
-            gradientsCode.append("        float x = (float)bounds.getX();\n");
-            gradientsCode.append("        float y = (float)bounds.getY();\n");
-            gradientsCode.append("        float w = (float)bounds.getWidth();\n");
-            gradientsCode.append("        float h = (float)bounds.getHeight();\n");
-            gradientsCode.append(methodBody);
-            gradientsCode.append("\n    }\n\n");
-            methods.put(methodBody, methodName);
-        }
-        return methodName;
-    }
-
-    //note that this method is not thread-safe. In fact, none of this class is.
-    static void writePainter(UIRegion r, Map<String, String> variables, File painterPackageRoot, String prefix) throws IOException {
-        //Need only write out the stuff for this region, don't need to worry about subregions
-        //since this method will be called for each of those (and they go in their own file, anyway).
-        //The only subregion that we compound into this is the one for icons.
-
-        String painterName = makePretty(prefix) + "Painter";
-        PainterGenerator gen = new PainterGenerator(r);
-        System.out.println("Generating source file: " + painterName + ".java");
-        System.out.println(gen.stateTypeCode.toString());
-        variables.put("PAINTER_NAME", painterName);
-        variables.put("STATIC_DECL", gen.stateTypeCode.toString());
-        variables.put("COLORS_DECL", gen.colorCode.toString());
-        variables.put("DO_PAINT_SWITCH_BODY", gen.switchCode.toString());
-        variables.put("PAINTING_DECL", gen.paintingCode.toString());
-        variables.put("GET_EXTENDED_CACHE_KEYS", gen.getExtendedCacheKeysCode.toString());
-        variables.put("SHAPES_DECL", gen.shapesCode.toString());
-        variables.put("GRADIENTS_DECL", gen.gradientsCode.toString());
-
-        writeSrcFile(getPainterImplTemplate(), variables, new File(painterPackageRoot, painterName + ".java"));
-
-        variables.remove("PAINTER_NAME");
-        variables.remove("STATIC_DECL");
-        variables.remove("COLORS_DECL");
-        variables.remove("DO_PAINT_SWITCH_BODY");
-        variables.remove("PAINTING_DECL");
-        variables.remove("SHAPES_DECL");
-        variables.remove("GRADIENTS_DECL");
-    }
-
-    /**
-     * Represents the usage of a color from a component within a painter. That
-     * is, a painter can use colors from the component when it paints. This
-     * class represents the usage of such a color, containing a reference to
-     * the name of the property that contains the color, and the various
-     * derivation offsets to apply to that color.
-     */
-    private static class ComponentColor {
-        public String propertyName;
-        public String defaultColorVariableName;
-        private float saturationOffset = 0, brightnessOffset = 0;
-        private int alphaOffset = 0;
-
-        private ComponentColor(String propertyName,
-                               String defaultColorVariableName,
-                               float saturationOffset,
-                               float brightnessOffset,
-                               int alphaOffset) {
-            this.propertyName = propertyName;
-            this.defaultColorVariableName = defaultColorVariableName;
-            this.saturationOffset = saturationOffset;
-            this.brightnessOffset = brightnessOffset;
-            this.alphaOffset = alphaOffset;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            ComponentColor c = (ComponentColor)o;
-            if (alphaOffset != c.alphaOffset) return false;
-            if (Float.compare(saturationOffset, c.saturationOffset) != 0)
-                return false;
-            if (Float.compare(brightnessOffset, c.brightnessOffset) != 0)
-                return false;
-            if (defaultColorVariableName != null ?
-                    !defaultColorVariableName.equals(c.defaultColorVariableName) :
-                    c.defaultColorVariableName != null) return false;
-            if (propertyName != null ? !propertyName.equals(c.propertyName) :
-                    c.propertyName != null) return false;
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 5;
-            hash = 61 * hash + (this.propertyName != null ?
-                this.propertyName.hashCode() : 0);
-            hash = 61 * hash + (this.defaultColorVariableName != null ?
-                this.defaultColorVariableName.hashCode() : 0);
-            hash = 61 * hash + Float.floatToIntBits(this.saturationOffset);
-            hash = 61 * hash + Float.floatToIntBits(this.brightnessOffset);
-            hash = 61 * hash + this.alphaOffset;
-            return hash;
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/generator/TemplateWriter.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,114 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.generator;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintWriter;
-import java.io.StringReader;
-import java.util.Map;
-
-/**
- * TemplateWriter - Class for writing Java Source files using a src template and variable subsitution
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class TemplateWriter {
-
-    /**
-     * Write a Java source file by taking a template file and applying variable substitution and writing to the output
-     * file.
-     *
-     * @param template  The template to use
-     * @param variables Map of the variable names and values to substitute in the template
-     * @param output    The file to write to
-     * @throws IOException If there was a problem writing the Java source file
-     */
-    static void writeSrcFile(String template, Map<String, String> variables, File output) throws IOException {
-        TemplateReader in = new TemplateReader(variables, template);
-        PrintWriter out =
-                new PrintWriter(new FileWriter(output));
-
-        String line = in.readLine();
-        while (line != null) {
-            out.println(line);
-            line = in.readLine();
-        }
-
-        out.close();
-    }
-
-    /**
-     * Read a template file into a string
-     *
-     * @param name The template file path relative to Generator class
-     * @return The contents of the template file as string
-     * @throws IOException If there was a problem reading the template file
-     */
-    static String read(String name) throws IOException {
-        InputStream in = Generator.class.getResourceAsStream(name);
-        if (in==null) throw new IOException("Could not find template ["+name+
-                "] relative to class ["+Generator.class.getName()+"]");
-        byte[] data = new byte[4096];
-        int length = -1;
-        StringBuilder buffer = new StringBuilder();
-        while ((length = in.read(data)) != -1) {
-            buffer.append(new String(data, 0, length));
-        }
-        return buffer.toString();
-    }
-
-    /** A BufferedReader implementation that automatically performs string replacements as needed. */
-    private static final class TemplateReader extends BufferedReader {
-        private Map<String, String> variables;
-
-        TemplateReader(Map<String, String> variables, String template) {
-            super(new StringReader(template));
-            this.variables = variables;
-        }
-
-        /**
-         * @return a line of text from the template but with variables substituted. Other methods will return the text
-         *         sans substitution. Call this method.
-         * @throws java.io.IOException
-         */
-        public String readLine() throws IOException {
-            return substituteVariables(super.readLine());
-        }
-
-        private String substituteVariables(String input) {
-            if (input == null) return null;
-            for (Map.Entry<String, String> variable : variables.entrySet()) {
-                input = input.replace("${" + variable.getKey() + "}", variable.getValue());
-            }
-            return input;
-        }
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/CustomUIDefault.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,43 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-/**
- * CustomUIDefault
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class CustomUIDefault<T> extends UIDefault<T> {
-    private static int counter = -1;
-
-    public CustomUIDefault() {
-        super("Unnamed" + (++counter == 0 ? "" : counter), null);
-    }
-
-    public void setName(String id) {
-        super.setName(id);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/HasUIStyle.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,36 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-/**
- * HasUIStyle - A marker interface for all classes that have a UIStyle
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public interface HasUIStyle {
-
-    public UIStyle getStyle();
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/PainterBorder.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,43 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import javax.swing.border.EmptyBorder;
-
-/**
- * Represents a border that refers to a Painter to do it's work. This border
- * doesn't actually render -- it is just used as part of the model.
- *
- * @author Richard Bair
- */
-public class PainterBorder extends EmptyBorder {
-    private String painterName;
-    public PainterBorder(String painterName, int top, int left, int bottom, int right) {
-        super(top, left, bottom, right);
-        this.painterName = painterName;
-    }
-
-    public String getPainterName() { return painterName; }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/SynthModel.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,530 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.utils.HasResources;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.JButton;
-import javax.swing.JCheckBox;
-import javax.swing.JCheckBoxMenuItem;
-import javax.swing.JColorChooser;
-import javax.swing.JComboBox;
-import javax.swing.JDesktopPane;
-import javax.swing.JEditorPane;
-import javax.swing.JFileChooser;
-import javax.swing.JFormattedTextField;
-import javax.swing.JInternalFrame;
-import javax.swing.JLabel;
-import javax.swing.JList;
-import javax.swing.JMenu;
-import javax.swing.JMenuBar;
-import javax.swing.JMenuItem;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.JPasswordField;
-import javax.swing.JPopupMenu;
-import javax.swing.JProgressBar;
-import javax.swing.JRadioButton;
-import javax.swing.JRadioButtonMenuItem;
-import javax.swing.JRootPane;
-import javax.swing.JScrollBar;
-import javax.swing.JScrollPane;
-import javax.swing.JSeparator;
-import javax.swing.JSlider;
-import javax.swing.JSpinner;
-import javax.swing.JSplitPane;
-import javax.swing.JTabbedPane;
-import javax.swing.JTable;
-import javax.swing.JTextArea;
-import javax.swing.JTextField;
-import javax.swing.JTextPane;
-import javax.swing.JToggleButton;
-import javax.swing.JToolBar;
-import javax.swing.JToolTip;
-import javax.swing.JTree;
-import javax.swing.JViewport;
-import javax.swing.UIDefaults;
-import javax.swing.plaf.basic.BasicLookAndFeel;
-import javax.swing.plaf.metal.MetalLookAndFeel;
-import static javax.swing.plaf.synth.SynthConstants.*;
-import javax.swing.table.JTableHeader;
-import java.awt.Insets;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Models a Synth look and feel. Contains all of the colors, fonts, painters, states, etc that compose a synth look and
- * feel.
- * <p/>
- * To model Synth properly, I need to both Model the way Synth works (with styles, and so forth) and the way a look and
- * feel works (UIDefaults table, etc) since both of these are supported ways of doing things in Synth.
- * <p/>
- * One important (but non-visual) thing that needs to be configurable is the support for InputMaps per component. In
- * Synth, an input map can be associated with the main Synth element, meaning it applies to everything. Or it can be
- * associated with a single style. An Inputmap can have an id, and it can contain multiple key/action pairs (where
- * actions are denoted by name).
- * <p/>
- * It looks like Regions can have InputMaps? Sounds fishy to me. I think only Components really have input maps.
- * <p/>
- * I would like some way of denoting special keys between mac and other platforms. For example, cut, copy, paste etc
- * should be different. In general, the ctrl key and apple (meta) key are reversed from what is typically on windows.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class SynthModel extends AbstractBean implements HasUIDefaults, HasUIStyle, HasResources {
-    //I'm going to want:
-    //entries related to the Control color, and other colors of the Basic LAF
-    //entries related to fonts (standard fonts) used in the Basic LAF
-    //entries related to standard insets, borders, dimensions, icons
-    //entries related to component specific entries in the LAF
-    private List<UIPaint> colors;
-    private List<UIFont> fonts;
-    private List<UIInsets> insets;
-    private List<UIBorder> borders;
-    private List<UIDimension> dimensions;
-    private List<UIIcon> icons;
-    private List<UIComponent> components;
-    /**
-     * This is a local UIDefaults that contains all the UIDefaults in this synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     */
-    private transient UIDefaults modelDefaults = new UIDefaults();
-    private transient UIStyle globalStyle = new UIStyle();
-
-    private transient File resourcesDir;
-    private transient File imagesDir;
-    private transient File templatesDir;
-
-    /** Default constructor used by JIBX to create new empty SynthModel */
-    protected SynthModel() {
-        this(false);
-    }
-
-    public SynthModel(boolean populateWithDefaults) {
-        // create observable lists that fire changes on as property changes
-        colors = new ArrayList<UIPaint>();
-        fonts = new ArrayList<UIFont>();
-        insets = new ArrayList<UIInsets>();
-        borders = new ArrayList<UIBorder>();
-        dimensions = new ArrayList<UIDimension>();
-        icons = new ArrayList<UIIcon>();
-        components = new ArrayList<UIComponent>();
-
-        if (populateWithDefaults) {
-            //get the ui defaults from the SynthLookAndFeel. Using the UIDefaults table,
-            //pre initialize everything.
-//        SynthLookAndFeel synth = new SynthLookAndFeel();
-            BasicLookAndFeel synth = new MetalLookAndFeel();
-            UIDefaults defaults = synth.getDefaults();
-
-            //pre-init the palettes
-            colors.add(new UIColor("desktop", defaults.getColor("desktop"), modelDefaults));
-            colors.add(new UIColor("activeCaption", defaults.getColor("activeCaption"), modelDefaults));
-            colors.add(new UIColor("activeCaptionText", defaults.getColor("activeCaptionText"), modelDefaults));
-            colors.add(new UIColor("activeCaptionBorder", defaults.getColor("activeCaptionBorder"), modelDefaults));
-            colors.add(new UIColor("inactiveCaption", defaults.getColor("inactiveCaption"), modelDefaults));
-            colors.add(new UIColor("inactiveCaptionText", defaults.getColor("inactiveCaptionText"), modelDefaults));
-            colors.add(new UIColor("inactiveCaptionBorder", defaults.getColor("inactiveCaptionBorder"), modelDefaults));
-            colors.add(new UIColor("window", defaults.getColor("window"), modelDefaults));
-            colors.add(new UIColor("windowBorder", defaults.getColor("windowBorder"), modelDefaults));
-            colors.add(new UIColor("windowText", defaults.getColor("windowText"), modelDefaults));
-            colors.add(new UIColor("menu", defaults.getColor("menu"), modelDefaults));
-            colors.add(new UIColor("menuText", defaults.getColor("menuText"), modelDefaults));
-            colors.add(new UIColor("text", defaults.getColor("text"), modelDefaults));
-            colors.add(new UIColor("textText", defaults.getColor("textText"), modelDefaults));
-            colors.add(new UIColor("textHighlight", defaults.getColor("textHighlight"), modelDefaults));
-            colors.add(new UIColor("textHighlightText", defaults.getColor("textHighlightText"), modelDefaults));
-            colors.add(new UIColor("textInactiveText", defaults.getColor("textInactiveText"), modelDefaults));
-            colors.add(new UIColor("control", defaults.getColor("control"), modelDefaults));
-            colors.add(new UIColor("controlText", defaults.getColor("controlText"), modelDefaults));
-            colors.add(new UIColor("controlHighlight", defaults.getColor("controlHighlight"), modelDefaults));
-            colors.add(new UIColor("controlLHighlight", defaults.getColor("controlLHighlight"), modelDefaults));
-            colors.add(new UIColor("controlShadow", defaults.getColor("controlShadow"), modelDefaults));
-            colors.add(new UIColor("controlDkShadow", defaults.getColor("controlDkShadow"), modelDefaults));
-            colors.add(new UIColor("scrollbar", defaults.getColor("scrollbar"), modelDefaults));
-            colors.add(new UIColor("info", defaults.getColor("info"), modelDefaults));
-            colors.add(new UIColor("infoText", defaults.getColor("infoText"), modelDefaults));
-
-            fonts.add(new UIFont("dialogPlain", defaults.getFont("Button.font"), modelDefaults));
-            fonts.add(new UIFont("serifPlain", defaults.getFont("TextPane.font"), modelDefaults));
-            fonts.add(new UIFont("sansSerifPlain", defaults.getFont("ToolTip.font"), modelDefaults));
-            fonts.add(new UIFont("monospacedPlain", defaults.getFont("TextArea.font"), modelDefaults));
-            fonts.add(new UIFont("dialogBold", defaults.getFont("InternalFrame.titleFont"), modelDefaults));
-
-            insets.add(new UIInsets("zeroInsets", new Insets(0, 0, 0, 0)));
-            insets.add(new UIInsets("twoInsets", new Insets(2, 2, 2, 2)));
-            insets.add(new UIInsets("threeInsets", new Insets(3, 3, 3, 3)));
-
-            borders.add(new UIBorder("marginBorder", defaults.getBorder("MenuItem.border")));
-            borders.add(new UIBorder("etchedBorder", defaults.getBorder("TitledBorder.border")));
-            borders.add(new UIBorder("loweredBevelBorder", defaults.getBorder("Table.scrollPaneBorder")));
-            borders.add(new UIBorder("blackLineBorder", defaults.getBorder("ToolTip.border")));
-
-            //TODO have to deal with the special arrow button region
-
-            //pre-init the list of UI components
-            UIComponent button = new UIComponent("Button", JButton.class.getName(), "ButtonUI");
-            addStates(this, button, DEFAULT, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(button);
-
-            UIComponent toggleButton =
-                    new UIComponent("ToggleButton", JToggleButton.class.getName(), "ToggleButtonUI");
-            addStates(this, toggleButton, DEFAULT, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED, SELECTED,
-                    SELECTED | PRESSED, SELECTED | MOUSE_OVER, DISABLED | SELECTED);
-            components.add(toggleButton);
-
-            UIComponent radioButton =
-                    new UIComponent("RadioButton", JRadioButton.class.getName(), "RadioButtonUI");
-            addStates(this, radioButton, DEFAULT, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED, SELECTED,
-                    SELECTED | PRESSED, SELECTED | MOUSE_OVER, DISABLED | SELECTED);
-            components.add(radioButton);
-
-            UIComponent checkBox =
-                    new UIComponent("CheckBox", JCheckBox.class.getName(), "CheckBoxUI");
-            addStates(this, checkBox, DEFAULT, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED, SELECTED,
-                    SELECTED | PRESSED, SELECTED | MOUSE_OVER, DISABLED | SELECTED);
-            components.add(checkBox);
-
-            UIComponent colorChooser =
-                    new UIComponent("ColorChooser", JColorChooser.class.getName(), "ColorChooserUI");
-            addStates(this, colorChooser, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(colorChooser);
-
-            UIComponent comboBox =
-                    new UIComponent("ComboBox", JComboBox.class.getName(), "ComboBoxUI");
-            addStates(this, comboBox, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(comboBox);
-
-            UIComponent fileChooser =
-                    new UIComponent("FileChooser", JFileChooser.class.getName(), "FileChooserUI");
-            addStates(this, fileChooser, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(fileChooser);
-
-            //not represented in Synth
-//        UIComponent  fileView = new UIComponent ("FileView",
-//                list(DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-
-            UIComponent internalFrame =
-                    new UIComponent("InternalFrame", JInternalFrame.class.getName(), "InternalFrameUI");
-            addStates(this, internalFrame, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has an internal frame title pane region
-            components.add(internalFrame);
-
-            //TODO DesktopIcon ???
-
-            UIComponent desktop =
-                    new UIComponent("Desktop", JDesktopPane.class.getName(), "DesktopPaneUI");
-            addStates(this, desktop, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(desktop);
-
-            UIComponent label = new UIComponent("Label", JLabel.class.getName(), "LabelUI");
-            addStates(this, label, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(label);
-
-            UIComponent list = new UIComponent("List", JList.class.getName(), "ListUI");
-            addStates(this, list, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(list);
-
-            UIComponent menuBar = new UIComponent("MenuBar", JMenuBar.class.getName(), "MenuBarUI");
-            addStates(this, menuBar, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(menuBar);
-
-            UIComponent menuItem =
-                    new UIComponent("MenuItem", JMenuItem.class.getName(), "MenuItemUI");
-            addStates(this, menuItem, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has a menuItemAccelerator region
-            components.add(menuItem);
-
-            UIComponent radioButtonMenuItem =
-                    new UIComponent("RadioButtonMenuItem", JRadioButtonMenuItem.class.getName(),
-                            "RadioButtonMenuItemUI");
-            addStates(this, radioButtonMenuItem, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(radioButtonMenuItem);
-
-            UIComponent checkBoxMenuItem =
-                    new UIComponent("CheckBoxMenuItem", JCheckBoxMenuItem.class.getName(),
-                            "CheckBoxMenuItemUI");
-            addStates(this, checkBoxMenuItem, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(checkBoxMenuItem);
-
-            UIComponent menu = new UIComponent("Menu", JMenu.class.getName(), "MenuUI");
-            addStates(this, menu, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(menu);
-
-            UIComponent popupMenu =
-                    new UIComponent("PopupMenu", JPopupMenu.class.getName(), "PopupMenuUI");
-            addStates(this, popupMenu, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has a popupMenuSeparator region
-            components.add(popupMenu);
-
-            UIComponent optionPane =
-                    new UIComponent("OptionPane", JOptionPane.class.getName(), "OptionPaneUI");
-            addStates(this, optionPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(optionPane);
-
-            UIComponent panel = new UIComponent("Panel", JPanel.class.getName(), "PanelUI");
-            addStates(this, panel, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(panel);
-
-            UIComponent progressBar =
-                    new UIComponent("ProgressBar", JProgressBar.class.getName(), "ProgressBarUI");
-            addStates(this, progressBar, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(progressBar);
-
-            UIComponent separator =
-                    new UIComponent("Separator", JSeparator.class.getName(), "SeparatorUI");
-            addStates(this, separator, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(separator);
-
-            UIRegion scrollBarThumb = new UIRegion("ScrollBar.Thumb");
-            addStates(this, scrollBarThumb, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            UIRegion scrollBarTrack = new UIRegion("ScrollBar.Track");
-            addStates(this, scrollBarTrack, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            UIComponent scrollBar =
-                    new UIComponent("ScrollBar", JScrollBar.class.getName(), "ScrollBarUI", scrollBarThumb,
-                            scrollBarTrack);
-            addStates(this, scrollBar, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(scrollBar);
-
-            UIComponent scrollPane =
-                    new UIComponent("ScrollPane", JScrollPane.class.getName(), "ScrollPaneUI");
-            addStates(this, scrollPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(scrollPane);
-
-            UIComponent viewport =
-                    new UIComponent("Viewport", JViewport.class.getName(), "ViewportUI");
-            addStates(this, viewport, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(viewport);
-
-            UIComponent slider = new UIComponent("Slider", JSlider.class.getName(), "SliderUI");
-            addStates(this, slider, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has sliderThumb and sliderTrack sub regions
-            components.add(slider);
-
-            UIComponent spinner = new UIComponent("Spinner", JSpinner.class.getName(), "SpinnerUI");
-            addStates(this, spinner, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(spinner);
-
-            UIComponent splitPane =
-                    new UIComponent("SplitPane", JSplitPane.class.getName(), "SplitPaneUI");
-            addStates(this, splitPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has splitPaneDivider sub region
-            components.add(splitPane);
-
-            UIComponent tabbedPane =
-                    new UIComponent("TabbedPane", JTabbedPane.class.getName(), "TabbedPaneUI");
-            addStates(this, tabbedPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //has tabbedPaneContent and tabbedPaneTab and TabbedPaneTabArea sub regions
-            components.add(tabbedPane);
-
-            UIComponent table = new UIComponent("Table", JTable.class.getName(), "TableUI");
-            addStates(this, table, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(table);
-
-            UIComponent tableHeader =
-                    new UIComponent("TableHeader", JTableHeader.class.getName(), "TableHeaderUI");
-            addStates(this, tableHeader, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(tableHeader);
-
-            UIComponent textField =
-                    new UIComponent("TextField", JTextField.class.getName(), "TextFieldUI");
-            addStates(this, textField, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(textField);
-
-            UIComponent formattedTextField =
-                    new UIComponent("FormattedTextField", JFormattedTextField.class.getName(),
-                            "FormattedTextFieldUI");
-            addStates(this, formattedTextField, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(formattedTextField);
-
-            UIComponent passwordField =
-                    new UIComponent("PasswordField", JPasswordField.class.getName(), "PasswordFieldUI");
-            addStates(this, passwordField, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(passwordField);
-
-            UIComponent textArea =
-                    new UIComponent("TextArea", JTextArea.class.getName(), "TextAreaUI");
-            addStates(this, textArea, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(textArea);
-
-            UIComponent textPane =
-                    new UIComponent("TextPane", JTextPane.class.getName(), "TextPaneUI");
-            addStates(this, textPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(textPane);
-
-            UIComponent editorPane =
-                    new UIComponent("EditorPane", JEditorPane.class.getName(), "EditorPaneUI");
-            addStates(this, editorPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(editorPane);
-
-            /*
-            * The only thing not represented in Synth as a region. I suppose we'll have
-            * to make it a CustomUIComponent
-            */
-//        UIComponent  titledBorder = new UIComponent ("TitledBorder",
-//                list(DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-
-            UIComponent toolBar = new UIComponent("ToolBar", JToolBar.class.getName(), "ToolBarUI");
-            addStates(this, toolBar, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //toolBarContent, toolBarDragWindow, toolBarSeparator sub regions
-            components.add(toolBar);
-
-            UIComponent toolTip = new UIComponent("ToolTip", JToolTip.class.getName(), "ToolTipUI");
-            addStates(this, toolTip, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(toolTip);
-
-            //tooltip manager
-
-            UIComponent tree = new UIComponent("Tree", JTree.class.getName(), "TreeUI");
-            addStates(this, tree, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            //treeCell sub region
-            components.add(tree);
-
-            UIComponent rootPane =
-                    new UIComponent("RootPane", JRootPane.class.getName(), "RootPaneUI");
-            addStates(this, rootPane, DISABLED, ENABLED, FOCUSED, MOUSE_OVER, PRESSED);
-            components.add(rootPane);
-        }
-    }
-
-    public List<UIPaint> getColorPalette() {
-        return colors;
-    }
-
-    public List<UIFont> getFontPalette() {
-        return fonts;
-    }
-
-    public List<UIInsets> getInsetPalette() {
-        return insets;
-    }
-
-    public List<UIBorder> getBorderPalette() {
-        return borders;
-    }
-
-    public List<UIDimension> getDimensionPalette() {
-        return dimensions;
-    }
-
-    public List<UIIcon> getIconPalette() {
-        return icons;
-    }
-
-    public List<UIComponent> getComponents() {
-        return components;
-    }
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in this synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     *
-     * @return The UIDefaults for the synth model
-     */
-    public UIDefaults getUiDefaults() {
-        return modelDefaults;
-    }
-
-    public UIStyle getStyle() {
-        return globalStyle;
-    }
-
-    // by default there are no painters assigned to the various states
-    private static void addStates(SynthModel model, UIRegion parentRegion, int... states) {
-        for (int state : states) {
-            List<String> stateList = new ArrayList<String>();
-            if ((state & ENABLED) != 0) {
-                stateList.add(UIStateType.ENABLED_KEY);
-            }
-            if ((state & MOUSE_OVER) != 0) {
-                stateList.add(UIStateType.MOUSE_OVER_KEY);
-            }
-            if ((state & PRESSED) != 0) {
-                stateList.add(UIStateType.PRESSED_KEY);
-            }
-            if ((state & DISABLED) != 0) {
-                stateList.add(UIStateType.DISABLED_KEY);
-            }
-            if ((state & FOCUSED) != 0) {
-                stateList.add(UIStateType.FOCUSED_KEY);
-            }
-            if ((state & SELECTED) != 0) {
-                stateList.add(UIStateType.SELECTED_KEY);
-            }
-            if ((state & DEFAULT) != 0) {
-                stateList.add(UIStateType.DEFAULT_KEY);
-            }
-            parentRegion.addBackgroundState(new UIState(model, parentRegion, stateList.toArray(new String[stateList.size()])));
-        }
-    }
-
-    public File getResourcesDir() {
-        return resourcesDir;
-    }
-
-    public void setResourcesDir(File resourcesDir) {
-        System.out.println("SynthModel.setResourcesDir(" + resourcesDir + ")");
-        File old = getResourcesDir();
-        this.resourcesDir = resourcesDir;
-        firePropertyChange("resourcesDir", old, getResourcesDir());
-    }
-
-    public File getImagesDir() {
-        return imagesDir;
-    }
-
-    public void setImagesDir(File imagesDir) {
-        System.out.println("SynthModel.setImagesDir(" + imagesDir + ")");
-        File old = getImagesDir();
-        this.imagesDir = imagesDir;
-        firePropertyChange("imagesDir", old, getImagesDir());
-    }
-
-    public File getTemplatesDir() {
-        return templatesDir;
-    }
-
-    public void setTemplatesDir(File templatesDir) {
-        System.out.println("SynthModel.setTemplatesDir(" + templatesDir + ")");
-        File old = getTemplatesDir();
-        this.templatesDir = templatesDir;
-        firePropertyChange("templatesDir", old, getTemplatesDir());
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    public void preSet(IUnmarshallingContext context) {
-        File resourcesDir = (File) context.getUserContext();
-        this.resourcesDir = resourcesDir;
-        this.imagesDir = new File(resourcesDir, "images");
-        this.templatesDir = new File(resourcesDir, "templates");
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/SynthModel.jibx.xml	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,181 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
- Copyright 1998-2004 Sun Microsystems, Inc.  All Rights Reserved.
- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-
- This code is free software; you can redistribute it and/or modify it
- under the terms of the GNU General Public License version 2 only, as
- published by the Free Software Foundation.  Sun designates this
- particular file as subject to the "Classpath" exception as provided
- by Sun in the LICENSE file that accompanied this code.
-
- This code is distributed in the hope that it will be useful, but WITHOUT
- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- version 2 for more details (a copy is included in the LICENSE file that
- accompanied this code).
-
- You should have received a copy of the GNU General Public License version
- 2 along with this work; if not, write to the Free Software Foundation,
- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
- Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- CA 95054 USA or visit www.sun.com if you need additional information or
- have any questions.
--->
-
-<!DOCTYPE binding SYSTEM "http://jibx.sourceforge.net">
-<binding>
-    <mapping class="org.jdesktop.synthdesigner.synthmodel.UIDefault" abstract="true" post-set="postSet">
-        <value name="name" field="name" style="attribute"/>
-    </mapping>
-    <!-- == AWT TYPES =========================================================================================== -->
-    <mapping class="java.awt.Color"
-             marshaller="org.jdesktop.swingx.designer.jibxhelpers.ColorMapper"
-             unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.ColorMapper"/>
-    <mapping class="java.lang.Class"
-             marshaller="org.jdesktop.synthdesigner.synthmodel.jibxhelpers.ClassMapper"
-             unmarshaller="org.jdesktop.synthdesigner.synthmodel.jibxhelpers.ClassMapper"/>
-    <!-- == UI FONT =========================================================================================== -->
-    <mapping name="typeface" class="org.jdesktop.swingx.designer.font.Typeface" post-set="postSet">
-        <value name="family" field="name" style="attribute" usage="optional"/>
-        <value name="bold" field="bold" style="attribute" usage="optional" default="Default"/>
-        <value name="italic" field="italic" style="attribute" usage="optional" default="Default"/>
-        <value name="size" field="size" style="attribute" usage="optional"/>
-        <value name="sizeOffset" field="sizeOffset" style="attribute" usage="optional" default="1"/>
-        <value name="uiDefaultParentName" field="uiDefaultParentName" style="attribute" usage="optional"/>
-    </mapping>
-    <mapping name="uiFont" class="org.jdesktop.synthdesigner.synthmodel.UIFont"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIDefault">
-        <structure map-as="org.jdesktop.synthdesigner.synthmodel.UIDefault"/>
-        <collection get-method="getFonts" set-method="setFonts" create-type="java.util.ArrayList"/>
-    </mapping>
-    <!-- == UI INSETS =========================================================================================== -->
-    <mapping name="uiInsets" class="org.jdesktop.synthdesigner.synthmodel.UIInsets"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIDefault">
-        <structure map-as="org.jdesktop.synthdesigner.synthmodel.UIDefault"/>
-        <structure name="insets" get-method="getInsets" set-method="setInsets"
-                   marshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"
-                   unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"/>
-    </mapping>
-    <!-- == UI PAINT =========================================================================================== -->
-    <mapping name="matte" class="org.jdesktop.swingx.designer.paint.Matte" post-set="postSet">
-        <value name="red" field="red" style="attribute"/>
-        <value name="green" field="green" style="attribute"/>
-        <value name="blue" field="blue" style="attribute"/>
-        <value name="alpha" field="alpha" style="attribute"/>
-        <value name="uiDefaultParentName" field="uiDefaultParentName" style="attribute" usage="optional"/>
-        <value name="componentPropertyName" field="componentPropertyName" style="attribute" usage="optional"/>
-        <value name="hueOffset" field="hueOffset" style="attribute"/>
-        <value name="saturationOffset" field="saturationOffset" style="attribute"/>
-        <value name="brightnessOffset" field="brightnessOffset" style="attribute"/>
-        <value name="alphaOffset" field="alphaOffset" style="attribute"/>
-        <value name="uiResource" field="uiResource" style="attribute" usage="optional" default="true"/>
-    </mapping>
-    <mapping class="org.jdesktop.synthdesigner.synthmodel.UIPaint" abstract="true" type-name="uipaint"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIDefault">
-        <structure map-as="org.jdesktop.synthdesigner.synthmodel.UIDefault"/>
-        <structure get-method="getPaint" set-method="setPaint"/>
-    </mapping>
-    <mapping name="uiPaint" class="org.jdesktop.synthdesigner.synthmodel.UIPaint"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIDefault">
-        <structure map-as="uipaint"/>
-    </mapping>
-    <mapping name="uiColor" class="org.jdesktop.synthdesigner.synthmodel.UIColor"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIPaint">
-        <structure map-as="uipaint"/>
-    </mapping>
-    <!-- == UI STYLE =========================================================================================== -->
-    <mapping class="org.jdesktop.synthdesigner.synthmodel.UIStyle" abstract="true" post-set="postSet">
-        <structure field="font" usage="optional"/>
-        <structure name="textForeground" usage="optional">
-            <structure field="textForeground" usage="optional"/>
-        </structure>
-        <structure name="textBackground" usage="optional">
-            <structure field="textBackground" usage="optional"/>
-        </structure>
-        <structure name="background" usage="optional">
-            <structure field="background" usage="optional"/>
-        </structure>
-        <value name="inherit-font" field="fontInherited" usage="optional" default="true"/>
-        <value name="inherit-textForeground" field="textForegroundInherited" usage="optional" default="true"/>
-        <value name="inherit-textBackground" field="textBackgroundInherited" usage="optional" default="true"/>
-        <value name="inherit-background" field="backgroundInherited" usage="optional" default="true"/>
-        <value name="hintAlphaInterpolation" field="hintAlphaInterpolation" usage="optional"/>
-        <value name="hintAntialiasing" field="hintAntialiasing" usage="optional"/>
-        <value name="hintColorRendering" field="hintColorRendering" usage="optional"/>
-        <value name="hintDithering" field="hintDithering" usage="optional"/>
-        <value name="hintFractionalMetrics" field="hintFractionalMetrics" usage="optional"/>
-        <value name="hintInterpolation" field="hintInterpolation" usage="optional"/>
-        <value name="hintRendering" field="hintRendering" usage="optional"/>
-        <value name="hintStrokeControl" field="hintStrokeControl" usage="optional"/>
-        <value name="hintTextAntialiasing" field="hintTextAntialiasing" usage="optional"/>
-        <value name="cacheSettingsInherited" field="cacheSettingsInherited" usage="optional" default="true"/>
-        <value name="cacheMode" field="cacheMode" usage="optional" default="FIXED_SIZES"/>
-        <value name="maxHozCachedImgScaling" field="maxHozCachedImgScaling" usage="optional" default="1"/>
-        <value name="maxVertCachedImgScaling" field="maxVertCachedImgScaling" usage="optional" default="1"/>
-        <collection name="uiproperties" field="uiProperties" create-type="java.util.ArrayList">
-            <structure marshaller="org.jdesktop.synthdesigner.synthmodel.jibxhelpers.UIPropertyMapper"
-                       unmarshaller="org.jdesktop.synthdesigner.synthmodel.jibxhelpers.UIPropertyMapper"/>
-        </collection>
-    </mapping>
-    <!-- == UI STATE =========================================================================================== -->
-    <mapping name="stateType" class="org.jdesktop.synthdesigner.synthmodel.UIStateType">
-        <value name="key" field="key" style="attribute"/>
-        <structure name="codeSnippet" usage="optional" test-method="hasCodeSnippet">
-            <value field="codeSnippet" style="cdata" usage="optional"/>
-        </structure>
-    </mapping>
-    <mapping name="state" class="org.jdesktop.synthdesigner.synthmodel.UIState" post-set="postSet" pre-set="preSet">
-        <value name="stateKeys" field="stateKeys" style="attribute" get-method="getStateKeys" set-method="setStateKeys"
-               serializer="org.jdesktop.synthdesigner.synthmodel.UIState.keysToString"
-               deserializer="org.jdesktop.synthdesigner.synthmodel.UIState.stringToKeys"/>
-        <value name="inverted" field="inverted" style="attribute" usage="optional"/>
-        <structure name="style" field="style"/>
-        <structure field="canvas"
-                   marshaller="org.jdesktop.swingx.designer.jibxhelpers.CanvasMapper"
-                   unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.CanvasMapper"/>
-    </mapping>
-    <!-- == REGIONS =========================================================================================== -->
-    <mapping class="org.jdesktop.synthdesigner.synthmodel.UIRegion" abstract="true"
-             type-name="region" pre-set="preSet">
-        <value name="name" field="name" style="attribute"/>
-        <value name="ui" field="ui" style="attribute" usage="optional"/>
-        <value name="subregion" field="subregion" style="attribute"/>
-        <value name="key" field="key" style="attribute" usage="optional"/>
-        <value name="title" field="title" style="attribute" usage="optional"/>
-        <structure name="contentMargins" field="contentMargins"
-                   marshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"
-                   unmarshaller="org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper"/>
-        <structure name="style" field="style"/>
-        <collection name="backgroundStates" field="backgroundStates" create-type="java.util.ArrayList"/>
-        <collection name="foregroundStates" field="foregroundStates" create-type="java.util.ArrayList"/>
-        <collection name="borderStates" field="borderStates" create-type="java.util.ArrayList"/>
-        <collection name="regions" field="subRegions" create-type="java.util.ArrayList"/>
-    </mapping>
-    <mapping name="region" class="org.jdesktop.synthdesigner.synthmodel.UIRegion">
-        <structure map-as="region"/>
-    </mapping>
-    <mapping name="uiIconRegion" class="org.jdesktop.synthdesigner.synthmodel.UIIconRegion"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIRegion">
-        <structure map-as="region"/>
-        <value name="basicKey" field="basicKey" style="attribute" usage="optional"/>
-    </mapping>
-    <mapping name="uiComponent" class="org.jdesktop.synthdesigner.synthmodel.UIComponent"
-             extends="org.jdesktop.synthdesigner.synthmodel.UIRegion">
-        <value name="opaque" field="opaque" style="attribute"/>
-        <value name="componentName" field="componentName" style="attribute" usage="optional"/>
-        <value name="type" field="type" style="attribute"/>
-        <collection name="stateTypes" field="stateTypes" create-type="java.util.ArrayList"/>
-        <structure map-as="region"/>
-    </mapping>
-    <!-- == BASE MODEL =========================================================================================== -->
-    <mapping name="synthModel" class="org.jdesktop.synthdesigner.synthmodel.SynthModel" pre-set="preSet">
-        <collection name="insets" field="insets" create-type="java.util.ArrayList"/>
-        <collection name="colors" field="colors" create-type="java.util.ArrayList"/>
-        <collection name="fonts" field="fonts" create-type="java.util.ArrayList"/>
-        <structure name="style" field="globalStyle"/>
-        <collection name="components" field="components" create-type="java.util.ArrayList"/>
-    </mapping>
-</binding>
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIBorder.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,53 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import javax.swing.border.Border;
-
-/**
- * UIBorder
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIBorder extends UIDefault<Border> {
-
-    public UIBorder() {
-    }
-
-    public UIBorder(String id, Border b) {
-        super(id, b);
-    }
-
-    public Border getBorder() {
-        return super.getValue();
-    }
-
-    public void setBorder(Border b) {
-        Border old = getBorder();
-        super.setValue(b);
-        firePropertyChange("border", old, b);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIColor.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,58 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-
-import javax.swing.UIDefaults;
-import java.awt.Color;
-
-/**
- * UIColor
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIColor extends UIPaint {
-
-    public UIColor() {
-    }
-
-    public UIColor(String id, Matte value) {
-        super(id, value);
-    }
-
-    public UIColor(String id, Color color, UIDefaults modelDefaults) {
-        this(id, new Matte(color, modelDefaults));
-    }
-
-    public Matte getPaint() {
-        return (Matte) super.getPaint();
-    }
-
-    public void setPaint(Matte c) {
-        super.setPaint(c);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIComponent.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,138 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/**
- * UIComponent - model node that represents the designs for a single swing component
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIComponent extends UIRegion implements HasUIDefaults {
-
-    /** The classname of the swing component that this UIComponent represents */
-    private String type;
-    /** The name of the component if its a named component or null if its a generic component */
-    private String componentName = null;
-    /** If this components is opaque which means that when it is painted all of its bounds are filled */
-    private boolean opaque = false;
-    /**
-     * A list of state types that are available to this region and sub regions of this component but not subcomponents
-     * of this component. If this list is empty then the standard synth set of state types are assumed.
-     */
-    private List<UIStateType> stateTypes;
-
-    // =================================================================================================================
-    // Contructors
-
-    /** no-args contructor for JIBX */
-    protected UIComponent() {
-        super();
-        // create new observable list for state types so we get events for when the model changes
-        stateTypes = new ArrayList<UIStateType>();
-    }
-
-    public UIComponent(String name, String type, String ui, UIRegion... subRegions) {
-        super(name, ui, subRegions);
-        this.type = type;
-        for (UIRegion r : subRegions) {
-            r.setRegion(this);
-        }
-        // create new observable list for state types so we get events for when the model changes
-        stateTypes = new ArrayList<UIStateType>();
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    public String getComponentName() {
-        return componentName;
-    }
-
-    public void setComponentName(String componentName) {
-        String old = getComponentName();
-        this.componentName = componentName;
-        firePropertyChange("componentName", old, getComponentName());
-    }
-
-    public boolean isOpaque() {
-        return opaque;
-    }
-
-    public void setOpaque(boolean opaque) {
-        boolean old = isOpaque();
-        this.opaque = opaque;
-        firePropertyChange("opaque", old, isOpaque());
-    }
-
-    public String getType() {
-        return type;
-    }
-
-    public void setType(String type) {
-        String old = getType();
-        this.type = type;
-        firePropertyChange("type", old, getType());
-    }
-
-    /**
-     * Get the list of state types that are available to this region and sub regions of this component but not
-     * subcomponents of this component. If this list is empty then the standard synth set of state types are assumed.
-     *
-     * @return List of available state types
-     */
-    public List<UIStateType> getStateTypes() {
-        return stateTypes;
-    }
-
-    @Override public String getKey() {
-        if (key == null || "".equals(key)) {
-            if (componentName == null || "".equals(componentName)) {
-                return getName();
-            } else {
-                return "\"" + componentName + "\"";
-            }
-        } else {
-            return key;
-        }
-    }
-
-    @Override public String getTitle() {
-        if (title == null || "".equals(title)) {
-            if (componentName == null || "".equals(componentName)) {
-                return getName();
-            } else {
-                return componentName;
-            }
-        } else {
-            return title;
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIDefault.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,116 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.UIDefaults;
-
-/**
- * Represents an entry in the UI defaults table.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIDefault<T> extends AbstractBean implements HasUIDefaults {
-    private String name;
-    private T value;
-    /**
-     * This is a local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     */
-    private transient UIDefaults modelDefaults = null;
-
-    public UIDefault() {
-    }
-
-    public UIDefault(String name, T value) {
-        this.name = name;
-        this.value = value;
-    }
-
-    public UIDefault(String name, T value, UIDefaults modelDefaults) {
-        this.name = name;
-        this.value = value;
-        this.modelDefaults = modelDefaults;
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void postSet(IUnmarshallingContext context) {
-        // walk up till we get synth model
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIDefaults) {
-                modelDefaults = ((HasUIDefaults) context.getStackObject(i)).getUiDefaults();
-                if (modelDefaults != null) break;
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     *
-     * @return The UIDefaults for the synth model
-     */
-    public UIDefaults getUiDefaults() {
-        return modelDefaults;
-    }
-
-    public void setValue(T t) {
-        T old = this.value;
-        this.value = t;
-        firePropertyChange("value", old, getValue());
-    }
-
-    public T getValue() {
-        return value;
-    }
-
-    public final String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        String old = this.name;
-        firePropertyChange("name", old, name);
-        this.name = name;
-        // update model defaults
-        if (old != null) modelDefaults.remove(old);
-        modelDefaults.put(getName(), getValue());
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIDimension.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import java.awt.Dimension;
-
-/**
- * UIDimension
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIDimension extends UIDefault<Dimension> {
-    public UIDimension() {
-    }
-
-    public Dimension getDimension() {
-        return super.getValue();
-    }
-
-    public void setDimension(Dimension d) {
-        Dimension old = getDimension();
-        super.setValue(d);
-        firePropertyChange("dimension", old, d);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIFont.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,79 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import java.awt.Font;
-import org.jdesktop.swingx.designer.font.Typeface;
-import java.util.Arrays;
-import java.util.List;
-import java.util.ArrayList;
-import javax.swing.UIDefaults;
-
-/**
- * Represents a single font entry in the UIDefaults table. Each UIFont takes a
- * list of Typefaces. These typefaces are listed by order of preference. Thus,
- * when putting a font into UIDefaults, the code can check whether each font
- * exists, and when it finds the first font that does, insert it.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIFont extends UIDefault<List<Typeface>> implements Cloneable {
-
-    private void updateUIDefaults() {
-        if (getUiDefaults() != null) {
-            for (Typeface t : getFonts()) {
-                if (t.isFontSupported()) {
-                    getUiDefaults().put(getName(), t.getFont());
-                    return;
-                }
-            }
-        }
-
-        //TODO must not have found any. Default to the Default platform font
-        getUiDefaults().put(getName(), new Font("Arial", Font.PLAIN, 12));
-    }
-
-    public UIFont() {
-        setValue(new ArrayList<Typeface>());
-    }
-
-    public UIFont(String id, List<Typeface> values, UIDefaults defaults) {
-        super(id, values, defaults);
-        updateUIDefaults();
-    }
-
-    public UIFont(String id, Font font, UIDefaults modelDefaults) {
-        this(id, Arrays.asList(new Typeface(font, modelDefaults)), modelDefaults);
-    }
-
-    public List<Typeface> getFonts() {
-        return super.getValue();
-    }
-
-    private void setFonts(List<Typeface> values) {
-        super.setValue(values);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIIcon.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,49 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import javax.swing.Icon;
-
-/**
- * UIIcon
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIIcon extends UIDefault<Icon> {
-
-    public UIIcon() {
-    }
-
-    public Icon getIcon() {
-        return super.getValue();
-    }
-
-    public void setIcon(Icon i) {
-        Icon old = getIcon();
-        super.setValue(i);
-        firePropertyChange("icon", old, i);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIIconRegion.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-/**
- * A UIRegion subclass which is used for generating icons. For example, JRadioButton and JCheckBox represent themselves
- * mainly via their icons. However, from the designers perspective, the main design isn't an "icon", but just a region
- * on the button.
- * <p/>
- * That type of region is represented by a UIIconRegion. UIIconRegion contains a string which references the UIDefault
- * value associated with this icon. For example, RadioButton.icon.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIIconRegion extends UIRegion {
-    /** The UiDefaults key which this icon should be stored for basic LaF to find it. This is absolute */
-    private String basicKey = null;
-
-    public UIIconRegion() {
-        super();
-    }
-
-    public String getBasicKey() {
-        return basicKey;
-    }
-
-    public void setBasicKey(String basicKey) {
-        String old = getBasicKey();
-        this.basicKey = basicKey;
-        firePropertyChange("basicKey",old,getBasicKey());
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIInsets.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import java.awt.Insets;
-
-/**
- * UIInsets
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIInsets extends UIDefault<Insets> {
-
-    public UIInsets() {
-    }
-
-    public UIInsets(String id, Insets value) {
-        super(id, value);
-    }
-
-    public Insets getInsets() {
-        return super.getValue();
-    }
-
-    public void setInsets(Insets i) {
-        Insets old = getInsets();
-        super.setValue(i);
-        firePropertyChange("insets", old, i);
-        // update model defaults
-        getUiDefaults().put(getName(), i);
-    }
-
-
-    public String toString() {
-        return "UiInset(" + getName() + ")" +
-                ((getInsets() == null) ? " NONE" : "(" + getInsets().top + "," + getInsets().left + "," +
-                        getInsets().bottom + "," + getInsets().right + ")");
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIPaint.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,84 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.swingx.designer.paint.Matte;
-import org.jdesktop.swingx.designer.paint.PaintModel;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-
-/**
- * UIPaint
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIPaint extends UIDefault<PaintModel> {
-
-    /** Listener to keep model UiDefaults up to date for this UiPaint */
-    private PropertyChangeListener matteListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            PaintModel paintModel = getValue();
-            if (paintModel instanceof Matte) {
-                getUiDefaults().put(getName(), ((Matte) paintModel).getColor());
-            }
-            // propogate the paint change up as PaintModel is a mutable object
-            if (evt.getPropertyName().equals("paint")) {
-                firePropertyChange("paint", null, getPaint());
-                firePropertyChange("value", null, getPaint());
-            }
-        }
-    };
-
-    public UIPaint() {}
-
-    public UIPaint(String id, PaintModel value) {
-        super(id, value, (value instanceof Matte) ? ((Matte) value).getUiDefaults() : null);
-        // update model defaults
-        if (value instanceof Matte) {
-            Matte matte = (Matte) value;
-            if (getUiDefaults() != null) getUiDefaults().put(getName(), matte.getColor());
-            matte.addPropertyChangeListener(matteListener);
-        }
-    }
-
-    public PaintModel getPaint() {
-        return super.getValue();
-    }
-
-    public void setPaint(PaintModel c) {
-        PaintModel old = getPaint();
-        if (old instanceof Matte) old.removePropertyChangeListener(matteListener);
-        super.setValue(c);
-        firePropertyChange("paint", old, c);
-        // update model defaults
-        if (c instanceof Matte) {
-            Matte matte = (Matte) c;
-            getUiDefaults().put(getName(), matte.getColor());
-            matte.addPropertyChangeListener(matteListener);
-        }
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIProperty.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,85 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-
-/**
- * UIProperty
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIProperty extends AbstractBean {
-    public static enum PropertyType {
-        BOOLEAN, INT, FLOAT, DOUBLE, STRING, FONT, COLOR, INSETS, DIMENSION, BORDER
-    }
-
-    private String name;
-    private PropertyType type;
-    private Object value;
-
-    protected UIProperty() {
-    }
-
-    public UIProperty(String name, PropertyType type, Object value) {
-        this.name = name;
-        this.type = type;
-        this.value = value;
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        String old = getName();
-        this.name = name;
-        firePropertyChange("name", old, getName());
-    }
-
-    public PropertyType getType() {
-        return type;
-    }
-
-    public void setType(PropertyType type) {
-        PropertyType old = getType();
-        this.type = type;
-        firePropertyChange("type", old, getType());
-    }
-
-    public Object getValue() {
-        return value;
-    }
-
-    public void setValue(Object value) {
-        Object old = getValue();
-        this.value = value;
-        firePropertyChange("value", old, getValue());
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIRegion.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,253 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.UIDefaults;
-import java.awt.Insets;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.List;
-import java.util.ArrayList;
-
-/**
- * Represents a "Region" in synth, which also includes entire components.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIRegion extends AbstractBean implements HasUIDefaults, HasUIStyle {
-    private String name;//the code-wise name of the region
-    protected String key; //the UIdefaults key for this region
-    protected String title; //the user friendly name/title of this region
-    /** List of background states */
-    private List<UIState> backgroundStates;
-    /** List of foreground states */
-    private List<UIState> foregroundStates;
-    /** List of border states */
-    private List<UIState> borderStates;
-    private UIStyle style = new UIStyle();
-    protected Insets contentMargins = new Insets(0, 0, 0, 0);
-    /** Sub regions, if any */
-    private List<UIRegion> subRegions;
-
-    //together with name, these two fields allow me to reconstruct, in
-    //code, a synth Region, including a custom Region, if you make one.
-    private String ui;
-    private boolean subregion;
-    /**
-     * This is a local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     */
-    private transient UIDefaults modelDefaults = null;
-
-    private UIRegion region; //the region that this region belongs to
-
-    // =================================================================================================================
-    // Constructors
-
-    /** no-args contructor for JIBX */
-    protected UIRegion() {
-        subRegions = new ArrayList<UIRegion>();
-        backgroundStates = new ArrayList<UIState>();
-        foregroundStates = new ArrayList<UIState>();
-        borderStates = new ArrayList<UIState>();
-        style.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("style." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-            }
-        });
-    }
-
-    public UIRegion(String name, UIRegion... subRegions) {
-        this(name, null, true, subRegions);
-    }
-
-    public UIRegion(String name, String ui, UIRegion... subRegions) {
-        this(name, ui, false, subRegions);
-    }
-
-    public UIRegion(String name, String ui, boolean subregion, UIRegion... subRegions) {
-        this();
-        this.name = name;
-        this.ui = ui;
-        this.subregion = subregion;
-        if (subRegions != null) {
-            for (UIRegion r : subRegions) {
-                if (r != null) {
-                    this.subRegions.add(r);
-                    r.getStyle().setParentStyle(getStyle());
-                }
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void preSet(IUnmarshallingContext context) {
-        // walk up till we get synth model
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIDefaults) {
-                modelDefaults = ((HasUIDefaults) context.getStackObject(i)).getUiDefaults();
-                if (modelDefaults != null) break;
-            }
-        }
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof UIRegion && context.getStackObject(i) != this) {
-                region = (UIRegion) context.getStackObject(i);
-                break;
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    public Insets getContentMargins() {
-        return contentMargins;
-    }
-
-    public void setContentMargins(Insets contentMargins) {
-        Insets old = getContentMargins();
-        this.contentMargins = contentMargins;
-        firePropertyChange("contentMargins", old, getContentMargins());
-    }
-
-    void setRegion(UIRegion r) {
-        this.region = r;
-    }
-
-    public UIRegion getRegion() {
-        return region;
-    }
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     *
-     * @return The UIDefaults for the synth model
-     */
-    public UIDefaults getUiDefaults() {
-        return modelDefaults;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public final UIRegion[] getSubRegions() {
-        return subRegions.toArray(new UIRegion[0]);
-    }
-
-    public final UIState[] getBackgroundStates() {
-        return backgroundStates.toArray(new UIState[0]);
-    }
-
-    public final UIState[] getForegroundStates() {
-        return foregroundStates.toArray(new UIState[0]);
-    }
-
-    public final UIState[] getBorderStates() {
-        return borderStates.toArray(new UIState[0]);
-    }
-
-    public UIStyle getStyle() {
-        return style;
-    }
-
-    public final boolean isSubRegion() {
-        return subregion;
-    }
-
-    public final String getUi() {
-        return ui;
-    }
-
-    public void addBackgroundState(UIState state) {
-        // check if we already have that state
-        for (UIState uiState : backgroundStates) {
-            if (uiState.getName().equals(state.getName())) return;
-        }
-        backgroundStates.add(state);
-        state.setRegion(this);
-        firePropertyChange("backgroundStates", null, backgroundStates);
-    }
-
-    public void removeBackgroundState(UIState state) {
-        if (backgroundStates.remove(state)) {
-            firePropertyChange("backgroundStates", null, backgroundStates);
-        }
-    }
-
-    public void addForegroundState(UIState state) {
-        // check if we already have that state
-        for (UIState uiState : foregroundStates) {
-            if (uiState.getName().equals(state.getName())) return;
-        }
-        foregroundStates.add(state);
-        state.setRegion(this);
-        firePropertyChange("foregroundStates", null, foregroundStates);
-    }
-
-    public void removeForegroundState(UIState state) {
-        if (foregroundStates.remove(state)) {
-            firePropertyChange("foregroundStates", null, foregroundStates);
-        }
-    }
-
-    public void addBorderState(UIState state) {
-        // check if we already have that state
-        for (UIState uiState : borderStates) {
-            if (uiState.getName().equals(state.getName())) return;
-        }
-        borderStates.add(state);
-        state.setRegion(this);
-        firePropertyChange("borderStates", null, borderStates);
-    }
-
-    public void removeBorderState(UIState state) {
-        if (borderStates.remove(state)) {
-            firePropertyChange("borderStates", null, borderStates);
-        }
-    }
-
-
-    public String getKey() {
-        return key == null || "".equals(key) ? name : key;
-    }
-
-    public String getTitle() {
-        return title == null || "".equals(title) ? name : title;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIState.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,298 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.Canvas;
-import org.jdesktop.swingx.designer.utils.HasPath;
-import org.jdesktop.swingx.designer.utils.HasUIDefaults;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import javax.swing.UIDefaults;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Represents a State in the Synth LAF.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIState extends AbstractBean implements HasUIStyle, HasPath {
-
-    private List<String> stateKeys;
-    private boolean inverted; //indicates whether to invert the meaning of the 9-square stretching insets
-    /** A cached string representing the list of stateKeys deliminated with "+" */
-    private String cachedName = null;
-    private Canvas canvas;
-    private UIStyle style;
-    /** the region that this state belongs to */
-    private UIRegion region;
-    /**
-     * This is a local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     */
-    private transient UIDefaults modelDefaults = null;
-
-    // =================================================================================================================
-    // Contructors
-
-    public UIState() {
-        // Create state keys as event list so model changes are propogated
-        stateKeys = new ArrayList<String>();
-    }
-
-    public UIState(SynthModel model, UIRegion parentRegion, String... stateTypeKeys) {
-        // Create state keys as event list so model changes are propogated
-        stateKeys = new ArrayList<String>();
-        this.stateKeys.addAll(Arrays.asList(stateTypeKeys));
-        //
-        modelDefaults = model.getUiDefaults();
-        region = parentRegion;
-        // create new canvas
-        canvas = new Canvas(100, 30);
-        canvas.setUiDefaults(modelDefaults);
-        String canvasPath = getPath();
-        canvas.setResourcesDir(new File(model.getResourcesDir(), canvasPath));
-        canvas.setTemplatesDir(new File(model.getTemplatesDir(), canvasPath));
-        canvas.setImagesDir(new File(model.getImagesDir(), canvasPath));
-        canvas.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("canvas." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-            }
-        });
-        // create new style
-        style = new UIStyle();
-        style.setParentStyle(region.getStyle());
-        style.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("style." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-            }
-        });
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * JIBX needs this
-     *
-     * @param stateKeys The new list of states
-     */
-    private void setStateKeys(List<String> stateKeys) {
-        if (stateKeys != this.stateKeys) {
-            this.stateKeys.clear();
-            this.stateKeys.addAll(stateKeys);
-        }
-    }
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void preSet(IUnmarshallingContext context) {
-        // walk up till we get synth model
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIDefaults) {
-                modelDefaults = ((HasUIDefaults) context.getStackObject(i)).getUiDefaults();
-                if (modelDefaults != null) break;
-            }
-        }
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof UIRegion) {
-                region = (UIRegion) context.getStackObject(i);
-                break;
-            }
-        }
-    }
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void postSet(IUnmarshallingContext context) {
-        // add listeners to pass canvas and style events up tree
-        canvas.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("canvas." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-            }
-        });
-        style.addPropertyChangeListener(new PropertyChangeListener() {
-            public void propertyChange(PropertyChangeEvent evt) {
-                firePropertyChange("style." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-            }
-        });
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get path to this UI State of the form /RegionA/RegionB/StateName
-     *
-     * @return Path to this state
-     */
-    public String getPath() {
-        StringBuilder buf = new StringBuilder(getName());
-        UIRegion region = getRegion();
-        // check if we are foreground background or border
-        boolean found = false;
-        for (UIState state : region.getBackgroundStates()) {
-            if (state == this) {
-                buf.insert(0, "Background/");
-                found = true;
-                break;
-            }
-        }
-        if (!found) {
-            for (UIState state : region.getForegroundStates()) {
-                if (state == this) {
-                    buf.insert(0, "Foreground/");
-                    found = true;
-                    break;
-                }
-            }
-        }
-        if (!found) {
-            for (UIState state : region.getBorderStates()) {
-                if (state == this) {
-                    buf.insert(0, "Border/");
-                    found = true;
-                    break;
-                }
-            }
-        }
-        // add parent regions
-        while (region != null) {
-            buf.insert(0, '/');
-            if (region instanceof UIComponent && ((UIComponent) region).getComponentName() != null) {
-                buf.insert(0, ((UIComponent) region).getComponentName());
-            } else {
-                buf.insert(0, region.getName());
-            }
-            region = region.getRegion();
-        }
-        return buf.toString();
-    }
-
-    void setRegion(UIRegion r) {
-        this.region = r;
-        this.style.setParentStyle(r.getStyle());
-    }
-
-    public UIRegion getRegion() {
-        return region;
-    }
-
-    /**
-     * Get the local UIDefaults that contains all the UIDefaults in the synth model. It is kept uptodate by the
-     * indervidual UIDefaults nodes
-     *
-     * @return The UIDefaults for the synth model
-     */
-    public UIDefaults getUIDefaults() {
-        return modelDefaults;
-    }
-
-
-    /**
-     * Get the list of state type keys for this state. This state is applied when the current component state matches as
-     * many as possible of these state types.
-     *
-     * @return List of state types that need to be true for this state. This is direct access to the data and changes to
-     *         the returned list will effect this UiState.
-     */
-    public List<String> getStateKeys() {
-        return stateKeys;
-    }
-
-    public void setInverted(boolean b) {
-        boolean old = inverted;
-        inverted = b;
-        firePropertyChange("invert", old, b);
-    }
-
-    public final boolean isInverted() {
-        return inverted;
-    }
-
-    /**
-     * Get the name of this state
-     *
-     * @return
-     */
-    public String getName() {
-        if (cachedName == null) {
-            StringBuilder buf = new StringBuilder();
-            List<String> keys = new ArrayList<String>(stateKeys);
-            Collections.sort(keys);
-            for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
-                buf.append(iter.next());
-                if (iter.hasNext()) buf.append('+');
-            }
-            cachedName = buf.toString();
-        }
-        return cachedName;
-    }
-
-    public final Canvas getCanvas() {
-        return canvas;
-    }
-
-    public void setCanvas(Canvas c) {
-        Canvas old = canvas;
-        canvas = c;
-        firePropertyChange("canvas", old, c);
-    }
-
-    public UIStyle getStyle() {
-        return style;
-    }
-
-    // =================================================================================================================
-    // JIBX Helper Methods
-
-    public static String keysToString(List<String> keys) {
-        StringBuilder buf = new StringBuilder();
-        for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
-            buf.append(iter.next());
-            if (iter.hasNext()) buf.append('+');
-        }
-        return buf.toString();
-    }
-
-    public static List<String> stringToKeys(String keysString) {
-        return Arrays.asList(keysString.split("\\+"));
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIStateType.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,129 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-
-/**
- * UIStateType - A UIComponents has a collection of these which constitute the avilables states which can be chosen in
- * the components regions. A UIStateType can be either a custom state or one of the predefined standard states.
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIStateType extends AbstractBean {
-    /* Keys for standard synth states */
-    public static final String ENABLED_KEY = "Enabled";
-    public static final String MOUSE_OVER_KEY = "MouseOver";
-    public static final String PRESSED_KEY = "Pressed";
-    public static final String DISABLED_KEY = "Disabled";
-    public static final String FOCUSED_KEY = "Focused";
-    public static final String SELECTED_KEY = "Selected";
-    public static final String DEFAULT_KEY = "Default";
-    public static final String[] STANDARD_SYNTH_STATE_KEYS = new String[]{
-            ENABLED_KEY, MOUSE_OVER_KEY, PRESSED_KEY, DISABLED_KEY, FOCUSED_KEY, SELECTED_KEY, DEFAULT_KEY
-    };
-    public static final UIStateType[] STANDARD_SYNTH_STATES = new UIStateType[]{
-            new UIStateType(ENABLED_KEY),
-            new UIStateType(MOUSE_OVER_KEY),
-            new UIStateType(PRESSED_KEY),
-            new UIStateType(DISABLED_KEY),
-            new UIStateType(FOCUSED_KEY),
-            new UIStateType(SELECTED_KEY),
-            new UIStateType(DEFAULT_KEY)
-    };
-
-    /** Unique string for the ui key for this state, must be unique within a components set of UiStateTypes */
-    private String key;
-    /**
-     * Snippet of java code that defines calculates the value of this state for a particular component. The varaiable
-     * <code>c</code> is the component. You end with a return statement returning boolean true/false for the current
-     * value of this state for this component. This can be null if the key is one of that standard synth states defined
-     * in constants in this class.
-     */
-    private String codeSnippet;
-
-    /** JIBX no-args contructor */
-    private UIStateType() {}
-
-    private UIStateType(String key) {
-        this.key = key;
-        this.codeSnippet = null;
-    }
-
-    public UIStateType(String key, String codeSnippet) {
-        this.key = key;
-        this.codeSnippet = codeSnippet;
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    /**
-     * Get the ui defaults key for this state type. Unique string for the ui key for this state, must be unique within a
-     * components set of UiStateTypes.
-     *
-     * @return Unique ui default key
-     */
-    public String getKey() {
-        return key;
-    }
-
-    /**
-     * Get the snippet of java code that defines calculates the value of this state for a particular component. The
-     * varaiable <code>c</code> is the component. You end with a return statement returning boolean true/false for the
-     * current value of this state for this component. This can be null if the key is one of that standard synth states
-     * defined in constants in this class.
-     *
-     * @return Snippet of java code or null if this is a synth standard state
-     */
-    public String getCodeSnippet() {
-        return codeSnippet;
-    }
-
-    /**
-     * Set the snippet of java code that defines calculates the value of this state for a particular component. The
-     * varaiable <code>c</code> is the component. You end with a return statement returning boolean true/false for the
-     * current value of this state for this component. This can be null if the key is one of that standard synth states
-     * defined in constants in this class.
-     *
-     * @param codeSnippet Snippet of java code or null if this is a synth standard state
-     */
-    public void setCodeSnippet(String codeSnippet) {
-        this.codeSnippet = codeSnippet;
-    }
-
-    /**
-     * Returns if this state type is a standard synth type and has no code snippet or a custom type that has a code
-     * snippet. It is used by JIBX to determin if the code snippet should be written to XML.
-     *
-     * @return <code>true</code> if codeSnippet is non null
-     */
-    public boolean hasCodeSnippet() {
-        return codeSnippet != null;
-    }
-
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/UIStyle.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,467 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel;
-
-import org.jdesktop.beans.AbstractBean;
-import org.jdesktop.swingx.designer.font.Typeface;
-import org.jdesktop.swingx.designer.paint.Matte;
-import org.jibx.runtime.IUnmarshallingContext;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.util.List;
-import java.util.ArrayList;
-
-/**
- * UIStyle
- *
- * @author  Richard Bair
- * @author  Jasper Potts
- */
-public class UIStyle extends AbstractBean {
-    public static enum CacheMode {NO_CACHING,FIXED_SIZES,NINE_SQUARE_SCALE}
-    public static enum HintAlphaInterpolation {
-        DEFAULT, QUALITY, SPEED
-    }
-
-    public static enum HintAntialiasing {
-        DEFAULT, ON, OFF
-    }
-
-    public static enum HintColorRendering {
-        DEFAULT, QUALITY, SPEED
-    }
-
-    public static enum HintDithering {
-        DEFAULT, DISABLE, ENABLE
-    }
-
-    public static enum HintFractionalMetrics {
-        DEFAULT, ON, OFF
-    }
-
-    public static enum HintInterpolation {
-        NEAREST_NEIGHBOR, BILINEAR, BICUBIC
-    }
-
-    public static enum HintRendering {
-        DEFAULT, QUALITY, SPEED
-    }
-
-    public static enum HintStrokeControl {
-        DEFAULT, NORMALIZE, PURE
-    }
-
-    public static enum HintTextAntialiasing {
-        DEFAULT, ON, OFF, GASP, LCD_HBGR, LCD_HRGB, LCD_VBGR, LCD_VRGB
-    }
-
-    private Typeface font = null;
-    private boolean fontInherited = true;
-    private Matte textForeground = null;
-    private boolean textForegroundInherited = true;
-    private Matte textBackground = null;
-    private boolean textBackgroundInherited = true;
-    private Matte background = null;
-    private boolean backgroundInherited = true;
-
-    private boolean cacheSettingsInherited = true;
-    private CacheMode cacheMode = CacheMode.FIXED_SIZES;
-    private double maxHozCachedImgScaling = 1;
-    private double maxVertCachedImgScaling = 1;
-
-    private HintAlphaInterpolation hintAlphaInterpolation = null;
-    private HintAntialiasing hintAntialiasing = null;
-    private HintColorRendering hintColorRendering = null;
-    private HintDithering hintDithering = null;
-    private HintFractionalMetrics hintFractionalMetrics = null;
-    private HintInterpolation hintInterpolation = null;
-    private HintRendering hintRendering = null;
-    private HintStrokeControl hintStrokeControl = null;
-    private HintTextAntialiasing hintTextAntialiasing = null;
-    private List<UIProperty> uiProperties;
-    private UIStyle parentStyle = null;
-
-    private PropertyChangeListener textForegoundListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            firePropertyChange("textForeground." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-    private PropertyChangeListener textBackgroundListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            firePropertyChange("textBackground." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-    private PropertyChangeListener backgroundListener = new PropertyChangeListener() {
-        public void propertyChange(PropertyChangeEvent evt) {
-            firePropertyChange("background." + evt.getPropertyName(), evt.getOldValue(), evt.getNewValue());
-        }
-    };
-
-    // =================================================================================================================
-    // Constructors
-
-    public UIStyle() {
-        uiProperties = new ArrayList<UIProperty>();
-    }
-
-    // =================================================================================================================
-    // JIBX Methods
-
-    /**
-     * Called by JIBX after all fields have been set
-     *
-     * @param context The JIBX Unmarshalling Context
-     */
-    private void postSet(IUnmarshallingContext context) {
-        // walk up till we get a parent style
-        for (int i = 0; i < context.getStackDepth(); i++) {
-            if (context.getStackObject(i) instanceof HasUIStyle) {
-                HasUIStyle hasStyle = (HasUIStyle) context.getStackObject(i);
-                if (hasStyle.getStyle() != this) {
-                    parentStyle = hasStyle.getStyle();
-                    if (parentStyle != null) break;
-                }
-            }
-        }
-    }
-
-    // =================================================================================================================
-    // Bean Methods
-
-    public UIStyle getParentStyle() {
-        return parentStyle;
-    }
-
-    public void setParentStyle(UIStyle parentStyle) {
-        UIStyle old = getParentStyle();
-        this.parentStyle = parentStyle;
-        firePropertyChange("parentStyle", old, getParentStyle());
-    }
-
-    public List<UIProperty> getUiProperties() {
-        return uiProperties;
-    }
-
-    public void addUiProperty(UIProperty uiProperty) {
-        uiProperties.add(uiProperty);
-        // todo not quite sure what events we want here
-        fireIndexedPropertyChange("uiProperties", uiProperties.size(), null, uiProperty);
-//        firePropertyChange("uiProperties", null, uiProperties);
-    }
-
-    public void removeUiProperty(UIProperty uiProperty) {
-        int index = uiProperties.indexOf(uiProperty);
-        if (index != -1) {
-            uiProperties.remove(uiProperty);
-            // todo not quite sure what events we want here
-            fireIndexedPropertyChange("uiProperties", index, null, uiProperty);
-//            firePropertyChange("uiProperties", null, uiProperties);
-        }
-    }
-
-    public Typeface getFont() {
-        if (isFontInherited()) {
-            return parentStyle == null ? font : parentStyle.getFont();
-        } else {
-            return font;
-        }
-    }
-
-    public void setFont(Typeface font) {
-        Typeface old = getFont();
-        this.font = font;
-        firePropertyChange("font", old, font);
-    }
-
-    public boolean isFontInherited() {
-        return fontInherited;
-    }
-
-    public void setFontInherited(boolean b) {
-        boolean old = isFontInherited();
-        fontInherited = b;
-        firePropertyChange("fontInherited", old, b);
-
-        if (!fontInherited && font == null && parentStyle != null && parentStyle.getFont() != null) {
-            font = parentStyle.getFont().clone();
-            firePropertyChange("font", null, font);
-        }
-    }
-
-    public Matte getTextForeground() {
-        if (isTextForegroundInherited()) {
-            return parentStyle == null ? null : parentStyle.getTextForeground();
-        } else {
-            return textForeground;
-        }
-    }
-
-    public boolean isTextForegroundInherited() {
-        return textForegroundInherited;
-    }
-
-    public void setTextForegroundInherited(boolean b) {
-        boolean old = isTextForegroundInherited();
-        textForegroundInherited = b;
-        firePropertyChange("foregroundInherited", old, b);
-
-        if (!textForegroundInherited && textForeground == null && parentStyle != null &&
-                parentStyle.getTextForeground() != null) {
-            textForeground = parentStyle.getTextForeground().clone();
-            firePropertyChange("textForeground", null, textForeground);
-        }
-    }
-
-    public void setTextForeground(Matte textForeground) {
-        Matte old = this.textForeground;
-        if (old != null) old.removePropertyChangeListener(textForegoundListener);
-        this.textForeground = textForeground;
-        if (this.textForeground != null) this.textForeground.addPropertyChangeListener(textForegoundListener);
-        firePropertyChange("textForeground", old, this.textForeground);
-    }
-
-    public Matte getTextBackground() {
-        if (isTextBackgroundInherited()) {
-            return parentStyle == null ? null : parentStyle.getBackground();
-        } else {
-            return textBackground;
-        }
-    }
-
-    public boolean isTextBackgroundInherited() {
-        return textBackgroundInherited;
-    }
-
-    public void setTextBackgroundInherited(boolean b) {
-        boolean old = isBackgroundInherited();
-        textBackgroundInherited = b;
-        firePropertyChange("textBackgroundInherited", old, b);
-
-        if (!textBackgroundInherited && textBackground == null && parentStyle != null &&
-                parentStyle.getTextBackground() != null) {
-            textBackground = parentStyle.getTextBackground().clone();
-            firePropertyChange("textBackground", null, textBackground);
-        }
-    }
-
-    public void setTextBackground(Matte textBackground) {
-        Matte old = this.textBackground;
-        if (old != null) old.removePropertyChangeListener(textBackgroundListener);
-        this.textBackground = textBackground;
-        if (this.textBackground != null) this.textBackground.addPropertyChangeListener(textBackgroundListener);
-        firePropertyChange("textBackground", old, this.textBackground);
-    }
-
-    public Matte getBackground() {
-        if (isBackgroundInherited()) {
-            return parentStyle == null ? null : parentStyle.getBackground();
-        } else {
-            return background;
-        }
-    }
-
-    public boolean isBackgroundInherited() {
-        return backgroundInherited;
-    }
-
-    public void setBackgroundInherited(boolean b) {
-        boolean old = isBackgroundInherited();
-        backgroundInherited = b;
-        firePropertyChange("backgroundInherited", old, b);
-
-        if (!backgroundInherited && background == null && parentStyle != null && parentStyle.getBackground() != null) {
-            background = parentStyle.getBackground().clone();
-            firePropertyChange("background", null, background);
-        }
-    }
-
-    public void setBackground(Matte background) {
-        Matte old = this.background;
-        if (old != null) old.removePropertyChangeListener(backgroundListener);
-        this.background = background;
-        if (this.background != null) this.background.addPropertyChangeListener(backgroundListener);
-        firePropertyChange("background", old, this.background);
-    }
-
-    public HintAlphaInterpolation getHintAlphaInterpolation() {
-        return hintAlphaInterpolation;
-    }
-
-    public void setHintAlphaInterpolation(HintAlphaInterpolation hintAlphaInterpolation) {
-        HintAlphaInterpolation old = getHintAlphaInterpolation();
-        this.hintAlphaInterpolation = hintAlphaInterpolation;
-        firePropertyChange("hintAlphaInterpolation", old, getHintAlphaInterpolation());
-    }
-
-    public HintAntialiasing getHintAntialiasing() {
-        return hintAntialiasing;
-    }
-
-    public void setHintAntialiasing(HintAntialiasing hintAntialiasing) {
-        HintAntialiasing old = getHintAntialiasing();
-        this.hintAntialiasing = hintAntialiasing;
-        firePropertyChange("hintAntialiasing", old, getHintAntialiasing());
-    }
-
-    public HintColorRendering getHintColorRendering() {
-        return hintColorRendering;
-    }
-
-    public void setHintColorRendering(HintColorRendering hintColorRendering) {
-        HintColorRendering old = getHintColorRendering();
-        this.hintColorRendering = hintColorRendering;
-        firePropertyChange("hintColorRendering", old, getHintColorRendering());
-    }
-
-    public HintDithering getHintDithering() {
-        return hintDithering;
-    }
-
-    public void setHintDithering(HintDithering hintDithering) {
-        HintDithering old = getHintDithering();
-        this.hintDithering = hintDithering;
-        firePropertyChange("hintDithering", old, getHintDithering());
-    }
-
-    public HintFractionalMetrics getHintFractionalMetrics() {
-        return hintFractionalMetrics;
-    }
-
-    public void setHintFractionalMetrics(HintFractionalMetrics hintFractionalMetrics) {
-        HintFractionalMetrics old = getHintFractionalMetrics();
-        this.hintFractionalMetrics = hintFractionalMetrics;
-        firePropertyChange("hintFractionalMetrics", old, getHintFractionalMetrics());
-    }
-
-    public HintInterpolation getHintInterpolation() {
-        return hintInterpolation;
-    }
-
-    public void setHintInterpolation(HintInterpolation hintInterpolation) {
-        HintInterpolation old = getHintInterpolation();
-        this.hintInterpolation = hintInterpolation;
-        firePropertyChange("hintInterpolation", old, getHintInterpolation());
-    }
-
-    public HintRendering getHintRendering() {
-        return hintRendering;
-    }
-
-    public void setHintRendering(HintRendering hintRendering) {
-        HintRendering old = getHintRendering();
-        this.hintRendering = hintRendering;
-        firePropertyChange("hintRendering", old, getHintRendering());
-    }
-
-    public HintStrokeControl getHintStrokeControl() {
-        return hintStrokeControl;
-    }
-
-    public void setHintStrokeControl(HintStrokeControl hintStrokeControl) {
-        HintStrokeControl old = getHintStrokeControl();
-        this.hintStrokeControl = hintStrokeControl;
-        firePropertyChange("hintStrokeControl", old, getHintStrokeControl());
-    }
-
-    public HintTextAntialiasing getHintTextAntialiasing() {
-        return hintTextAntialiasing;
-    }
-
-    public void setHintTextAntialiasing(HintTextAntialiasing hintTextAntialiasing) {
-        HintTextAntialiasing old = getHintTextAntialiasing();
-        this.hintTextAntialiasing = hintTextAntialiasing;
-        firePropertyChange("hintTextAntialiasing", old, getHintTextAntialiasing());
-    }
-
-    public boolean isCacheSettingsInherited() {
-        return cacheSettingsInherited;
-    }
-
-    public void setCacheSettingsInherited(boolean cacheSettingsInherited) {
-        boolean old = isCacheSettingsInherited();
-        this.cacheSettingsInherited = cacheSettingsInherited;
-        firePropertyChange("cacheSettingsInherited", old, isCacheSettingsInherited());
-    }
-
-    public CacheMode getCacheMode() {
-        if (isCacheSettingsInherited()) {
-            return (parentStyle == null)?CacheMode.FIXED_SIZES : parentStyle.getCacheMode();
-        } else {
-            return cacheMode;
-        }
-    }
-
-    public void setCacheMode(CacheMode cacheMode) {
-        CacheMode old = this.cacheMode;
-        this.cacheMode = cacheMode;
-        if (isCacheSettingsInherited()) {
-            setCacheSettingsInherited(false);
-            UIStyle parent = getParentStyle();
-            setMaxHozCachedImgScaling(parent == null ? 1 : parent.getMaxHozCachedImgScaling());
-            setMaxVertCachedImgScaling(parent == null ? 1 : parent.getMaxVertCachedImgScaling());
-        }
-        firePropertyChange("cacheMode",old,cacheMode);
-    }
-
-    public double getMaxHozCachedImgScaling() {
-        if (isCacheSettingsInherited()) {
-            return parentStyle == null ? 1 : parentStyle.getMaxHozCachedImgScaling();
-        } else {
-            return maxHozCachedImgScaling;
-        }
-    }
-
-    public void setMaxHozCachedImgScaling(double maxHozCachedImgScaling) {
-        double old = getMaxHozCachedImgScaling();
-        this.maxHozCachedImgScaling = maxHozCachedImgScaling;
-        if (isCacheSettingsInherited()) {
-            setCacheSettingsInherited(false);
-            setCacheMode((parentStyle == null)?CacheMode.FIXED_SIZES : parentStyle.getCacheMode());
-            setMaxVertCachedImgScaling(parentStyle == null ? 1 : parentStyle.getMaxVertCachedImgScaling());
-        }
-        firePropertyChange("maxHozCachedImgScaling", old, getMaxHozCachedImgScaling());
-    }
-
-    public double getMaxVertCachedImgScaling() {
-        if (isCacheSettingsInherited()) {
-            return parentStyle == null ? 1 : parentStyle.getMaxVertCachedImgScaling();
-        } else {
-            return maxVertCachedImgScaling;
-        }
-    }
-
-    public void setMaxVertCachedImgScaling(double maxVertCachedImgScaling) {
-        double old = getMaxVertCachedImgScaling();
-        this.maxVertCachedImgScaling = maxVertCachedImgScaling;
-        if (isCacheSettingsInherited()) {
-            setCacheSettingsInherited(false);
-            setCacheMode((parentStyle == null)?CacheMode.FIXED_SIZES : parentStyle.getCacheMode());
-            setMaxHozCachedImgScaling(parentStyle == null ? 1 : parentStyle.getMaxHozCachedImgScaling());
-        }
-        firePropertyChange("maxVertCachedImgScaling", old, getMaxVertCachedImgScaling());
-    }
-}
-
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/jibxhelpers/BorderMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,285 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel.jibxhelpers;
-
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IAliasable;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-import org.jdesktop.swingx.designer.jibxhelpers.ColorMapper;
-
-import javax.swing.border.LineBorder;
-import javax.swing.border.EmptyBorder;
-import javax.swing.border.EtchedBorder;
-import javax.swing.border.BevelBorder;
-import javax.swing.border.MatteBorder;
-import javax.swing.border.CompoundBorder;
-import javax.swing.border.Border;
-import javax.swing.BorderFactory;
-import java.awt.Insets;
-import java.awt.Color;
-import org.jdesktop.synthdesigner.synthmodel.PainterBorder;
-
-/**
- * BorderMapper - JIBX xml mapper for swing standard borders
- *
- * @author Jasper Potts
- */
-public class BorderMapper implements IMarshaller, IUnmarshaller, IAliasable {
-    private static enum BorderType {
-        empty, line, etched, bevel, matte, compound, painter
-    }
-    private static enum SubType {
-        raised(EtchedBorder.RAISED), lowered(EtchedBorder.LOWERED);
-        private int subtype;
-
-        SubType(int type) {
-            this.subtype = type;
-        }
-
-        public int getSubType() {
-            return subtype;
-        }
-    }
-    private static final String ELEMENT_NAME = "border";
-    private static final String TYPE_NAME = "type";
-    private static final String SUB_TYPE_NAME = "subtype";
-    private static final String TOP_NAME = "top";
-    private static final String BOTTOM_NAME = "bottom";
-    private static final String LEFT_NAME = "left";
-    private static final String RIGHT_NAME = "right";
-    private static final String THICKNESS_NAME = "thickness";
-    private static final String INSIDE_NAME = "inside";
-    private static final String OUTSIDE_NAME = "outside";
-    private static final String PAINTER_NAME = "painter";
-
-    private String uri;
-    private int index;
-    private String name;
-
-    public BorderMapper() {
-        uri = null;
-        index = 0;
-        name = ELEMENT_NAME;
-    }
-
-    public BorderMapper(String uri, int index, String name) {
-        this.uri = uri;
-        this.index = index;
-        this.name = name;
-    }
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws
-            JiBXException {
-        return iUnmarshallingContext.isAt(uri, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext)
-            throws JiBXException {
-        if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            if (object instanceof PainterBorder) {
-                PainterBorder border = (PainterBorder) object;
-                Insets insets = border.getBorderInsets();
-                ctx.startTagAttributes(index, name)
-                        .attribute(index, TYPE_NAME, BorderType.painter.toString())
-                        .attribute(index, PAINTER_NAME, border.getPainterName())
-                        .attribute(index, TOP_NAME, insets.top)
-                        .attribute(index, BOTTOM_NAME, insets.bottom)
-                        .attribute(index, LEFT_NAME, insets.left)
-                        .attribute(index, RIGHT_NAME, insets.right)
-                        .closeStartContent();
-                ctx.endTag(index, name);
-            } else if (object instanceof EmptyBorder) {
-                Insets insets = ((EmptyBorder) object).getBorderInsets();
-                ctx.startTagAttributes(index, name)
-                        .attribute(index, TYPE_NAME,
-                                BorderType.empty.toString())
-                        .attribute(index, TOP_NAME, insets.top)
-                        .attribute(index, BOTTOM_NAME, insets.bottom)
-                        .attribute(index, LEFT_NAME, insets.left)
-                        .attribute(index, RIGHT_NAME, insets.right)
-                        .closeStartEmpty();
-            } else if (object instanceof LineBorder) {
-                LineBorder border = (LineBorder) object;
-                ctx.startTagAttributes(index, name).
-                        attribute(index, TYPE_NAME, BorderType.line.toString()).
-                        attribute(index, THICKNESS_NAME, border.getThickness()).
-                        closeStartContent();
-                new ColorMapper().marshal(border.getLineColor(), ctx);
-                ctx.endTag(index, name);
-            } else if (object instanceof EtchedBorder) {
-                EtchedBorder border = (EtchedBorder) object;
-                ctx.startTagAttributes(index, name).
-                        attribute(index, TYPE_NAME,
-                                BorderType.etched.toString()).
-                        attribute(index, SUB_TYPE_NAME,
-                                border.getEtchType()==EtchedBorder.RAISED?
-                                        SubType.raised.toString():
-                                        SubType.lowered.toString()).
-                        closeStartContent();
-                new ColorMapper().marshal(border.getHighlightColor(), ctx);
-                new ColorMapper().marshal(border.getShadowColor(), ctx);
-                ctx.endTag(index, name);
-            } else if (object instanceof BevelBorder) {
-                BevelBorder border = (BevelBorder) object;
-                ctx.startTagAttributes(index, name).
-                        attribute(index, TYPE_NAME,
-                                BorderType.bevel.toString()).
-                        attribute(index, SUB_TYPE_NAME,
-                                border.getBevelType()==BevelBorder.RAISED?
-                                        SubType.raised.toString():
-                                        SubType.lowered.toString()).
-                        closeStartContent();
-                new ColorMapper().marshal(border.getHighlightInnerColor(), ctx);
-                new ColorMapper().marshal(border.getHighlightOuterColor(), ctx);
-                new ColorMapper().marshal(border.getShadowInnerColor(), ctx);
-                new ColorMapper().marshal(border.getHighlightOuterColor(), ctx);
-                ctx.endTag(index, name);
-            } else if (object instanceof MatteBorder) {
-                MatteBorder border = (MatteBorder) object;
-                Insets insets = ((EmptyBorder) object).getBorderInsets();
-                ctx.startTagAttributes(index, name)
-                        .attribute(index, TYPE_NAME,
-                                BorderType.matte.toString())
-                        .attribute(index, TOP_NAME, insets.top)
-                        .attribute(index, BOTTOM_NAME, insets.bottom)
-                        .attribute(index, LEFT_NAME, insets.left)
-                        .attribute(index, RIGHT_NAME, insets.right)
-                        .closeStartContent();
-                new ColorMapper().marshal(border.getMatteColor(), ctx);
-                // todo: we should support tiled icons here to be 100% complete
-                ctx.endTag(index, name);
-            } else if (object instanceof CompoundBorder) {
-                CompoundBorder border = (CompoundBorder) object;
-                ctx.startTagAttributes(index, name)
-                        .attribute(index, TYPE_NAME,
-                                BorderType.compound.toString())
-                        .closeStartContent();
-                new BorderMapper(null,0, INSIDE_NAME).marshal(border.getInsideBorder(),ctx);
-                new BorderMapper(null,0, OUTSIDE_NAME).marshal(border.getOutsideBorder(),ctx);
-                ctx.endTag(index, name);
-            } else {
-                throw new JiBXException("Invalid object type for marshaller");
-            }
-        }
-    }
-
-    public Object unmarshal(Object object,
-                            IUnmarshallingContext iUnmarshallingContext)
-            throws JiBXException {
-        Border border = null;
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(uri, name)) {
-            ctx.throwStartTagNameError(uri, name);
-        }
-        // get type
-        BorderType type = BorderType.valueOf(ctx.attributeText(uri, TYPE_NAME)
-                .toLowerCase());
-        int top,bottom,left,right;
-        Color color;
-        switch(type){
-            case empty:
-                top = ctx.attributeInt(uri, TOP_NAME, index);
-                bottom = ctx.attributeInt(uri, BOTTOM_NAME, index);
-                left = ctx.attributeInt(uri, LEFT_NAME, index);
-                right = ctx.attributeInt(uri, RIGHT_NAME, index);
-                border = BorderFactory.createEmptyBorder(top,left,bottom,right);
-                break;
-            case line:
-                int thickness = ctx.attributeInt(uri, THICKNESS_NAME, index);
-                ctx.parsePastStartTag(uri,name);
-                color = (Color)new ColorMapper().unmarshal(null,ctx);
-                border = BorderFactory.createLineBorder(color,thickness);
-                break;
-            case etched:
-                SubType etchedType = SubType.valueOf(
-                        ctx.attributeText(uri, SUB_TYPE_NAME).toLowerCase());
-                ctx.parsePastStartTag(uri,name);
-                Color highColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                Color shadowColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                border = BorderFactory.createEtchedBorder(
-                        etchedType.getSubType(),highColor,shadowColor);
-                break;
-            case bevel:
-                SubType bevelType = SubType.valueOf(
-                        ctx.attributeText(uri, SUB_TYPE_NAME).toLowerCase());
-                ctx.parsePastStartTag(uri,name);
-                Color innerHighColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                Color outerHighColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                Color innerShadowColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                Color outerShadowColor = (Color)new ColorMapper()
-                        .unmarshal(null,ctx);
-                border = BorderFactory.createBevelBorder(
-                        bevelType.getSubType(),outerHighColor,innerHighColor,
-                        outerShadowColor,innerShadowColor);
-                break;
-            case matte:
-                top = ctx.attributeInt(uri, TOP_NAME, index);
-                bottom = ctx.attributeInt(uri, BOTTOM_NAME, index);
-                left = ctx.attributeInt(uri, LEFT_NAME, index);
-                right = ctx.attributeInt(uri, RIGHT_NAME, index);
-                ctx.parsePastStartTag(uri,name);
-                color = (Color)new ColorMapper().unmarshal(null,ctx);
-                border = BorderFactory.createMatteBorder(top,left,bottom,right,
-                        color);
-                break;
-            case compound:
-                ctx.parsePastStartTag(uri,name);
-                Border inside = (Border) new BorderMapper(null,0, INSIDE_NAME)
-                        .unmarshal(null,ctx);
-                Border outside = (Border) new BorderMapper(null,0, OUTSIDE_NAME)
-                        .unmarshal(null,ctx);
-                border = BorderFactory.createCompoundBorder(outside, inside);
-                break;
-            case painter:
-                String painterName = ctx.attributeText(uri, PAINTER_NAME);
-                top = ctx.attributeInt(uri, TOP_NAME, index);
-                bottom = ctx.attributeInt(uri, BOTTOM_NAME, index);
-                left = ctx.attributeInt(uri, LEFT_NAME, index);
-                right = ctx.attributeInt(uri, RIGHT_NAME, index);
-                border = new PainterBorder(painterName, top, left, bottom, right);
-        }
-        ctx.parsePastEndTag(uri, name);
-        return border;
-    }
-}
-
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/jibxhelpers/ClassConverter.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,53 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel.jibxhelpers;
-
-/**
- * ClassConverter
- *
- * @author Created by Jasper Potts (Jul 16, 2007)
- */
-public class ClassConverter {
-
-    public static String classToString(Class c) {
-        return c == null ? "" : c.getName();
-    }
-
-    public static Class stringToClass(String className) {
-        if (className == null || className.length() == 0) {
-            return null;
-        }
-        try {
-            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-            if (classLoader == null) classLoader = ClassConverter.class.getClassLoader();
-            return classLoader.loadClass(className);
-        } catch (ClassNotFoundException e) {
-            System.err.println("Failed to find class with name [" + className + "] in ClassConverter");
-            e.printStackTrace();
-            return null;
-        }
-    }
-
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/jibxhelpers/ClassMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,78 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel.jibxhelpers;
-
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-
-public class ClassMapper implements IMarshaller, IUnmarshaller {
-    private static final String ELEMENT_NAME = "type";
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(null, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Class)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            Class clazz = (Class) object;
-            ctx.startTagAttributes(0, ELEMENT_NAME).
-                    attribute(0, "value", clazz.getName()).
-                    closeStartEmpty();
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(null, ELEMENT_NAME)) {
-            ctx.throwStartTagNameError(null, ELEMENT_NAME);
-        }
-        // get values
-        String value = ctx.attributeText(null, "value", null);
-        ctx.parsePastEndTag(null, ELEMENT_NAME);
-        // create
-        try {
-            return Class.forName(value);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        return null;
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/jibxhelpers/FontMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,86 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel.jibxhelpers;
-
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-import java.awt.Font;
-
-/**
- * FontMapper
- *
- * @author Created by Jasper Potts (Jun 8, 2007)
- */
-public class FontMapper implements IMarshaller, IUnmarshaller {
-    private static final String ELEMENT_NAME = "font";
-    private static final String FAMILY_NAME = "family";
-    private static final String STYLE_NAME = "style";
-    private static final String SIZE_NAME = "size";
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(null, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof Font)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            Font font = (Font) object;
-            ctx.startTagAttributes(0, ELEMENT_NAME).
-                    attribute(0, FAMILY_NAME, font.getFamily()).
-                    attribute(0, STYLE_NAME, font.getStyle()).
-                    attribute(0, SIZE_NAME, font.getSize()).
-                    closeStartEmpty();
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(null, ELEMENT_NAME)) {
-            ctx.throwStartTagNameError(null, ELEMENT_NAME);
-        }
-        // get values
-        String name = ctx.attributeText(null, FAMILY_NAME, null);
-        int style = ctx.attributeInt(null, STYLE_NAME, 0);
-        int size = ctx.attributeInt(null, SIZE_NAME, 0);
-        ctx.parsePastEndTag(null, ELEMENT_NAME);
-        // create
-        return new Font(name, style, size);
-    }
-}
--- a/make/tools/swing-nimbus/classes/org/jdesktop/synthdesigner/synthmodel/jibxhelpers/UIPropertyMapper.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,155 +0,0 @@
-/*
- * Copyright 2005-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-package org.jdesktop.synthdesigner.synthmodel.jibxhelpers;
-
-import org.jdesktop.swingx.designer.jibxhelpers.DimensionMapper;
-import org.jdesktop.swingx.designer.jibxhelpers.InsetsMapper;
-import org.jdesktop.synthdesigner.synthmodel.UIProperty;
-import org.jibx.runtime.IMarshallable;
-import org.jibx.runtime.IMarshaller;
-import org.jibx.runtime.IMarshallingContext;
-import org.jibx.runtime.IUnmarshaller;
-import org.jibx.runtime.IUnmarshallingContext;
-import org.jibx.runtime.JiBXException;
-import org.jibx.runtime.impl.MarshallingContext;
-import org.jibx.runtime.impl.UnmarshallingContext;
-
-/**
- * UIPropertyMapper
- *
- * @author Created by Jasper Potts (Jul 10, 2007)
- */
-public class UIPropertyMapper implements IMarshaller, IUnmarshaller {
-    private static final String ELEMENT_NAME = "uiProperty";
-    private static final String NAME_NAME = "name";
-    private static final String TYPE_NAME = "type";
-    private static final String VALUE_NAME = "value";
-
-    public boolean isExtension(int i) {
-        return false;
-    }
-
-    public boolean isPresent(IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        return iUnmarshallingContext.isAt(null, ELEMENT_NAME);
-    }
-
-    public void marshal(Object object, IMarshallingContext iMarshallingContext) throws JiBXException {
-        if (!(object instanceof UIProperty)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else if (!(iMarshallingContext instanceof MarshallingContext)) {
-            throw new JiBXException("Invalid object type for marshaller");
-        } else {
-            MarshallingContext ctx = (MarshallingContext) iMarshallingContext;
-            UIProperty property = (UIProperty) object;
-            ctx.startTagAttributes(0, ELEMENT_NAME);
-            ctx.attribute(0, NAME_NAME, property.getName());
-            ctx.attribute(0, TYPE_NAME, property.getType().toString());
-            switch (property.getType()) {
-                case BOOLEAN:
-                case DOUBLE:
-                case INT:
-                case FLOAT:
-                case STRING:
-                    ctx.attribute(0, VALUE_NAME, property.getValue().toString());
-                    ctx.closeStartEmpty();
-                    break;
-                case INSETS:
-                    ctx.closeStartContent();
-                    new InsetsMapper().marshal(property.getValue(), ctx);
-                    ctx.endTag(0, ELEMENT_NAME);
-                    break;
-                case COLOR:
-                case FONT:
-                    ctx.closeStartContent();
-                    if (property.getValue() instanceof IMarshallable) {
-                        ((IMarshallable) property.getValue()).marshal(ctx);
-                    } else {
-                        throw new JiBXException("Mapped value is not marshallable");
-                    }
-                    ctx.endTag(0, ELEMENT_NAME);
-                    break;
-                case DIMENSION:
-                    ctx.closeStartContent();
-                    new DimensionMapper().marshal(property.getValue(), ctx);
-                    ctx.endTag(0, ELEMENT_NAME);
-                    break;
-                case BORDER:
-                    ctx.closeStartContent();
-                    new BorderMapper().marshal(property.getValue(), ctx);
-                    ctx.endTag(0, ELEMENT_NAME);
-                    break;
-            }
-        }
-    }
-
-    public Object unmarshal(Object object, IUnmarshallingContext iUnmarshallingContext) throws JiBXException {
-        // make sure we're at the appropriate start tag
-        UnmarshallingContext ctx = (UnmarshallingContext) iUnmarshallingContext;
-        if (!ctx.isAt(null, ELEMENT_NAME)) {
-            ctx.throwStartTagNameError(null, ELEMENT_NAME);
-        }
-        // get values
-        Object value = null;
-        String name = ctx.attributeText(null, NAME_NAME, null);
-        UIProperty.PropertyType type = UIProperty.PropertyType.valueOf(ctx.attributeText(null, TYPE_NAME, null));
-        switch (type) {
-            case BOOLEAN:
-                value = Boolean.parseBoolean(ctx.attributeText(null, VALUE_NAME, null));
-                break;
-            case DOUBLE:
-                value = Double.parseDouble(ctx.attributeText(null, VALUE_NAME, null));
-                break;
-            case INT:
-                value = Integer.parseInt(ctx.attributeText(null, VALUE_NAME, null));
-                break;
-            case FLOAT:
-                value = Float.parseFloat(ctx.attributeText(null, VALUE_NAME, null));
-                break;
-            case STRING:
-                value = ctx.attributeText(null, VALUE_NAME, null);
-                break;
-            case INSETS:
-                ctx.parsePastStartTag(null, ELEMENT_NAME);
-                value = new InsetsMapper().unmarshal(value, ctx);
-                break;
-            case COLOR:
-            case FONT:
-                ctx.parsePastStartTag(null, ELEMENT_NAME);
-                value = ctx.unmarshalElement();
-                break;
-            case DIMENSION:
-                ctx.parsePastStartTag(null, ELEMENT_NAME);
-                value = new DimensionMapper().unmarshal(value, ctx);
-                break;
-            case BORDER:
-                ctx.parsePastStartTag(null, ELEMENT_NAME);
-                value = new BorderMapper().unmarshal(value, ctx);
-                break;
-        }
-        ctx.parsePastEndTag(null, ELEMENT_NAME);
-        // create
-        return new UIProperty(name, type, value);
-    }
-}
--- a/src/share/classes/sun/nio/ch/AbstractFuture.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,63 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.nio.ch;
-
-import java.nio.channels.AsynchronousChannel;
-import java.util.concurrent.Future;
-
-/**
- * Base implementation of Future used for asynchronous I/O
- */
-
-abstract class AbstractFuture<V,A>
-    implements Future<V>
-{
-    private final AsynchronousChannel channel;
-    private final A attachment;
-
-    protected AbstractFuture(AsynchronousChannel channel, A attachment) {
-        this.channel = channel;
-        this.attachment = attachment;
-    }
-
-    final AsynchronousChannel channel() {
-        return channel;
-    }
-
-    final A attachment() {
-        return attachment;
-    }
-
-    /**
-     * Returns the result of the operation if it has completed successfully.
-     */
-    abstract V value();
-
-    /**
-     * Returns the exception if the operation has failed.
-     */
-    abstract Throwable exception();
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/ChangeLog	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,481 +0,0 @@
-
-		ChangeLog file for zlib
-
-Changes in 1.1.3.f-jdk (23 Apr 2003) by Sun Microsystems
-- Backport security fixes from zlib 1.1.4
-- Minor tweaks for 64 bit architectures
-- Remove warnings on Linux
-- Fix minor typos in comments in zlib.h
-- adler32.c was renamed to zadler32.c
-- crc32.c was renamed to zcrc32.c, with signed longs made unsigned.
-- Fixed bug in calculation of checksum in inflate.c
-- GPL headers added
-	
-Changes in 1.1.3 (9 July 1998)
-- fix "an inflate input buffer bug that shows up on rare but persistent
-  occasions" (Mark)
-- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)
-- fix gzseek(..., SEEK_SET) in write mode
-- fix crc check after a gzeek (Frank Faubert)
-- fix miniunzip when the last entry in a zip file is itself a zip file
-  (J Lillge)
-- add contrib/asm586 and contrib/asm686 (Brian Raiter)
-  See http://www.muppetlabs.com/~breadbox/software/assembly.html
-- add support for Delphi 3 in contrib/delphi (Bob Dellaca)
-- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)
-- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)
-- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)
-- added a FAQ file
-
-- Support gzdopen on Mac with Metrowerks (Jason Linhart)
-- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)
-- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)
-- avoid some warnings with Borland C (Tom Tanner)
-- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)
-- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)
-- allow several arguments to configure (Tim Mooney, Frodo Looijaard)
-- use libdir and includedir in Makefile.in (Tim Mooney)
-- support shared libraries on OSF1 V4 (Tim Mooney)
-- remove so_locations in "make clean"  (Tim Mooney)
-- fix maketree.c compilation error (Glenn, Mark)
-- Python interface to zlib now in Python 1.5 (Jeremy Hylton)
-- new Makefile.riscos (Rich Walker)
-- initialize static descriptors in trees.c for embedded targets (Nick Smith)
-- use "foo-gz" in example.c for RISCOS and VMS (Nick Smith)
-- add the OS/2 files in Makefile.in too (Andrew Zabolotny)
-- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)
-- fix maketree.c to allow clean compilation of inffixed.h (Mark)
-- fix parameter check in deflateCopy (Gunther Nikl)
-- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)
-- Many portability patches by Christian Spieler:
-  . zutil.c, zutil.h: added "const" for zmem*
-  . Make_vms.com: fixed some typos
-  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists
-  . msdos/Makefile.msc: remove "default rtl link library" info from obj files
-  . msdos/Makefile.*: use model-dependent name for the built zlib library
-  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:
-     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)
-- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)
-- replace __far with _far for better portability (Christian Spieler, Tom Lane)
-- fix test for errno.h in configure (Tim Newsham)
-
-Changes in 1.1.2 (19 March 98)
-- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)
-  See http://www.winimage.com/zLibDll/unzip.html
-- preinitialize the inflate tables for fixed codes, to make the code
-  completely thread safe (Mark)
-- some simplifications and slight speed-up to the inflate code (Mark)
-- fix gzeof on non-compressed files (Allan Schrum)
-- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)
-- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)
-- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)
-- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)
-- do not wrap extern "C" around system includes (Tom Lane)
-- mention zlib binding for TCL in README (Andreas Kupries)
-- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)
-- allow "make install prefix=..." even after configure (Glenn Randers-Pehrson)
-- allow "configure --prefix $HOME" (Tim Mooney)
-- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)
-- move Makefile.sas to amiga/Makefile.sas
-
-Changes in 1.1.1 (27 Feb 98)
-- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)
-- remove block truncation heuristic which had very marginal effect for zlib
-  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the
-  compression ratio on some files. This also allows inlining _tr_tally for
-  matches in deflate_slow.
-- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)
-
-Changes in 1.1.0 (24 Feb 98)
-- do not return STREAM_END prematurely in inflate (John Bowler)
-- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)
-- compile with -DFASTEST to get compression code optimized for speed only
-- in minigzip, try mmap'ing the input file first (Miguel Albrecht)
-- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain
-  on Sun but significant on HP)
-
-- add a pointer to experimental unzip library in README (Gilles Vollant)
-- initialize variable gcc in configure (Chris Herborth)
-
-Changes in 1.0.9 (17 Feb 1998)
-- added gzputs and gzgets functions
-- do not clear eof flag in gzseek (Mark Diekhans)
-- fix gzseek for files in transparent mode (Mark Diekhans)
-- do not assume that vsprintf returns the number of bytes written (Jens Krinke)
-- replace EXPORT with ZEXPORT to avoid conflict with other programs
-- added compress2 in zconf.h, zlib.def, zlib.dnt
-- new asm code from Gilles Vollant in contrib/asm386
-- simplify the inflate code (Mark):
- . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()
- . ZALLOC the length list in inflate_trees_fixed() instead of using stack
- . ZALLOC the value area for huft_build() instead of using stack
- . Simplify Z_FINISH check in inflate()
-
-- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8
-- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)
-- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with
-  the declaration of FAR (Gilles VOllant)
-- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)
-- read_buf buf parameter of type Bytef* instead of charf*
-- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)
-- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)
-- fix check for presence of directories in "make install" (Ian Willis)
-
-Changes in 1.0.8 (27 Jan 1998)
-- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)
-- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)
-- added compress2() to allow setting the compression level
-- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)
-- use constant arrays for the static trees in trees.c instead of computing
-  them at run time (thanks to Ken Raeburn for this suggestion). To create
-  trees.h, compile with GEN_TREES_H and run "make test".
-- check return code of example in "make test" and display result
-- pass minigzip command line options to file_compress
-- simplifying code of inflateSync to avoid gcc 2.8 bug
-
-- support CC="gcc -Wall" in configure -s (QingLong)
-- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)
-- fix test for shared library support to avoid compiler warnings
-- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)
-- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)
-- do not use fdopen for Metrowerks on Mac (Brad Pettit))
-- add checks for gzputc and gzputc in example.c
-- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)
-- use const for the CRC table (Ken Raeburn)
-- fixed "make uninstall" for shared libraries
-- use Tracev instead of Trace in infblock.c
-- in example.c use correct compressed length for test_sync
-- suppress +vnocompatwarnings in configure for HPUX (not always supported)
-
-Changes in 1.0.7 (20 Jan 1998)
-- fix gzseek which was broken in write mode
-- return error for gzseek to negative absolute position
-- fix configure for Linux (Chun-Chung Chen)
-- increase stack space for MSC (Tim Wegner)
-- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)
-- define EXPORTVA for gzprintf (Gilles Vollant)
-- added man page zlib.3 (Rick Rodgers)
-- for contrib/untgz, fix makedir() and improve Makefile
-
-- check gzseek in write mode in example.c
-- allocate extra buffer for seeks only if gzseek is actually called
-- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)
-- add inflateSyncPoint in zconf.h
-- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def
-
-Changes in 1.0.6 (19 Jan 1998)
-- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and
-  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)
-- Fix a deflate bug occuring only with compression level 0 (thanks to
-  Andy Buckler for finding this one).
-- In minigzip, pass transparently also the first byte for .Z files.
-- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()
-- check Z_FINISH in inflate (thanks to Marc Schluper)
-- Implement deflateCopy (thanks to Adam Costello)
-- make static libraries by default in configure, add --shared option.
-- move MSDOS or Windows specific files to directory msdos
-- suppress the notion of partial flush to simplify the interface
-  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)
-- suppress history buffer provided by application to simplify the interface
-  (this feature was not implemented anyway in 1.0.4)
-- next_in and avail_in must be initialized before calling inflateInit or
-  inflateInit2
-- add EXPORT in all exported functions (for Windows DLL)
-- added Makefile.nt (thanks to Stephen Williams)
-- added the unsupported "contrib" directory:
-   contrib/asm386/ by Gilles Vollant <info@winimage.com>
-	386 asm code replacing longest_match().
-   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-   contrib/iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
-	Another C++ I/O streams interface
-   contrib/untgz/  by "Pedro A. Aranda Guti\irrez" <paag@tid.es>
-	A very simple tar.gz file extractor using zlib
-   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>
-        How to use compress(), uncompress() and the gz* functions from VB.
-- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression
-  level) in minigzip (thanks to Tom Lane)
-
-- use const for rommable constants in deflate
-- added test for gzseek and gztell in example.c
-- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)
-- add undocumented function zError to convert error code to string
-  (for Tim Smithers)
-- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.
-- Use default memcpy for Symantec MSDOS compiler.
-- Add EXPORT keyword for check_func (needed for Windows DLL)
-- add current directory to LD_LIBRARY_PATH for "make test"
-- create also a link for libz.so.1
-- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)
-- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)
-- added -soname for Linux in configure (Chun-Chung Chen,
-- assign numbers to the exported functions in zlib.def (for Windows DLL)
-- add advice in zlib.h for best usage of deflateSetDictionary
-- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)
-- allow compilation with ANSI keywords only enabled for TurboC in large model
-- avoid "versionString"[0] (Borland bug)
-- add NEED_DUMMY_RETURN for Borland
-- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).
-- allow compilation with CC
-- defined STDC for OS/2 (David Charlap)	
-- limit external names to 8 chars for MVS (Thomas Lund)
-- in minigzip.c, use static buffers only for 16-bit systems
-- fix suffix check for "minigzip -d foo.gz"
-- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)
-- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)
-- added makelcc.bat for lcc-win32 (Tom St Denis)
-- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)
-- Avoid expanded $Id$. Use "rcs -kb" or "cvs admin -kb" to avoid Id expansion.
-- check for unistd.h in configure (for off_t)
-- remove useless check parameter in inflate_blocks_free
-- avoid useless assignment of s->check to itself in inflate_blocks_new
-- do not flush twice in gzclose (thanks to Ken Raeburn)
-- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h
-- use NO_ERRNO_H instead of enumeration of operating systems with errno.h
-- work around buggy fclose on pipes for HP/UX
-- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)
-- fix configure if CC is already equal to gcc
-
-Changes in 1.0.5 (3 Jan 98)
-- Fix inflate to terminate gracefully when fed corrupted or invalid data
-- Use const for rommable constants in inflate
-- Eliminate memory leaks on error conditions in inflate
-- Removed some vestigial code in inflate
-- Update web address in README
-  
-Changes in 1.0.4 (24 Jul 96)
-- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF
-  bit, so the decompressor could decompress all the correct data but went
-  on to attempt decompressing extra garbage data. This affected minigzip too.
-- zlibVersion and gzerror return const char* (needed for DLL)
-- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)
-- use z_error only for DEBUG (avoid problem with DLLs)
-
-Changes in 1.0.3 (2 Jul 96)
-- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS
-  small and medium models; this makes the library incompatible with previous
-  versions for these models. (No effect in large model or on other systems.)
-- return OK instead of BUF_ERROR if previous deflate call returned with
-  avail_out as zero but there is nothing to do
-- added memcmp for non STDC compilers
-- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)
-- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)
-- better check for 16-bit mode MSC (avoids problem with Symantec)
-
-Changes in 1.0.2 (23 May 96)
-- added Windows DLL support
-- added a function zlibVersion (for the DLL support)
-- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)
-- Bytef is define's instead of typedef'd only for Borland C
-- avoid reading uninitialized memory in example.c
-- mention in README that the zlib format is now RFC1950
-- updated Makefile.dj2
-- added algorithm.doc
-
-Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]
-- fix array overlay in deflate.c which sometimes caused bad compressed data
-- fix inflate bug with empty stored block
-- fix MSDOS medium model which was broken in 0.99
-- fix deflateParams() which could generated bad compressed data.
-- Bytef is define'd instead of typedef'ed (work around Borland bug)
-- added an INDEX file
-- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),
-  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)
-- speed up adler32 for modern machines without auto-increment
-- added -ansi for IRIX in configure
-- static_init_done in trees.c is an int
-- define unlink as delete for VMS
-- fix configure for QNX
-- add configure branch for SCO and HPUX
-- avoid many warnings (unused variables, dead assignments, etc...)
-- no fdopen for BeOS
-- fix the Watcom fix for 32 bit mode (define FAR as empty)
-- removed redefinition of Byte for MKWERKS
-- work around an MWKERKS bug (incorrect merge of all .h files)
-
-Changes in 0.99 (27 Jan 96)
-- allow preset dictionary shared between compressor and decompressor
-- allow compression level 0 (no compression)
-- add deflateParams in zlib.h: allow dynamic change of compression level
-  and compression strategy.
-- test large buffers and deflateParams in example.c
-- add optional "configure" to build zlib as a shared library
-- suppress Makefile.qnx, use configure instead
-- fixed deflate for 64-bit systems (detected on Cray)
-- fixed inflate_blocks for 64-bit systems (detected on Alpha)
-- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)
-- always return Z_BUF_ERROR when deflate() has nothing to do
-- deflateInit and inflateInit are now macros to allow version checking
-- prefix all global functions and types with z_ with -DZ_PREFIX
-- make falloc completely reentrant (inftrees.c)
-- fixed very unlikely race condition in ct_static_init
-- free in reverse order of allocation to help memory manager
-- use zlib-1.0/* instead of zlib/* inside the tar.gz
-- make zlib warning-free with "gcc -O3 -Wall -Wwrite-strings -Wpointer-arith
-  -Wconversion -Wstrict-prototypes -Wmissing-prototypes"
-- allow gzread on concatenated .gz files
-- deflateEnd now returns Z_DATA_ERROR if it was premature
-- deflate is finally (?) fully deterministic (no matches beyond end of input)
-- Document Z_SYNC_FLUSH
-- add uninstall in Makefile
-- Check for __cpluplus in zlib.h
-- Better test in ct_align for partial flush
-- avoid harmless warnings for Borland C++
-- initialize hash_head in deflate.c
-- avoid warning on fdopen (gzio.c) for HP cc -Aa
-- include stdlib.h for STDC compilers
-- include errno.h for Cray
-- ignore error if ranlib doesn't exist
-- call ranlib twice for NeXTSTEP
-- use exec_prefix instead of prefix for libz.a
-- renamed ct_* as _tr_* to avoid conflict with applications
-- clear z->msg in inflateInit2 before any error return
-- initialize opaque in example.c, gzio.c, deflate.c and inflate.c
-- fixed typo in zconf.h (_GNUC__ => __GNUC__)
-- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)
-- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)
-- in fcalloc, normalize pointer if size > 65520 bytes
-- don't use special fcalloc for 32 bit Borland C++
-- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...
-- use Z_BINARY instead of BINARY
-- document that gzclose after gzdopen will close the file
-- allow "a" as mode in gzopen.
-- fix error checking in gzread
-- allow skipping .gz extra-field on pipes
-- added reference to Perl interface in README
-- put the crc table in FAR data (I dislike more and more the medium model :)
-- added get_crc_table
-- added a dimension to all arrays (Borland C can't count).
-- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast
-- guard against multiple inclusion of *.h (for precompiled header on Mac)
-- Watcom C pretends to be Microsoft C small model even in 32 bit mode.
-- don't use unsized arrays to avoid silly warnings by Visual C++:
-     warning C4746: 'inflate_mask' : unsized array treated as  '__far'
-     (what's wrong with far data in far model?).
-- define enum out of inflate_blocks_state to allow compilation with C++
-
-Changes in 0.95 (16 Aug 95)
-- fix MSDOS small and medium model (now easier to adapt to any compiler)
-- inlined send_bits
-- fix the final (:-) bug for deflate with flush (output was correct but
-  not completely flushed in rare occasions).
-- default window size is same for compression and decompression
-  (it's now sufficient to set MAX_WBITS in zconf.h).
-- voidp -> voidpf and voidnp -> voidp (for consistency with other
-  typedefs and because voidnp was not near in large model).
-
-Changes in 0.94 (13 Aug 95)
-- support MSDOS medium model
-- fix deflate with flush (could sometimes generate bad output)
-- fix deflateReset (zlib header was incorrectly suppressed)
-- added support for VMS
-- allow a compression level in gzopen()
-- gzflush now calls fflush
-- For deflate with flush, flush even if no more input is provided.
-- rename libgz.a as libz.a
-- avoid complex expression in infcodes.c triggering Turbo C bug
-- work around a problem with gcc on Alpha (in INSERT_STRING)
-- don't use inline functions (problem with some gcc versions)
-- allow renaming of Byte, uInt, etc... with #define.
-- avoid warning about (unused) pointer before start of array in deflate.c
-- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c
-- avoid reserved word 'new' in trees.c
-
-Changes in 0.93 (25 June 95)
-- temporarily disable inline functions
-- make deflate deterministic
-- give enough lookahead for PARTIAL_FLUSH
-- Set binary mode for stdin/stdout in minigzip.c for OS/2
-- don't even use signed char in inflate (not portable enough)
-- fix inflate memory leak for segmented architectures
-
-Changes in 0.92 (3 May 95)
-- don't assume that char is signed (problem on SGI)
-- Clear bit buffer when starting a stored block
-- no memcpy on Pyramid
-- suppressed inftest.c
-- optimized fill_window, put longest_match inline for gcc
-- optimized inflate on stored blocks.
-- untabify all sources to simplify patches
-
-Changes in 0.91 (2 May 95)
-- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h
-- Document the memory requirements in zconf.h
-- added "make install"
-- fix sync search logic in inflateSync
-- deflate(Z_FULL_FLUSH) now works even if output buffer too short
-- after inflateSync, don't scare people with just "lo world"
-- added support for DJGPP
-
-Changes in 0.9 (1 May 95)
-- don't assume that zalloc clears the allocated memory (the TurboC bug
-  was Mark's bug after all :)
-- let again gzread copy uncompressed data unchanged (was working in 0.71)
-- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented
-- added a test of inflateSync in example.c
-- moved MAX_WBITS to zconf.h because users might want to change that.
-- document explicitly that zalloc(64K) on MSDOS must return a normalized
-  pointer (zero offset)
-- added Makefiles for Microsoft C, Turbo C, Borland C++
-- faster crc32()
-
-Changes in 0.8 (29 April 95)
-- added fast inflate (inffast.c)
-- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this
-  is incompatible with previous versions of zlib which returned Z_OK.
-- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)
-  (actually that was not a compiler bug, see 0.81 above)
-- gzread no longer reads one extra byte in certain cases
-- In gzio destroy(), don't reference a freed structure
-- avoid many warnings for MSDOS
-- avoid the ERROR symbol which is used by MS Windows
-
-Changes in 0.71 (14 April 95)
-- Fixed more MSDOS compilation problems :( There is still a bug with
-  TurboC large model.
-
-Changes in 0.7 (14 April 95)
-- Added full inflate support.
-- Simplified the crc32() interface. The pre- and post-conditioning
-  (one's complement) is now done inside crc32(). WARNING: this is
-  incompatible with previous versions; see zlib.h for the new usage.
-
-Changes in 0.61 (12 April 95)
-- workaround for a bug in TurboC. example and minigzip now work on MSDOS.
-
-Changes in 0.6 (11 April 95)
-- added minigzip.c
-- added gzdopen to reopen a file descriptor as gzFile
-- added transparent reading of non-gziped files in gzread.
-- fixed bug in gzread (don't read crc as data)
-- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).
-- don't allocate big arrays in the stack (for MSDOS)
-- fix some MSDOS compilation problems
-
-Changes in 0.5:
-- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but
-  not yet Z_FULL_FLUSH.
-- support decompression but only in a single step (forced Z_FINISH)
-- added opaque object for zalloc and zfree.
-- added deflateReset and inflateReset
-- added a variable zlib_version for consistency checking.
-- renamed the 'filter' parameter of deflateInit2 as 'strategy'.
-  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.
-
-Changes in 0.4:
-- avoid "zip" everywhere, use zlib instead of ziplib.
-- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush
-  if compression method == 8.
-- added adler32 and crc32
-- renamed deflateOptions as deflateInit2, call one or the other but not both
-- added the method parameter for deflateInit2.
-- added inflateInit2
-- simplied considerably deflateInit and inflateInit by not supporting
-  user-provided history buffer. This is supported only in deflateInit2
-  and inflateInit2.
-
-Changes in 0.3:
-- prefix all macro names with Z_
-- use Z_FINISH instead of deflateEnd to finish compression.
-- added Z_HUFFMAN_ONLY
-- added gzerror()
--- a/src/share/native/java/util/zip/zlib-1.1.3/README	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,151 +0,0 @@
-zlib 1.1.3 is a general purpose data compression library.  All the code
-is thread safe.  The data format used by the zlib library
-is described by RFCs (Request for Comments) 1950 to 1952 in the files 
-ftp://ds.internic.net/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate
-format) and rfc1952.txt (gzip format). These documents are also available in
-other formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact jloup@gzip.org). A usage
-example of the library is given in the file example.c which also tests that
-the library is working correctly. Another example is given in the file
-minigzip.c. The compression library itself is composed of all source files
-except example.c and minigzip.c.
-
-To compile all files and run the test program, follow the instructions
-given at the top of Makefile. In short "make test; make install"
-should work for most machines. For Unix: "configure; make test; make install"
-For MSDOS, use one of the special makefiles such as Makefile.msc.
-For VMS, use Make_vms.com or descrip.mms.
-
-Questions about zlib should be sent to <zlib@quest.jpl.nasa.gov>, or to
-Gilles Vollant <info@winimage.com> for the Windows DLL version.
-The zlib home page is http://www.cdrom.com/pub/infozip/zlib/
-The official zlib ftp site is ftp://ftp.cdrom.com/pub/infozip/zlib/
-Before reporting a problem, please check those sites to verify that
-you have the latest version of zlib; otherwise get the latest version and
-check whether the problem still exists or not.
-
-Mark Nelson <markn@tiny.com> wrote an article about zlib for the Jan. 1997
-issue of  Dr. Dobb's Journal; a copy of the article is available in
-http://web2.airmail.net/markn/articles/zlibtool/zlibtool.htm
-
-There are minor changes by Sun Microsystems in 1.1.3.f-jdk as compared with
-the official 1.1.3 version; see the file ChangeLog.
-
-The changes made in version 1.1.3 are documented in the file ChangeLog.
-The main changes since 1.1.2 are:
-
-- fix "an inflate input buffer bug that shows up on rare but persistent
-  occasions" (Mark)
-- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)
-- fix gzseek(..., SEEK_SET) in write mode
-- fix crc check after a gzeek (Frank Faubert)
-- fix miniunzip when the last entry in a zip file is itself a zip file
-  (J Lillge)
-- add contrib/asm586 and contrib/asm686 (Brian Raiter)
-  See http://www.muppetlabs.com/~breadbox/software/assembly.html
-- add support for Delphi 3 in contrib/delphi (Bob Dellaca)
-- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)
-- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)
-- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)
-- added a FAQ file
-
-plus many changes for portability.
-
-Unsupported third party contributions are provided in directory "contrib".
-
-A Java implementation of zlib is available in the Java Development Kit 1.1
-http://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html
-See the zlib home page http://www.cdrom.com/pub/infozip/zlib/ for details.
-
-A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>
-is in the CPAN (Comprehensive Perl Archive Network) sites, such as:
-ftp://ftp.cis.ufl.edu/pub/perl/CPAN/modules/by-module/Compress/Compress-Zlib*
-
-A Python interface to zlib written by A.M. Kuchling <amk@magnet.com>
-is available in Python 1.5 and later versions, see
-http://www.python.org/doc/lib/module-zlib.html
-
-A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com>
-is availlable at http://www.westend.com/~kupries/doc/trf/man/man.html
-
-An experimental package to read and write files in .zip format,
-written on top of zlib by Gilles Vollant <info@winimage.com>, is
-available at http://www.winimage.com/zLibDll/unzip.html
-and also in the contrib/minizip directory of zlib.
-
-
-Notes for some targets:
-
-- To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc
-  and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL
-  The zlib DLL support was initially done by Alessandro Iacopetti and is
-  now maintained by Gilles Vollant <info@winimage.com>. Check the zlib DLL
-  home page at http://www.winimage.com/zLibDll
-
-  From Visual Basic, you can call the DLL functions which do not take
-  a structure as argument: compress, uncompress and all gz* functions.
-  See contrib/visual-basic.txt for more information, or get
-  http://www.tcfb.com/dowseware/cmp-z-it.zip
-
-- For 64-bit Irix, deflate.c must be compiled without any optimization.
-  With -O, one libpng test fails. The test works in 32 bit mode (with
-  the -n32 compiler flag). The compiler bug has been reported to SGI.
-
-- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   
-  it works when compiled with cc.
-
-- on Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1
-  is necessary to get gzprintf working correctly. This is done by configure.
-
-- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works
-  with other compilers. Use "make test" to check your compiler.
-
-- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.
-
-- For Turbo C the small model is supported only with reduced performance to
-  avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
-
-- For PalmOs, see http://www.cs.uit.no/~perm/PASTA/pilot/software.html
-  Per Harald Myrvang <perm@stud.cs.uit.no>
-
-
-Acknowledgments:
-
-  The deflate format used by zlib was defined by Phil Katz. The deflate
-  and zlib specifications were written by L. Peter Deutsch. Thanks to all the
-  people who reported problems and suggested various improvements in zlib;
-  they are too numerous to cite here.
-
-Copyright notice:
-
- (C) 1995-1998 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not*
-receiving lengthy legal documents to sign. The sources are provided
-for free but without warranty of any kind.  The library has been
-entirely written by Jean-loup Gailly and Mark Adler; it does not
-include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include
-in the file ChangeLog history information documenting your changes.
--- a/src/share/native/java/util/zip/zlib-1.1.3/compress.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,96 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * compress.c -- compress a memory buffer
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zlib.h"
-
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-#ifdef MAXSEG_64K
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-#endif
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-
-    err = deflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        deflateEnd(&stream);
-        return err == Z_OK ? Z_BUF_ERROR : err;
-    }
-    *destLen = stream.total_out;
-
-    err = deflateEnd(&stream);
-    return err;
-}
-
-/* ===========================================================================
- */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/deflate.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1380 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-#include "deflate.h"
-
-const char deflate_copyright[] =
-   " deflate 1.1.3.f-jdk Copyright 1995-1998 Jean-loup Gailly ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifdef ASMV
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#endif
-
-#ifdef DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
- *    input characters, so that a running hash key can be computed from the
- *    previous key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
- *    input characters and the first MIN_MATCH bytes of str are valid
- *    (except for the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    s->head[s->hash_size-1] = NIL; \
-    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
-
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int noheader = 0;
-    static const char* my_version = ZLIB_VERSION;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-    if (strm->zalloc == Z_NULL) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == Z_NULL) strm->zfree = zcfree;
-
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#ifdef FASTEST
-    level = 1;
-#endif
-
-    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
-        noheader = 1;
-        windowBits = -windowBits;
-    }
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
-        return Z_STREAM_ERROR;
-    }
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-
-    s->noheader = noheader;
-    s->w_bits = windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return deflateReset(strm);
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt length = dictLength;
-    uInt n;
-    IPos hash_head = 0;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
-        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
-
-    s = strm->state;
-    strm->adler = adler32(strm->adler, dictionary, dictLength);
-
-    if (length < MIN_MATCH) return Z_OK;
-    if (length > MAX_DIST(s)) {
-        length = MAX_DIST(s);
-#ifndef USE_DICT_HEAD
-        dictionary += dictLength - length; /* use the tail of the dictionary */
-#endif
-    }
-    zmemcpy(s->window, dictionary, length);
-    s->strstart = length;
-    s->block_start = (long)length;
-
-    /* Insert all strings in the hash table (except for the last two bytes).
-     * s->lookahead stays null, so s->ins_h will be recomputed at the next
-     * call of fill_window.
-     */
-    s->ins_h = s->window[0];
-    UPDATE_HASH(s, s->ins_h, s->window[1]);
-    for (n = 0; n <= length - MIN_MATCH; n++) {
-        INSERT_STRING(s, n, hash_head);
-    }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->noheader < 0) {
-        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
-    }
-    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
-    strm->adler = 1;
-    s->last_flush = Z_NO_FLUSH;
-
-    _tr_init(s);
-    lm_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    int err = Z_OK;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-
-    if (level == Z_DEFAULT_COMPRESSION) {
-        level = 6;
-    }
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if (func != configuration_table[level].func && strm->total_in != 0) {
-        /* Flush the last buffer: */
-        err = deflate(strm, Z_PARTIAL_FLUSH);
-    }
-    if (s->level != level) {
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return err;
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output goes
- * through this function so some applications may wish to modify it
- * to avoid allocating a large strm->next_out buffer and copying into it.
- * (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len = strm->state->pending;
-
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    zmemcpy(strm->next_out, strm->state->pending_out, len);
-    strm->next_out  += len;
-    strm->state->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out  -= len;
-    strm->state->pending -= len;
-    if (strm->state->pending == 0) {
-        strm->state->pending_out = strm->state->pending_buf;
-    }
-}
-
-/* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        flush > Z_FINISH || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-
-    if (strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-
-    s->strm = strm; /* just in case */
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Write the zlib header */
-    if (s->status == INIT_STATE) {
-
-        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-        uInt level_flags = (s->level-1) >> 1;
-
-        if (level_flags > 3) level_flags = 3;
-        header |= (level_flags << 6);
-        if (s->strstart != 0) header |= PRESET_DICT;
-        header += 31 - (header % 31);
-
-        s->status = BUSY_STATE;
-        putShortMSB(s, header);
-
-        /* Save the adler32 of the preset dictionary: */
-        if (s->strstart != 0) {
-            putShortMSB(s, (uInt)(strm->adler >> 16));
-            putShortMSB(s, (uInt)(strm->adler & 0xffff));
-        }
-        strm->adler = 1L;
-    }
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && flush <= old_flush &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-        bstate = (*(configuration_table[s->level].func))(s, flush);
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    Assert(strm->avail_out > 0, "bug2");
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->noheader) return Z_STREAM_END;
-
-    /* Write the zlib trailer (adler32) */
-    putShortMSB(s, (uInt)(strm->adler >> 16));
-    putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    s->noheader = -1; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-
-    status = strm->state->status;
-    if (status != INIT_STATE && status != BUSY_STATE &&
-        status != FINISH_STATE) {
-      return Z_STREAM_ERROR;
-    }
-
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-
-
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = source->state;
-
-    *dest = *source;
-
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    *ds = *ss;
-    ds->strm = dest;
-
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uchf *) overlay;
-
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    if (!strm->state->noheader) {
-        strm->adler = adler32(strm->adler, strm->next_in, len);
-    }
-    zmemcpy(buf, strm->next_in, len);
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return (int)len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-#ifdef ASMV
-    match_init(); /* initialize the asm code */
-#endif
-}
-
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-#ifndef ASMV
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-#ifndef FASTEST
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = s->prev_length;              /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2:
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-
-#else /* FASTEST */
-/* ---------------------------------------------------------------------------
- * Optimized version for level == 1 only
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    Assert(cur_match < s->strstart, "no future");
-
-    match = s->window + cur_match;
-
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-
-    /* The check at best_len-1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart+258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-    len = MAX_MATCH - (int)(strend - scan);
-
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-
-    s->match_start = cur_match;
-    return len <= s->lookahead ? len : s->lookahead;
-}
-#endif /* FASTEST */
-#endif /* ASMV */
-
-#ifdef DEBUG
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    register unsigned n, m;
-    register Posf *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-            more = wsize;
-
-        } else if (more == (unsigned)(-1)) {
-            /* Very unlikely, but possible on 16 bit machine if strstart == 0
-             * and lookahead == 1 (input done one byte at time)
-             */
-            more--;
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        } else if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-
-            /* Slide the hash table (could be avoided with 32 bit values
-               at the expense of memory usage). We slide even when level == 0
-               to keep the hash table consistent if we switch back to level > 0
-               later. (Using level 0 permanently is not an optimal usage of
-               zlib, so we don't care about this pathological case.)
-             */
-            n = s->hash_size;
-            p = &s->head[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-            } while (--n);
-
-            n = wsize;
-#ifndef FASTEST
-            p = &s->prev[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-                /* If n is not on any hash chain, prev[n] is garbage but
-                 * its value will never be used.
-                 */
-            } while (--n);
-#endif
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) return;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead >= MIN_MATCH) {
-            s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, eof) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (eof)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, eof) { \
-   FLUSH_BLOCK_ONLY(s, eof); \
-   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
-}
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- * This function does not insert new strings in the dictionary since
- * uncompressible data is probably not useful. This function is used
- * only for the level=0 compression option.
- * NOTE: this function should be optimized to avoid extra copying from
- * window to pending_buf.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
-     * to pending_buf_size, and each stored block has a 5 byte header:
-     */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
-
-    if (max_block_size > s->pending_buf_size - 5) {
-        max_block_size = s->pending_buf_size - 5;
-    }
-
-    /* Copy as much as possible from input to output: */
-    for (;;) {
-        /* Fill the window as much as possible: */
-        if (s->lookahead <= 1) {
-
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-                   s->block_start >= (long)s->w_size, "slide too late");
-
-            fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
-
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        Assert(s->block_start >= 0L, "block gone");
-
-        s->strstart += s->lookahead;
-        s->lookahead = 0;
-
-        /* Emit a stored block if pending_buf will be full: */
-        max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
-            /* strstart == 0 is possible when wraparound on 16-bit machine */
-            s->lookahead = (uInt)(s->strstart - max_start);
-            s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
-        }
-        /* Flush if we may have to slide, otherwise block_start may become
-         * negative and the data will be gone:
-         */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
-        }
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL; /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
-            }
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in hash table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL;    /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
-            }
-            /* longest_match() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
-                 (s->match_length == MIN_MATCH &&
-                  s->strstart - s->match_start > TOO_FAR))) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-        s->match_available = 0;
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/deflate.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,346 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * deflate.h -- internal compression state
- * Copyright (C) 1995-1998 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _DEFLATE_H
-#define _DEFLATE_H
-
-#include "zutil.h"
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define INIT_STATE    42
-#define BUSY_STATE   113
-#define FINISH_STATE 666
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    static_tree_desc *stat_desc; /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    int   pending;       /* nb of bytes in the pending buffer */
-    int   noheader;      /* suppress zlib header and adler32 */
-    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to supress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    int last_eob_len;   /* bit length of EOB code for last block */
-
-#ifdef DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-        /* in trees.c */
-void _tr_init         OF((deflate_state *s));
-int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
-void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
-void _tr_align        OF((deflate_state *s));
-void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch _length_code[];
-  extern uch _dist_code[];
-#else
-  extern const uch _length_code[];
-  extern const uch _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (length); \
-    ush dist = (distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif
--- a/src/share/native/java/util/zip/zlib-1.1.3/doc/algorithm.doc	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,213 +0,0 @@
-1. Compression algorithm (deflate)
-
-The deflation algorithm used by gzip (also zip and zlib) is a variation of
-LZ77 (Lempel-Ziv 1977, see reference below). It finds duplicated strings in
-the input data.  The second occurrence of a string is replaced by a
-pointer to the previous string, in the form of a pair (distance,
-length).  Distances are limited to 32K bytes, and lengths are limited
-to 258 bytes. When a string does not occur anywhere in the previous
-32K bytes, it is emitted as a sequence of literal bytes.  (In this
-description, `string' must be taken as an arbitrary sequence of bytes,
-and is not restricted to printable characters.)
-
-Literals or match lengths are compressed with one Huffman tree, and
-match distances are compressed with another tree. The trees are stored
-in a compact form at the start of each block. The blocks can have any
-size (except that the compressed data for one block must fit in
-available memory). A block is terminated when deflate() determines that
-it would be useful to start another block with fresh trees. (This is
-somewhat similar to the behavior of LZW-based _compress_.)
-
-Duplicated strings are found using a hash table. All input strings of
-length 3 are inserted in the hash table. A hash index is computed for
-the next 3 bytes. If the hash chain for this index is not empty, all
-strings in the chain are compared with the current input string, and
-the longest match is selected.
-
-The hash chains are searched starting with the most recent strings, to
-favor small distances and thus take advantage of the Huffman encoding.
-The hash chains are singly linked. There are no deletions from the
-hash chains, the algorithm simply discards matches that are too old.
-
-To avoid a worst-case situation, very long hash chains are arbitrarily
-truncated at a certain length, determined by a runtime option (level
-parameter of deflateInit). So deflate() does not always find the longest
-possible match but generally finds a match which is long enough.
-
-deflate() also defers the selection of matches with a lazy evaluation
-mechanism. After a match of length N has been found, deflate() searches for
-a longer match at the next input byte. If a longer match is found, the
-previous match is truncated to a length of one (thus producing a single
-literal byte) and the process of lazy evaluation begins again. Otherwise,
-the original match is kept, and the next match search is attempted only N
-steps later.
-
-The lazy match evaluation is also subject to a runtime parameter. If
-the current match is long enough, deflate() reduces the search for a longer
-match, thus speeding up the whole process. If compression ratio is more
-important than speed, deflate() attempts a complete second search even if
-the first match is already long enough.
-
-The lazy match evaluation is not performed for the fastest compression
-modes (level parameter 1 to 3). For these fast modes, new strings
-are inserted in the hash table only when no match was found, or
-when the match is not too long. This degrades the compression ratio
-but saves time since there are both fewer insertions and fewer searches.
-
-
-2. Decompression algorithm (inflate)
-
-2.1 Introduction
-
-The real question is, given a Huffman tree, how to decode fast.  The most
-important realization is that shorter codes are much more common than
-longer codes, so pay attention to decoding the short codes fast, and let
-the long codes take longer to decode.
-
-inflate() sets up a first level table that covers some number of bits of
-input less than the length of longest code.  It gets that many bits from the
-stream, and looks it up in the table.  The table will tell if the next
-code is that many bits or less and how many, and if it is, it will tell
-the value, else it will point to the next level table for which inflate()
-grabs more bits and tries to decode a longer code.
-
-How many bits to make the first lookup is a tradeoff between the time it
-takes to decode and the time it takes to build the table.  If building the
-table took no time (and if you had infinite memory), then there would only
-be a first level table to cover all the way to the longest code.  However,
-building the table ends up taking a lot longer for more bits since short
-codes are replicated many times in such a table.  What inflate() does is
-simply to make the number of bits in the first table a variable, and set it
-for the maximum speed.
-
-inflate() sends new trees relatively often, so it is possibly set for a
-smaller first level table than an application that has only one tree for
-all the data.  For inflate, which has 286 possible codes for the
-literal/length tree, the size of the first table is nine bits.  Also the
-distance trees have 30 possible values, and the size of the first table is
-six bits.  Note that for each of those cases, the table ended up one bit
-longer than the ``average'' code length, i.e. the code length of an
-approximately flat code which would be a little more than eight bits for
-286 symbols and a little less than five bits for 30 symbols.  It would be
-interesting to see if optimizing the first level table for other
-applications gave values within a bit or two of the flat code size.
-
-
-2.2 More details on the inflate table lookup
-
-Ok, you want to know what this cleverly obfuscated inflate tree actually  
-looks like.  You are correct that it's not a Huffman tree.  It is simply a  
-lookup table for the first, let's say, nine bits of a Huffman symbol.  The  
-symbol could be as short as one bit or as long as 15 bits.  If a particular  
-symbol is shorter than nine bits, then that symbol's translation is duplicated
-in all those entries that start with that symbol's bits.  For example, if the  
-symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a  
-symbol is nine bits long, it appears in the table once.
-
-If the symbol is longer than nine bits, then that entry in the table points  
-to another similar table for the remaining bits.  Again, there are duplicated  
-entries as needed.  The idea is that most of the time the symbol will be short
-and there will only be one table look up.  (That's whole idea behind data  
-compression in the first place.)  For the less frequent long symbols, there  
-will be two lookups.  If you had a compression method with really long  
-symbols, you could have as many levels of lookups as is efficient.  For  
-inflate, two is enough.
-
-So a table entry either points to another table (in which case nine bits in  
-the above example are gobbled), or it contains the translation for the symbol  
-and the number of bits to gobble.  Then you start again with the next  
-ungobbled bit.
-
-You may wonder: why not just have one lookup table for how ever many bits the  
-longest symbol is?  The reason is that if you do that, you end up spending  
-more time filling in duplicate symbol entries than you do actually decoding.   
-At least for deflate's output that generates new trees every several 10's of  
-kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code  
-would take too long if you're only decoding several thousand symbols.  At the  
-other extreme, you could make a new table for every bit in the code.  In fact,
-that's essentially a Huffman tree.  But then you spend two much time  
-traversing the tree while decoding, even for short symbols.
-
-So the number of bits for the first lookup table is a trade of the time to  
-fill out the table vs. the time spent looking at the second level and above of
-the table.
-
-Here is an example, scaled down:
-
-The code being decoded, with 10 symbols, from 1 to 6 bits long:
-
-A: 0
-B: 10
-C: 1100
-D: 11010
-E: 11011
-F: 11100
-G: 11101
-H: 11110
-I: 111110
-J: 111111
-
-Let's make the first table three bits long (eight entries):
-
-000: A,1
-001: A,1
-010: A,1
-011: A,1
-100: B,2
-101: B,2
-110: -> table X (gobble 3 bits)
-111: -> table Y (gobble 3 bits)
-
-Each entry is what the bits decode to and how many bits that is, i.e. how  
-many bits to gobble.  Or the entry points to another table, with the number of
-bits to gobble implicit in the size of the table.
-
-Table X is two bits long since the longest code starting with 110 is five bits
-long:
-
-00: C,1
-01: C,1
-10: D,2
-11: E,2
-
-Table Y is three bits long since the longest code starting with 111 is six  
-bits long:
-
-000: F,2
-001: F,2
-010: G,2
-011: G,2
-100: H,2
-101: H,2
-110: I,3
-111: J,3
-
-So what we have here are three tables with a total of 20 entries that had to  
-be constructed.  That's compared to 64 entries for a single table.  Or  
-compared to 16 entries for a Huffman tree (six two entry tables and one four  
-entry table).  Assuming that the code ideally represents the probability of  
-the symbols, it takes on the average 1.25 lookups per symbol.  That's compared
-to one lookup for the single table, or 1.66 lookups per symbol for the  
-Huffman tree.
-
-There, I think that gives you a picture of what's going on.  For inflate, the  
-meaning of a particular symbol is often more than just a letter.  It can be a  
-byte (a "literal"), or it can be either a length or a distance which  
-indicates a base value and a number of bits to fetch after the code that is  
-added to the base value.  Or it might be the special end-of-block code.  The  
-data structures created in inftrees.c try to encode all that information  
-compactly in the tables.
-
-
-Jean-loup Gailly        Mark Adler
-jloup@gzip.org          madler@alumni.caltech.edu
-
-
-References:
-
-[LZ77] Ziv J., Lempel A., ``A Universal Algorithm for Sequential Data
-Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,
-pp. 337-343.
-
-``DEFLATE Compressed Data Format Specification'' available in
-ftp://ds.internic.net/rfc/rfc1951.txt
--- a/src/share/native/java/util/zip/zlib-1.1.3/example.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,584 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include <stdio.h>
-#include "zlib.h"
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#else
-   extern void exit  OF((int));
-#endif
-
-#if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
-#else
-#  define TESTFILE "foo.gz"
-#endif
-
-#define CHECK_ERR(err, msg) { \
-    if (err != Z_OK) { \
-        fprintf(stderr, "%s error: %d\n", msg, err); \
-        exit(1); \
-    } \
-}
-
-const char hello[] = "hello, hello!";
-/* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- */
-
-const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_compress      OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_gzio          OF((const char *out, const char *in,
-                            Byte *uncompr, int uncomprLen));
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-int  main               OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Test compress() and uncompress()
- */
-void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    uLong len = strlen(hello)+1;
-
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
-    CHECK_ERR(err, "compress");
-
-    strcpy((char*)uncompr, "garbage");
-
-    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
-    CHECK_ERR(err, "uncompress");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad uncompress\n");
-        exit(1);
-    } else {
-        printf("uncompress(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test read/write of .gz files
- */
-void test_gzio(out, in, uncompr, uncomprLen)
-    const char *out; /* compressed output file */
-    const char *in;  /* compressed input file */
-    Byte *uncompr;
-    int  uncomprLen;
-{
-    int err;
-    int len = strlen(hello)+1;
-    gzFile file;
-    z_off_t pos;
-
-    file = gzopen(out, "wb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    gzputc(file, 'h');
-    if (gzputs(file, "ello") != 4) {
-        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (gzprintf(file, ", %s!", "hello") != 8) {
-        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
-    gzclose(file);
-
-    file = gzopen(in, "rb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-    }
-    strcpy((char*)uncompr, "garbage");
-
-    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);
-    if (uncomprLen != len) {
-        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
-        exit(1);
-    } else {
-        printf("gzread(): %s\n", (char *)uncompr);
-    }
-
-    pos = gzseek(file, -8L, SEEK_CUR);
-    if (pos != 6 || gztell(file) != pos) {
-        fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
-        exit(1);
-    }
-
-    if (gzgetc(file) != ' ') {
-        fprintf(stderr, "gzgetc error\n");
-        exit(1);
-    }
-
-    gzgets(file, (char*)uncompr, uncomprLen);
-    uncomprLen = strlen((char*)uncompr);
-    if (uncomprLen != 6) { /* "hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello+7)) {
-        fprintf(stderr, "bad gzgets after gzseek\n");
-        exit(1);
-    } else {
-        printf("gzgets() after gzseek: %s\n", (char *)uncompr);
-    }
-
-    gzclose(file);
-}
-
-/* ===========================================================================
- * Test deflate() with small buffers
- */
-void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    int len = strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-
-    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {
-        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
-        err = deflate(&c_stream, Z_NO_FLUSH);
-        CHECK_ERR(err, "deflate");
-    }
-    /* Finish the stream, still forcing small buffers: */
-    for (;;) {
-        c_stream.avail_out = 1;
-        err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "deflate");
-    }
-
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with small buffers
- */
-void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 0;
-    d_stream.next_out = uncompr;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
-        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate\n");
-        exit(1);
-    } else {
-        printf("inflate(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with large buffers and dynamic change of compression level
- */
-void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_SPEED);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    /* At this point, uncompr is still mostly zeroes, so it should compress
-     * very well:
-     */
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-    if (c_stream.avail_in != 0) {
-        fprintf(stderr, "deflate not greedy\n");
-        exit(1);
-    }
-
-    /* Feed in already compressed data and switch to no compression: */
-    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-    c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    /* Switch back to compressing mode: */
-    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with large buffers
- */
-void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    for (;;) {
-        d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "large inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
-        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
-        exit(1);
-    } else {
-        printf("large_inflate(): OK\n");
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with full flush
- */
-void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    int len = strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-    c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
-    err = deflate(&c_stream, Z_FULL_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    compr[3]++; /* force an error in first compressed block */
-    c_stream.avail_in = len - 3;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        CHECK_ERR(err, "deflate");
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-
-    *comprLen = c_stream.total_out;
-}
-
-/* ===========================================================================
- * Test inflateSync()
- */
-void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 2; /* just read the zlib header */
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    inflate(&d_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "inflate");
-
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
-    err = inflateSync(&d_stream);           /* but skip the damaged part */
-    CHECK_ERR(err, "inflateSync");
-
-    err = inflate(&d_stream, Z_FINISH);
-    if (err != Z_DATA_ERROR) {
-        fprintf(stderr, "inflate should report DATA_ERROR\n");
-        /* Because of incorrect adler32 */
-        exit(1);
-    }
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    printf("after inflateSync(): hel%s\n", (char *)uncompr);
-}
-
-/* ===========================================================================
- * Test deflate() with preset dictionary
- */
-void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    err = deflateSetDictionary(&c_stream,
-                               (const Bytef*)dictionary, sizeof(dictionary));
-    CHECK_ERR(err, "deflateSetDictionary");
-
-    dictId = c_stream.adler;
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with a preset dictionary
- */
-void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    for (;;) {
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        if (err == Z_NEED_DICT) {
-            if (d_stream.adler != dictId) {
-                fprintf(stderr, "unexpected dictionary");
-                exit(1);
-            }
-            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
-                                       sizeof(dictionary));
-        }
-        CHECK_ERR(err, "inflate with dict");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate with dict\n");
-        exit(1);
-    } else {
-        printf("inflate with dictionary: %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Usage:  example [output.gz  [input.gz]]
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
-
-    if (zlibVersion()[0] != myVersion[0]) {
-        fprintf(stderr, "incompatible zlib version\n");
-        exit(1);
-
-    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
-        fprintf(stderr, "warning: different zlib version\n");
-    }
-
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
-    /* compr and uncompr are cleared to avoid reading uninitialized
-     * data and to ensure that uncompr compresses well.
-     */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
-        printf("out of memory\n");
-        exit(1);
-    }
-    test_compress(compr, comprLen, uncompr, uncomprLen);
-
-    test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              (argc > 2 ? argv[2] : TESTFILE),
-              uncompr, (int)uncomprLen);
-
-    test_deflate(compr, comprLen);
-    test_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-    test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_flush(compr, &comprLen);
-    test_sync(compr, comprLen, uncompr, uncomprLen);
-    comprLen = uncomprLen;
-
-    test_dict_deflate(compr, comprLen);
-    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    exit(0);
-    return 0; /* to avoid warning */
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/gzio.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,903 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * gzio.c -- IO on .gz files
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Compile this file with -DNO_DEFLATE to avoid the compression code.
- */
-
-#include <stdio.h>
-
-#include "zutil.h"
-
-struct internal_state {int dummy;}; /* for buggy compilers */
-
-#ifndef Z_BUFSIZE
-#  ifdef MAXSEG_64K
-#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
-#  else
-#    define Z_BUFSIZE 16384
-#  endif
-#endif
-#ifndef Z_PRINTF_BUFSIZE
-#  define Z_PRINTF_BUFSIZE 4096
-#endif
-
-#define ALLOC(size) malloc(size)
-#define TRYFREE(p) {if (p) free(p);}
-
-static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
-
-/* gzip flag byte */
-#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
-#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
-#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
-#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
-#define COMMENT      0x10 /* bit 4 set: file comment present */
-#define RESERVED     0xE0 /* bits 5..7: reserved */
-
-typedef struct gz_stream {
-    z_stream stream;
-    int      z_err;   /* error code for last stream operation */
-    int      z_eof;   /* set if end of input file */
-    FILE     *file;   /* .gz file */
-    Byte     *inbuf;  /* input buffer */
-    Byte     *outbuf; /* output buffer */
-    uLong    crc;     /* crc32 of uncompressed data */
-    char     *msg;    /* error message */
-    char     *path;   /* path name for debugging only */
-    int      transparent; /* 1 if input file is not a .gz file */
-    char     mode;    /* 'w' or 'r' */
-    long     startpos; /* start of compressed data in file (header skipped) */
-} gz_stream;
-
-
-local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
-local int do_flush        OF((gzFile file, int flush));
-local int    get_byte     OF((gz_stream *s));
-local void   check_header OF((gz_stream *s));
-local int    destroy      OF((gz_stream *s));
-local void   putLong      OF((FILE *file, uLong x));
-local uLong  getLong      OF((gz_stream *s));
-
-/* ===========================================================================
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
-   or path name (if fd == -1).
-     gz_open return NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).
-*/
-local gzFile gz_open (path, mode, fd)
-    const char *path;
-    const char *mode;
-    int  fd;
-{
-    int err;
-    int level = Z_DEFAULT_COMPRESSION; /* compression level */
-    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
-    char *p = (char*)mode;
-    gz_stream *s;
-    char fmode[80]; /* copy of mode, without the compression level */
-    char *m = fmode;
-
-    if (!path || !mode) return Z_NULL;
-
-    s = (gz_stream *)ALLOC(sizeof(gz_stream));
-    if (!s) return Z_NULL;
-
-    s->stream.zalloc = (alloc_func)0;
-    s->stream.zfree = (free_func)0;
-    s->stream.opaque = (voidpf)0;
-    s->stream.next_in = s->inbuf = Z_NULL;
-    s->stream.next_out = s->outbuf = Z_NULL;
-    s->stream.avail_in = s->stream.avail_out = 0;
-    s->file = NULL;
-    s->z_err = Z_OK;
-    s->z_eof = 0;
-    s->crc = crc32(0L, Z_NULL, 0);
-    s->msg = NULL;
-    s->transparent = 0;
-
-    s->path = (char*)ALLOC(strlen(path)+1);
-    if (s->path == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
-    }
-    strcpy(s->path, path); /* do this early for debugging */
-
-    s->mode = '\0';
-    do {
-        if (*p == 'r') s->mode = 'r';
-        if (*p == 'w' || *p == 'a') s->mode = 'w';
-        if (*p >= '0' && *p <= '9') {
-            level = *p - '0';
-        } else if (*p == 'f') {
-          strategy = Z_FILTERED;
-        } else if (*p == 'h') {
-          strategy = Z_HUFFMAN_ONLY;
-        } else {
-            *m++ = *p; /* copy the mode */
-        }
-    } while (*p++ && m != fmode + sizeof(fmode));
-    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
-
-    if (s->mode == 'w') {
-#ifdef NO_DEFLATE
-        err = Z_STREAM_ERROR;
-#else
-        err = deflateInit2(&(s->stream), level,
-                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
-        /* windowBits is passed < 0 to suppress zlib header */
-
-        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
-#endif
-        if (err != Z_OK || s->outbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
-        }
-    } else {
-        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
-
-        err = inflateInit2(&(s->stream), -MAX_WBITS);
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
-         * present after the compressed stream.
-         */
-        if (err != Z_OK || s->inbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
-        }
-    }
-    s->stream.avail_out = Z_BUFSIZE;
-
-    errno = 0;
-    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
-
-    if (s->file == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
-    }
-    if (s->mode == 'w') {
-        /* Write a very simple .gz header:
-         */
-        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
-             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
-        s->startpos = 10L;
-        /* We use 10L instead of ftell(s->file) to because ftell causes an
-         * fflush on some systems. This version of the library doesn't use
-         * startpos anyway in write mode, so this initialization is not
-         * necessary.
-         */
-    } else {
-        check_header(s); /* skip the .gz header */
-        s->startpos = (ftell(s->file) - s->stream.avail_in);
-    }
-
-    return (gzFile)s;
-}
-
-/* ===========================================================================
-     Opens a gzip (.gz) file for reading or writing.
-*/
-gzFile ZEXPORT gzopen (path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open (path, mode, -1);
-}
-
-/* ===========================================================================
-     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
-   to mimic the behavio(u)r of fdopen.
-*/
-gzFile ZEXPORT gzdopen (fd, mode)
-    int fd;
-    const char *mode;
-{
-    char name[20];
-
-    if (fd < 0) return (gzFile)Z_NULL;
-    sprintf(name, "<fd:%d>", fd); /* for debugging */
-
-    return gz_open (name, mode, fd);
-}
-
-/* ===========================================================================
- * Update the compression level and strategy
- */
-int ZEXPORT gzsetparams (file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    /* Make room to allow flushing */
-    if (s->stream.avail_out == 0) {
-
-        s->stream.next_out = s->outbuf;
-        if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
-            s->z_err = Z_ERRNO;
-        }
-        s->stream.avail_out = Z_BUFSIZE;
-    }
-
-    return deflateParams (&(s->stream), level, strategy);
-}
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
-*/
-local int get_byte(s)
-    gz_stream *s;
-{
-    if (s->z_eof) return EOF;
-    if (s->stream.avail_in == 0) {
-        errno = 0;
-        s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
-        if (s->stream.avail_in == 0) {
-            s->z_eof = 1;
-            if (ferror(s->file)) s->z_err = Z_ERRNO;
-            return EOF;
-        }
-        s->stream.next_in = s->inbuf;
-    }
-    s->stream.avail_in--;
-    return *(s->stream.next_in)++;
-}
-
-/* ===========================================================================
-      Check the gzip header of a gz_stream opened for reading. Set the stream
-    mode to transparent if the gzip magic header is not present; set s->err
-    to Z_DATA_ERROR if the magic header is present but the rest of the header
-    is incorrect.
-    IN assertion: the stream s has already been created sucessfully;
-       s->stream.avail_in is zero for the first time, but may be non-zero
-       for concatenated .gz files.
-*/
-local void check_header(s)
-    gz_stream *s;
-{
-    int method; /* method byte */
-    int flags;  /* flags byte */
-    uInt len;
-    int c;
-
-    /* Check the gzip magic header */
-    for (len = 0; len < 2; len++) {
-        c = get_byte(s);
-        if (c != gz_magic[len]) {
-            if (len != 0) s->stream.avail_in++, s->stream.next_in--;
-            if (c != EOF) {
-                s->stream.avail_in++, s->stream.next_in--;
-                s->transparent = 1;
-            }
-            s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
-            return;
-        }
-    }
-    method = get_byte(s);
-    flags = get_byte(s);
-    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
-        s->z_err = Z_DATA_ERROR;
-        return;
-    }
-
-    /* Discard time, xflags and OS code: */
-    for (len = 0; len < 6; len++) (void)get_byte(s);
-
-    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
-        len  =  (uInt)get_byte(s);
-        len += ((uInt)get_byte(s))<<8;
-        /* len is garbage if EOF but the loop below will quit anyway */
-        while (len-- != 0 && get_byte(s) != EOF) ;
-    }
-    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
-        while ((c = get_byte(s)) != 0 && c != EOF) ;
-    }
-    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
-        while ((c = get_byte(s)) != 0 && c != EOF) ;
-    }
-    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
-        for (len = 0; len < 2; len++) (void)get_byte(s);
-    }
-    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
-}
-
- /* ===========================================================================
- * Cleanup then free the given gz_stream. Return a zlib error code.
-   Try freeing in the reverse order of allocations.
- */
-local int destroy (s)
-    gz_stream *s;
-{
-    int err = Z_OK;
-
-    if (!s) return Z_STREAM_ERROR;
-
-    TRYFREE(s->msg);
-
-    if (s->stream.state != NULL) {
-        if (s->mode == 'w') {
-#ifdef NO_DEFLATE
-            err = Z_STREAM_ERROR;
-#else
-            err = deflateEnd(&(s->stream));
-#endif
-        } else if (s->mode == 'r') {
-            err = inflateEnd(&(s->stream));
-        }
-    }
-    if (s->file != NULL && fclose(s->file)) {
-#ifdef ESPIPE
-        if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
-#endif
-            err = Z_ERRNO;
-    }
-    if (s->z_err < 0) err = s->z_err;
-
-    TRYFREE(s->inbuf);
-    TRYFREE(s->outbuf);
-    TRYFREE(s->path);
-    TRYFREE(s);
-    return err;
-}
-
-/* ===========================================================================
-     Reads the given number of uncompressed bytes from the compressed file.
-   gzread returns the number of bytes actually read (0 for end of file).
-*/
-int ZEXPORT gzread (file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    gz_stream *s = (gz_stream*)file;
-    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
-    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
-
-    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
-
-    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
-    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
-
-    next_out = (Byte*)buf;
-    s->stream.next_out = (Bytef*)buf;
-    s->stream.avail_out = len;
-
-    while (s->stream.avail_out != 0) {
-
-        if (s->transparent) {
-            /* Copy first the lookahead bytes: */
-            uInt n = s->stream.avail_in;
-            if (n > s->stream.avail_out) n = s->stream.avail_out;
-            if (n > 0) {
-                zmemcpy(s->stream.next_out, s->stream.next_in, n);
-                next_out += n;
-                s->stream.next_out = next_out;
-                s->stream.next_in   += n;
-                s->stream.avail_out -= n;
-                s->stream.avail_in  -= n;
-            }
-            if (s->stream.avail_out > 0) {
-                s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
-                                             s->file);
-            }
-            len -= s->stream.avail_out;
-            s->stream.total_in  += (uLong)len;
-            s->stream.total_out += (uLong)len;
-            if (len == 0) s->z_eof = 1;
-            return (int)len;
-        }
-        if (s->stream.avail_in == 0 && !s->z_eof) {
-
-            errno = 0;
-            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
-            if (s->stream.avail_in == 0) {
-                s->z_eof = 1;
-                if (ferror(s->file)) {
-                    s->z_err = Z_ERRNO;
-                    break;
-                }
-            }
-            s->stream.next_in = s->inbuf;
-        }
-        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
-
-        if (s->z_err == Z_STREAM_END) {
-            /* Check CRC and original size */
-            s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
-            start = s->stream.next_out;
-
-            if (getLong(s) != s->crc) {
-                s->z_err = Z_DATA_ERROR;
-            } else {
-                (void)getLong(s);
-                /* The uncompressed length returned by above getlong() may
-                 * be different from s->stream.total_out) in case of
-                 * concatenated .gz files. Check for such files:
-                 */
-                check_header(s);
-                if (s->z_err == Z_OK) {
-                    uLong total_in = s->stream.total_in;
-                    uLong total_out = s->stream.total_out;
-
-                    inflateReset(&(s->stream));
-                    s->stream.total_in = total_in;
-                    s->stream.total_out = total_out;
-                    s->crc = crc32(0L, Z_NULL, 0);
-                }
-            }
-        }
-        if (s->z_err != Z_OK || s->z_eof) break;
-    }
-    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
-
-    return (int)(len - s->stream.avail_out);
-}
-
-
-/* ===========================================================================
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
-*/
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    unsigned char c;
-
-    return gzread(file, &c, 1) == 1 ? c : -1;
-}
-
-
-/* ===========================================================================
-      Reads bytes from the compressed file until len-1 characters are
-   read, or a newline character is read and transferred to buf, or an
-   end-of-file condition is encountered.  The string is then terminated
-   with a null character.
-      gzgets returns buf, or Z_NULL in case of error.
-
-      The current implementation is not optimized at all.
-*/
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    char *b = buf;
-    if (buf == Z_NULL || len <= 0) return Z_NULL;
-
-    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
-    *buf = '\0';
-    return b == buf && len > 0 ? Z_NULL : b;
-}
-
-
-#ifndef NO_DEFLATE
-/* ===========================================================================
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of bytes actually written (0 in case of error).
-*/
-int ZEXPORT gzwrite (file, buf, len)
-    gzFile file;
-    const voidp buf;
-    unsigned len;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    s->stream.next_in = (Bytef*)buf;
-    s->stream.avail_in = len;
-
-    while (s->stream.avail_in != 0) {
-
-        if (s->stream.avail_out == 0) {
-
-            s->stream.next_out = s->outbuf;
-            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
-                s->z_err = Z_ERRNO;
-                break;
-            }
-            s->stream.avail_out = Z_BUFSIZE;
-        }
-        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
-        if (s->z_err != Z_OK) break;
-    }
-    s->crc = crc32(s->crc, (const Bytef *)buf, len);
-
-    return (int)(len - s->stream.avail_in);
-}
-
-/* ===========================================================================
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).
-*/
-#ifdef STDC
-#include <stdarg.h>
-
-int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
-{
-    char buf[Z_PRINTF_BUFSIZE];
-    va_list va;
-    int len;
-
-    va_start(va, format);
-#ifdef HAS_vsnprintf
-    (void)vsnprintf(buf, sizeof(buf), format, va);
-#else
-    (void)vsprintf(buf, format, va);
-#endif
-    va_end(va);
-    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
-    if (len <= 0) return 0;
-
-    return gzwrite(file, buf, (unsigned)len);
-}
-#else /* not ANSI C */
-
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    char buf[Z_PRINTF_BUFSIZE];
-    int len;
-
-#ifdef HAS_snprintf
-    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
-             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#else
-    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#endif
-    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
-    if (len <= 0) return 0;
-
-    return gzwrite(file, buf, len);
-}
-#endif
-
-/* ===========================================================================
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
-*/
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned char cc = (unsigned char) c; /* required for big endian systems */
-
-    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
-}
-
-
-/* ===========================================================================
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
-*/
-int ZEXPORT gzputs(file, s)
-    gzFile file;
-    const char *s;
-{
-    return gzwrite(file, (char*)s, (unsigned)strlen(s));
-}
-
-
-/* ===========================================================================
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function.
-*/
-local int do_flush (file, flush)
-    gzFile file;
-    int flush;
-{
-    uInt len;
-    int done = 0;
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    s->stream.avail_in = 0; /* should be zero already anyway */
-
-    for (;;) {
-        len = Z_BUFSIZE - s->stream.avail_out;
-
-        if (len != 0) {
-            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
-                s->z_err = Z_ERRNO;
-                return Z_ERRNO;
-            }
-            s->stream.next_out = s->outbuf;
-            s->stream.avail_out = Z_BUFSIZE;
-        }
-        if (done) break;
-        s->z_err = deflate(&(s->stream), flush);
-
-        /* Ignore the second of two consecutive flushes: */
-        if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
-
-        /* deflate has finished flushing only when it hasn't used up
-         * all the available space in the output buffer:
-         */
-        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
-
-        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
-    }
-    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
-}
-
-int ZEXPORT gzflush (file, flush)
-     gzFile file;
-     int flush;
-{
-    gz_stream *s = (gz_stream*)file;
-    int err = do_flush (file, flush);
-
-    if (err) return err;
-    fflush(s->file);
-    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
-}
-#endif /* NO_DEFLATE */
-
-/* ===========================================================================
-      Sets the starting position for the next gzread or gzwrite on the given
-   compressed file. The offset represents a number of bytes in the
-      gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error.
-      SEEK_END is not implemented, returns error.
-      In this version of the library, gzseek can be extremely slow.
-*/
-z_off_t ZEXPORT gzseek (file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || whence == SEEK_END ||
-        s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
-        return -1L;
-    }
-
-    if (s->mode == 'w') {
-#ifdef NO_DEFLATE
-        return -1L;
-#else
-        if (whence == SEEK_SET) {
-            offset -= s->stream.total_in;
-        }
-        if (offset < 0) return -1L;
-
-        /* At this point, offset is the number of zero bytes to write. */
-        if (s->inbuf == Z_NULL) {
-            s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
-            zmemzero(s->inbuf, Z_BUFSIZE);
-        }
-        while (offset > 0)  {
-            uInt size = Z_BUFSIZE;
-            if (offset < Z_BUFSIZE) size = (uInt)offset;
-
-            size = gzwrite(file, s->inbuf, size);
-            if (size == 0) return -1L;
-
-            offset -= size;
-        }
-        return (z_off_t)s->stream.total_in;
-#endif
-    }
-    /* Rest of function is for reading only */
-
-    /* compute absolute position */
-    if (whence == SEEK_CUR) {
-        offset += s->stream.total_out;
-    }
-    if (offset < 0) return -1L;
-
-    if (s->transparent) {
-        /* map to fseek */
-        s->stream.avail_in = 0;
-        s->stream.next_in = s->inbuf;
-        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;
-
-        s->stream.total_in = s->stream.total_out = (uLong)offset;
-        return offset;
-    }
-
-    /* For a negative seek, rewind and use positive seek */
-    if ((uLong)offset >= s->stream.total_out) {
-        offset -= s->stream.total_out;
-    } else if (gzrewind(file) < 0) {
-        return -1L;
-    }
-    /* offset is now the number of bytes to skip. */
-
-    if (offset != 0 && s->outbuf == Z_NULL) {
-        s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
-    }
-    while (offset > 0)  {
-        int size = Z_BUFSIZE;
-        if (offset < Z_BUFSIZE) size = (int)offset;
-
-        size = gzread(file, s->outbuf, (uInt)size);
-        if (size <= 0) return -1L;
-        offset -= size;
-    }
-    return (z_off_t)s->stream.total_out;
-}
-
-/* ===========================================================================
-     Rewinds input file.
-*/
-int ZEXPORT gzrewind (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'r') return -1;
-
-    s->z_err = Z_OK;
-    s->z_eof = 0;
-    s->stream.avail_in = 0;
-    s->stream.next_in = s->inbuf;
-    s->crc = crc32(0L, Z_NULL, 0);
-
-    if (s->startpos == 0) { /* not a compressed file */
-        rewind(s->file);
-        return 0;
-    }
-
-    (void) inflateReset(&s->stream);
-    return fseek(s->file, s->startpos, SEEK_SET);
-}
-
-/* ===========================================================================
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-*/
-z_off_t ZEXPORT gztell (file)
-    gzFile file;
-{
-    return gzseek(file, 0L, SEEK_CUR);
-}
-
-/* ===========================================================================
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-*/
-int ZEXPORT gzeof (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
-}
-
-/* ===========================================================================
-   Outputs a long in LSB order to the given file
-*/
-local void putLong (file, x)
-    FILE *file;
-    uLong x;
-{
-    int n;
-    for (n = 0; n < 4; n++) {
-        fputc((int)(x & 0xff), file);
-        x >>= 8;
-    }
-}
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets z_err in case
-   of error.
-*/
-local uLong getLong (s)
-    gz_stream *s;
-{
-    uLong x = (uLong)get_byte(s);
-    int c;
-
-    x += ((uLong)get_byte(s))<<8;
-    x += ((uLong)get_byte(s))<<16;
-    c = get_byte(s);
-    if (c == EOF) s->z_err = Z_DATA_ERROR;
-    x += ((uLong)c)<<24;
-    return x;
-}
-
-/* ===========================================================================
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state.
-*/
-int ZEXPORT gzclose (file)
-    gzFile file;
-{
-    int err;
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL) return Z_STREAM_ERROR;
-
-    if (s->mode == 'w') {
-#ifdef NO_DEFLATE
-        return Z_STREAM_ERROR;
-#else
-        err = do_flush (file, Z_FINISH);
-        if (err != Z_OK) return destroy((gz_stream*)file);
-
-        putLong (s->file, s->crc);
-        putLong (s->file, s->stream.total_in);
-#endif
-    }
-    return destroy((gz_stream*)file);
-}
-
-/* ===========================================================================
-     Returns the error message for the last error which occured on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occured in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
-*/
-const char*  ZEXPORT gzerror (file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    char *m;
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL) {
-        *errnum = Z_STREAM_ERROR;
-        return (const char*)ERR_MSG(Z_STREAM_ERROR);
-    }
-    *errnum = s->z_err;
-    if (*errnum == Z_OK) return (const char*)"";
-
-    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
-
-    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
-
-    TRYFREE(s->msg);
-    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
-    strcpy(s->msg, s->path);
-    strcat(s->msg, ": ");
-    strcat(s->msg, m);
-    return (const char*)s->msg;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/infblock.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,437 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * infblock.c -- interpret and process block types to last block
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infblock.h"
-#include "inftrees.h"
-#include "infcodes.h"
-#include "infutil.h"
-
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* Table for deflate from PKZIP's appnote.txt. */
-local const uInt border[] = { /* Order of the bit length code lengths */
-        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-/*
-   Notes beyond the 1.93a appnote.txt:
-
-   1. Distance pointers never point before the beginning of the output
-      stream.
-   2. Distance pointers can point back across blocks, up to 32k away.
-   3. There is an implied maximum of 7 bits for the bit length table and
-      15 bits for the actual data.
-   4. If only one code exists, then it is encoded using one bit.  (Zero
-      would be more efficient, but perhaps a little confusing.)  If two
-      codes exist, they are coded using one bit each (0 and 1).
-   5. There is no way of sending zero distance codes--a dummy must be
-      sent if there are none.  (History: a pre 2.0 version of PKZIP would
-      store blocks with no distance codes, but this was discovered to be
-      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
-      zero distance codes, which is sent as one code of zero bits in
-      length.
-   6. There are up to 286 literal/length codes.  Code 256 represents the
-      end-of-block.  Note however that the static length tree defines
-      288 codes just to fill out the Huffman codes.  Codes 286 and 287
-      cannot be used though, since there is no length base or extra bits
-      defined for them.  Similarily, there are up to 30 distance codes.
-      However, static trees define 32 codes (all 5 bits) to fill out the
-      Huffman codes, but the last two had better not show up in the data.
-   7. Unzip can check dynamic Huffman blocks for complete code sets.
-      The exception is that a single code would not be complete (see #4).
-   8. The five bits following the block type is really the number of
-      literal codes sent minus 257.
-   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
-      (1+6+6).  Therefore, to output three times the length, you output
-      three codes (1+1+1), whereas to output four times the same length,
-      you only need two codes (1+3).  Hmm.
-  10. In the tree reconstruction algorithm, Code = Code + Increment
-      only if BitLength(i) is not zero.  (Pretty obvious.)
-  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
-  12. Note: length code 284 can represent 227-258, but length code 285
-      really is 258.  The last length deserves its own, short code
-      since it gets used a lot in very redundant files.  The length
-      258 is special since 258 - 3 (the min match length) is 255.
-  13. The literal/length and distance code bit lengths are read as a
-      single stream of lengths.  It is possible (and advantageous) for
-      a repeat code (16, 17, or 18) to go across the boundary between
-      the two sets of lengths.
- */
-
-
-void inflate_blocks_reset(s, z, c)
-inflate_blocks_statef *s;
-z_streamp z;
-uLongf *c;
-{
-  if (c != Z_NULL)
-    *c = s->check;
-  if (s->mode == BTREE || s->mode == DTREE)
-    ZFREE(z, s->sub.trees.blens);
-  if (s->mode == CODES)
-    inflate_codes_free(s->sub.decode.codes, z);
-  s->mode = TYPE;
-  s->bitk = 0;
-  s->bitb = 0;
-  s->read = s->write = s->window;
-  if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
-  Tracev((stderr, "inflate:   blocks reset\n"));
-}
-
-
-inflate_blocks_statef *inflate_blocks_new(z, c, w)
-z_streamp z;
-check_func c;
-uInt w;
-{
-  inflate_blocks_statef *s;
-
-  if ((s = (inflate_blocks_statef *)ZALLOC
-       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
-    return s;
-  if ((s->hufts =
-       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
-  {
-    ZFREE(z, s);
-    return Z_NULL;
-  }
-  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
-  {
-    ZFREE(z, s->hufts);
-    ZFREE(z, s);
-    return Z_NULL;
-  }
-  s->end = s->window + w;
-  s->checkfn = c;
-  s->mode = TYPE;
-  Tracev((stderr, "inflate:   blocks allocated\n"));
-  inflate_blocks_reset(s, z, Z_NULL);
-  return s;
-}
-
-
-int inflate_blocks(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt t;               /* temporary storage */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input based on current state */
-  while (1) switch (s->mode)
-  {
-    case TYPE:
-      NEEDBITS(3)
-      t = (uInt)b & 7;
-      s->last = t & 1;
-      switch (t >> 1)
-      {
-        case 0:                         /* stored */
-          Tracev((stderr, "inflate:     stored block%s\n",
-                 s->last ? " (last)" : ""));
-          DUMPBITS(3)
-          t = k & 7;                    /* go to byte boundary */
-          DUMPBITS(t)
-          s->mode = LENS;               /* get length of stored block */
-          break;
-        case 1:                         /* fixed */
-          Tracev((stderr, "inflate:     fixed codes block%s\n",
-                 s->last ? " (last)" : ""));
-          {
-            uInt bl, bd;
-            inflate_huft *tl, *td;
-
-            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
-            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
-            if (s->sub.decode.codes == Z_NULL)
-            {
-              r = Z_MEM_ERROR;
-              LEAVE
-            }
-          }
-          DUMPBITS(3)
-          s->mode = CODES;
-          break;
-        case 2:                         /* dynamic */
-          Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                 s->last ? " (last)" : ""));
-          DUMPBITS(3)
-          s->mode = TABLE;
-          break;
-        case 3:                         /* illegal */
-          DUMPBITS(3)
-          s->mode = BAD;
-          z->msg = (char*)"invalid block type";
-          r = Z_DATA_ERROR;
-          LEAVE
-      }
-      break;
-    case LENS:
-      NEEDBITS(32)
-      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
-      {
-        s->mode = BAD;
-        z->msg = (char*)"invalid stored block lengths";
-        r = Z_DATA_ERROR;
-        LEAVE
-      }
-      s->sub.left = (uInt)b & 0xffff;
-      b = k = 0;                      /* dump bits */
-      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
-      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
-      break;
-    case STORED:
-      if (n == 0)
-        LEAVE
-      NEEDOUT
-      t = s->sub.left;
-      if (t > n) t = n;
-      if (t > m) t = m;
-      zmemcpy(q, p, t);
-      p += t;  n -= t;
-      q += t;  m -= t;
-      if ((s->sub.left -= t) != 0)
-        break;
-      Tracev((stderr, "inflate:       stored end, %lu total out\n",
-              z->total_out + (q >= s->read ? q - s->read :
-              (s->end - s->read) + (q - s->window))));
-      s->mode = s->last ? DRY : TYPE;
-      break;
-    case TABLE:
-      NEEDBITS(14)
-      s->sub.trees.table = t = (uInt)b & 0x3fff;
-#ifndef PKZIP_BUG_WORKAROUND
-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
-      {
-        s->mode = BAD;
-        z->msg = (char*)"too many length or distance symbols";
-        r = Z_DATA_ERROR;
-        LEAVE
-      }
-#endif
-      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
-      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
-      {
-        r = Z_MEM_ERROR;
-        LEAVE
-      }
-      DUMPBITS(14)
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       table sizes ok\n"));
-      s->mode = BTREE;
-    case BTREE:
-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
-      {
-        NEEDBITS(3)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
-        DUMPBITS(3)
-      }
-      while (s->sub.trees.index < 19)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
-      s->sub.trees.bb = 7;
-      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
-                             &s->sub.trees.tb, s->hufts, z);
-      if (t != Z_OK)
-      {
-
-        r = t;
-        if (r == Z_DATA_ERROR)
-        {
-          ZFREE(z, s->sub.trees.blens);
-          s->mode = BAD;
-        }
-        LEAVE
-      }
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       bits tree ok\n"));
-      s->mode = DTREE;
-    case DTREE:
-      while (t = s->sub.trees.table,
-             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
-      {
-        inflate_huft *h;
-        uInt i, j, c;
-
-        t = s->sub.trees.bb;
-        NEEDBITS(t)
-        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
-        t = h->bits;
-        c = h->base;
-        if (c < 16)
-        {
-          DUMPBITS(t)
-          s->sub.trees.blens[s->sub.trees.index++] = c;
-        }
-        else /* c == 16..18 */
-        {
-          i = c == 18 ? 7 : c - 14;
-          j = c == 18 ? 11 : 3;
-          NEEDBITS(t + i)
-          DUMPBITS(t)
-          j += (uInt)b & inflate_mask[i];
-          DUMPBITS(i)
-          i = s->sub.trees.index;
-          t = s->sub.trees.table;
-          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
-              (c == 16 && i < 1))
-          {
-            ZFREE(z, s->sub.trees.blens);
-            s->mode = BAD;
-            z->msg = (char*)"invalid bit length repeat";
-            r = Z_DATA_ERROR;
-            LEAVE
-          }
-          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
-          do {
-            s->sub.trees.blens[i++] = c;
-          } while (--j);
-          s->sub.trees.index = i;
-        }
-      }
-      s->sub.trees.tb = Z_NULL;
-      {
-        uInt bl, bd;
-        inflate_huft *tl, *td;
-        inflate_codes_statef *c;
-
-        bl = 9;         /* must be <= 9 for lookahead assumptions */
-        bd = 6;         /* must be <= 9 for lookahead assumptions */
-        t = s->sub.trees.table;
-        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
-                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
-                                  s->hufts, z);
-
-        if (t != Z_OK)
-        {
-          if (t == (uInt)Z_DATA_ERROR)
-          {
-              ZFREE(z, s->sub.trees.blens);
-              s->mode = BAD;
-          }
-          r = t;
-          LEAVE
-        }
-        Tracev((stderr, "inflate:       trees ok\n"));
-        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
-        {
-          r = Z_MEM_ERROR;
-          LEAVE
-        }
-        s->sub.decode.codes = c;
-      }
-      ZFREE(z, s->sub.trees.blens);
-      s->mode = CODES;
-    case CODES:
-      UPDATE
-      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
-        return inflate_flush(s, z, r);
-      r = Z_OK;
-      inflate_codes_free(s->sub.decode.codes, z);
-      LOAD
-      Tracev((stderr, "inflate:       codes end, %lu total out\n",
-              z->total_out + (q >= s->read ? q - s->read :
-              (s->end - s->read) + (q - s->window))));
-      if (!s->last)
-      {
-        s->mode = TYPE;
-        break;
-      }
-      s->mode = DRY;
-    case DRY:
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      s->mode = DONE;
-    case DONE:
-      r = Z_STREAM_END;
-      LEAVE
-    case BAD:
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-}
-
-
-int inflate_blocks_free(s, z)
-inflate_blocks_statef *s;
-z_streamp z;
-{
-  inflate_blocks_reset(s, z, Z_NULL);
-  ZFREE(z, s->window);
-  ZFREE(z, s->hufts);
-  ZFREE(z, s);
-  Tracev((stderr, "inflate:   blocks freed\n"));
-  return Z_OK;
-}
-
-
-void inflate_set_dictionary(s, d, n)
-inflate_blocks_statef *s;
-const Bytef *d;
-uInt  n;
-{
-  zmemcpy(s->window, d, n);
-  s->read = s->write = s->window + n;
-}
-
-
-/* Returns true if inflate is currently at the end of a block generated
- * by Z_SYNC_FLUSH or Z_FULL_FLUSH.
- * IN assertion: s != Z_NULL
- */
-int inflate_blocks_sync_point(s)
-inflate_blocks_statef *s;
-{
-  return s->mode == LENS;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/infblock.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * infblock.h -- header to use infblock.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-struct inflate_blocks_state;
-typedef struct inflate_blocks_state FAR inflate_blocks_statef;
-
-extern inflate_blocks_statef * inflate_blocks_new OF((
-    z_streamp z,
-    check_func c,               /* check function */
-    uInt w));                   /* window size */
-
-extern int inflate_blocks OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));                      /* initial return code */
-
-extern void inflate_blocks_reset OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    uLongf *));                  /* check value on output */
-
-extern int inflate_blocks_free OF((
-    inflate_blocks_statef *,
-    z_streamp));
-
-extern void inflate_set_dictionary OF((
-    inflate_blocks_statef *s,
-    const Bytef *d,  /* dictionary */
-    uInt  n));       /* dictionary length */
-
-extern int inflate_blocks_sync_point OF((
-    inflate_blocks_statef *s));
--- a/src/share/native/java/util/zip/zlib-1.1.3/infcodes.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,287 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * infcodes.c -- process literals and length/distance pairs
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "infblock.h"
-#include "infcodes.h"
-#include "infutil.h"
-#include "inffast.h"
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-      START,    /* x: set up for LEN */
-      LEN,      /* i: get length/literal/eob next */
-      LENEXT,   /* i: getting length extra (have base) */
-      DIST,     /* i: get distance next */
-      DISTEXT,  /* i: getting distance extra */
-      COPY,     /* o: copying bytes in window, waiting for space */
-      LIT,      /* o: got literal, waiting for output space */
-      WASH,     /* o: got eob, possibly still output waiting */
-      END,      /* x: got eob and all data flushed */
-      BADCODE}  /* x: got error */
-inflate_codes_mode;
-
-/* inflate codes private state */
-struct inflate_codes_state {
-
-  /* mode */
-  inflate_codes_mode mode;      /* current inflate_codes mode */
-
-  /* mode dependent information */
-  uInt len;
-  union {
-    struct {
-      inflate_huft *tree;       /* pointer into tree */
-      uInt need;                /* bits needed */
-    } code;             /* if LEN or DIST, where in tree */
-    uInt lit;           /* if LIT, literal */
-    struct {
-      uInt get;                 /* bits to get for extra */
-      uInt dist;                /* distance back to copy from */
-    } copy;             /* if EXT or COPY, where and how much */
-  } sub;                /* submode */
-
-  /* mode independent information */
-  Byte lbits;           /* ltree bits decoded per branch */
-  Byte dbits;           /* dtree bits decoder per branch */
-  inflate_huft *ltree;          /* literal/length/eob tree */
-  inflate_huft *dtree;          /* distance tree */
-
-};
-
-
-inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
-uInt bl, bd;
-inflate_huft *tl;
-inflate_huft *td; /* need separate declaration for Borland C++ */
-z_streamp z;
-{
-  inflate_codes_statef *c;
-
-  if ((c = (inflate_codes_statef *)
-       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
-  {
-    c->mode = START;
-    c->lbits = (Byte)bl;
-    c->dbits = (Byte)bd;
-    c->ltree = tl;
-    c->dtree = td;
-    Tracev((stderr, "inflate:       codes new\n"));
-  }
-  return c;
-}
-
-
-int inflate_codes(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt j;               /* temporary storage */
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  Bytef *f;             /* pointer to copy strings from */
-  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input and output based on current state */
-  while (1) switch (c->mode)
-  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-    case START:         /* x: set up for LEN */
-#ifndef SLOW
-      if (m >= 258 && n >= 10)
-      {
-        UPDATE
-        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
-        LOAD
-        if (r != Z_OK)
-        {
-          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
-          break;
-        }
-      }
-#endif /* !SLOW */
-      c->sub.code.need = c->lbits;
-      c->sub.code.tree = c->ltree;
-      c->mode = LEN;
-    case LEN:           /* i: get length/literal/eob next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e == 0)               /* literal */
-      {
-        c->sub.lit = t->base;
-        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-                 "inflate:         literal '%c'\n" :
-                 "inflate:         literal 0x%02x\n", t->base));
-        c->mode = LIT;
-        break;
-      }
-      if (e & 16)               /* length */
-      {
-        c->sub.copy.get = e & 15;
-        c->len = t->base;
-        c->mode = LENEXT;
-        break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-        c->sub.code.need = e;
-        c->sub.code.tree = t + t->base;
-        break;
-      }
-      if (e & 32)               /* end of block */
-      {
-        Tracevv((stderr, "inflate:         end of block\n"));
-        c->mode = WASH;
-        break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid literal/length code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case LENEXT:        /* i: getting length extra (have base) */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->len += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      c->sub.code.need = c->dbits;
-      c->sub.code.tree = c->dtree;
-      Tracevv((stderr, "inflate:         length %u\n", c->len));
-      c->mode = DIST;
-    case DIST:          /* i: get distance next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e & 16)               /* distance */
-      {
-        c->sub.copy.get = e & 15;
-        c->sub.copy.dist = t->base;
-        c->mode = DISTEXT;
-        break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-        c->sub.code.need = e;
-        c->sub.code.tree = t + t->base;
-        break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid distance code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case DISTEXT:       /* i: getting distance extra */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->sub.copy.dist += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
-      c->mode = COPY;
-    case COPY:          /* o: copying bytes in window, waiting for space */
-#ifndef __TURBOC__ /* Turbo C bug for following expression */
-      f = (uInt)(q - s->window) < c->sub.copy.dist ?
-          s->end - (c->sub.copy.dist - (q - s->window)) :
-          q - c->sub.copy.dist;
-#else
-      f = q - c->sub.copy.dist;
-      if ((uInt)(q - s->window) < c->sub.copy.dist)
-        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
-#endif
-      while (c->len)
-      {
-        NEEDOUT
-        OUTBYTE(*f++)
-        if (f == s->end)
-          f = s->window;
-        c->len--;
-      }
-      c->mode = START;
-      break;
-    case LIT:           /* o: got literal, waiting for output space */
-      NEEDOUT
-      OUTBYTE(c->sub.lit)
-      c->mode = START;
-      break;
-    case WASH:          /* o: got eob, possibly more output */
-      if (k > 7)        /* return unused byte, if any */
-      {
-        Assert(k < 16, "inflate_codes grabbed too many bytes")
-        k -= 8;
-        n++;
-        p--;            /* can always return one */
-      }
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      c->mode = END;
-    case END:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADCODE:       /* x: got error */
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-#ifdef NEED_DUMMY_RETURN
-  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
-#endif
-}
-
-
-void inflate_codes_free(c, z)
-inflate_codes_statef *c;
-z_streamp z;
-{
-  ZFREE(z, c);
-  Tracev((stderr, "inflate:       codes free\n"));
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/infcodes.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,56 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * infcodes.h -- header to use infcodes.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-struct inflate_codes_state;
-typedef struct inflate_codes_state FAR inflate_codes_statef;
-
-extern inflate_codes_statef *inflate_codes_new OF((
-    uInt, uInt,
-    inflate_huft *, inflate_huft *,
-    z_streamp ));
-
-extern int inflate_codes OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
-
-extern void inflate_codes_free OF((
-    inflate_codes_statef *,
-    z_streamp ));
--- a/src/share/native/java/util/zip/zlib-1.1.3/inffast.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,200 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inffast.c -- process literals and length/distance pairs fast
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "infblock.h"
-#include "infcodes.h"
-#include "infutil.h"
-#include "inffast.h"
-
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* macros for bit input with no checking and for returning unused bytes */
-#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}
-
-/* Called with number of bytes left to write in window at least 258
-   (the maximum string length) and number of input bytes available
-   at least ten.  The ten bytes are six bytes for the longest length/
-   distance pair plus four bytes for overloading the bit buffer. */
-
-int inflate_fast(bl, bd, tl, td, s, z)
-uInt bl, bd;
-inflate_huft *tl;
-inflate_huft *td; /* need separate declaration for Borland C++ */
-inflate_blocks_statef *s;
-z_streamp z;
-{
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  uInt ml;              /* mask for literal/length tree */
-  uInt md;              /* mask for distance tree */
-  uInt c;               /* bytes to copy */
-  uInt d;               /* distance back to copy from */
-  Bytef *r;             /* copy source pointer */
-
-  /* load input, output, bit values */
-  LOAD
-
-  /* initialize masks */
-  ml = inflate_mask[bl];
-  md = inflate_mask[bd];
-
-  /* do until not enough input or output space for fast loop */
-  do {                          /* assume called with m >= 258 && n >= 10 */
-    /* get literal/length code */
-    GRABBITS(20)                /* max bits for literal/length code */
-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
-    {
-      DUMPBITS(t->bits)
-      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-                "inflate:         * literal '%c'\n" :
-                "inflate:         * literal 0x%02x\n", t->base));
-      *q++ = (Byte)t->base;
-      m--;
-      continue;
-    }
-    do {
-      DUMPBITS(t->bits)
-      if (e & 16)
-      {
-        /* get extra bits for length */
-        e &= 15;
-        c = t->base + ((uInt)b & inflate_mask[e]);
-        DUMPBITS(e)
-        Tracevv((stderr, "inflate:         * length %u\n", c));
-
-        /* decode distance base of block to copy */
-        GRABBITS(15);           /* max bits for distance code */
-        e = (t = td + ((uInt)b & md))->exop;
-        do {
-          DUMPBITS(t->bits)
-          if (e & 16)
-          {
-            /* get extra bits to add to distance base */
-            e &= 15;
-            GRABBITS(e)         /* get extra bits (up to 13) */
-            d = t->base + ((uInt)b & inflate_mask[e]);
-            DUMPBITS(e)
-            Tracevv((stderr, "inflate:         * distance %u\n", d));
-
-            /* do the copy */
-            m -= c;
-            if ((uInt)(q - s->window) >= d)     /* offset before dest */
-            {                                   /*  just copy */
-              r = q - d;
-              *q++ = *r++;  c--;        /* minimum count is three, */
-              *q++ = *r++;  c--;        /*  so unroll loop a little */
-            }
-            else                        /* else offset after destination */
-            {
-              e = d - (uInt)(q - s->window); /* bytes from offset to end */
-              r = s->end - e;           /* pointer to offset */
-              if (c > e)                /* if source crosses, */
-              {
-                c -= e;                 /* copy to end of window */
-                do {
-                  *q++ = *r++;
-                } while (--e);
-                r = s->window;          /* copy rest from start of window */
-              }
-            }
-            do {                        /* copy all or what's left */
-              *q++ = *r++;
-            } while (--c);
-            break;
-          }
-          else if ((e & 64) == 0)
-          {
-            t += t->base;
-            e = (t += ((uInt)b & inflate_mask[e]))->exop;
-          }
-          else
-          {
-            z->msg = (char*)"invalid distance code";
-            UNGRAB
-            UPDATE
-            return Z_DATA_ERROR;
-          }
-        } while (1);
-        break;
-      }
-      if ((e & 64) == 0)
-      {
-        t += t->base;
-        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
-        {
-          DUMPBITS(t->bits)
-          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-                    "inflate:         * literal '%c'\n" :
-                    "inflate:         * literal 0x%02x\n", t->base));
-          *q++ = (Byte)t->base;
-          m--;
-          break;
-        }
-      }
-      else if (e & 32)
-      {
-        Tracevv((stderr, "inflate:         * end of block\n"));
-        UNGRAB
-        UPDATE
-        return Z_STREAM_END;
-      }
-      else
-      {
-        z->msg = (char*)"invalid literal/length code";
-        UNGRAB
-        UPDATE
-        return Z_DATA_ERROR;
-      }
-    } while (1);
-  } while (m >= 258 && n >= 10);
-
-  /* not enough input or output--restore pointers and return */
-  UNGRAB
-  UPDATE
-  return Z_OK;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/inffast.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,47 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inffast.h -- header to use inffast.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-extern int inflate_fast OF((
-    uInt,
-    uInt,
-    inflate_huft *,
-    inflate_huft *,
-    inflate_blocks_statef *,
-    z_streamp ));
--- a/src/share/native/java/util/zip/zlib-1.1.3/inffixed.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,175 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/* inffixed.h -- table for decoding fixed codes
- * Generated automatically by the maketree.c program
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-local uInt fixed_bl = 9;
-local uInt fixed_bd = 5;
-local inflate_huft fixed_tl[] = {
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
-  };
-local inflate_huft fixed_td[] = {
-    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
-    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
-    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
-    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
-    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
-    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
-    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
-    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
-  };
--- a/src/share/native/java/util/zip/zlib-1.1.3/inflate.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,403 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inflate.c -- zlib interface to inflate modules
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infblock.h"
-
-struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
-
-typedef enum {
-      METHOD,   /* waiting for method byte */
-      FLAG,     /* waiting for flag byte */
-      DICT4,    /* four dictionary check bytes to go */
-      DICT3,    /* three dictionary check bytes to go */
-      DICT2,    /* two dictionary check bytes to go */
-      DICT1,    /* one dictionary check byte to go */
-      DICT0,    /* waiting for inflateSetDictionary */
-      BLOCKS,   /* decompressing blocks */
-      CHECK4,   /* four check bytes to go */
-      CHECK3,   /* three check bytes to go */
-      CHECK2,   /* two check bytes to go */
-      CHECK1,   /* one check byte to go */
-      DONE,     /* finished check, done */
-      BAD}      /* got an error--stay here */
-inflate_mode;
-
-/* inflate private state */
-struct internal_state {
-
-  /* mode */
-  inflate_mode  mode;   /* current inflate mode */
-
-  /* mode dependent information */
-  union {
-    uInt method;        /* if FLAGS, method byte */
-    struct {
-      uLong was;                /* computed check value */
-      uLong need;               /* stream check value */
-    } check;            /* if CHECK, check values to compare */
-    uInt marker;        /* if BAD, inflateSync's marker bytes count */
-  } sub;        /* submode */
-
-  /* mode independent information */
-  int  nowrap;          /* flag for no wrapper */
-  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
-  inflate_blocks_statef
-    *blocks;            /* current inflate_blocks state */
-
-};
-
-
-int ZEXPORT inflateReset(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->total_in = z->total_out = 0;
-  z->msg = Z_NULL;
-  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
-  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
-  Tracev((stderr, "inflate: reset\n"));
-  return Z_OK;
-}
-
-
-int ZEXPORT inflateEnd(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->blocks != Z_NULL)
-    inflate_blocks_free(z->state->blocks, z);
-  ZFREE(z, z->state);
-  z->state = Z_NULL;
-  Tracev((stderr, "inflate: end\n"));
-  return Z_OK;
-}
-
-
-int ZEXPORT inflateInit2_(z, w, version, stream_size)
-z_streamp z;
-int w;
-const char *version;
-int stream_size;
-{
-  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-      stream_size != sizeof(z_stream))
-      return Z_VERSION_ERROR;
-
-  /* initialize state */
-  if (z == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->msg = Z_NULL;
-  if (z->zalloc == Z_NULL)
-  {
-    z->zalloc = zcalloc;
-    z->opaque = (voidpf)0;
-  }
-  if (z->zfree == Z_NULL) z->zfree = zcfree;
-  if ((z->state = (struct internal_state FAR *)
-       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
-    return Z_MEM_ERROR;
-  z->state->blocks = Z_NULL;
-
-  /* handle undocumented nowrap option (no zlib header or check) */
-  z->state->nowrap = 0;
-  if (w < 0)
-  {
-    w = - w;
-    z->state->nowrap = 1;
-  }
-
-  /* set window size */
-  if (w < 8 || w > 15)
-  {
-    inflateEnd(z);
-    return Z_STREAM_ERROR;
-  }
-  z->state->wbits = (uInt)w;
-
-  /* create inflate_blocks state */
-  if ((z->state->blocks =
-      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
-      == Z_NULL)
-  {
-    inflateEnd(z);
-    return Z_MEM_ERROR;
-  }
-  Tracev((stderr, "inflate: allocated\n"));
-
-  /* reset state */
-  inflateReset(z);
-  return Z_OK;
-}
-
-
-int ZEXPORT inflateInit_(z, version, stream_size)
-z_streamp z;
-const char *version;
-int stream_size;
-{
-  return inflateInit2_(z, DEF_WBITS, version, stream_size);
-}
-
-
-#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
-#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
-
-int ZEXPORT inflate(z, f)
-z_streamp z;
-int f;
-{
-  int r;
-  uInt b;
-
-  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
-    return Z_STREAM_ERROR;
-  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
-  r = Z_BUF_ERROR;
-  while (1) switch (z->state->mode)
-  {
-    case METHOD:
-      NEEDBYTE
-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
-      {
-        z->state->mode = BAD;
-        z->msg = (char*)"unknown compression method";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
-      {
-        z->state->mode = BAD;
-        z->msg = (char*)"invalid window size";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      z->state->mode = FLAG;
-    case FLAG:
-      NEEDBYTE
-      b = NEXTBYTE;
-      if (((z->state->sub.method << 8) + b) % 31)
-      {
-        z->state->mode = BAD;
-        z->msg = (char*)"incorrect header check";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      Tracev((stderr, "inflate: zlib header ok\n"));
-      if (!(b & PRESET_DICT))
-      {
-        z->state->mode = BLOCKS;
-        break;
-      }
-      z->state->mode = DICT4;
-    case DICT4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = DICT3;
-    case DICT3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = DICT2;
-    case DICT2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = DICT1;
-    case DICT1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-      z->adler = z->state->sub.check.need;
-      z->state->mode = DICT0;
-      return Z_NEED_DICT;
-    case DICT0:
-      z->state->mode = BAD;
-      z->msg = (char*)"need dictionary";
-      z->state->sub.marker = 0;       /* can try inflateSync */
-      return Z_STREAM_ERROR;
-    case BLOCKS:
-      r = inflate_blocks(z->state->blocks, z, r);
-      if (r == Z_DATA_ERROR)
-      {
-        z->state->mode = BAD;
-        z->state->sub.marker = 0;       /* can try inflateSync */
-        break;
-      }
-      if (r == Z_OK)
-        r = f;
-      if (r != Z_STREAM_END)
-        return r;
-      r = f;
-      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
-
-      /* zlib.h inflate() doc states that z->adler contains a checksum
-         of all uncompressed output even when returning Z_STREAM_END. */
-      z->adler = z->state->sub.check.was;
-
-      if (z->state->nowrap)
-      {
-        z->state->mode = DONE;
-        break;
-      }
-      z->state->mode = CHECK4;
-    case CHECK4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = CHECK3;
-    case CHECK3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = CHECK2;
-    case CHECK2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = CHECK1;
-    case CHECK1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-
-      if (z->state->sub.check.was != z->state->sub.check.need)
-      {
-        z->state->mode = BAD;
-        z->msg = (char*)"incorrect data check";
-        z->state->sub.marker = 5;       /* can't try inflateSync */
-        break;
-      }
-      Tracev((stderr, "inflate: zlib check ok\n"));
-      z->state->mode = DONE;
-    case DONE:
-      return Z_STREAM_END;
-    case BAD:
-      return Z_DATA_ERROR;
-    default:
-      return Z_STREAM_ERROR;
-  }
-#ifdef NEED_DUMMY_RETURN
-  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
-#endif
-}
-
-
-int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
-z_streamp z;
-const Bytef *dictionary;
-uInt  dictLength;
-{
-  uInt length = dictLength;
-
-  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
-    return Z_STREAM_ERROR;
-
-  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
-  z->adler = 1L;
-
-  if (length >= ((uInt)1<<z->state->wbits))
-  {
-    length = (1<<z->state->wbits)-1;
-    dictionary += dictLength - length;
-  }
-  inflate_set_dictionary(z->state->blocks, dictionary, length);
-  z->state->mode = BLOCKS;
-  return Z_OK;
-}
-
-
-int ZEXPORT inflateSync(z)
-z_streamp z;
-{
-  uInt n;       /* number of bytes to look at */
-  Bytef *p;     /* pointer to bytes */
-  uInt m;       /* number of marker bytes found in a row */
-  uLong r, w;   /* temporaries to save total_in and total_out */
-
-  /* set up */
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->mode != BAD)
-  {
-    z->state->mode = BAD;
-    z->state->sub.marker = 0;
-  }
-  if ((n = z->avail_in) == 0)
-    return Z_BUF_ERROR;
-  p = z->next_in;
-  m = z->state->sub.marker;
-
-  /* search */
-  while (n && m < 4)
-  {
-    static const Byte mark[4] = {0, 0, 0xff, 0xff};
-    if (*p == mark[m])
-      m++;
-    else if (*p)
-      m = 0;
-    else
-      m = 4 - m;
-    p++, n--;
-  }
-
-  /* restore */
-  z->total_in += p - z->next_in;
-  z->next_in = p;
-  z->avail_in = n;
-  z->state->sub.marker = m;
-
-  /* return no joy or set up to restart on a new block */
-  if (m != 4)
-    return Z_DATA_ERROR;
-  r = z->total_in;  w = z->total_out;
-  inflateReset(z);
-  z->total_in = r;  z->total_out = w;
-  z->state->mode = BLOCKS;
-  return Z_OK;
-}
-
-
-/* Returns true if inflate is currently at the end of a block generated
- * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
- * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
- * but removes the length bytes of the resulting empty stored block. When
- * decompressing, PPP checks that at the end of input packet, inflate is
- * waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(z)
-z_streamp z;
-{
-  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
-    return Z_STREAM_ERROR;
-  return inflate_blocks_sync_point(z->state->blocks);
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/inftrees.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,487 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-
-#if !defined(BUILDFIXED) && !defined(STDC)
-#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
-#endif
-
-const char inflate_copyright[] =
-   " inflate 1.1.3.f-jdk Copyright 1995-1998 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-struct internal_state  {int dummy;}; /* for buggy compilers */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-
-local int huft_build OF((
-    uIntf *,            /* code lengths in bits */
-    uInt,               /* number of codes */
-    uInt,               /* number of "simple" codes */
-    const uIntf *,      /* list of base values for non-simple codes */
-    const uIntf *,      /* list of extra bits for non-simple codes */
-    inflate_huft * FAR*,/* result: starting table */
-    uIntf *,            /* maximum lookup bits (returns actual) */
-    inflate_huft *,     /* space for trees */
-    uInt *,             /* hufts used in space */
-    uIntf * ));         /* space for values */
-
-/* Tables for deflate from PKZIP's appnote.txt. */
-local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-        /* see note #13 above about 258 */
-local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
-local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
-local const uInt cpdext[30] = { /* Extra bits for distance codes */
-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
-
-/*
-   Huffman code decoding is performed using a multi-level table lookup.
-   The fastest way to decode is to simply build a lookup table whose
-   size is determined by the longest code.  However, the time it takes
-   to build this table can also be a factor if the data being decoded
-   is not very long.  The most common codes are necessarily the
-   shortest codes, so those codes dominate the decoding time, and hence
-   the speed.  The idea is you can have a shorter table that decodes the
-   shorter, more probable codes, and then point to subsidiary tables for
-   the longer codes.  The time it costs to decode the longer codes is
-   then traded against the time it takes to make longer tables.
-
-   This results of this trade are in the variables lbits and dbits
-   below.  lbits is the number of bits the first level table for literal/
-   length codes can decode in one step, and dbits is the same thing for
-   the distance codes.  Subsequent tables are also less than or equal to
-   those sizes.  These values may be adjusted either when all of the
-   codes are shorter than that, in which case the longest code length in
-   bits is used, or when the shortest code is *longer* than the requested
-   table size, in which case the length of the shortest code in bits is
-   used.
-
-   There are two different values for the two tables, since they code a
-   different number of possibilities each.  The literal/length table
-   codes 286 possible values, or in a flat code, a little over eight
-   bits.  The distance table codes 30 possible values, or a little less
-   than five bits, flat.  The optimum values for speed end up being
-   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
-   The optimum values may differ though from machine to machine, and
-   possibly even between compilers.  Your mileage may vary.
- */
-
-
-/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
-#define BMAX 15         /* maximum bit length of any code */
-
-local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
-uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
-uInt n;                 /* number of codes (assumed <= 288) */
-uInt s;                 /* number of simple-valued codes (0..s-1) */
-const uIntf *d;         /* list of base values for non-simple codes */
-const uIntf *e;         /* list of extra bits for non-simple codes */
-inflate_huft * FAR *t;  /* result: starting table */
-uIntf *m;               /* maximum lookup bits, returns actual */
-inflate_huft *hp;       /* space for trees */
-uInt *hn;               /* hufts used in space */
-uIntf *v;               /* working area: values in order of bit length */
-/* Given a list of code lengths and a maximum table size, make a set of
-   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
-   if the given code set is incomplete (the tables are still built in this
-   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
-   lengths), or Z_MEM_ERROR if not enough memory. */
-{
-
-  uInt a;                       /* counter for codes of length k */
-  uInt c[BMAX+1];               /* bit length count table */
-  uInt f;                       /* i repeats in table every f entries */
-  int g;                        /* maximum code length */
-  int h;                        /* table level */
-  register uInt i;              /* counter, current code */
-  register uInt j;              /* counter */
-  register int k;               /* number of bits in current code */
-  int l;                        /* bits per table (returned in m) */
-  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
-  register uIntf *p;            /* pointer into c[], b[], or v[] */
-  inflate_huft *q;              /* points to current table */
-  struct inflate_huft_s r;      /* table entry for structure assignment */
-  inflate_huft *u[BMAX];        /* table stack */
-  register int w;               /* bits before this table == (l * h) */
-  uInt x[BMAX+1];               /* bit offsets, then code stack */
-  uIntf *xp;                    /* pointer into x */
-  int y;                        /* number of dummy codes added */
-  uInt z;                       /* number of entries in current table */
-
-
-  /* Generate counts for each bit length */
-  p = c;
-#define C0 *p++ = 0;
-#define C2 C0 C0 C0 C0
-#define C4 C2 C2 C2 C2
-  C4                            /* clear c[]--assume BMAX+1 is 16 */
-  p = b;  i = n;
-  do {
-    c[*p++]++;                  /* assume all entries <= BMAX */
-  } while (--i);
-  if (c[0] == n)                /* null input--all zero length codes */
-  {
-    *t = (inflate_huft *)Z_NULL;
-    *m = 0;
-    return Z_OK;
-  }
-
-
-  /* Find minimum and maximum length, bound *m by those */
-  l = *m;
-  for (j = 1; j <= BMAX; j++)
-    if (c[j])
-      break;
-  k = j;                        /* minimum code length */
-  if ((uInt)l < j)
-    l = j;
-  for (i = BMAX; i; i--)
-    if (c[i])
-      break;
-  g = i;                        /* maximum code length */
-  if ((uInt)l > i)
-    l = i;
-  *m = l;
-
-
-  /* Adjust last length count to fill out codes, if needed */
-  for (y = 1 << j; j < i; j++, y <<= 1)
-    if ((y -= c[j]) < 0)
-      return Z_DATA_ERROR;
-  if ((y -= c[i]) < 0)
-    return Z_DATA_ERROR;
-  c[i] += y;
-
-
-  /* Generate starting offsets into the value table for each length */
-  x[1] = j = 0;
-  p = c + 1;  xp = x + 2;
-  while (--i) {                 /* note that i == g from above */
-    *xp++ = (j += *p++);
-  }
-
-
-  /* Make a table of values in order of bit lengths */
-  p = b;  i = 0;
-  do {
-    if ((j = *p++) != 0)
-      v[x[j]++] = i;
-  } while (++i < n);
-  n = x[g];                     /* set n to length of v */
-
-
-  /* Generate the Huffman codes and for each, make the table entries */
-  x[0] = i = 0;                 /* first Huffman code is zero */
-  p = v;                        /* grab values in bit order */
-  h = -1;                       /* no tables yet--level -1 */
-  w = -l;                       /* bits decoded == (l * h) */
-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
-  q = (inflate_huft *)Z_NULL;   /* ditto */
-  z = 0;                        /* ditto */
-
-  /* go through the bit lengths (k already is bits in shortest code) */
-  for (; k <= g; k++)
-  {
-    a = c[k];
-    while (a--)
-    {
-      /* here i is the Huffman code of length k bits for value *p */
-      /* make tables up to required level */
-      while (k > w + l)
-      {
-        h++;
-        w += l;                 /* previous table always l bits */
-
-        /* compute minimum size table less than or equal to l bits */
-        z = g - w;
-        z = z > (uInt)l ? (uInt)l : z;  /* table size upper limit */
-        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
-        {                       /* too few codes for k-w bit table */
-          f -= a + 1;           /* deduct codes from patterns left */
-          xp = c + k;
-          if (j < z)
-            while (++j < z)     /* try smaller tables up to z bits */
-            {
-              if ((f <<= 1) <= *++xp)
-                break;          /* enough codes to use up j bits */
-              f -= *xp;         /* else deduct codes from patterns */
-            }
-        }
-        z = 1 << j;             /* table entries for j-bit table */
-
-        /* allocate new table */
-        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
-          return Z_MEM_ERROR;   /* not enough memory */
-        u[h] = q = hp + *hn;
-        *hn += z;
-
-        /* connect to last table, if there is one */
-        if (h)
-        {
-          x[h] = i;             /* save pattern for backing up */
-          r.bits = (Byte)l;     /* bits to dump before this table */
-          r.exop = (Byte)j;     /* bits in this table */
-          j = i >> (w - l);
-          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
-          u[h-1][j] = r;        /* connect to last table */
-        }
-        else
-          *t = q;               /* first table is returned result */
-      }
-
-      /* set up table entry in r */
-      r.bits = (Byte)(k - w);
-      if (p >= v + n)
-        r.exop = 128 + 64;      /* out of values--invalid code */
-      else if (*p < s)
-      {
-        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
-        r.base = *p++;          /* simple code is just the value */
-      }
-      else
-      {
-        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
-        r.base = d[*p++ - s];
-      }
-
-      /* fill code-like entries with r */
-      f = 1 << (k - w);
-      for (j = i >> w; j < z; j += f)
-        q[j] = r;
-
-      /* backwards increment the k-bit code i */
-      for (j = 1 << (k - 1); i & j; j >>= 1)
-        i ^= j;
-      i ^= j;
-
-      /* backup over finished tables */
-      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
-      while ((i & mask) != x[h])
-      {
-        h--;                    /* don't need to update q */
-        w -= l;
-        mask = (1 << w) - 1;
-      }
-    }
-  }
-
-
-  /* Return Z_BUF_ERROR if we were given an incomplete table */
-  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
-}
-
-
-int inflate_trees_bits(c, bb, tb, hp, z)
-uIntf *c;               /* 19 code lengths */
-uIntf *bb;              /* bits tree desired/actual depth */
-inflate_huft * FAR *tb; /* bits tree result */
-inflate_huft *hp;       /* space for trees */
-z_streamp z;            /* for messages */
-{
-  int r;
-  uInt hn = 0;          /* hufts used in space */
-  uIntf *v;             /* work area for huft_build */
-
-  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
-    return Z_MEM_ERROR;
-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
-                 tb, bb, hp, &hn, v);
-  if (r == Z_DATA_ERROR)
-    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
-  else if (r == Z_BUF_ERROR || *bb == 0)
-  {
-    z->msg = (char*)"incomplete dynamic bit lengths tree";
-    r = Z_DATA_ERROR;
-  }
-  ZFREE(z, v);
-  return r;
-}
-
-
-int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
-uInt nl;                /* number of literal/length codes */
-uInt nd;                /* number of distance codes */
-uIntf *c;               /* that many (total) code lengths */
-uIntf *bl;              /* literal desired/actual bit depth */
-uIntf *bd;              /* distance desired/actual bit depth */
-inflate_huft * FAR *tl; /* literal/length tree result */
-inflate_huft * FAR *td; /* distance tree result */
-inflate_huft *hp;       /* space for trees */
-z_streamp z;            /* for messages */
-{
-  int r;
-  uInt hn = 0;          /* hufts used in space */
-  uIntf *v;             /* work area for huft_build */
-
-  /* allocate work area */
-  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
-    return Z_MEM_ERROR;
-
-  /* build literal/length tree */
-  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
-  if (r != Z_OK || *bl == 0)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed literal/length tree";
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"incomplete literal/length tree";
-      r = Z_DATA_ERROR;
-    }
-    ZFREE(z, v);
-    return r;
-  }
-
-  /* build distance tree */
-  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
-  if (r != Z_OK || (*bd == 0 && nl > 257))
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed distance tree";
-    else if (r == Z_BUF_ERROR) {
-#ifdef PKZIP_BUG_WORKAROUND
-      r = Z_OK;
-    }
-#else
-      z->msg = (char*)"incomplete distance tree";
-      r = Z_DATA_ERROR;
-    }
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"empty distance tree with lengths";
-      r = Z_DATA_ERROR;
-    }
-    ZFREE(z, v);
-    return r;
-#endif
-  }
-
-  /* done */
-  ZFREE(z, v);
-  return Z_OK;
-}
-
-
-/* build fixed tables only once--keep them here */
-#ifdef BUILDFIXED
-local int fixed_built = 0;
-#define FIXEDH 544      /* number of hufts used by fixed tables */
-local inflate_huft fixed_mem[FIXEDH];
-local uInt fixed_bl;
-local uInt fixed_bd;
-local inflate_huft *fixed_tl;
-local inflate_huft *fixed_td;
-#else
-#include "inffixed.h"
-#endif
-
-
-int inflate_trees_fixed(bl, bd, tl, td, z)
-uIntf *bl;               /* literal desired/actual bit depth */
-uIntf *bd;               /* distance desired/actual bit depth */
-inflate_huft * FAR *tl;  /* literal/length tree result */
-inflate_huft * FAR *td;  /* distance tree result */
-z_streamp z;             /* for memory allocation */
-{
-#ifdef BUILDFIXED
-  /* build fixed tables if not already */
-  if (!fixed_built)
-  {
-    int k;              /* temporary variable */
-    uInt f = 0;         /* number of hufts used in fixed_mem */
-    uIntf *c;           /* length list for huft_build */
-    uIntf *v;           /* work area for huft_build */
-
-    /* allocate memory */
-    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
-      return Z_MEM_ERROR;
-    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
-    {
-      ZFREE(z, c);
-      return Z_MEM_ERROR;
-    }
-
-    /* literal table */
-    for (k = 0; k < 144; k++)
-      c[k] = 8;
-    for (; k < 256; k++)
-      c[k] = 9;
-    for (; k < 280; k++)
-      c[k] = 7;
-    for (; k < 288; k++)
-      c[k] = 8;
-    fixed_bl = 9;
-    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
-               fixed_mem, &f, v);
-
-    /* distance table */
-    for (k = 0; k < 30; k++)
-      c[k] = 5;
-    fixed_bd = 5;
-    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
-               fixed_mem, &f, v);
-
-    /* done */
-    ZFREE(z, v);
-    ZFREE(z, c);
-    fixed_built = 1;
-  }
-#endif
-  *bl = fixed_bl;
-  *bd = fixed_bd;
-  *tl = fixed_tl;
-  *td = fixed_td;
-  return Z_OK;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/inftrees.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,88 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Huffman code lookup table entry--this entry is four bytes for machines
-   that have 16-bit pointers (e.g. PC's in the small or medium model). */
-
-typedef struct inflate_huft_s FAR inflate_huft;
-
-struct inflate_huft_s {
-  union {
-    struct {
-      Byte Exop;        /* number of extra bits or operation */
-      Byte Bits;        /* number of bits in this code or subcode */
-    } what;
-    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
-  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
-  uInt base;            /* literal, length base, distance base,
-                           or table offset */
-};
-
-/* Maximum size of dynamic tree.  The maximum found in a long but non-
-   exhaustive search was 1004 huft structures (850 for length/literals
-   and 154 for distances, the latter actually the result of an
-   exhaustive search).  The actual maximum is not known, but the
-   value below is more than safe. */
-#define MANY 1440
-
-extern int inflate_trees_bits OF((
-    uIntf *,                    /* 19 code lengths */
-    uIntf *,                    /* bits tree desired/actual depth */
-    inflate_huft * FAR *,       /* bits tree result */
-    inflate_huft *,             /* space for trees */
-    z_streamp));                /* for messages */
-
-extern int inflate_trees_dynamic OF((
-    uInt,                       /* number of literal/length codes */
-    uInt,                       /* number of distance codes */
-    uIntf *,                    /* that many (total) code lengths */
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    inflate_huft *,             /* space for trees */
-    z_streamp));                /* for messages */
-
-extern int inflate_trees_fixed OF((
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    z_streamp));                /* for memory allocation */
--- a/src/share/native/java/util/zip/zlib-1.1.3/infutil.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,117 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * inflate_util.c -- data and routines common to blocks and codes
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infblock.h"
-#include "inftrees.h"
-#include "infcodes.h"
-#include "infutil.h"
-
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
-
-/* And'ing with mask[n] masks the lower n bits */
-uInt inflate_mask[17] = {
-    0x0000,
-    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
-};
-
-
-/* copy as much as possible from the sliding window to the output area */
-int inflate_flush(s, z, r)
-inflate_blocks_statef *s;
-z_streamp z;
-int r;
-{
-  uInt n;
-  Bytef *p;
-  Bytef *q;
-
-  /* local copies of source and destination pointers */
-  p = z->next_out;
-  q = s->read;
-
-  /* compute number of bytes to copy as far as end of window */
-  n = (uInt)((q <= s->write ? s->write : s->end) - q);
-  if (n > z->avail_out) n = z->avail_out;
-  if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-  /* update counters */
-  z->avail_out -= n;
-  z->total_out += n;
-
-  /* update check information */
-  if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(s->check, q, n);
-
-  /* copy as far as end of window */
-  zmemcpy(p, q, n);
-  p += n;
-  q += n;
-
-  /* see if more to copy at beginning of window */
-  if (q == s->end)
-  {
-    /* wrap pointers */
-    q = s->window;
-    if (s->write == s->end)
-      s->write = s->window;
-
-    /* compute bytes to copy */
-    n = (uInt)(s->write - q);
-    if (n > z->avail_out) n = z->avail_out;
-    if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-    /* update counters */
-    z->avail_out -= n;
-    z->total_out += n;
-
-    /* update check information */
-    if (s->checkfn != Z_NULL)
-      z->adler = s->check = (*s->checkfn)(s->check, q, n);
-
-    /* copy */
-    zmemcpy(p, q, n);
-    p += n;
-    q += n;
-  }
-
-  /* update pointers */
-  z->next_out = p;
-  s->read = q;
-
-  /* done */
-  return r;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/infutil.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,128 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * infutil.h -- types and macros common to blocks and codes
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _INFUTIL_H
-#define _INFUTIL_H
-
-typedef enum {
-      TYPE,     /* get type bits (3, including end bit) */
-      LENS,     /* get lengths for stored */
-      STORED,   /* processing stored block */
-      TABLE,    /* get table lengths */
-      BTREE,    /* get bit lengths tree for a dynamic block */
-      DTREE,    /* get length, distance trees for a dynamic block */
-      CODES,    /* processing fixed or dynamic block */
-      DRY,      /* output remaining window bytes */
-      DONE,     /* finished last block, done */
-      BAD}      /* got a data error--stuck here */
-inflate_block_mode;
-
-/* inflate blocks semi-private state */
-struct inflate_blocks_state {
-
-  /* mode */
-  inflate_block_mode  mode;     /* current inflate_block mode */
-
-  /* mode dependent information */
-  union {
-    uInt left;          /* if STORED, bytes left to copy */
-    struct {
-      uInt table;               /* table lengths (14 bits) */
-      uInt index;               /* index into blens (or border) */
-      uIntf *blens;             /* bit lengths of codes */
-      uInt bb;                  /* bit length tree depth */
-      inflate_huft *tb;         /* bit length decoding tree */
-    } trees;            /* if DTREE, decoding info for trees */
-    struct {
-      inflate_codes_statef
-         *codes;
-    } decode;           /* if CODES, current state */
-  } sub;                /* submode */
-  uInt last;            /* true if this block is the last block */
-
-  /* mode independent information */
-  uInt bitk;            /* bits in bit buffer */
-  uLong bitb;           /* bit buffer */
-  inflate_huft *hufts;  /* single malloc for tree space */
-  Bytef *window;        /* sliding window */
-  Bytef *end;           /* one byte after sliding window */
-  Bytef *read;          /* window read pointer */
-  Bytef *write;         /* window write pointer */
-  check_func checkfn;   /* check function */
-  uLong check;          /* check on output */
-
-};
-
-
-/* defines for inflate input/output */
-/*   update pointers and return */
-#define UPDBITS {s->bitb=b;s->bitk=k;}
-#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
-#define UPDOUT {s->write=q;}
-#define UPDATE {UPDBITS UPDIN UPDOUT}
-#define LEAVE {UPDATE return inflate_flush(s,z,r);}
-/*   get bytes and bits */
-#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
-#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
-#define NEXTBYTE (n--,*p++)
-#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define DUMPBITS(j) {b>>=(j);k-=(j);}
-/*   output bytes */
-#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
-#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
-#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
-#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
-#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
-#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
-/*   load local pointers */
-#define LOAD {LOADIN LOADOUT}
-
-/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
-extern uInt inflate_mask[17];
-
-/* copy as much as possible from the sliding window to the output area */
-extern int inflate_flush OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
-
-struct internal_state      {int dummy;}; /* for buggy compilers */
-
-#endif
--- a/src/share/native/java/util/zip/zlib-1.1.3/minigzip.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,348 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * minigzip.c -- simulate gzip using the zlib compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * minigzip is a minimal implementation of the gzip utility. This is
- * only an example of using zlib and isn't meant to replace the
- * full-featured gzip. No attempt is made to deal with file systems
- * limiting names to 14 or 8+3 characters, etc... Error checking is
- * very limited. So use minigzip only for testing; use gzip for the
- * real thing. On MSDOS, use only on file names without extension
- * or in pipe mode.
- */
-
-#include <stdio.h>
-#include "zlib.h"
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#else
-   extern void exit  OF((int));
-#endif
-
-#ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
-#endif
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
-#endif
-#ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
-#endif
-#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
-#endif
-
-#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
-#endif
-
-#ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
-#endif
-#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
-
-#define BUFLEN      16384
-#define MAX_NAME_LEN 1024
-
-#ifdef MAXSEG_64K
-#  define local static
-   /* Needed for systems with limitation on stack size. */
-#else
-#  define local
-#endif
-
-char *prog;
-
-void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
-#ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
-#endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
-void file_compress    OF((char  *file, char *mode));
-void file_uncompress  OF((char  *file));
-int  main             OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Display error message and exit
- */
-void error(msg)
-    const char *msg;
-{
-    fprintf(stderr, "%s: %s\n", prog, msg);
-    exit(1);
-}
-
-/* ===========================================================================
- * Compress input to output then close both files.
- */
-
-void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-#ifdef USE_MMAP
-    /* Try first compressing with mmap. If mmap fails (minigzip used in a
-     * pipe), use the normal fread loop.
-     */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
-#endif
-    for (;;) {
-        len = fread(buf, 1, sizeof(buf), in);
-        if (ferror(in)) {
-            perror("fread");
-            exit(1);
-        }
-        if (len == 0) break;
-
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
-    }
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-}
-
-#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
-
-/* Try compressing the input file at once using mmap. Return Z_OK if
- * if success, Z_ERRNO otherwise.
- */
-int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    int len;
-    int err;
-    int ifd = fileno(in);
-    caddr_t buf;    /* mmap'ed buffer for the entire input file */
-    off_t buf_len;  /* length of the input file */
-    struct stat sb;
-
-    /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
-    buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
-
-    /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
-
-    /* Compress the whole file at once: */
-    len = gzwrite(out, (char *)buf, (unsigned)buf_len);
-
-    if (len != (int)buf_len) error(gzerror(out, &err));
-
-    munmap(buf, buf_len);
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-    return Z_OK;
-}
-#endif /* USE_MMAP */
-
-/* ===========================================================================
- * Uncompress input to output then close both files.
- */
-void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-    for (;;) {
-        len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
-
-        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
-            error("failed fwrite");
-        }
-    }
-    if (fclose(out)) error("failed fclose");
-
-    if (gzclose(in) != Z_OK) error("failed gzclose");
-}
-
-
-/* ===========================================================================
- * Compress the given file: create a corresponding .gz file and remove the
- * original.
- */
-void file_compress(file, mode)
-    char  *file;
-    char  *mode;
-{
-    local char outfile[MAX_NAME_LEN];
-    FILE  *in;
-    gzFile out;
-
-    strcpy(outfile, file);
-    strcat(outfile, GZ_SUFFIX);
-
-    in = fopen(file, "rb");
-    if (in == NULL) {
-        perror(file);
-        exit(1);
-    }
-    out = gzopen(outfile, mode);
-    if (out == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
-        exit(1);
-    }
-    gz_compress(in, out);
-
-    unlink(file);
-}
-
-
-/* ===========================================================================
- * Uncompress the given file and remove the original.
- */
-void file_uncompress(file)
-    char  *file;
-{
-    local char buf[MAX_NAME_LEN];
-    char *infile, *outfile;
-    FILE  *out;
-    gzFile in;
-    int len = strlen(file);
-
-    strcpy(buf, file);
-
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
-        infile = file;
-        outfile = buf;
-        outfile[len-3] = '\0';
-    } else {
-        outfile = file;
-        infile = buf;
-        strcat(infile, GZ_SUFFIX);
-    }
-    in = gzopen(infile, "rb");
-    if (in == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
-        exit(1);
-    }
-    out = fopen(outfile, "wb");
-    if (out == NULL) {
-        perror(file);
-        exit(1);
-    }
-
-    gz_uncompress(in, out);
-
-    unlink(infile);
-}
-
-
-/* ===========================================================================
- * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]
- *   -d : decompress
- *   -f : compress with Z_FILTERED
- *   -h : compress with Z_HUFFMAN_ONLY
- *   -1 to -9 : compression level
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    int uncompr = 0;
-    gzFile file;
-    char outmode[20];
-
-    strcpy(outmode, "wb6 ");
-
-    prog = argv[0];
-    argc--, argv++;
-
-    while (argc > 0) {
-      if (strcmp(*argv, "-d") == 0)
-        uncompr = 1;
-      else if (strcmp(*argv, "-f") == 0)
-        outmode[3] = 'f';
-      else if (strcmp(*argv, "-h") == 0)
-        outmode[3] = 'h';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-               (*argv)[2] == 0)
-        outmode[2] = (*argv)[1];
-      else
-        break;
-      argc--, argv++;
-    }
-    if (argc == 0) {
-        SET_BINARY_MODE(stdin);
-        SET_BINARY_MODE(stdout);
-        if (uncompr) {
-            file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
-            gz_uncompress(file, stdout);
-        } else {
-            file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
-            gz_compress(stdin, file);
-        }
-    } else {
-        do {
-            if (uncompr) {
-                file_uncompress(*argv);
-            } else {
-                file_compress(*argv, outmode);
-            }
-        } while (argv++, --argc);
-    }
-    exit(0);
-    return 0; /* to avoid warning */
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/trees.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1242 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-1998 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* #define GEN_TREES_H */
-
-#include "deflate.h"
-
-#ifdef DEBUG
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-#define Buf_size (8 * 2*sizeof(char))
-/* Number of bits used within bi_buf. (bi_buf might be implemented on
- * more than 16 bits on some systems.)
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local void set_data_type  OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
-                              int header));
-
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-
-#ifndef DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (value << s->bi_valid);
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !DEBUG */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = value;\
-    s->bi_buf |= (val << s->bi_valid);\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* DEBUG */
-
-
-#define MAX(a,b) (a >= b ? a : b)
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-#ifdef DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Trace((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if (tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void _tr_stored_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
-#ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-#endif
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
-}
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- * The current inflate code requires 9 bits of lookahead. If the
- * last two codes for the previous block (real code plus EOB) were coded
- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
- * the last real code. In this case we send two empty static blocks instead
- * of one. (There are no problems if the previous block is stored or fixed.)
- * To simplify the code, we assume the worst case of last real code encoded
- * on one bit only.
- */
-void _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-    /* Of the 10 bits for the empty block, we have already sent
-     * (10 - bi_valid) bits. The lookahead for the last real code (before
-     * the EOB of the previous block) was thus at least one plus the length
-     * of the EOB plus what we have just sent of the empty static block.
-     */
-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
-        send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-        s->compressed_len += 10L;
-#endif
-        bi_flush(s);
-    }
-    s->last_eob_len = 7;
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and output the encoded block to the zip file.
- */
-void _tr_flush_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-         /* Check if the file is ascii or binary */
-        if (s->data_type == Z_UNKNOWN) set_data_type(s);
-
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-
-        /* Determine the best encoding. Compute first the block length in bytes*/
-        opt_lenb = (s->opt_len+3+7)>>3;
-        static_lenb = (s->static_len+3+7)>>3;
-
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->last_lit));
-
-        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, eof);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1)+eof, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-
-    if (eof) {
-        bi_windup(s);
-#ifdef DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*eof));
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-#ifdef TRUNCATE_BLOCK
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-#endif
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-    s->last_eob_len = ltree[END_BLOCK].Len;
-}
-
-/* ===========================================================================
- * Set the data type to ASCII or BINARY, using a crude approximation:
- * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
- * IN assertion: the fields freq of dyn_ltree are set and the total of all
- * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
- */
-local void set_data_type(s)
-    deflate_state *s;
-{
-    int n = 0;
-    unsigned ascii_freq = 0;
-    unsigned bin_freq = 0;
-    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
-    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
-    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
-    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
-
-/* ===========================================================================
- * Copy a stored block, storing first the length and its
- * one's complement if requested.
- */
-local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
-{
-    bi_windup(s);        /* align on byte boundary */
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-
-    if (header) {
-        put_short(s, (ush)len);
-        put_short(s, (ush)~len);
-#ifdef DEBUG
-        s->bits_sent += 2*16;
-#endif
-    }
-#ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
-#endif
-    while (len--) {
-        put_byte(s, *buf++);
-    }
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/trees.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,151 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
--- a/src/share/native/java/util/zip/zlib-1.1.3/uncompr.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,86 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zlib.h"
-
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-
-    err = inflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        inflateEnd(&stream);
-        return err == Z_OK ? Z_BUF_ERROR : err;
-    }
-    *destLen = stream.total_out;
-
-    err = inflateEnd(&stream);
-    return err;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/zadler32.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,78 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zlib.h"
-
-#define BASE 65521L /* largest prime smaller than 65536 */
-#define NMAX 5552
-/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
-
-#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
-{
-    unsigned long s1 = adler & 0xffff;
-    unsigned long s2 = (adler >> 16) & 0xffff;
-    int k;
-
-    if (buf == Z_NULL) return 1L;
-
-    while (len > 0) {
-        k = len < NMAX ? len : NMAX;
-        len -= k;
-        while (k >= 16) {
-            DO16(buf);
-            buf += 16;
-            k -= 16;
-        }
-        if (k != 0) do {
-            s1 += *buf++;
-            s2 += s1;
-        } while (--k);
-        s1 %= BASE;
-        s2 %= BASE;
-    }
-    return (s2 << 16) | s1;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/zconf.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,316 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifndef _ZCONF_H
-#define _ZCONF_H
-
-/* for _LP64 */
-#include <sys/types.h>
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- */
-#ifdef Z_PREFIX
-#  define deflateInit_  z_deflateInit_
-#  define deflate       z_deflate
-#  define deflateEnd    z_deflateEnd
-#  define inflateInit_  z_inflateInit_
-#  define inflate       z_inflate
-#  define inflateEnd    z_inflateEnd
-#  define deflateInit2_ z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy   z_deflateCopy
-#  define deflateReset  z_deflateReset
-#  define deflateParams z_deflateParams
-#  define inflateInit2_ z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync   z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset  z_inflateReset
-#  define compress      z_compress
-#  define compress2     z_compress2
-#  define uncompress    z_uncompress
-#  define adler32       z_adler32
-#  define crc32         z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte          z_Byte
-#  define uInt          z_uInt
-#  define uLong         z_uLong
-#  define Bytef         z_Bytef
-#  define charf         z_charf
-#  define intf          z_intf
-#  define uIntf         z_uIntf
-#  define uLongf        z_uLongf
-#  define voidpf        z_voidpf
-#  define voidp         z_voidp
-#endif
-
-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
-#  define WIN32
-#endif
-#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
-#  ifndef __32BIT__
-#    define __32BIT__
-#  endif
-#endif
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#if defined(MSDOS) && !defined(__32BIT__)
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
-#  define STDC
-#endif
-#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
-#  ifndef STDC
-#    define STDC
-#  endif
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Old Borland C incorrectly complains about missing returns: */
-#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
-#  define NEED_DUMMY_RETURN
-#endif
-
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
-   /* MSC small or medium model */
-#  define SMALL_MEDIUM
-#  ifdef _MSC_VER
-#    define FAR _far
-#  else
-#    define FAR far
-#  endif
-#endif
-#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
-#  ifndef __32BIT__
-#    define SMALL_MEDIUM
-#    define FAR _far
-#  endif
-#endif
-
-/* Compile with -DZLIB_DLL for Windows DLL support */
-#if defined(ZLIB_DLL)
-#  if defined(_WINDOWS) || defined(WINDOWS)
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-#    define ZEXPORT  WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA  WINAPIV
-#    else
-#      define ZEXPORTVA  FAR _cdecl _export
-#    endif
-#  endif
-#  if defined (__BORLANDC__)
-#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
-#      include <windows.h>
-#      define ZEXPORT __declspec(dllexport) WINAPI
-#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
-#    else
-#      if defined (_Windows) && defined (__DLL__)
-#        define ZEXPORT _export
-#        define ZEXPORTVA _export
-#      endif
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  if defined (ZLIB_DLL)
-#    define ZEXTERN extern __declspec(dllexport)
-#  else
-#    define ZEXTERN extern __declspec(dllimport)
-#  endif
-#endif
-
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-
-#ifndef FAR
-#   define FAR
-#endif
-
-#if !defined(MACOS) && !defined(TARGET_OS_MAC)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-#ifdef _LP64
-typedef unsigned int  uLong; /* 32 bits or more */
-#else
-typedef unsigned long  uLong; /* 32 bits or more */
-#endif
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void FAR *voidpf;
-   typedef void     *voidp;
-#else
-   typedef Byte FAR *voidpf;
-   typedef Byte     *voidp;
-#endif
-
-#ifdef HAVE_UNISTD_H
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  define z_off_t  off_t
-#endif
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define  z_off_t long
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(inflate_blocks,"INBL")
-#   pragma map(inflate_blocks_new,"INBLNE")
-#   pragma map(inflate_blocks_free,"INBLFR")
-#   pragma map(inflate_blocks_reset,"INBLRE")
-#   pragma map(inflate_codes_free,"INCOFR")
-#   pragma map(inflate_codes,"INCO")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_flush,"INFLU")
-#   pragma map(inflate_mask,"INMA")
-#   pragma map(inflate_set_dictionary,"INSEDI2")
-#   pragma map(inflate_copyright,"INCOPY")
-#   pragma map(inflate_trees_bits,"INTRBI")
-#   pragma map(inflate_trees_dynamic,"INTRDY")
-#   pragma map(inflate_trees_fixed,"INTRFI")
-#   pragma map(inflate_trees_free,"INTRFR")
-#endif
-
-#endif /* _ZCONF_H */
--- a/src/share/native/java/util/zip/zlib-1.1.3/zcrc32.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,192 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-1998 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zlib.h"
-
-#define local static
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local int crc_table_empty = 1;
-local uLongf crc_table[256];
-local void make_crc_table OF((void));
-
-/*
-  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The table is simply the CRC of all possible eight bit values.  This is all
-  the information needed to generate CRC's on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.
-*/
-local void make_crc_table()
-{
-  uLong c;
-  int n, k;
-  uLong poly;            /* polynomial exclusive-or pattern */
-  /* terms of polynomial defining this crc (except x^32): */
-  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-  /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-  poly = 0UL;
-  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
-    poly |= 1L << (31 - p[n]);
-
-  for (n = 0; n < 256; n++)
-  {
-    c = (uLong)n;
-    for (k = 0; k < 8; k++)
-      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-    crc_table[n] = c;
-  }
-  crc_table_empty = 0;
-}
-#else
-/* ========================================================================
- * Table of CRC-32's of all single-byte values (made by make_crc_table)
- */
-local const uLongf crc_table[256] = {
-  0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-  0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-  0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-  0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-  0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-  0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-  0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-  0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-  0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-  0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-  0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-  0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-  0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-  0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-  0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-  0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-  0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-  0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-  0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-  0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-  0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-  0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-  0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-  0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-  0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-  0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-  0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-  0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-  0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-  0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-  0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-  0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-  0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-  0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-  0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-  0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-  0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-  0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-  0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-  0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-  0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-  0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-  0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-  0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-  0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-  0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-  0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-  0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-  0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-  0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-  0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-  0x2d02ef8dUL
-};
-#endif
-
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const uLongf * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-  if (crc_table_empty) make_crc_table();
-#endif
-  return (const uLongf *)crc_table;
-}
-
-/* ========================================================================= */
-#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
-#define DO2(buf)  DO1(buf); DO1(buf);
-#define DO4(buf)  DO2(buf); DO2(buf);
-#define DO8(buf)  DO4(buf); DO4(buf);
-
-/* ========================================================================= */
-uLong ZEXPORT crc32(crc, buf, len)
-    uLong crc;
-    const Bytef *buf;
-    uInt len;
-{
-    if (buf == Z_NULL) return 0UL;
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-      make_crc_table();
-#endif
-    crc = crc ^ 0xffffffffUL;
-    while (len >= 8)
-    {
-      DO8(buf);
-      len -= 8;
-    }
-    if (len) do {
-      DO1(buf);
-    } while (--len);
-    return crc ^ 0xffffffffUL;
-}
--- a/src/share/native/java/util/zip/zlib-1.1.3/zlib.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,931 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
-  This file is available under and governed by the GNU General Public
-  License version 2 only, as published by the Free Software Foundation.
-  However, the following notice accompanied the original version of this
-  file and, per its terms, should not be removed:
-
-  zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.1.3, July 9th, 1998
-
-  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-/* This distribution of zlib 1.1.3.f-jdk contains changes by Sun Microsystems.
-   The changes, made on or before 23 Apr 2003, are are described in ChangeLog.
-
-   For help or issues with these changes, please contact: tl-dev@sun.com
-*/
-
-#ifndef _ZLIB_H
-#define _ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.1.3.f-jdk"
-
-/*
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms will be added later and will have the same
-  stream interface.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-     The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio.
-
-     The library does not install any signal handler. The decoder checks
-  the consistency of the compressed data, so the library should never
-  crash even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    long long total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    long long total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: ascii or binary */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   opaque value.
-
-   zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-/* Allowed flush values; see deflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative
- * values are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_ASCII    1
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
-   This check is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression. The fields
-   zalloc, zfree and opaque must be initialized before by the caller.
-   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
-   use default allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at
-   all (the input data is simply copied a block at a time).
-   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
-   compression (currently equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).
-   msg is set to null if there is no error message.  deflateInit does not
-   perform any compression: this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce some
-  output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows. deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly. This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).
-    Some output may be provided even if flush is not set.
-
-  Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating avail_in or avail_out accordingly; avail_out
-  should never be zero before the call. The application can consume the
-  compressed output when it wants, for example when the output buffer is full
-  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
-  and with zero avail_out, it must be called again after making room in the
-  output buffer because there might be more output pending.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far. (In particular
-  avail_in is zero after the call if enough output space has been provided
-  before the call.)  Flushing may degrade compression for some compression
-  algorithms and so it should be used only when necessary.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
-  the compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there
-  was enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error. After
-  deflate has returned Z_STREAM_END, the only possible operations on the
-  stream are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step. In this case, avail_out must be at least
-  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update data_type if it can make a good guess about
-  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
-  binary. This field is only for information purposes and does not affect
-  the compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded). In the error case,
-   msg may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression. The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
-   value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller.  msg is set to null if there is no error
-   message. inflateInit does not perform any decompression apart from reading
-   the zlib header if present: this will be done by inflate().  (So next_in and
-   avail_in may be modified, but next_out and avail_out are unchanged.)
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may
-  introduce some output latency (reading input without producing any output)
-  except when forced to flush.
-
-  The detailed semantics are as follows. inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there
-    is no more input data or no more space in the output buffer (see below
-    about the flush parameter).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
-  must be called again after making room in the output buffer because there
-  might be more output pending.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
-  output as possible to the output buffer. The flushing behavior of inflate is
-  not specified for values of the flush parameter other than Z_SYNC_FLUSH
-  and Z_FINISH, but the current implementation actually flushes as much output
-  as possible anyway.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster routine
-  may be used for the single inflate() call.
-
-     If a preset dictionary is needed at this point (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the
-  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise
-  it sets strm->adler to the adler32 checksum of all output produced
-  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
-  an error code as described below. At the end of the stream, inflate()
-  checks that its computed adler32 checksum is equal to that saved by the
-  compressor and returns Z_STREAM_END only if the checksum is correct.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect
-  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
-  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
-  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
-  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
-  case, the application may then call inflateSync to look for a good
-  compression block.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options. The
-   fields next_in, zalloc, zfree and opaque must be initialized before by
-   the caller.
-
-     The method parameter is the compression method. It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library. Larger values of this parameter result in better
-   compression at the expense of memory usage. The default value is 15 if
-   deflateInit is used instead.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state. memLevel=1 uses minimum memory but
-   is slow and reduces compression ratio; memLevel=9 uses maximum memory
-   for optimal speed. The default value is 8. See zconf.h for total memory
-   usage as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm. Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match).  Filtered data consists mostly of small values with a
-   somewhat random distribution. In this case, the compression algorithm is
-   tuned to compress them better. The effect of Z_FILTERED is to force more
-   Huffman coding and less string matching; it is somewhat intermediate
-   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
-   the compression ratio but not the correctness of the compressed output even
-   if it is not set appropriately.
-
-      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
-   method). msg is set to null if there is no error message.  deflateInit2 does
-   not perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output. This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any
-   call of deflate. The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary. Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size in
-   deflate or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front.
-
-     Upon return of this function, strm->adler is set to the Adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor. (The Adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.)
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort). deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter. The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and
-   can consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.
-   The stream will keep the same compression level and any other attributes
-   that may have been set by deflateInit2.
-
-      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different
-   strategy. If the compression level is changed, the input available so far
-   is compressed with the old level (and may be flushed); the new level will
-   take effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to
-   be compressed and flushed. In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
-   if strm->avail_out was zero.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter. The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library. The default value is 15 if inflateInit is used
-   instead. If a compressed stream with a larger window size is given as
-   input, inflate() will return with the error code Z_DATA_ERROR instead of
-   trying to allocate a larger window.
-
-      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
-   memLevel). msg is set to null if there is no error message.  inflateInit2
-   does not perform any decompression apart from reading the zlib header if
-   present: this will be done by inflate(). (So next_in and avail_in may be
-   modified, but next_out and avail_out are unchanged.)
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of inflate
-   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
-   can be determined from the Adler32 value returned by this call of
-   inflate. The compressor and decompressor must use exactly the same
-   dictionary (see deflateSetDictionary).
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler32 value). inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-    Skips invalid compressed data until a full flush point (see above the
-  description of deflate with Z_FULL_FLUSH) can be found, or until all
-  available input is skipped. No output is provided.
-
-    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
-
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the
-   basic stream-oriented functions. To simplify the interface, some
-   default options are assumed (compression level and memory usage,
-   standard memory allocation functions). The source code of these
-   utility functions can easily be modified if you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be at least 0.1% larger than
-   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
-   compressed buffer.
-     This function can be used to compress a whole file at once if the
-   input file is mmap'ed.
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-
-
-typedef voidp gzFile;
-
-ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
-/*
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb") but can also include a compression level
-   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
-   Huffman only compression as in "wb1h". (See the description
-   of deflateInit2 for more information about the strategy parameter.)
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).  */
-
-ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
-/*
-     gzdopen() associates a gzFile with the file descriptor fd.  File
-   descriptors are obtained from calls like open, dup, creat, pipe or
-   fileno (in the file has been previously opened with fopen).
-   The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the
-   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
-   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
-     gzdopen returns NULL if there was insufficient memory to allocate
-   the (de)compression state.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy. See the description
-   of deflateInit2 for the meaning of these parameters.
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.
-   If the input file was not in gzip format, gzread copies the given number
-   of bytes into the buffer.
-     gzread returns the number of uncompressed bytes actually read (0 for
-   end of file, -1 for error). */
-
-ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
-                                   const voidp buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes actually written
-   (0 in case of error).
-*/
-
-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-      Reads bytes from the compressed file until len-1 characters are read, or
-   a newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  The string is then terminated with a null
-   character.
-      gzgets returns buf, or Z_NULL in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
-/*
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
-/*
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function. The return value is the zlib
-   error number (see function gzerror below). gzflush returns Z_OK if
-   the flush parameter is Z_FINISH and all output could be flushed.
-     gzflush should be called only when strictly necessary because it can
-   degrade compression.
-*/
-
-ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
-                                      z_off_t offset, int whence));
-/*
-      Sets the starting position for the next gzread or gzwrite on the
-   given compressed file. The offset represents a number of bytes in the
-   uncompressed data stream. The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow. If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-      gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-/*
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-
-   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state. The return value is the zlib
-   error number (see function gzerror below).
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
-*/
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the
-   compression library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running crc with the bytes buf[0..len-1] and return the updated
-   crc. If buf is NULL, this function returns the required initial value
-   for the crc. Pre- and post-conditioning (one's complement) is performed
-   within this function so it shouldn't be done by the application.
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-
-
-#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
-#endif
-
-ZEXTERN const char   * ZEXPORT zError           OF((int err));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _ZLIB_H */
--- a/src/share/native/java/util/zip/zlib-1.1.3/zutil.c	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,253 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-
-struct internal_state      {int dummy;}; /* for buggy compilers */
-
-#ifndef STDC
-extern void exit OF((int));
-#endif
-
-const char *z_errmsg[10] = {
-"need dictionary",     /* Z_NEED_DICT       2  */
-"stream end",          /* Z_STREAM_END      1  */
-"",                    /* Z_OK              0  */
-"file error",          /* Z_ERRNO         (-1) */
-"stream error",        /* Z_STREAM_ERROR  (-2) */
-"data error",          /* Z_DATA_ERROR    (-3) */
-"insufficient memory", /* Z_MEM_ERROR     (-4) */
-"buffer error",        /* Z_BUF_ERROR     (-5) */
-"incompatible version",/* Z_VERSION_ERROR (-6) */
-""};
-
-
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-
-#ifdef DEBUG
-
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int z_verbose = verbose;
-
-void z_error (m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-
-
-#ifndef HAVE_MEMCPY
-
-void zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-
-int zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-
-void zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-
-#ifdef __TURBOC__
-#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
-/* Small and medium model in Turbo C are for now limited to near allocation
- * with reduced MAX_WBITS and MAX_MEM_LEVEL
- */
-#  define MY_ZCALLOC
-
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-
-#define MAX_PTR 10
-/* 10*64K = 640K */
-
-local int next_ptr = 0;
-
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf = opaque; /* just to make some compilers happy */
-    ulg bsize = (ulg)items*size;
-
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-
-void  zcfree (voidpf opaque, voidpf ptr)
-{
-    int n;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    ptr = opaque; /* just to make some compilers happy */
-    Assert(0, "zcfree: ptr not found");
-}
-#endif
-#endif /* __TURBOC__ */
-
-
-#if defined(M_I86) && !defined(__32BIT__)
-/* Microsoft C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    return _halloc((long)items, size);
-}
-
-void  zcfree (voidpf opaque, voidpf ptr)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    _hfree(ptr);
-}
-
-#endif /* MSC */
-
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-#ifndef STDC
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-voidpf zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    if (opaque) items += size - size; /* make compiler happy */
-    return (voidpf)calloc(items, size);
-}
-
-void  zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    free(ptr);
-    if (opaque) return; /* make compiler happy */
-}
-
-#endif /* MY_ZCALLOC */
--- a/src/share/native/java/util/zip/zlib-1.1.3/zutil.h	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,257 +0,0 @@
-/*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- * THIS FILE WAS MODIFIED BY SUN MICROSYSTEMS, INC.
- */
-
-/*
- * This file is available under and governed by the GNU General Public
- * License version 2 only, as published by the Free Software Foundation.
- * However, the following notice accompanied the original version of this
- * file and, per its terms, should not be removed:
- *
- * zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-1998 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-#ifndef _Z_UTIL_H
-#define _Z_UTIL_H
-
-#include "zlib.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-#ifdef NEVER
-#ifndef _LP64
-typedef unsigned long  ulg;
-#else
-typedef unsigned int  ulg;
-#endif
-#endif
-
-extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = (char*)ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#ifdef MSDOS
-#  define OS_CODE  0x00
-#  if defined(__TURBOC__) || defined(__BORLANDC__)
-#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-       /* Allow compilation with ANSI keywords only enabled */
-       void _Cdecl farfree( void *block );
-       void *_Cdecl farmalloc( unsigned long nbytes );
-#    else
-#     include <alloc.h>
-#    endif
-#  else /* MSC or DJGPP */
-#    include <malloc.h>
-#  endif
-#endif
-
-#ifdef OS2
-#  define OS_CODE  0x06
-#endif
-
-#ifdef WIN32 /* Window 95 & Windows NT */
-#  define OS_CODE  0x0b
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  0x02
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  0x01
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  0x05
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  0x07
-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#    include <unix.h> /* for fdopen */
-#  else
-#    ifndef fdopen
-#      define fdopen(fd,mode) NULL /* No fdopen() */
-#    endif
-#  endif
-#endif
-
-#ifdef __50SERIES /* Prime/PRIMOS */
-#  define OS_CODE  0x0F
-#endif
-
-#ifdef TOPS20
-#  define OS_CODE  0x0a
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600))
-#  define fdopen(fd,type)  _fdopen(fd,type)
-#endif
-
-
-        /* Common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  0x03  /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#ifdef HAVE_STRERROR
-   extern char *strerror OF((int));
-#  define zstrerror(errnum) strerror(errnum)
-#else
-#  define zstrerror(errnum) ""
-#endif
-
-#if defined(pyr)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
-   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
-   extern void zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef DEBUG
-#  include <stdio.h>
-   extern int z_verbose;
-   extern void z_error    OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-
-typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
-                                       uInt len));
-voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
-void   zcfree  OF((voidpf opaque, voidpf ptr));
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-#endif /* _Z_UTIL_H */
--- a/test/java/util/concurrent/LinkedBlockingQueue/LastElement.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,105 +0,0 @@
-/*
- * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * @test
- * @bug 6215625
- * @summary Check correct behavior when last element is removed.
- * @author Martin Buchholz
- */
-
-import java.util.*;
-import java.util.concurrent.*;
-
-public class LastElement {
-    static volatile int passed = 0, failed = 0;
-
-    static void fail(String msg) {
-        failed++;
-        new Exception(msg).printStackTrace();
-    }
-
-    static void pass() {
-        passed++;
-    }
-
-    static void unexpected(Throwable t) {
-        failed++;
-        t.printStackTrace();
-    }
-
-    static void check(boolean condition, String msg) {
-        if (condition)
-            passed++;
-        else
-            fail(msg);
-    }
-
-    static void check(boolean condition) {
-        check(condition, "Assertion failure");
-    }
-
-    public static void main(String[] args) throws Throwable {
-        testQueue(new LinkedBlockingQueue<Integer>());
-        // Uncomment when LinkedBlockingDeque is integrated
-        //testQueue(new LinkedBlockingDeque<Integer>());
-        testQueue(new ArrayBlockingQueue<Integer>(10));
-
-        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
-        if (failed > 0) throw new Exception("Some tests failed");
-    }
-
-    private static void testQueue(BlockingQueue<Integer> q) throws Throwable {
-        Integer one = 1;
-        Integer two = 2;
-        Integer three = 3;
-
-        // remove(Object)
-        q.put(one);
-        q.put(two);
-        check(! q.isEmpty() && q.size() == 2);
-        check(q.remove(one));
-        check(q.remove(two));
-        check(q.isEmpty() && q.size() == 0);
-        q.put(three);
-        try {check(q.take() == three);}
-        catch (Throwable t) {unexpected(t);}
-        check(q.isEmpty() && q.size() == 0);
-
-        // iterator().remove()
-        q.clear();
-        q.put(one);
-        check(q.offer(two));
-        check(! q.isEmpty() && q.size() == 2);
-        Iterator<Integer> i = q.iterator();
-        check(i.next() == one);
-        i.remove();
-        check(i.next() == two);
-        i.remove();
-        check(q.isEmpty() && q.size() == 0);
-        q.put(three);
-        try {check(q.take() == three);}
-        catch (Throwable t) {unexpected(t);}
-        check(q.isEmpty() && q.size() == 0);
-    }
-}
--- a/test/java/util/concurrent/LinkedBlockingQueue/OfferRemoveLoops.java	Tue Sep 15 16:15:36 2009 +0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,101 +0,0 @@
-/*
- * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * @test
- * @bug 6316155 6595669
- * @summary Test concurrent offer vs. remove
- * @author Martin Buchholz
- */
-
-import java.util.*;
-import java.util.concurrent.*;
-
-public class OfferRemoveLoops {
-    void test(String[] args) throws Throwable {
-        testQueue(new LinkedBlockingQueue<String>(10));
-        testQueue(new LinkedBlockingQueue<String>());
-        testQueue(new LinkedBlockingDeque<String>(10));
-        testQueue(new LinkedBlockingDeque<String>());
-        testQueue(new ArrayBlockingQueue<String>(10));
-        testQueue(new PriorityBlockingQueue<String>(10));
-        testQueue(new ConcurrentLinkedQueue<String>());
-    }
-
-    abstract class CheckedThread extends Thread {
-        abstract protected void realRun();
-        public void run() {
-            try { realRun(); } catch (Throwable t) { unexpected(t); }
-        }
-    }
-
-    void testQueue(final Queue<String> q) throws Throwable {
-        System.out.println(q.getClass().getSimpleName());
-        final int count = 1000 * 1000;
-        final long testDurationSeconds = 1L;
-        final long testDurationMillis = testDurationSeconds * 1000L;
-        final long quittingTimeNanos
-            = System.nanoTime() + testDurationSeconds * 1000L * 1000L * 1000L;
-        Thread t1 = new CheckedThread() {
-            protected void realRun() {
-                for (int i = 0; i < count; i++) {
-                    if ((i % 1024) == 0 &&
-                        System.nanoTime() - quittingTimeNanos > 0)
-                        return;
-                    while (! q.remove(String.valueOf(i)))
-                        Thread.yield();
-                }}};
-        Thread t2 = new CheckedThread() {
-            protected void realRun() {
-                for (int i = 0; i < count; i++) {
-                    if ((i % 1024) == 0 &&
-                        System.nanoTime() - quittingTimeNanos > 0)
-                        return;
-                    while (! q.offer(String.valueOf(i)))
-                        Thread.yield();
-                    }}};
-        t1.setDaemon(true); t2.setDaemon(true);
-        t1.start(); t2.start();
-        t1.join(10 * testDurationMillis);
-        t2.join(10 * testDurationMillis);
-        check(! t1.isAlive());
-        check(! t2.isAlive());
-    }
-
-    //--------------------- Infrastructure ---------------------------
-    volatile int passed = 0, failed = 0;
-    void pass() {passed++;}
-    void fail() {failed++; Thread.dumpStack();}
-    void fail(String msg) {System.err.println(msg); fail();}
-    void unexpected(Throwable t) {failed++; t.printStackTrace();}
-    void check(boolean cond) {if (cond) pass(); else fail();}
-    void equal(Object x, Object y) {
-        if (x == null ? y == null : x.equals(y)) pass();
-        else fail(x + " not equal to " + y);}
-    public static void main(String[] args) throws Throwable {
-        new OfferRemoveLoops().instanceMain(args);}
-    public void instanceMain(String[] args) throws Throwable {
-        try {test(args);} catch (Throwable t) {unexpected(t);}
-        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
-        if (failed > 0) throw new AssertionError("Some tests failed");}
-}


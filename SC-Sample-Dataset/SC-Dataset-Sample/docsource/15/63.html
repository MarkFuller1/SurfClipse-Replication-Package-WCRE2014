<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<HEAD>
<meta name="generator" content="JDiff v1.0.6">
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<meta name="description" content="JDiff is a Javadoc doclet which generates an HTML report of all the packages, classes, constructors, methods, and fields which have been removed, added or changed in any way, including their documentation, when two APIs are compared.">
<meta name="keywords" content="diff, jdiff, javadiff, java diff, java difference, API difference, API diff, Javadoc, doclet">
<LINK REL="stylesheet" TYPE="text/css" HREF="../stylesheet-jdiff.css" TITLE="Style">
<TITLE>
java.io Documentation Differences
</TITLE>
</HEAD>
<BODY>
<!-- Start of nav bar -->
<TABLE summary="Navigation bar" BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
  <TABLE summary="Navigation bar" BORDER="0" CELLPADDING="0" CELLSPACING="3">
    <TR ALIGN="center" VALIGN="top">
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/io/package-summary.html" target="_top"><FONT CLASS="NavBarFont1"><B><tt>J2SE1.3</tt></B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="changes-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
      <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="docdiffs_index.html"><FONT CLASS="NavBarFont1"><B>Text Changes</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_statistics.html"><FONT CLASS="NavBarFont1"><B>Statistics</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_help.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
    </TR>
  </TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM><b>Generated by<br><a href="http://www.jdiff.org" class="staysblack" target="_top">JDiff</a></b></EM></TD>
</TR>
<TR>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="docdiffs_java.beans.beancontext.html"><B>PREV PACKAGE</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_java.lang.html"><B>NEXT PACKAGE</B></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <A HREF="../changes.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_java.io.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2">&nbsp;</TD>
</TR>
</TABLE>
<HR>
<!-- End of nav bar -->
<h2>
java.io Documentation Differences
</h2>

<blockquote>
This file contains all the changes in documentation in the package <code>java.io</code> as colored differences.
Deletions are shown <strike>like this</strike>, and
additions are shown <span style="background: #FFFF00">like this</span>.
</blockquote>
<blockquote>
If no deletions or additions are shown in an entry, the HTML tags will be what has changed. The <i>new</i> HTML tags are shown in the differences. 
If no documentation existed, and then some was added in a later version, this change is noted in the appropriate class pages of differences, but the change is not shown on this page. Only changes in existing text are shown here. 
Similarly, documentation which was inherited from another class or interface is not shown here.
</blockquote>
<blockquote>
 Note that an HTML error in the new documentation may cause the display of other documentation changes to be presented incorrectly. For instance, failure to close a &lt;code&gt; tag will cause all subsequent paragraphs to be displayed differently.
</blockquote>
<hr>

<A NAME="java.io.BufferedInputStream!class"></A><a href="java.io.BufferedInputStream.html" class="hiddenlink">Class <b>BufferedInputStream</b></a><br><br><blockquote>A <code>BufferedInputStream</code> adds functionality to another input stream-namely the ability to buffer the input and to support the <code>mark</code> and <code>reset</code> methods. When the <code>BufferedInputStream</code> is created an internal buffer array is created. As bytes from the stream are read or skipped the internal buffer is refilled as necessary from the contained input stream many bytes at a time. The <code>mark</code> operation remembers a point in the input stream and the <code>reset</code> operation causes all the bytes read since the most recent <code>mark</code> operation to be reread before new bytes are taken from the contained input stream. @author Arthur van Hoff @version 1.<strike>36 08</strike><span style="background: #FFFF00">41 02</span>/<strike>18</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.BufferedOutputStream!class"></A><a href="java.io.BufferedOutputStream.html" class="hiddenlink">Class <b>BufferedOutputStream</b></a><br><br><blockquote>The class implements a buffered output stream. By setting up such an output stream an application can write bytes to the underlying output stream without necessarily causing a call to the underlying system for each byte written. The data is written into an internal buffer and then written to the underlying stream if the buffer reaches its capacity the buffer output stream is closed or the buffer output stream is explicitly flushed. @author Arthur van Hoff @version 1.<strike>25 04</strike><span style="background: #FFFF00">27 02</span>/<strike>30</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.BufferedReader!class"></A><a href="java.io.BufferedReader.html" class="hiddenlink">Class <b>BufferedReader</b></a><br><br><blockquote>Read text from a character-input stream buffering characters so as to provide for the efficient reading of characters arrays and lines. <p> The buffer size may be specified or the default size may be used. The default is large enough for most purposes. <p> In general each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly such as FileReaders and InputStreamReaders. For example <pre> BufferedReader in = new BufferedReader(new FileReader("foo.in")); </pre> will buffer the input from the specified file. Without buffering each invocation of read() or readLine() could cause bytes to be read from the file converted into characters and then returned which can be very inefficient. <p> Programs that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader. @see FileReader @see InputStreamReader @version 1.<strike>19 98</strike><span style="background: #FFFF00">25 00</span>/<strike>08</strike><span style="background: #FFFF00">02</span>/<strike>18</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.BufferedReader.dmethod.skip(long)"></A><a href="java.io.BufferedReader.html" class="hiddenlink">Class <b>BufferedReader</b></a>, <a href="java.io.BufferedReader.html#java.io.BufferedReader.skip_changed(long)" class="hiddenlink">long <b>skip(long)</b></a><br><br><blockquote>Skip characters. @param n The number of characters to skip @return The number of characters actually skipped @exception <span style="background: #FFFF00">IllegalArgumentException If <code>n</code> is negative. @exception </span>IOException If an I/O error occurs</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.BufferedWriter!class"></A><a href="java.io.BufferedWriter.html" class="hiddenlink">Class <b>BufferedWriter</b></a><br><br><blockquote>Write text to a character-output stream buffering characters so as to provide for the efficient writing of single characters arrays and strings. <p> The buffer size may be specified or the default size may be accepted. The default is large enough for most purposes. <p> A newLine() method is provided which uses the platform's own notion of line separator as defined by the system property <tt>line.separator</tt>. Not all platforms use the newline character ('\n') to terminate lines. Calling this method to terminate each output line is therefore preferred to writing a newline character directly. <p> In general a Writer sends its output immediately to the underlying character or byte stream. Unless prompt output is required it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly such as FileWriters and OutputStreamWriters. For example <pre> PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out"))); </pre> will buffer the PrintWriter's output to the file. Without buffering each invocation of a print() method would cause characters to be converted into bytes that would then be written immediately to the file which can be very inefficient. @see PrintWriter @see FileWriter @see OutputStreamWriter @version 1.<strike>20 98</strike><span style="background: #FFFF00">22 00</span>/<strike>08</strike><span style="background: #FFFF00">02</span>/<strike>03</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ByteArrayInputStream!class"></A><a href="java.io.ByteArrayInputStream.html" class="hiddenlink">Class <b>ByteArrayInputStream</b></a><br><br><blockquote>A <code>ByteArrayInputStream</code> contains an internal buffer that contains bytes that may be read from the stream. An internal counter keeps track of the next byte to be supplied by the <code>read</code> method. @author Arthur van Hoff @version 1.<strike>32 09</strike><span style="background: #FFFF00">35 02</span>/<strike>30</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.StringBufferInputStream @since JDK1.0</blockquote>
<A NAME="java.io.ByteArrayInputStream.dmethod.reset()"></A><a href="java.io.ByteArrayInputStream.html" class="hiddenlink">Class <b>ByteArrayInputStream</b></a>, <a href="java.io.ByteArrayInputStream.html#java.io.ByteArrayInputStream.reset_changed()" class="hiddenlink">void <b>reset()</b></a><br><br><blockquote>Resets the buffer to the marked position. The marked position is the beginning unless another position was marked. The value of <code>pos</code> is set to 0.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ByteArrayOutputStream!class"></A><a href="java.io.ByteArrayOutputStream.html" class="hiddenlink">Class <b>ByteArrayOutputStream</b></a><br><br><blockquote>This class implements an output stream in which the data is written into a byte array. The buffer automatically grows as data is written to it. The data can be retrieved using <code>toByteArray()</code> and <code>toString()</code>. @author Arthur van Hoff @version 1.<strike>27 10</strike><span style="background: #FFFF00">43 02</span>/<strike>20</strike><span style="background: #FFFF00">02</span>/<strike>97</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<A NAME="java.io.ByteArrayOutputStream.dmethod.toString()"></A><a href="java.io.ByteArrayOutputStream.html" class="hiddenlink">Class <b>ByteArrayOutputStream</b></a>, <a href="java.io.ByteArrayOutputStream.html#java.io.ByteArrayOutputStream.toString_changed()" class="hiddenlink">String <b>toString()</b></a><br><br><blockquote>Converts the buffer's contents into a string translating bytes into characters according to the platform's default character encoding.<span style="background: #FFFF00"> @return String translated from the buffer's contents. @since JDK1.1</span></blockquote>
<A NAME="java.io.ByteArrayOutputStream.dmethod.toString(String)"></A><a href="java.io.ByteArrayOutputStream.html" class="hiddenlink">Class <b>ByteArrayOutputStream</b></a>, <a href="java.io.ByteArrayOutputStream.html#java.io.ByteArrayOutputStream.toString_changed(java.lang.String)" class="hiddenlink">String <b>toString(String)</b></a><br><br><blockquote>Converts the buffer's contents into a string translating bytes into characters according to the specified character encoding. @param enc a character-encoding name. @<span style="background: #FFFF00">return String translated from the buffer's contents. @throws UnsupportedEncodingException If the named encoding is not supported. @</span>since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.CharArrayReader!class"></A><a href="java.io.CharArrayReader.html" class="hiddenlink">Class <b>CharArrayReader</b></a><br><br><blockquote>This class implements a character buffer that can be used as a character-input stream. @author Herb Jellinek @version 1.<strike>12 06</strike><span style="background: #FFFF00">15 02</span>/<strike>05</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.CharArrayReader.field.buf"></A><a href="java.io.CharArrayReader.html" class="hiddenlink">Class <b>CharArrayReader</b></a>, <a href="java.io.CharArrayReader.html#java.io.CharArrayReader.buf" class="hiddenlink">char[] <b>buf</b></a><br><br><blockquote><strike>Character</strike><span style="background: #FFFF00">The</span> <span style="background: #FFFF00">character </span>buffer<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.CharArrayReader.field.count"></A><a href="java.io.CharArrayReader.html" class="hiddenlink">Class <b>CharArrayReader</b></a>, <a href="java.io.CharArrayReader.html#java.io.CharArrayReader.count" class="hiddenlink">int <b>count</b></a><br><br><blockquote><strike>Number</strike><span style="background: #FFFF00">The</span> <span style="background: #FFFF00">number </span>of valid characters in <span style="background: #FFFF00">the </span>buffer<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.CharArrayReader.field.markedPos"></A><a href="java.io.CharArrayReader.html" class="hiddenlink">Class <b>CharArrayReader</b></a>, <a href="java.io.CharArrayReader.html#java.io.CharArrayReader.markedPos" class="hiddenlink">int <b>markedPos</b></a><br><br><blockquote><strike>Position</strike><span style="background: #FFFF00">The</span> <span style="background: #FFFF00">position </span>of mark in buffer<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.CharArrayReader.field.pos"></A><a href="java.io.CharArrayReader.html" class="hiddenlink">Class <b>CharArrayReader</b></a>, <a href="java.io.CharArrayReader.html#java.io.CharArrayReader.pos" class="hiddenlink">int <b>pos</b></a><br><br><blockquote><strike>Current</strike><span style="background: #FFFF00">The</span> <span style="background: #FFFF00">current </span>buffer position<span style="background: #FFFF00">.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.CharArrayWriter!class"></A><a href="java.io.CharArrayWriter.html" class="hiddenlink">Class <b>CharArrayWriter</b></a><br><br><blockquote>This class implements a character buffer that can be used as an Writer. The buffer automatically grows when data is written to the stream. The data can be retrieved using toCharArray() and toString(). @author Herb Jellinek @version 1.<strike>11 06</strike><span style="background: #FFFF00">15 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.CharArrayWriter.ctor(int)"></A><a href="java.io.CharArrayWriter.html" class="hiddenlink">Class <b>CharArrayWriter</b></a>, <a href="java.io.CharArrayWriter.html#java.io.CharArrayWriter.ctor_changed(int)" class="hiddenlink">constructor <b>CharArrayWriter(int)</b></a><br><br><blockquote>Creates a new CharArrayWriter with the specified initial size. @<span style="background: #FFFF00">param initialSize an int specifying the initial buffer size. @</span>exception IllegalArgumentException if initialSize is negative</blockquote>
<A NAME="java.io.CharArrayWriter.dmethod.size()"></A><a href="java.io.CharArrayWriter.html" class="hiddenlink">Class <b>CharArrayWriter</b></a>, <a href="java.io.CharArrayWriter.html#java.io.CharArrayWriter.size_changed()" class="hiddenlink">int <b>size()</b></a><br><br><blockquote>Returns the current size of the buffer.<span style="background: #FFFF00"> @return an int representing the current size of the buffer.</span></blockquote>
<A NAME="java.io.CharArrayWriter.dmethod.toCharArray()"></A><a href="java.io.CharArrayWriter.html" class="hiddenlink">Class <b>CharArrayWriter</b></a>, <a href="java.io.CharArrayWriter.html#java.io.CharArrayWriter.toCharArray_changed()" class="hiddenlink">char[] <b>toCharArray()</b></a><br><br><blockquote>Returns a copy of the input data.<span style="background: #FFFF00"> @return an array of chars copied from the input data.</span></blockquote>
<A NAME="java.io.CharArrayWriter.dmethod.writeTo(Writer)"></A><a href="java.io.CharArrayWriter.html" class="hiddenlink">Class <b>CharArrayWriter</b></a>, <a href="java.io.CharArrayWriter.html#java.io.CharArrayWriter.writeTo_changed(java.io.Writer)" class="hiddenlink">void <b>writeTo(Writer)</b></a><br><br><blockquote>Writes the contents of the buffer to another character stream. @param out the output stream to write to<span style="background: #FFFF00"> @throws IOException If an I/O error occurs.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.CharConversionException!class"></A><a href="java.io.CharConversionException.html" class="hiddenlink">Class <b>CharConversionException</b></a><br><br><blockquote><strike>base</strike><span style="background: #FFFF00">Base</span> class for character conversion exceptions<span style="background: #FFFF00">.</span> @author Asmus Freytag @version 1.<strike>8 09</strike><span style="background: #FFFF00">12 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.CharConversionException.ctor()"></A><a href="java.io.CharConversionException.html" class="hiddenlink">Class <b>CharConversionException</b></a>, <a href="java.io.CharConversionException.html#java.io.CharConversionException.ctor_changed()" class="hiddenlink">constructor <b>CharConversionException()</b></a><br><br><blockquote><span style="background: #FFFF00">This </span>provides no detailed message<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.CharConversionException.ctor(String)"></A><a href="java.io.CharConversionException.html" class="hiddenlink">Class <b>CharConversionException</b></a>, <a href="java.io.CharConversionException.html#java.io.CharConversionException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>CharConversionException(String)</b></a><br><br><blockquote><span style="background: #FFFF00">This </span>provides a detailed message<span style="background: #FFFF00">.</span> @param s <span style="background: #FFFF00">the </span>detailed message<span style="background: #FFFF00"> associated with the exception.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.DataInput!class"></A><a href="java.io.DataInput.html" class="hiddenlink">Class <b>DataInput</b></a><br><br><blockquote>The <code>DataInput</code> interface provides for reading bytes from a binary stream and reconstructing from them data in any of the Java primitive types. There is also a facility for reconstructing a <code>String</code> from data in Java modified UTF-8 format. <p> It is generally true of all the reading routines in this interface that if end of file is reached before the desired number of bytes has been read an <code>EOFException</code> (which is a kind of <code>IOException</code>) is thrown. If any byte cannot be read for any reason other than end of file an <code>IOException</code> other than <code>EOFException</code> is thrown. In particular an <code>IOException</code> may be thrown if the input stream has been closed. @author Frank Yellin @version 1.<strike>13 06</strike><span style="background: #FFFF00">16 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInputStream @see java.io.DataOutput @since JDK1.0</blockquote>
<A NAME="java.io.DataInput.dmethod.readFully(byte[], int, int)"></A><a href="java.io.DataInput.html" class="hiddenlink">Class <b>DataInput</b></a>, <a href="java.io.DataInput.html#java.io.DataInput.readFully_changed(byte[], int, int)" class="hiddenlink">void <b>readFully(byte[], int, int)</b></a><br><br><blockquote>Reads <code>len</code> bytes from an input stream. <p> This method blocks until one of the following conditions occurs:<p> <ul> <li><code>len</code> bytes of input data are available in which case a normal return is made. <li>End of file is detected in which case an <code>EOFException</code> is thrown. <li>An I/O error occurs in which case an <code>IOException</code> other than <code>EOFException</code> is thrown. </ul> <p> If <code>b</code> is <code>null</code> a <code>NullPointerException</code> is thrown. If <code>off</code> is negative or <code>len</code> is negative or <code>off+len</code> is greater than the length of the array <code>b</code> then an <code>IndexOutOfBoundsException</code> is thrown. If <code>len</code> is zero then no bytes are read. Otherwise the first byte read is stored into element <code>b[off]</code> the next one into <code>b[off+1]</code> and so on. The number of bytes read is at most equal to <code>len</code>. @param b the buffer into which the data is read. @<span style="background: #FFFF00">param off an int specifying the offset into the data. @param len an int specifying the number of bytes to read. @</span>exception EOFException if this stream reaches the end before reading all the bytes. @exception IOException if an I/O error occurs.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.DataInputStream!class"></A><a href="java.io.DataInputStream.html" class="hiddenlink">Class <b>DataInputStream</b></a><br><br><blockquote>A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. An application uses a data output stream to write data that can later be read by a data input stream. <p> Data input streams and data output streams represent Unicode strings in a format that is a slight modification of UTF-8. (For more information see X/Open Company Ltd. "File System Safe UCS Transformation Format (FSS_UTF)" X/Open Preliminary Specification Document Number: P316. This information also appears in ISO/IEC 10646 Annex P.) <p> All characters in the range <code>'&#92;u0001'</code> to <code>'&#92;u007F'</code> are represented by a single byte: <center><table border="3"> <tr><td><i>0</i></td> <td>bits 0-7</td></tr> </table></center> <p> The null character <code>'&#92;u0000'</code> and characters in the range <code>'&#92;u0080'</code> to <code>'&#92;u07FF'</code> are represented by a pair of bytes: <center><table border="3"> <tr><td>1</td> <td>1</td> <td>0</td> <td>bits 6-10</td></tr> <tr><td>1</td> <td>0</td> <td colspan=2>bits 0-5</td></tr> </table></center><br> Characters in the range <code>'&#92;u0800'</code> to <code>'&#92;uFFFF'</code> are represented by three bytes: <center><table border="3"> <tr><td>1</td> <td>1</td> <td>1</td> <td>0</td> <td>bits 12-15</td</tr> <tr><td>1</td> <td>0</td> <td colspan=3>bits 6-11</td></tr> <tr><td>1</td> <td>0</td> <td colspan=3>bits 0-5</td></tr> </table></center> <p> The two differences between this format and the "standard" UTF-8 format are the following: <ul> <li>The null byte <code>'&#92;u0000'</code> is encoded in 2-byte format rather than 1-byte so that the encoded strings never have embedded nulls. <li>Only the 1-byte 2-byte and 3-byte formats are used. </ul> @author Arthur van Hoff @version 1.<strike>46 06</strike><span style="background: #FFFF00">50 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataOutputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.DataOutput!class"></A><a href="java.io.DataOutput.html" class="hiddenlink">Class <b>DataOutput</b></a><br><br><blockquote>The <code>DataOutput</code> interface provides for converting data from any of the Java primitive types to a series of bytes and writing these bytes to a binary stream. There is also a facility for converting a <code>String</code> into Java modified UTF-8 format and writing the resulting series of bytes. <p> For all the methods in this interface that write bytes it is generally true that if a byte cannot be written for any reason an <code>IOException</code> is thrown. @author Frank Yellin @version 1.<strike>10 06</strike><span style="background: #FFFF00">13 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInput @see java.io.DataOutputStream @since JDK1.0</blockquote>
<A NAME="java.io.DataOutput.dmethod.writeUTF(String)"></A><a href="java.io.DataOutput.html" class="hiddenlink">Class <b>DataOutput</b></a>, <a href="java.io.DataOutput.html#java.io.DataOutput.writeUTF_changed(java.lang.String)" class="hiddenlink">void <b>writeUTF(String)</b></a><br><br><blockquote>Writes two bytes of length information to the output stream followed by the Java modified UTF representation of every character in the string <code>s</code>. If <code>s</code> is <code>null</code> a <code>NullPointerException</code> is thrown. Each character in the string <code>s</code> is converted to a group of one two or three bytes depending on the value of the character.<p> If a character <code>c</code> is in the range <code>&#92;u0001</code> through <code>&#92;u007f</code> it is represented by one byte:<p> <pre>(byte)c </pre> <p> If a character <code>c</code> is <code>&#92;u0000</code> or is in the range <code>&#92;u0080</code> through <code>&#92;u07ff</code> then it is represented by two bytes to be written in the order shown:<p> <pre><code> (byte)(0xc0 | (0x1f &amp; (c &gt;&gt; 6))) (byte)(0x80 | (0x3f &amp; c)) </code></pre> <p> If a character <code>c</code> is in the range <code>&#92;u0800</code> through <code>uffff</code> then it is represented by three bytes to be written in the order shown:<p> <pre><code> (byte)(<strike>0xc0</strike><span style="background: #FFFF00">0xe0</span> | (0x0f &amp; (c &gt;&gt; 12))) (byte)(0x80 | (0x3f &amp; (c &gt;&gt; 6))) (byte)(0x80 | (0x3f &amp; c)) </code></pre> <p> First the total number of bytes needed to represent all the characters of <code>s</code> is calculated. If this number is larger than <code>65535</code> then a <code>UTFDataFormatError</code> is thrown. Otherwise this length is written to the output stream in exactly the manner of the <code>writeShort</code> method; after this the one- two- or three-byte representation of each character in the string <code>s</code> is written.<p> The bytes written by this method may be read by the <code>readUTF</code> method of interface <code>DataInput</code> which will then return a <code>String</code> equal to <code>s</code>. @param str the string value to be written. @exception IOException if an I/O error occurs.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.DataOutputStream!class"></A><a href="java.io.DataOutputStream.html" class="hiddenlink">Class <b>DataOutputStream</b></a><br><br><blockquote>A data input stream lets an application write primitive Java data types to an output stream in a portable way. An application can then use a data input stream to read the data back in. @author unascribed @version 1.<strike>28 04</strike><span style="background: #FFFF00">32 02</span>/<strike>30</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.EOFException!class"></A><a href="java.io.EOFException.html" class="hiddenlink">Class <b>EOFException</b></a><br><br><blockquote>Signals that an end of file or end of stream has been reached unexpectedly during input. <p> This exception is mainly used by data input streams which generally expect a binary file in a specific format and for which an end of stream is an unusual condition. Most other input streams return a special value on end of stream. <p> Note that some input operations react to end-of-file by returning a distinguished value (such as <code>-1</code>) rather than by throwing an exception. @author Frank Yellin @version 1.<strike>7 06</strike><span style="background: #FFFF00">9 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInputStream @see java.io.IOException @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.Externalizable!class"></A><a href="java.io.Externalizable.html" class="hiddenlink">Class <b>Externalizable</b></a><br><br><blockquote>Only the identity of the class of an Externalizable instance is written in the serialization stream and it is the responsibility of the class to save and restore the contents of its instances. The writeExternal and readExternal methods of the Externalizable interface are implemented by a class to give the class complete control over the format and contents of the stream for an object and its supertypes. These methods must explicitly coordinate with the supertype to save its state. These methods supercede customized implementations of writeObject and readObject methods.<br> Object Serialization uses the Serializable and Externalizable interfaces. Object persistence mechanisms can use them as well. Each object to be stored is tested for the Externalizable interface. If the object supports Externalizable the writeExternal method is called. If the object does not support Externalizable and does implement Serializable the object is saved using ObjectOutputStream. <br> When an Externalizable object is reconstructed an instance is created using the public no-arg constructor then the readExternal method called. Serializable objects are restored by reading them from an ObjectInputStream.<br> An Externalizable instance can designate a substitution object via the writeReplace and readResolve methods documented in the Serializable interface.<br> @author unascribed @version 1.<strike>12 06</strike><span style="background: #FFFF00">15 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.ObjectOutputStream @see java.io.ObjectInputStream @see java.io.ObjectOutput @see java.io.ObjectInput @see java.io.Serializable @since JDK1.1</blockquote>
<A NAME="java.io.Externalizable.dmethod.readExternal(ObjectInput)"></A><a href="java.io.Externalizable.html" class="hiddenlink">Class <b>Externalizable</b></a>, <a href="java.io.Externalizable.html#java.io.Externalizable.readExternal_changed(java.io.ObjectInput)" class="hiddenlink">void <b>readExternal(ObjectInput)</b></a><br><br><blockquote>The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects strings and arrays. The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal. @<span style="background: #FFFF00">param in the stream to read data from in order to restore the object @exception IOException if I/O errors occur @</span>exception ClassNotFoundException If the class for an object being restored cannot be found.</blockquote>
<A NAME="java.io.Externalizable.dmethod.writeExternal(ObjectOutput)"></A><a href="java.io.Externalizable.html" class="hiddenlink">Class <b>Externalizable</b></a>, <a href="java.io.Externalizable.html#java.io.Externalizable.writeExternal_changed(java.io.ObjectOutput)" class="hiddenlink">void <b>writeExternal(ObjectOutput)</b></a><br><br><blockquote>The object implements the writeExternal method to save its contents by calling the methods of DataOutput for its primitive values or calling the writeObject method of ObjectOutput for objects strings and arrays. @serialData Overriding methods should use this tag to describe the data layout of this Externalizable object. List the sequence of element types and if possible relate the element to a public/protected field and/or method of this Externalizable class. @<span style="background: #FFFF00">param out the stream to write the object to @</span>exception IOException Includes any I/O exceptions that may occur</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.File!class"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a><br><br><blockquote>An abstract representation of file and directory pathnames. <p> User interfaces and operating systems use system-dependent <em>pathname strings</em> to name files and directories. This class presents an abstract system-independent view of hierarchical pathnames. An <em>abstract pathname</em> has two components: <ol> <li> An optional system-dependent <em>prefix</em> string <br> such as a disk-drive specifier <code>"/"</code> for the UNIX root directory or <code>"\\"</code> for a Win32 UNC pathname and <li> A sequence of zero or more string <em>names</em>. </ol> Each name in an abstract pathname except for the last denotes a directory; the last name may denote either a directory or a file. The <em>empty</em> abstract pathname has no prefix and an empty name sequence. <p> The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string each name is separated from the next by a single copy of the default <em>separator character</em>. The default name-separator character is defined by the system property <code>file.separator</code> and is made available in the public static fields <code>{@link #separator}</code> and <code>{@link #separatorChar}</code> of this class. When a pathname string is converted into an abstract pathname the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system. <p> A pathname whether abstract or in string form may be either <em>absolute</em> or <em>relative</em>. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname in contrast must be interpreted in terms of information taken from some other pathname. By default the classes in the <code>java.io</code> package always resolve relative pathnames against the current user directory. This directory is named by the system property <code>user.dir</code> and is typically the directory in which the Java virtual machine was invoked. <p> The prefix concept is used to handle root directories on UNIX platforms and drive specifiers root directories and UNC pathnames on Win32 platforms as follows: <ul> <li> For UNIX platforms the prefix of an absolute pathname is always <code>"/"</code>. Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix <code>"/"</code> and an empty name sequence. <li> For Win32 platforms the prefix of a pathname that contains a drive specifier consists of the drive letter followed by <code>":"</code> and possibly followed by <code>"\"</code> if the pathname is absolute. The prefix of a UNC pathname is <code>"\\"</code>; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix. </ul> <p> Instances of the <code>File</code> class are immutable; that is once created the abstract pathname represented by a <code>File</code> object will never change. @version 1.<strike>79 98</strike><span style="background: #FFFF00">92 02</span>/<strike>08</strike><span style="background: #FFFF00">02</span>/<strike>18</strike><span style="background: #FFFF00">00</span> @author unascribed @since JDK1.0</blockquote>
<A NAME="java.io.File.dmethod.compareTo(File)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.compareTo_changed(java.io.File)" class="hiddenlink">int <b>compareTo(File)</b></a><br><br><blockquote>Compares two abstract pathnames lexicographically. The ordering defined by this method depends upon the underlying system. On UNIX systems alphabetic case is significant in comparing pathnames; on Win32 systems it is not. @param pathname The abstract pathname to be compared to this abstract pathname @return Zero if the argument is equal to this abstract pathname a value less than zero if this abstract pathname is lexicographically less than the argument or a value greater than zero if this abstract pathname is lexicographically greater than the argument @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.compareTo(Object)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.compareTo_changed(java.lang.Object)" class="hiddenlink">int <b>compareTo(Object)</b></a><br><br><blockquote>Compares this abstract pathname to another object. If the other object is an abstract pathname then this function behaves like <code>{@link #compareTo(File)}</code>. Otherwise it throws a <code>ClassCastException</code> since abstract pathnames can only be compared to abstract pathnames. @param o The <code>Object</code> to be compared to this abstract pathname @return If the argument is an abstract pathname returns zero if the argument is equal to this abstract pathname a value less than zero if this abstract pathname is lexicographically less than the argument or a value greater than zero if this abstract pathname is lexicographically greater than the argument @throws <code>ClassCastException</code> if the argument is not an abstract pathname @see java.lang.Comparable @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.createNewFile()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.createNewFile_changed()" class="hiddenlink">boolean <b>createNewFile()</b></a><br><br><blockquote>Atomically creates a new empty file named by this abstract pathname if and only if a file with this name does not yet exist. The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. This method in combination with the <code>{@link #deleteOnExit}</code> method can therefore serve as the basis for a simple but reliable cooperative file-locking protocol. @return <code>true</code> if the named file does not exist and was successfully created; <code>false</code> if the named file already exists @throws IOException If an I/O error occurred @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method denies write access to the file @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.createTempFile(String, String)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.createTempFile_changed(java.lang.String, java.lang.String)" class="hiddenlink">File <b>createTempFile(String, String)</b></a><br><br><blockquote>Creates an empty file in the default temporary-file directory using the given prefix and suffix to generate its name. Invoking this method is equivalent to invoking <code>{@link #createTempFile(java.lang.String java.lang.String java.io.File) createTempFile(prefix &nbsp;suffix &nbsp;null)}</code>. @param prefix The prefix string to be used in generating the file's name; must be at least three characters long @param suffix The suffix string to be used in generating the file's name; may be <code>null</code> in which case the suffix <code>".tmp"</code> will be used @return An abstract pathname denoting a newly-created empty file @throws IllegalArgumentException If the <code>prefix</code> argument contains fewer than three characters @throws IOException If a file could not be created @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method does not allow a file to be created @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.createTempFile(String, String, File)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.createTempFile_changed(java.lang.String, java.lang.String, java.io.File)" class="hiddenlink">File <b>createTempFile(String, String, File)</b></a><br><br><blockquote><p> Creates a new empty file in the specified directory using the given prefix and suffix strings to generate its name. If this method returns successfully then it is guaranteed that: <ol> <li> The file denoted by the returned abstract pathname did not exist before this method was invoked and <li> Neither this method nor any of its variants will return the same abstract pathname again in the current invocation of the virtual machine. </ol> This method provides only part of a temporary-file facility. To arrange for a file created by this method to be deleted automatically use the <code>{@link #deleteOnExit}</code> method. <p> The <code>prefix</code> argument must be at least three characters long. It is recommended that the prefix be a short meaningful string such as <code>"hjb"</code> or <code>"mail"</code>. The <code>suffix</code> argument may be <code>null</code> in which case the suffix <code>".tmp"</code> will be used. <p> To create the new file the prefix and the suffix may first be adjusted to fit the limitations of the underlying platform. If the prefix is too long then it will be truncated but its first three characters will always be preserved. If the suffix is too long then it too will be truncated but if it begins with a period character (<code>'.'</code>) then the period and the first three characters following it will always be preserved. Once these adjustments have been made the name of the new file will be generated by concatenating the prefix five or more internally-generated characters and the suffix. <p> If the <code>directory</code> argument is <code>null</code> then the system-dependent default temporary-file directory will be used. The default temporary-file directory is specified by the system property <code>java.io.tmpdir</code>. On UNIX systems the default value of this property is typically <code>"/tmp"</code> or <code>"/var/tmp"</code>; on Win32 systems it is typically <code>"c:\\temp"</code>. @param prefix The prefix string to be used in generating the file's name; must be at least three characters long @param suffix The suffix string to be used in generating the file's name; may be <code>null</code> in which case the suffix <code>".tmp"</code> will be used @param directory The directory in which the file is to be created or <code>null</code> if the default temporary-file directory is to be used @return An abstract pathname denoting a newly-created empty file @throws IllegalArgumentException If the <code>prefix</code> argument contains fewer than three characters @throws IOException If a file could not be created @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method does not allow a file to be created @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.deleteOnExit()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.deleteOnExit_changed()" class="hiddenlink">void <b>deleteOnExit()</b></a><br><br><blockquote>Requests that the file or directory denoted by this abstract pathname be deleted when the virtual machine terminates. Deletion will be attempted only for normal termination of the virtual machine as defined by the Java Language Specification (12.9). <p> Once deletion has been requested it is not possible to cancel the request. This method should therefore be used with care. @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkDelete}</code> method denies delete access to the file @see #delete @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.getAbsoluteFile()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.getAbsoluteFile_changed()" class="hiddenlink">File <b>getAbsoluteFile()</b></a><br><br><blockquote>Returns the absolute form of this abstract pathname. Equivalent to <code>new&nbsp;File(this.{@link #getAbsolutePath}())</code>. @return The absolute abstract pathname denoting the same file or directory as this abstract pathname @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.getCanonicalFile()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.getCanonicalFile_changed()" class="hiddenlink">File <b>getCanonicalFile()</b></a><br><br><blockquote>Returns the canonical form of this abstract pathname. Equivalent to <code>new&nbsp;File(this.{@link #getCanonicalPath}())</code>. @return The canonical pathname string denoting the same file or directory as this abstract pathname @throws IOException If an I/O error occurs which is possible because the construction of the canonical pathname may require filesystem queries @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.getParentFile()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.getParentFile_changed()" class="hiddenlink">File <b>getParentFile()</b></a><br><br><blockquote>Returns the abstract pathname of this abstract pathname's parent or <code>null</code> if this pathname does not name a parent directory. <p> The <em>parent</em> of an abstract pathname consists of the pathname's prefix if any and each name in the pathname's name sequence except for the last. If the name sequence is empty then the pathname does not name a parent directory. @return The abstract pathname of the parent directory named by this abstract pathname or <code>null</code> if this pathname does not name a parent @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.isHidden()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.isHidden_changed()" class="hiddenlink">boolean <b>isHidden()</b></a><br><br><blockquote>Tests whether the file named by this abstract pathname is a hidden file. The exact definition of <em>hidden</em> is system-dependent. On UNIX systems a file is considered to be hidden if its name begins with a period character (<code>'.'</code>). On Win32 systems a file is considered to be hidden if it has been marked as such in the filesystem. @return <code>true</code> if and only if the file denoted by this abstract pathname is hidden according to the conventions of the underlying platform @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkRead}</code> method denies read access to the file @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.listFiles()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.listFiles_changed()" class="hiddenlink">File[] <b>listFiles()</b></a><br><br><blockquote>Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname. <p> If this abstract pathname does not denote a directory then this method returns <code>null</code>. Otherwise an array of <code>File</code> objects is returned one for each file or directory in the directory. Pathnames denoting the directory itself and the directory's parent directory are not included in the result. Each resulting abstract pathname is constructed from this abstract pathname using the <code>{@link #File(java.io.File java.lang.String) File(File &nbsp;String)}</code> constructor. Therefore if this pathname is absolute then each resulting pathname is absolute; if this pathname is relative then each resulting pathname will be relative to the same directory. <p> There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not in particular guaranteed to appear in alphabetical order. @return An array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname. The array will be empty if the directory is empty. Returns <code>null</code> if this abstract pathname does not denote a directory or if an I/O error occurs. @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkRead}</code> method denies read access to the directory @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.listFiles(FileFilter)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.listFiles_changed(java.io.FileFilter)" class="hiddenlink">File[] <b>listFiles(FileFilter)</b></a><br><br><blockquote>Returns an array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter. The behavior of this method is the same as that of the <code>{@link #listFiles()}</code> method except that the pathnames in the returned array must satisfy the filter. If the given <code>filter</code> is <code>null</code> then all pathnames are accepted. Otherwise a pathname satisfies the filter if and only if the value <code>true</code> results when the <code>{@link FilenameFilter#accept}</code> method of the filter is invoked on the pathname. @param filter A filename filter @return An array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname. The array will be empty if the directory is empty. Returns <code>null</code> if this abstract pathname does not denote a directory or if an I/O error occurs. @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkRead}</code> method denies read access to the directory @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.listFiles(FilenameFilter)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.listFiles_changed(java.io.FilenameFilter)" class="hiddenlink">File[] <b>listFiles(FilenameFilter)</b></a><br><br><blockquote>Returns an array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter. The behavior of this method is the same as that of the <code>{@link #listFiles()}</code> method except that the pathnames in the returned array must satisfy the filter. If the given <code>filter</code> is <code>null</code> then all pathnames are accepted. Otherwise a pathname satisfies the filter if and only if the value <code>true</code> results when the <code>{@link FilenameFilter#accept}</code> method of the filter is invoked on this abstract pathname and the name of a file or directory in the directory that it denotes. @param filter A filename filter @return An array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname. The array will be empty if the directory is empty. Returns <code>null</code> if this abstract pathname does not denote a directory or if an I/O error occurs. @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkRead}</code> method denies read access to the directory @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.listRoots()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.listRoots_changed()" class="hiddenlink">File[] <b>listRoots()</b></a><br><br><blockquote>List the available filesystem roots. <p> A particular Java platform may support zero or more hierarchically-organized file systems. Each file system has a <code>root</code> directory from which all other files in that file system can be reached. Windows platforms for example have a root directory for each active drive; UNIX platforms have a single root directory namely <code>"/"</code>. The set of available filesystem roots is affected by various system-level operations such the insertion or ejection of removable media and the disconnecting or unmounting of physical or virtual disk drives. <p> This method returns an array of <code>File</code> objects that denote the root directories of the available filesystem roots. It is guaranteed that the canonical pathname of any file physically present on the local machine will begin with one of the roots returned by this method. <p> The canonical pathname of a file that resides on some other machine and is accessed via a remote-filesystem protocol such as SMB or NFS may or may not begin with one of the roots returned by this method. If the pathname of a remote file is syntactically indistinguishable from the pathname of a local file then it will begin with one of the roots returned by this method. Thus for example <code>File</code> objects denoting the root directories of the mapped network drives of a Windows platform will be returned by this method while <code>File</code> objects containing UNC pathnames will not be returned by this method. <p> Unlike most methods in this class this method does not throw security exceptions. If a security manager exists and its <code>{@link java.lang.SecurityManager#checkRead}</code> method denies read access to a particular root directory then that directory will not appear in the result. @return An array of <code>File</code> objects denoting the available filesystem roots or <code>null</code> if the set of roots could not be determined. The array will be empty if there are no filesystem roots. @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.renameTo(File)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.renameTo_changed(java.io.File)" class="hiddenlink">boolean <b>renameTo(File)</b></a><br><br><blockquote>Renames the file denoted by this abstract pathname. @param dest The new abstract pathname for the named file @return <code>true</code> if and only if the renaming succeeded; <code>false</code> otherwise @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method denies write access to <strike>both</strike><span style="background: #FFFF00">either</span> the old <strike>and</strike><span style="background: #FFFF00">or</span> new pathnames @throws NullPointerException If parameter <code>dest</code> is <code>null</code></blockquote>
<A NAME="java.io.File.dmethod.setLastModified(long)"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.setLastModified_changed(long)" class="hiddenlink">boolean <b>setLastModified(long)</b></a><br><br><blockquote>Sets the last-modified time of the file or directory named by this abstract pathname. <p> All platforms support file-modification times to the nearest second but some provide more precision. The argument will be truncated to fit the supported precision. If the operation succeeds and no intervening operations on the file take place then the next invocation of the <code>{@link #lastModified}</code> method will return the (possibly truncated) <code>time</code> argument that was passed to this method. @param time The new last-modified time measured in milliseconds since the epoch (00:00:00 GMT January 1 1970) @<strike>returns</strike><span style="background: #FFFF00">return</span> <code>true</code> if and only if the operation succeeded; <code>false</code> otherwise @throws IllegalArgumentException If the argument is negative @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method denies write access to the named file @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.setReadOnly()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.setReadOnly_changed()" class="hiddenlink">boolean <b>setReadOnly()</b></a><br><br><blockquote>Marks the file or directory named by this abstract pathname so that only read operations are allowed. After invoking this method the file or directory is guaranteed not to change until it is either deleted or marked to allow write access. Whether or not a read-only file or directory may be deleted depends upon the underlying system. @<strike>returns</strike><span style="background: #FFFF00">return</span> <code>true</code> if and only if the operation succeeded; <code>false</code> otherwise @throws SecurityException If a security manager exists and its <code>{@link java.lang.SecurityManager#checkWrite}</code> method denies write access to the named file @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.File.dmethod.toURL()"></A><a href="java.io.File.html" class="hiddenlink">Class <b>File</b></a>, <a href="java.io.File.html#java.io.File.toURL_changed()" class="hiddenlink">URL <b>toURL()</b></a><br><br><blockquote>Converts this abstract pathname into a <code>file:</code> URL. The exact form of the URL is system-dependent. If it can be determined that the file denoted by this abstract pathname is a directory then the resulting URL will end with a slash. @<span style="background: #FFFF00">return a URL object representing the equivalent file URL. @throws MalformedURLException if the path cannot be parsed as a URL. @</span>see java.net.URL @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileDescriptor!class"></A><a href="java.io.FileDescriptor.html" class="hiddenlink">Class <b>FileDescriptor</b></a><br><br><blockquote>Instances of the file descriptor class serve as an opaque handle to the underlying machine-specific structure representing an open file an open socket or another source or sink of bytes. The main practical use for a file descriptor is to create a <code>FileInputStream</code> or <code>FileOutputStream</code> to contain it. <p> Applications should not create their own file descriptors. @author Pavani Diwanji @version 1.<strike>15 06</strike><span style="background: #FFFF00">18 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.FileInputStream @see java.io.FileOutputStream @<strike>see java.net.SocketInputStream @see java.net.SocketOutputStream @</strike>since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileFilter!class"></A><a href="java.io.FileFilter.html" class="hiddenlink">Class <b>FileFilter</b></a><br><br><blockquote>A filter for abstract pathnames. <p> Instances of this interface may be passed to the <code>{@link File#listFiles(java.io.FileFilter)<strike>;</strike> listFiles(FileFilter)}</code> method of the <code>{@link java.io.FileFilter}</code> class. @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileInputStream!class"></A><a href="java.io.FileInputStream.html" class="hiddenlink">Class <b>FileInputStream</b></a><br><br><blockquote>A <code>FileInputStream</code> obtains input bytes from a file in a file system. What files are available depends on the host environment. @author Arthur van Hoff @version 1.<strike>42 09</strike><span style="background: #FFFF00">45 02</span>/<strike>24</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.File @see java.io.FileDescriptor @see java.io.FileOutputStream @since JDK1.0</blockquote>
<A NAME="java.io.FileInputStream.ctor(FileDescriptor)"></A><a href="java.io.FileInputStream.html" class="hiddenlink">Class <b>FileInputStream</b></a>, <a href="java.io.FileInputStream.html#java.io.FileInputStream.ctor_changed(java.io.FileDescriptor)" class="hiddenlink">constructor <b>FileInputStream(FileDescriptor)</b></a><br><br><blockquote>Creates a <code>FileInputStream</code> by using the file descriptor <code>fdObj</code> which represents an existing connection to an actual file in the file system. <p> <strike>First</strike><span style="background: #FFFF00">If</span> <strike>if </strike>there is a security manager its <code>checkRead</code> method is called with the file descriptor <code>fdObj</code> as its argument to see if it's ok to read the file descriptor. <span style="background: #FFFF00">If read access is denied to the file descriptor a <code>SecurityException</code> is thrown. <p> If <code>fdObj</code> is null then a <code>NullPointerException</code> is thrown. </span>@param fdObj the file descriptor to be opened for reading. @throws SecurityException if a security manager exists and its <code>checkRead</code> method denies read access to the file descriptor. @see SecurityManager#checkRead(java.io.FileDescriptor)</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileNotFoundException!class"></A><a href="java.io.FileNotFoundException.html" class="hiddenlink">Class <b>FileNotFoundException</b></a><br><br><blockquote>Signals that an attempt to open the file denoted by a specified pathname has failed. <p> This exception will be thrown by the <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/io/FileNotFoundException/FileInputStream.html" target="_top">FileInputStream</A> <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/io/FileNotFoundException/FileOutputStream.html" target="_top">FileOutputStream</A> and <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/io/FileNotFoundException/RandomAccessFile.html" target="_top">RandomAccessFile</A> constructors when a file with the specified pathname does not exist. It will also be thrown by these constructors if the file does exist but for some reason is inaccessible for example when an attempt is made to open a read-only file for writing. @author unascribed @version 1.<strike>16 09</strike><span style="background: #FFFF00">20 02</span>/02/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileOutputStream!class"></A><a href="java.io.FileOutputStream.html" class="hiddenlink">Class <b>FileOutputStream</b></a><br><br><blockquote>A file output stream is an output stream for writing data to a <code>File</code> or to a <code>FileDescriptor</code>. <strike>What</strike><span style="background: #FFFF00">Whether</span> <strike>files</strike><span style="background: #FFFF00">or not a</span> <strike>are</strike><span style="background: #FFFF00">file is</span> available or may be created depends <strike>on</strike><span style="background: #FFFF00">upon the underlying platform. Some platforms in particular allow a file to be opened for writing by only</span> <span style="background: #FFFF00">one <tt>FileOutputStream</tt> (or other file-writing object) at a time. In such situations the constructors in this class will fail if </span>the <strike>host</strike><span style="background: #FFFF00">file involved is already</span> <strike>environment</strike><span style="background: #FFFF00">open</span>. @author Arthur van Hoff @version 1.<strike>35</strike><span style="background: #FFFF00">39</span> <strike>09</strike><span style="background: #FFFF00">02</span>/<strike>24</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.File @see java.io.FileDescriptor @see java.io.FileInputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilePermission!class"></A><a href="java.io.FilePermission.html" class="hiddenlink">Class <b>FilePermission</b></a><br><br><blockquote>This class represents access to a file or directory. A FilePermission consists of a pathname and a set of actions valid for that pathname. <P> Pathname is the pathname of the file or directory granted the specified actions. A pathname that ends in "/*" (where "/" is the file separator character <code>File.separatorChar</code>) indicates all the files and directories contained in that directory. A pathname that ends with "/-" indicates (recursively) all files and subdirectories contained in that directory. A pathname consisting of the special token "&lt;&lt;ALL FILES&gt;&gt;" matches <bold>any</bold> file. <P> Note: A pathname consisting of a single "*" indicates all the files in the current directory while a pathname consisting of a single "-" indicates all the files in the current directory and (recursively) all files and subdirectories contained in the current directory. <P> The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are "read" "write" "execute" and "delete". Their meaning is defined as follows: <P> <DL> <DT> read <DD> read permission <DT> write <DD> write permission <DT> execute <DD> execute permission. Allows <code>Runtime.exec</code> to be called. Corresponds to <code>SecurityManager.checkExec</code>. <DT> delete <DD> delete permission. Allows <code>File.delete</code> to be called. Corresponds to <code>SecurityManager.checkDelete</code>. </DL> <P> The actions string is converted to lowercase before processing. <P> Be careful when granting FilePermissions. Think about the implications of granting read and especially write access to various files and directories. The "&lt;&lt;ALL FILES>>" permission with write action is especially dangerous. This grants permission to write to the entire file system. One thing this effectively allows is replacement of the system binary including the JVM runtime environment. <p>Please note: Code can always read a file from the same directory it's in (or a subdirectory of that directory); it does not need explicit permission to do so. @see java.security.Permission @see java.security.Permissions @see java.security.PermissionCollection @version 1.<strike>59 99</strike><span style="background: #FFFF00">67 00</span>/<strike>04</strike><span style="background: #FFFF00">02</span>/<strike>22</strike><span style="background: #FFFF00">02</span> @author Marianne Mueller @author Roland Schemers<span style="background: #FFFF00"> @since 1.2 @serial exclude</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileReader!class"></A><a href="java.io.FileReader.html" class="hiddenlink">Class <b>FileReader</b></a><br><br><blockquote>Convenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate. To specify these values yourself construct an InputStreamReader on a FileInputStream. @see InputStreamReader @see FileInputStream @version 1.<strike>7 98</strike><span style="background: #FFFF00">10 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FileWriter!class"></A><a href="java.io.FileWriter.html" class="hiddenlink">Class <b>FileWriter</b></a><br><br><blockquote>Convenience class for writing character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable. To specify these values yourself construct an OutputStreamWriter on a FileOutputStream. @see OutputStreamWriter @see FileOutputStream @version 1.<strike>7 98</strike><span style="background: #FFFF00">11 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilenameFilter!class"></A><a href="java.io.FilenameFilter.html" class="hiddenlink">Class <b>FilenameFilter</b></a><br><br><blockquote>Instances of classes that implement this interface are used to filter filenames. These instances are used to filter directory listings in the <code>list</code> method of class <code>File</code> and by the Abstract Window Toolkit's file dialog component. @author Arthur van Hoff @author Jonathan Payne @version 1.<strike>18 06</strike><span style="background: #FFFF00">20 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.awt.FileDialog#setFilenameFilter(java.io.FilenameFilter) @see java.io.File @see java.io.File#list(java.io.FilenameFilter) @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilterInputStream!class"></A><a href="java.io.FilterInputStream.html" class="hiddenlink">Class <b>FilterInputStream</b></a><br><br><blockquote>A <code>FilterInputStream</code> contains some other input stream which it uses as its basic source of data possibly transforming the data along the way or providing additional functionality. The class <code>FilterInputStream</code> itself simply overrides all methods of <code>InputStream</code> with versions that pass all requests to the contained input stream. Subclasses of <code>FilterInputStream</code> may further override some of these methods and may also provide additional methods and fields. @author Jonathan Payne @version 1.<strike>21 06</strike><span style="background: #FFFF00">23 02</span>/<strike>24</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilterOutputStream!class"></A><a href="java.io.FilterOutputStream.html" class="hiddenlink">Class <b>FilterOutputStream</b></a><br><br><blockquote>This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the <i>underlying</i> output stream) which it uses as its basic sink of data but possibly transforming the data along the way or providing additional functionality. <p> The class <code>FilterOutputStream</code> itself simply overrides all methods of <code>OutputStream</code> with versions that pass all requests to the underlying output stream. Subclasses of <code>FilterOutputStream</code> may further override some of these methods as well as provide additional methods and fields. @author Jonathan Payne @version 1.<strike>25 08</strike><span style="background: #FFFF00">28 02</span>/<strike>26</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilterReader!class"></A><a href="java.io.FilterReader.html" class="hiddenlink">Class <b>FilterReader</b></a><br><br><blockquote>Abstract class for reading filtered character streams. @version 1.<strike>8 98</strike><span style="background: #FFFF00">11 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.FilterReader.ctor(Reader)"></A><a href="java.io.FilterReader.html" class="hiddenlink">Class <b>FilterReader</b></a>, <a href="java.io.FilterReader.html#java.io.FilterReader.ctor_changed(java.io.Reader)" class="hiddenlink">constructor <b>FilterReader(Reader)</b></a><br><br><blockquote>Create a new filtered reader.<span style="background: #FFFF00"> @param in a Reader object providing the underlying stream.</span></blockquote>
<A NAME="java.io.FilterReader.field.in"></A><a href="java.io.FilterReader.html" class="hiddenlink">Class <b>FilterReader</b></a>, <a href="java.io.FilterReader.html#java.io.FilterReader.in" class="hiddenlink">Reader <b>in</b></a><br><br><blockquote>The underlying character-input stream or null if the stream has been closed<span style="background: #FFFF00">.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.FilterWriter!class"></A><a href="java.io.FilterWriter.html" class="hiddenlink">Class <b>FilterWriter</b></a><br><br><blockquote>Abstract class for writing filtered character streams. @version 1.<strike>8 98</strike><span style="background: #FFFF00">11 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.FilterWriter.ctor(Writer)"></A><a href="java.io.FilterWriter.html" class="hiddenlink">Class <b>FilterWriter</b></a>, <a href="java.io.FilterWriter.html#java.io.FilterWriter.ctor_changed(java.io.Writer)" class="hiddenlink">constructor <b>FilterWriter(Writer)</b></a><br><br><blockquote>Create a new filtered writer.<span style="background: #FFFF00"> @param out a Writer object to provide the underlying stream.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.IOException!class"></A><a href="java.io.IOException.html" class="hiddenlink">Class <b>IOException</b></a><br><br><blockquote>Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations. @author unascribed @version 1.<strike>17 06</strike><span style="background: #FFFF00">19 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.InputStream @see java.io.OutputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.InputStream!class"></A><a href="java.io.InputStream.html" class="hiddenlink">Class <b>InputStream</b></a><br><br><blockquote>This abstract class is the superclass of all classes representing an input stream of bytes. <p> Applications that need to define a subclass of <code>InputStream</code> must always provide a method that returns the next byte of input. @author Arthur van Hoff @version 1.<strike>34 08</strike><span style="background: #FFFF00">36 02</span>/<strike>16</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.BufferedInputStream @see java.io.ByteArrayInputStream @see java.io.DataInputStream @see java.io.FilterInputStream @see java.io.InputStream#read() @see java.io.OutputStream @see java.io.PushbackInputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.InputStreamReader!class"></A><a href="java.io.InputStreamReader.html" class="hiddenlink">Class <b>InputStreamReader</b></a><br><br><blockquote>An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and translates them into characters according to a specified <a href="../lang/package-summary.html#charenc">character encoding</a>. The encoding that it uses may be specified by name or the platform's default encoding may be accepted. <p> Each invocation of one of an InputStreamReader's read() methods may cause one or more bytes to be read from the underlying byte-input stream. <span style="background: #FFFF00">To enable the efficient conversion of bytes to characters more bytes may be read ahead from the underlying stream than are necessary to satisfy the current read operation. <p> </span>For top efficiency consider wrapping an InputStreamReader within a BufferedReader<strike>; for</strike><span style="background: #FFFF00">. For</span> example<span style="background: #FFFF00">:</span> <pre> BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); </pre> @see BufferedReader @see InputStream @<span style="background: #FFFF00">see <a href="../lang/package-summary.html#charenc">Character encodings</a> @</span>version 1.<strike>20 98</strike><span style="background: #FFFF00">25 00</span>/<strike>08</strike><span style="background: #FFFF00">02</span>/<strike>06</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.InputStreamReader.ctor(InputStream, String)"></A><a href="java.io.InputStreamReader.html" class="hiddenlink">Class <b>InputStreamReader</b></a>, <a href="java.io.InputStreamReader.html#java.io.InputStreamReader.ctor_changed(java.io.InputStream, java.lang.String)" class="hiddenlink">constructor <b>InputStreamReader(InputStream, String)</b></a><br><br><blockquote>Create an InputStreamReader that uses the named character encoding. @param in An InputStream @param enc <strike>Name</strike><span style="background: #FFFF00">The</span> <span style="background: #FFFF00">name </span>of <strike>encoding to</strike><span style="background: #FFFF00">a supported</span> <strike>be</strike><a href="../lang/package-summary.html#charenc"><span style="background: #FFFF00">character</span> <strike>used</strike><span style="background: #FFFF00">encoding</a></span> @exception UnsupportedEncodingException If the named encoding is not supported</blockquote>
<A NAME="java.io.InputStreamReader.dmethod.getEncoding()"></A><a href="java.io.InputStreamReader.html" class="hiddenlink">Class <b>InputStreamReader</b></a>, <a href="java.io.InputStreamReader.html#java.io.InputStreamReader.getEncoding_changed()" class="hiddenlink">String <b>getEncoding()</b></a><br><br><blockquote>Returns the canonical name of the character encoding being used by this stream. If this <code>InputStreamReader</code> was created with the <A HREF="http://java.sun.com/j2se/1.3/docs/api/#InputStreamReader(InputStream.html" target="_top">String)</A> constructor <span style="background: #FFFF00">then </span>the returned encoding name being canonical may differ from the encoding name passed to the constructor. May return <code>null</code> if the stream has been closed.<span style="background: #FFFF00"> @return a String representing the encoding name or possibly <code>null</code> if the stream has been closed @see <a href="../lang/package-summary.html#charenc">Character encodings</a></span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.InterruptedIOException!class"></A><a href="java.io.InterruptedIOException.html" class="hiddenlink">Class <b>InterruptedIOException</b></a><br><br><blockquote>Signals that an I/O operation has been interrupted. An <code>InterruptedIOException</code> is thrown to indicate that an input or output transfer has been terminated because the thread performing it was terminated. The field <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/io/InterruptedIOException/#bytesTransferred.html" target="_top">#bytesTransferred</A> indicates how many bytes were successfully transferred before the interruption occurred. @author unascribed @version 1.<strike>13 06</strike><span style="background: #FFFF00">15 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.InputStream @see java.io.OutputStream @see java.lang.Thread#interrupt() @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.InvalidClassException!class"></A><a href="java.io.InvalidClassException.html" class="hiddenlink">Class <b>InvalidClassException</b></a><br><br><blockquote>Thrown when the Serialization runtime detects one of the following problems with a Class. <UL> <LI> The serial version of the class does not match that of the class descriptor read from the stream <LI> The class contains unknown datatypes <LI> The class does not have an accessible no-arg constructor </UL> @author unascribed @version 1.<strike>13 06</strike><span style="background: #FFFF00">17 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.InvalidClassException.ctor(String)"></A><a href="java.io.InvalidClassException.html" class="hiddenlink">Class <b>InvalidClassException</b></a>, <a href="java.io.InvalidClassException.html#java.io.InvalidClassException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>InvalidClassException(String)</b></a><br><br><blockquote>Report a InvalidClassException for the reason specified.<span style="background: #FFFF00"> @param reason String describing the reason for the exception.</span></blockquote>
<A NAME="java.io.InvalidClassException.field.classname"></A><a href="java.io.InvalidClassException.html" class="hiddenlink">Class <b>InvalidClassException</b></a>, <a href="java.io.InvalidClassException.html#java.io.InvalidClassException.classname" class="hiddenlink">String <b>classname</b></a><br><br><blockquote><span style="background: #FFFF00">Name of the invalid class. </span>@serial Name of the invalid class.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.InvalidObjectException!class"></A><a href="java.io.InvalidObjectException.html" class="hiddenlink">Class <b>InvalidObjectException</b></a><br><br><blockquote>Indicates that one or more deserialized objects failed validation tests. The argument should provide the reason for the failure. @see ObjectInputValidation @since JDK1.1 @author unascribed @version 1.<strike>10 06</strike><span style="background: #FFFF00">12 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.LineNumberInputStream!class"></A><a href="java.io.LineNumberInputStream.html" class="hiddenlink">Class <b>LineNumberInputStream</b></a><br><br><blockquote>This class is an input stream filter that provides the added functionality of keeping track of the current line number. <p> A line is a sequence of bytes ending with a carriage return character (<code>'&#92;r'</code>) a newline character (<code>'&#92;n'</code>) or a carriage return character followed immediately by a linefeed character. In all three cases the line terminating character(s) are returned as a single newline character. <p> The line number begins at <code>0</code> and is incremented by <code>1</code> when a <code>read</code> returns a newline character. @author Arthur van Hoff @version 1.<strike>19 03</strike><span style="background: #FFFF00">22 02</span>/<strike>23</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.LineNumberReader @since JDK1.0 @deprecated This class incorrectly assumes that bytes adequately represent characters. As of JDK&nbsp;1.1 the preferred way to operate on character streams is via the new character-stream classes which include a class for counting line numbers.</blockquote>
<A NAME="java.io.LineNumberInputStream.dmethod.getLineNumber()"></A><a href="java.io.LineNumberInputStream.html" class="hiddenlink">Class <b>LineNumberInputStream</b></a>, <a href="java.io.LineNumberInputStream.html#java.io.LineNumberInputStream.getLineNumber_changed()" class="hiddenlink">int <b>getLineNumber()</b></a><br><br><blockquote>Returns the current line number. @return the current line number.<span style="background: #FFFF00"> @see #setLineNumber</span></blockquote>
<A NAME="java.io.LineNumberInputStream.dmethod.setLineNumber(int)"></A><a href="java.io.LineNumberInputStream.html" class="hiddenlink">Class <b>LineNumberInputStream</b></a>, <a href="java.io.LineNumberInputStream.html#java.io.LineNumberInputStream.setLineNumber_changed(int)" class="hiddenlink">void <b>setLineNumber(int)</b></a><br><br><blockquote>Sets the line number to the specified argument. @param lineNumber the new line number.<span style="background: #FFFF00"> @see #getLineNumber</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.LineNumberReader!class"></A><a href="java.io.LineNumberReader.html" class="hiddenlink">Class <b>LineNumberReader</b></a><br><br><blockquote>A buffered character-input stream that keeps track of line numbers. A line is considered to be terminated by any one of a line feed ('\n') a carriage return ('\r') or a carriage return followed immediately by a linefeed. @version 1.<strike>9 98</strike><span style="background: #FFFF00">13 00</span>/<strike>03</strike><span style="background: #FFFF00">02</span>/<strike>18</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.LineNumberReader.ctor(Reader)"></A><a href="java.io.LineNumberReader.html" class="hiddenlink">Class <b>LineNumberReader</b></a>, <a href="java.io.LineNumberReader.html#java.io.LineNumberReader.ctor_changed(java.io.Reader)" class="hiddenlink">constructor <b>LineNumberReader(Reader)</b></a><br><br><blockquote>Create a new line-numbering reader using the default input-buffer size.<span style="background: #FFFF00"> @param in a Reader object to provide the underlying stream.</span></blockquote>
<A NAME="java.io.LineNumberReader.ctor(Reader, int)"></A><a href="java.io.LineNumberReader.html" class="hiddenlink">Class <b>LineNumberReader</b></a>, <a href="java.io.LineNumberReader.html#java.io.LineNumberReader.ctor_changed(java.io.Reader, int)" class="hiddenlink">constructor <b>LineNumberReader(Reader, int)</b></a><br><br><blockquote>Create a new line-numbering reader reading characters into a buffer of the given size.<span style="background: #FFFF00"> @param in a Reader object to provide the underlying stream. @param sz an int specifying the size of the buffer.</span></blockquote>
<A NAME="java.io.LineNumberReader.dmethod.getLineNumber()"></A><a href="java.io.LineNumberReader.html" class="hiddenlink">Class <b>LineNumberReader</b></a>, <a href="java.io.LineNumberReader.html#java.io.LineNumberReader.getLineNumber_changed()" class="hiddenlink">int <b>getLineNumber()</b></a><br><br><blockquote>Get the current line number.<span style="background: #FFFF00"> @return The current line number. @see #setLineNumber</span></blockquote>
<A NAME="java.io.LineNumberReader.dmethod.setLineNumber(int)"></A><a href="java.io.LineNumberReader.html" class="hiddenlink">Class <b>LineNumberReader</b></a>, <a href="java.io.LineNumberReader.html#java.io.LineNumberReader.setLineNumber_changed(int)" class="hiddenlink">void <b>setLineNumber(int)</b></a><br><br><blockquote>Set the current line number.<span style="background: #FFFF00"> @param lineNumber an int specifying the line number. @see #getLineNumber</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.NotActiveException!class"></A><a href="java.io.NotActiveException.html" class="hiddenlink">Class <b>NotActiveException</b></a><br><br><blockquote>Thrown when serialization or deserialization is not active. @author unascribed @version 1.<strike>9 06</strike><span style="background: #FFFF00">12 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.NotActiveException.ctor(String)"></A><a href="java.io.NotActiveException.html" class="hiddenlink">Class <b>NotActiveException</b></a>, <a href="java.io.NotActiveException.html#java.io.NotActiveException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>NotActiveException(String)</b></a><br><br><blockquote>Constructor to create a new NotActiveException with the reason given.<span style="background: #FFFF00"> @param reason a String describing the reason for the exception.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.NotSerializableException!class"></A><a href="java.io.NotSerializableException.html" class="hiddenlink">Class <b>NotSerializableException</b></a><br><br><blockquote>Thrown when an instance is required to have a Serializable interface. The serialization runtime or the class of the instance can throw this exception. The argument should be the name of the class. @author unascribed @version 1.<strike>8 06</strike><span style="background: #FFFF00">11 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.NotSerializableException.ctor(String)"></A><a href="java.io.NotSerializableException.html" class="hiddenlink">Class <b>NotSerializableException</b></a>, <a href="java.io.NotSerializableException.html#java.io.NotSerializableException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>NotSerializableException(String)</b></a><br><br><blockquote><span style="background: #FFFF00">Constructs a NotSerializableException object with message string. </span>@param classname Class of the instance being serialized/deserialized.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectInput!class"></A><a href="java.io.ObjectInput.html" class="hiddenlink">Class <b>ObjectInput</b></a><br><br><blockquote>ObjectInput extends the DataInput interface to include the reading of objects. DataInput includes methods for the input of primitive types ObjectInput extends that interface to include objects arrays and Strings. @author unascribed @version 1.<strike>13 09</strike><span style="background: #FFFF00">16 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.InputStream @see java.io.ObjectOutputStream @see java.io.ObjectInputStream @since JDK1.1</blockquote>
<A NAME="java.io.ObjectInput.dmethod.available()"></A><a href="java.io.ObjectInput.html" class="hiddenlink">Class <b>ObjectInput</b></a>, <a href="java.io.ObjectInput.html#java.io.ObjectInput.available_changed()" class="hiddenlink">int <b>available()</b></a><br><br><blockquote>Returns the number of bytes that can be read without blocking. @return the number of available bytes.<span style="background: #FFFF00"> @exception IOException If an I/O error has occurred.</span></blockquote>
<A NAME="java.io.ObjectInput.dmethod.readObject()"></A><a href="java.io.ObjectInput.html" class="hiddenlink">Class <b>ObjectInput</b></a>, <a href="java.io.ObjectInput.html#java.io.ObjectInput.readObject_changed()" class="hiddenlink">Object <b>readObject()</b></a><br><br><blockquote>Read and return an object. The class that implements this interface defines where the object is "read" from. @<span style="background: #FFFF00">return the object read from the stream @</span>exception java.lang.ClassNotFoundException If the class of a serialized object cannot be found. @exception IOException If any of the usual Input/Output related exceptions occur.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectInputStream!class"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a><br><br><blockquote>An ObjectInputStream deserializes primitive data and objects previously written using an ObjectOutputStream. ObjectOutputStream and ObjectInputStream can provide an application with persistent storage for graphs of objects when used with a FileOutputStream and FileInputStream respectively. ObjectInputStream is used to recover those objects previously serialized. Other uses include passing objects between hosts using a socket stream or for marshaling and unmarshaling arguments and parameters in a remote communication system.<p> ObjectInputStream ensures that the types of all objects in the graph created from the stream match the classes present in the Java Virtual Machine. Classes are loaded as required using the standard mechanisms. <p> Only objects that support the java.io.Serializable or java.io.Externalizable interface can be read from streams. The method <STRONG>readObject</STRONG> is used to read an object from the stream. Java's safe casting should be used to get the desired type. In Java strings and arrays are objects and are treated as objects during serialization. When read they need to be cast to the expected type.<p> Primitive data types can be read from the stream using the appropriate method on DataInput. <p> The default deserialization mechanism for objects restores the contents of each field to the value and type it had when it was written. Fields declared as transient or static are ignored by the deserialization process. References to other objects cause those objects to be read from the stream as necessary. Graphs of objects are restored correctly using a reference sharing mechanism. New objects are always allocated when deserializing which prevents existing objects from being overwritten. <p> Reading an object is analogous to running the constructors of a new object. Memory is allocated for the object and initialized to zero (NULL). No-arg constructors are invoked for the non-serializable classes and then the fields of the serializable classes are restored from the stream starting with the serializable class closest to java.lang.object and finishing with the object's most specifiec class. <p> For example to read from a stream as written by the example in ObjectOutputStream: <br> <PRE> FileInputStream istream = new FileInputStream("t.tmp"); ObjectInputStream p = new ObjectInputStream(istream); int i = p.readInt(); String today = (String)p.readObject(); Date date = (Date)p.readObject(); istream.close(); </PRE> Classes control how they are serialized by implementing either the java.io.Serializable or java.io.Externalizable interfaces.<P> Implementing the Serializable interface allows object serialization to save and restore the entire state of the object and it allows classes to evolve between the time the stream is written and the time it is read. It automatically traverses references between objects saving and restoring entire graphs. Serializable classes that require special handling during the serialization and deserialization process should implement both of these methods:<p> <PRE> private void writeObject(java.io.ObjectOutputStream stream) throws IOException; private void readObject(java.io.ObjectInputStream stream) throws IOException ClassNotFoundException; </PRE><p> The readObject method is responsible for reading and restoring the state of the object for its particular class using data written to the stream by the corresponding writeObject method. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is restored by reading data from the ObjectInputStream for the individual fields and making assignments to the appropriate fields of the object. Reading primitive data types is supported by DataInput. <p> Serialization does not read or assign values to the fields of any object that does not implement the java.io.Serializable interface. Subclasses of Objects that are not serializable can be serializable. In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized. In this case it is the responsibility of the subclass to save and restore the state of the non-serializable class. It is frequently the case that the fields of that class are accessible (public package or protected) or that there are get and set methods that can be used to restore the state. <p> Any exception that occurs while deserializing an object will be caught by the ObjectInputStream and abort the reading process. <p> Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form. The methods of the Externalizable interface writeExternal and readExternal are called to save and restore the objects state. When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput. It is the responsibility of the objects to handle any versioning that occurs. @author Roger Riggs @version 1.<strike>78 09</strike><span style="background: #FFFF00">105 02</span>/<strike>24</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInput @see java.io.ObjectOutputStream @see java.io.Serializable @see <a href="../../../guide/serialization/spec/input.doc.html"> Object Serialization Specification Section 3 Object Input Classes</a> @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectInputStream.GetField.dmethod.defaulted(String)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.defaulted_changed(java.lang.String)" class="hiddenlink">boolean <b>defaulted(String)</b></a><br><br><blockquote>Return true if the named field is defaulted and has no value in this stream.<span style="background: #FFFF00"> @param name the name of the field @return true if and only if the named field is defaulted @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if <code>name</code> does not correspond to a serializable field</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, Object)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, java.lang.Object)" class="hiddenlink">Object <b>get(String, Object)</b></a><br><br><blockquote>Get the value of the named Object field from the persistent field.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>Object</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, boolean)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, boolean)" class="hiddenlink">boolean <b>get(String, boolean)</b></a><br><br><blockquote>Get the value of the named boolean field from the persistent field.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>boolean</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, byte)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, byte)" class="hiddenlink">byte <b>get(String, byte)</b></a><br><br><blockquote>Get the value of the named byte field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>byte</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, char)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, char)" class="hiddenlink">char <b>get(String, char)</b></a><br><br><blockquote>Get the value of the named char field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>char</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, double)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, double)" class="hiddenlink">double <b>get(String, double)</b></a><br><br><blockquote>Get the value of the named double field from the persistent field.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>double</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, float)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, float)" class="hiddenlink">float <b>get(String, float)</b></a><br><br><blockquote>Get the value of the named float field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>float</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, int)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, int)" class="hiddenlink">int <b>get(String, int)</b></a><br><br><blockquote>Get the value of the named int field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>int</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, long)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, long)" class="hiddenlink">long <b>get(String, long)</b></a><br><br><blockquote>Get the value of the named long field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>long</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.get(String, short)"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.get_changed(java.lang.String, short)" class="hiddenlink">short <b>get(String, short)</b></a><br><br><blockquote>Get the value of the named short field from the persistent fields.<span style="background: #FFFF00"> @param name the name of the field @param defvalue the default value to use if <code>name</code> does not have a value @return the value of the named <code>short</code> field @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws IllegalArgumentException if type of <code>name</code> is not serializable or if the field type is incorrect</span></blockquote>
<A NAME="java.io.ObjectInputStream.GetField.dmethod.getObjectStreamClass()"></A><a href="java.io.ObjectInputStream.GetField.html" class="hiddenlink">Class <b>ObjectInputStream.GetField</b></a>, <a href="java.io.ObjectInputStream.GetField.html#java.io.ObjectInputStream.GetField.getObjectStreamClass_changed()" class="hiddenlink">ObjectStreamClass <b>getObjectStreamClass()</b></a><br><br><blockquote>Get the ObjectStreamClass that describes the fields in the stream.<span style="background: #FFFF00"> @return the descriptor class that describes the serializable fields</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectInputStream.ctor()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.ctor_changed()" class="hiddenlink">constructor <b>ObjectInputStream()</b></a><br><br><blockquote>Provide a way for subclasses that are completely reimplementing ObjectInputStream to not have to allocate private data just used by this implementation of ObjectInputStream. <p>If there is a security manager installed this method first calls the security manager's <code>checkPermission</code> method with the <code>SerializablePermission("enableSubclassImplementation")</code> permission to ensure it's ok to enable subclassing. @exception IOException Thrown if not called by a subclass. @throws SecurityException if a security manager exists and its <code>checkPermission</code> method denies enabling subclassing. @see SecurityManager#checkPermission @see java.<strike>security</strike><span style="background: #FFFF00">io</span>.SerializablePermission</blockquote>
<A NAME="java.io.ObjectInputStream.ctor(InputStream)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.ctor_changed(java.io.InputStream)" class="hiddenlink">constructor <b>ObjectInputStream(InputStream)</b></a><br><br><blockquote>Create an ObjectInputStream that reads from the specified InputStream. The stream header containing the magic number and version number are read from the stream and verified. This method will block until the corresponding ObjectOutputStream has written and flushed the header. @<span style="background: #FFFF00">param in the underlying <code>InputStream</code> from which to read @</span>exception StreamCorruptedException The version or magic number are incorrect. @exception IOException An exception occurred in the underlying stream.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.available()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.available_changed()" class="hiddenlink">int <b>available()</b></a><br><br><blockquote>Returns the number of bytes that can be read without blocking. @return the number of available bytes.<span style="background: #FFFF00"> @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code></span></blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.enableResolveObject(boolean)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.enableResolveObject_changed(boolean)" class="hiddenlink">boolean <b>enableResolveObject(boolean)</b></a><br><br><blockquote>Enable the stream to allow objects read from the stream to be replaced. When enabled the resolveObject method is called for every object being deserialized. If <i>enable</i> is true and there is a security manager installed this method first calls the security manager's <code>checkPermission</code> method with the <code>SerializablePermission("enableSubstitution")</code> permission to ensure it's ok to enable the stream to allow objects read from the stream to be replaced. @<span style="background: #FFFF00">param enable true for enabling use of <code>resolveObject</code> for every object being deserialized @return the previous setting before this method was invoked @</span>throws SecurityException if a security manager exists and its <code>checkPermission</code> method denies enabling the stream to allow objects read from the stream to be replaced. @see SecurityManager#checkPermission @see java.<strike>security</strike><span style="background: #FFFF00">io</span>.SerializablePermission</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readFields()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readFields_changed()" class="hiddenlink">GetField <b>readFields()</b></a><br><br><blockquote>Reads the persistent fields from the stream and makes them available by name. @<span style="background: #FFFF00">return the <code>GetField</code> object representing the persistent fields of the object being deserialized @</span>exception java.lang.ClassNotFoundException if the class of a serialized object could not be found. @exception IOException if an I/O error occurs. @exception NotActiveException if the stream is not currently reading objects. @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readFully(byte[])"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readFully_changed(byte[])" class="hiddenlink">void <b>readFully(byte[])</b></a><br><br><blockquote>Reads bytes blocking until all bytes are read. @param <strike>b</strike><span style="background: #FFFF00">data</span> the buffer into which the data is read @exception EOFException If end of file is reached. @exception IOException If other I/O error has occurred.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readFully(byte[], int, int)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readFully_changed(byte[], int, int)" class="hiddenlink">void <b>readFully(byte[], int, int)</b></a><br><br><blockquote>Reads bytes blocking until all bytes are read. @param <strike>b</strike><span style="background: #FFFF00">data</span> the buffer into which the data is read @param <strike>off</strike><span style="background: #FFFF00">offset</span> the start offset of the data @param <strike>len</strike><span style="background: #FFFF00">size</span> the maximum number of bytes to read @exception EOFException If end of file is reached. @exception IOException If other I/O error has occurred.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readLine()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readLine_changed()" class="hiddenlink">String <b>readLine()</b></a><br><br><blockquote>Reads in a line that has been terminated by a \n \r \r\n or EOF. @return a String copy of the line. @<span style="background: #FFFF00">throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @</span>deprecated This method does not properly convert bytes to characters. see DataInputStream for the details and alternatives.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readObjectOverride()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readObjectOverride_changed()" class="hiddenlink">Object <b>readObjectOverride()</b></a><br><br><blockquote>This method is called by trusted subclasses of ObjectOutputStream that constructed ObjectOutputStream using the protected no-arg constructor. The subclass is expected to provide an override method with the modifier "final". @return the Object read from the stream. @<span style="background: #FFFF00">exception java.lang.ClassNotFoundException Class definition of a serialized object cannot be found. @exception OptionalDataException Primitive data was found in the stream instead of objects. @exception IOException if I/O errors occurred while reading from the underlying stream @</span>see #ObjectInputStream() @see #readObject() @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readStreamHeader()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readStreamHeader_changed()" class="hiddenlink">void <b>readStreamHeader()</b></a><br><br><blockquote>The readStreamHeader method is provided to allow subclasses to read and verify their own stream headers. It reads and verifies the magic number and version number.<span style="background: #FFFF00"> @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code> @throws StreamCorruptedException if control information in the stream is inconsistent</span></blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.readUTF()"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.readUTF_changed()" class="hiddenlink">String <b>readUTF()</b></a><br><br><blockquote>Reads a UTF format String. @return the String.<span style="background: #FFFF00"> @throws IOException if there are I/O errors while reading from the underlying <code>InputStream</code></span></blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.resolveClass(ObjectStreamClass)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.resolveClass_changed(java.io.ObjectStreamClass)" class="hiddenlink">Class <b>resolveClass(ObjectStreamClass)</b></a><br><br><blockquote>Load the local class equivalent of the specified stream class description. Subclasses may implement this method to allow classes to be fetched from an alternate source. The corresponding method in ObjectOutputStream is annotateClass. This method will be invoked only once for each unique class in the stream. This method can be implemented by subclasses to use an alternate loading mechanism but must return a Class object. Once returned the serialVersionUID of the class is compared to the serialVersionUID of the serialized class. If there is a mismatch the deserialization fails and an exception is raised. <p> By default the class name is resolved relative to the class that called readObject. <p> @<span style="background: #FFFF00">param v an instance of class ObjectStreamClass @return a Class object corresponding to <code>v</code> @exception IOException Any of the usual Input/Output exceptions. @</span>exception ClassNotFoundException If class of a serialized object cannot be found.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.resolveObject(Object)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.resolveObject_changed(java.lang.Object)" class="hiddenlink">Object <b>resolveObject(Object)</b></a><br><br><blockquote>This method will allow trusted subclasses of ObjectInputStream to substitute one object for another during deserialization. Replacing objects is disabled until enableResolveObject is called. The enableResolveObject method checks that the stream requesting to resolve object can be trusted. Every reference to serializable objects is passed to resolveObject. To insure that the private state of objects is not unintentionally exposed only trusted streams may use resolveObject. <p> This method is called after an object has been read but before it is returned from readObject. The default resolveObject method just returns the <strike>new</strike><span style="background: #FFFF00">same</span> object. <p> When a subclass is replacing objects it must insure that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored. <p> This method is called only once when each object is first encountered. All subsequent references to the object will be redirected to the new object. <P> @<span style="background: #FFFF00">param obj object to be substituted @return the substituted object @</span>exception IOException Any of the usual Input/Output exceptions.</blockquote>
<A NAME="java.io.ObjectInputStream.dmethod.skipBytes(int)"></A><a href="java.io.ObjectInputStream.html" class="hiddenlink">Class <b>ObjectInputStream</b></a>, <a href="java.io.ObjectInputStream.html#java.io.ObjectInputStream.skipBytes_changed(int)" class="hiddenlink">int <b>skipBytes(int)</b></a><br><br><blockquote>Skips bytes block until all bytes are skipped. @param <strike>n</strike><span style="background: #FFFF00">len</span> the number of bytes to be skipped @return the actual number of bytes skipped. @exception EOFException If end of file is reached. @exception IOException If other I/O error has occurred.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectInputValidation!class"></A><a href="java.io.ObjectInputValidation.html" class="hiddenlink">Class <b>ObjectInputValidation</b></a><br><br><blockquote>Callback interface to allow validation of objects within a graph. Allows an object to be called when a complete graph of objects has been deserialized. @author unascribed @version 1.<strike>12 09</strike><span style="background: #FFFF00">15 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see ObjectInputStream @see ObjectInputStream#registerValidation(java.io.ObjectInputValidation int) @since JDK1.1</blockquote>
<A NAME="java.io.ObjectInputValidation.dmethod.validateObject()"></A><a href="java.io.ObjectInputValidation.html" class="hiddenlink">Class <b>ObjectInputValidation</b></a>, <a href="java.io.ObjectInputValidation.html#java.io.ObjectInputValidation.validateObject_changed()" class="hiddenlink">void <b>validateObject()</b></a><br><br><blockquote>Validates the object<span style="background: #FFFF00">.</span> @exception InvalidObjectException If the object cannot validate itself.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectOutput!class"></A><a href="java.io.ObjectOutput.html" class="hiddenlink">Class <b>ObjectOutput</b></a><br><br><blockquote>ObjectOutput extends the DataOutput interface to include writing of objects. DataOutput includes methods for output of primitive types ObjectOutput extends that interface to include objects arrays and Strings. @author unascribed @version 1.<strike>10 09</strike><span style="background: #FFFF00">13 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.InputStream @see java.io.ObjectOutputStream @see java.io.ObjectInputStream @since JDK1.1</blockquote>
<A NAME="java.io.ObjectOutput.dmethod.writeObject(Object)"></A><a href="java.io.ObjectOutput.html" class="hiddenlink">Class <b>ObjectOutput</b></a>, <a href="java.io.ObjectOutput.html#java.io.ObjectOutput.writeObject_changed(java.lang.Object)" class="hiddenlink">void <b>writeObject(Object)</b></a><br><br><blockquote>Write an object to the underlying storage or stream. The class that implements this interface defines how the object is written. @<span style="background: #FFFF00">param obj the object to be written @</span>exception IOException Any of the usual Input/Output related exceptions.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectOutputStream!class"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a><br><br><blockquote>An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream. The objects can be read (reconstituted) using an ObjectInputStream. Persistent storage of objects can be accomplished by using a file for the stream. If the stream is a network socket stream the objects can be reconsituted on another host or in another process. <p> Only objects that support the java.io.Serializable interface can be written to streams. The class of each serializable object is encoded including the class name and signature of the class the values of the object's fields and arrays and the closure of any other objects referenced from the initial objects. <p> The method <STRONG>writeObject</STRONG> is used to write an object to the stream. Any object including Strings and arrays is written with writeObject. Multiple objects or primitives can be written to the stream. The objects must be read back from the corresponding ObjectInputstream with the same types and in the same order as they were written.<p> Primitive data types can also be written to the stream using the appropriate methods from DataOutput. Strings can also be written using the writeUTF method.<p> The default serialization mechanism for an object writes the class of the object the class signature and the values of all non-transient and non-static fields. References to other objects (except in transient or static fields) cause those objects to be written also. Multiple references to a single object are encoded using a reference sharing mechanism so that graphs of objects can be restored to the same shape as when the original was written. <p> For example to write an object that can be read by the example in ObjectInputStream: <br> <PRE> FileOutputStream ostream = new FileOutputStream("t.tmp"); ObjectOutputStream p = new ObjectOutputStream(ostream); p.writeInt(12345); p.writeObject("Today"); p.writeObject(new Date()); p.flush(); ostream.close(); </PRE> Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures: <p> <PRE> private void readObject(java.io.ObjectInputStream stream) throws IOException ClassNotFoundException; private void writeObject(java.io.ObjectOutputStream stream) throws IOException </PRE><p> The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The method does not need to concern itself with the state belonging to the object's superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput. <p> Serialization does not write out the fields of any object that does not implement the java.io.Serializable interface. Subclasses of Objects that are not serializable can be serializable. In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized. In this case it is the responsibility of the subclass to save and restore the state of the non-serializable class. It is frequently the case that the fields of that class are accessible (public package or protected) or that there are get and set methods that can be used to restore the state. <p> Serialization of an object can be prevented by implementing writeObject and readObject methods that throw the NotSerializableException. The exception will be caught by the ObjectOutputStream and abort the serialization process. Implementing the Externalizable interface allows the object to assume complete control over the contents and format of the object's serialized form. The methods of the Externalizable interface writeExternal and readExternal are called to save and restore the objects state. When implemented by a class they can write and read their own state using all of the methods of ObjectOutput and ObjectInput. It is the responsibility of the objects to handle any versioning that occurs. Primitive data excluding serializable fields and externalizable data is written to the ObjectOutputStream in block-data records. A block data record is composed of a header and data. The block data header consists of a marker and the number of bytes to follow the header. Consecutive primitive data writes are merged into one block-data record. (*) The blocking factor used for a block-data record will be 1024 bytes. (*) Each block-data record will be filled up to 1024 bytes or be written whenever there is a termination of block-data mode. Calls to the ObjectOutputStream methods writeObject defaultWriteObject and writeFields initially terminate any existing block-data record. @author Roger Riggs @version 1.<strike>67</strike><span style="background: #FFFF00">103</span> <strike>03/</strike>02/<strike>98</strike><span style="background: #FFFF00">17/00</span> @see java.io.DataOutput @see java.io.ObjectInputStream @see java.io.Serializable @see java.io.Externalizable @see <a href="../../../guide/serialization/spec/output.doc.html"> Object Serialization Specification Section 2 Object Output Classes</a> @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectOutputStream.PutField!class"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a><br><br><blockquote>Provide programatic access to the persistent fields to be written to ObjectOutput. @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, Object)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, java.lang.Object)" class="hiddenlink">void <b>put(String, Object)</b></a><br><br><blockquote>Put the value of the named Object field into the persistent field.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, boolean)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, boolean)" class="hiddenlink">void <b>put(String, boolean)</b></a><br><br><blockquote>Put the value of the named boolean field into the persistent field.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, byte)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, byte)" class="hiddenlink">void <b>put(String, byte)</b></a><br><br><blockquote>Put the value of the named byte field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, char)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, char)" class="hiddenlink">void <b>put(String, char)</b></a><br><br><blockquote>Put the value of the named char field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, double)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, double)" class="hiddenlink">void <b>put(String, double)</b></a><br><br><blockquote>Put the value of the named double field into the persistent field.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, float)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, float)" class="hiddenlink">void <b>put(String, float)</b></a><br><br><blockquote>Put the value of the named float field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, int)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, int)" class="hiddenlink">void <b>put(String, int)</b></a><br><br><blockquote>Put the value of the named int field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, long)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, long)" class="hiddenlink">void <b>put(String, long)</b></a><br><br><blockquote>Put the value of the named long field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.put(String, short)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.put_changed(java.lang.String, short)" class="hiddenlink">void <b>put(String, short)</b></a><br><br><blockquote>Put the value of the named short field into the persistent fields.<span style="background: #FFFF00"> @param name the name of the serializable field @param value the value to assign to the field</span></blockquote>
<A NAME="java.io.ObjectOutputStream.PutField.dmethod.write(ObjectOutput)"></A><a href="java.io.ObjectOutputStream.PutField.html" class="hiddenlink">Class <b>ObjectOutputStream.PutField</b></a>, <a href="java.io.ObjectOutputStream.PutField.html#java.io.ObjectOutputStream.PutField.write_changed(java.io.ObjectOutput)" class="hiddenlink">void <b>write(ObjectOutput)</b></a><br><br><blockquote>Write the data and fields to the specified ObjectOutput stream.<span style="background: #FFFF00"> @param out the stream to write the data and fields to @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectOutputStream.ctor()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.ctor_changed()" class="hiddenlink">constructor <b>ObjectOutputStream()</b></a><br><br><blockquote>Provide a way for subclasses that are completely reimplementing ObjectOutputStream to not have to allocate private data just used by this implementation of ObjectOutputStream. <p>If there is a security manager installed this method first calls the security manager's <code>checkPermission</code> method with a <code>SerializablePermission("enableSubclassImplementation")</code> permission to ensure it's ok to enable subclassing. @exception IOException Thrown if not called by a subclass. @throws SecurityException if a security manager exists and its <code>checkPermission</code> method denies enabling subclassing. @see SecurityManager#checkPermission @see java.<strike>security</strike><span style="background: #FFFF00">io</span>.SerializablePermission</blockquote>
<A NAME="java.io.ObjectOutputStream.ctor(OutputStream)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.ctor_changed(java.io.OutputStream)" class="hiddenlink">constructor <b>ObjectOutputStream(OutputStream)</b></a><br><br><blockquote>Creates an ObjectOutputStream that writes to the specified OutputStream. The stream header is written to the stream. The caller may want to call flush immediately so that the corresponding ObjectInputStream can read the header immediately. @<span style="background: #FFFF00">param out <code>OutputStream</code> to read from @</span>exception IOException Any exception thrown by the underlying OutputStream.</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.annotateClass(Class)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.annotateClass_changed(java.lang.Class)" class="hiddenlink">void <b>annotateClass(Class)</b></a><br><br><blockquote>Subclasses may implement this method to allow class data to be stored in the stream. By default this method does nothing. The corresponding method in ObjectInputStream is resolveClass. This method is called exactly once for each unique class in the stream. The class name and signature will have already been written to the stream. This method may make free use of the ObjectOutputStream to save any representation of the class it deems suitable (for example the bytes of the class file). The resolveClass method in the corresponding subclass of ObjectInputStream must read and use any data or objects written by annotateClass. @<span style="background: #FFFF00">param cl the class to annotate custom data for @</span>exception IOException Any exception thrown by the underlying OutputStream.</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.defaultWriteObject()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.defaultWriteObject_changed()" class="hiddenlink">void <b>defaultWriteObject()</b></a><br><br><blockquote>Write the non-static and non-transient fields of the current class to this stream. This may only be called from the writeObject method of the class being serialized. It will throw the NotActiveException if it is called otherwise.<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying <code>OutputStream</code></span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.drain()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.drain_changed()" class="hiddenlink">void <b>drain()</b></a><br><br><blockquote>Drain any buffered data in ObjectOutputStream. Similar to flush but does not propagate the flush to the underlaying stream.<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.enableReplaceObject(boolean)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.enableReplaceObject_changed(boolean)" class="hiddenlink">boolean <b>enableReplaceObject(boolean)</b></a><br><br><blockquote>Enable the stream to do replacement of objects in the stream. <p>When enabled the replaceObject method is called for every object being serialized. <p>If <i>enable</i> is true and there is a security manager installed this method first calls the security manager's <code>checkPermission</code> method with a <code>SerializablePermission("enableSubstitution")</code> permission to ensure it's ok to enable the stream to do replacement of objects in the stream. @<span style="background: #FFFF00">param enable boolean parameter to enable replacement of objects @return the previous setting before this method was invoked @</span>throws SecurityException if a security manager exists and its <code>checkPermission</code> method denies enabling the stream to do replacement of objects in the stream. @see SecurityManager#checkPermission @see java.<strike>security</strike><span style="background: #FFFF00">io</span>.SerializablePermission</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.putFields()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.putFields_changed()" class="hiddenlink">PutField <b>putFields()</b></a><br><br><blockquote>Retrieve the object used to buffer persistent fields to be written to the stream. The fields will be written to the stream when writeFields method is called. @<span style="background: #FFFF00">return an instance of the class Putfield that holds the serializable fields @exception IOException if I/O errors occur @</span>since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.replaceObject(Object)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.replaceObject_changed(java.lang.Object)" class="hiddenlink">Object <b>replaceObject(Object)</b></a><br><br><blockquote>This method will allow trusted subclasses of ObjectOutputStream to substitute one object for another during serialization. Replacing objects is disabled until enableReplaceObject is called. The enableReplaceObject method checks that the stream requesting to do replacment can be trusted. <strike>Every reference to serializable</strike><span style="background: #FFFF00">The first occurrence of</span> <strike>objects</strike><span style="background: #FFFF00">each object written into the serialization</span> <span style="background: #FFFF00">stream </span>is passed to replaceObject. <span style="background: #FFFF00">Subsequent references to the object are replaced by the object returned by the original call to replaceObject. </span>To <strike>insure</strike><span style="background: #FFFF00">ensure</span> that the private state of objects is not unintentionally exposed only trusted streams may use replaceObject. <p> <span style="background: #FFFF00">The ObjectOutputStream.writeObject method takes a parameter of type Object (as opposed to type Serializable) to allow for cases where non-serializable objects are replaced by serializable ones. </span>When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored. <p> This method is called only once when each object is first encountered. All subsequent references to the object will be redirected to the new object. This method should return the object to be substituted or the original object. <P> Null can be returned as the object to be substituted but may cause NullReferenceException in classes that contain references to the original object since they may be expecting an object instead of null.<p> @<span style="background: #FFFF00">param obj the object to be replaced @return the alternate object that replaced the specified one @</span>exception IOException Any exception thrown by the underlying OutputStream.</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.reset()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.reset_changed()" class="hiddenlink">void <b>reset()</b></a><br><br><blockquote>Reset will disregard the state of any objects already written to the stream. The state is reset to be the same as a new ObjectOutputStream. The current point in the stream is marked as reset so the corresponding ObjectInputStream will be reset at the same point. Objects previously written to the stream will not be refered to as already being in the stream. They will be written to the stream again.<span style="background: #FFFF00"> @throws IOException if reset() is invoked while serializing an object.</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.useProtocolVersion(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.useProtocolVersion_changed(int)" class="hiddenlink">void <b>useProtocolVersion(int)</b></a><br><br><blockquote>Specify stream protocol version to use when writing the stream.<p> This routine provides a hook to enable the current version of Serialization to write in a format that is backwards compatible to a previous version of the stream format.<p> Every effort will be made to avoid introducing additional backwards incompatibilities; however sometimes there is no other alternative.<p> @param version use ProtocolVersion from java.io.ObjectStreamConstants. @exception IllegalStateException Thrown if called after any objects have been serialized. @exception <strike>IllegalArgument</strike><span style="background: #FFFF00">IllegalArgumentException</span> if invalid version is passed in. @<span style="background: #FFFF00">throws IOException if I/O errors occur @</span>see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1 @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2<span style="background: #FFFF00"> @since 1.2</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.write(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.write_changed(int)" class="hiddenlink">void <b>write(int)</b></a><br><br><blockquote>Writes a byte. This method will block until the byte is actually written. @param <strike>b</strike><span style="background: #FFFF00">data</span> the byte <span style="background: #FFFF00">to be written to the stream </span>@exception IOException If an I/O error has occurred.</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeBoolean(boolean)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeBoolean_changed(boolean)" class="hiddenlink">void <b>writeBoolean(boolean)</b></a><br><br><blockquote>Writes a boolean. @param data the boolean to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeByte(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeByte_changed(int)" class="hiddenlink">void <b>writeByte(int)</b></a><br><br><blockquote>Writes an 8 bit byte. @param data the byte value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeBytes(String)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeBytes_changed(java.lang.String)" class="hiddenlink">void <b>writeBytes(String)</b></a><br><br><blockquote>Writes a String as a sequence of bytes. @param <strike>s</strike><span style="background: #FFFF00">data</span> the String of bytes to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeChar(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeChar_changed(int)" class="hiddenlink">void <b>writeChar(int)</b></a><br><br><blockquote>Writes a 16 bit char. @param data the char value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeChars(String)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeChars_changed(java.lang.String)" class="hiddenlink">void <b>writeChars(String)</b></a><br><br><blockquote>Writes a String as a sequence of chars. @param <strike>s</strike><span style="background: #FFFF00">data</span> the String of chars to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeDouble(double)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeDouble_changed(double)" class="hiddenlink">void <b>writeDouble(double)</b></a><br><br><blockquote>Writes a 64 bit double. @param data the double value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeFields()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeFields_changed()" class="hiddenlink">void <b>writeFields()</b></a><br><br><blockquote>Write the buffered fields to the stream. @<strike>since</strike><span style="background: #FFFF00">throws</span> <strike>JDK1.2</strike><span style="background: #FFFF00">IOException if I/O errors occur while writing to</span> <span style="background: #FFFF00">the underlying stream </span>@<strike>exception</strike><span style="background: #FFFF00">throws</span> NotActiveException Called when a classes writeObject method was not called to write the state of the object.<span style="background: #FFFF00"> @since 1.2</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeFloat(float)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeFloat_changed(float)" class="hiddenlink">void <b>writeFloat(float)</b></a><br><br><blockquote>Writes a 32 bit float. @param data the float value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeInt(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeInt_changed(int)" class="hiddenlink">void <b>writeInt(int)</b></a><br><br><blockquote>Writes a 32 bit int. @param data the integer value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeLong(long)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeLong_changed(long)" class="hiddenlink">void <b>writeLong(long)</b></a><br><br><blockquote>Writes a 64 bit long. @param data the long value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeObjectOverride(Object)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeObjectOverride_changed(java.lang.Object)" class="hiddenlink">void <b>writeObjectOverride(Object)</b></a><br><br><blockquote><span style="background: #FFFF00">Method used by subclasses to override the default writeObject method. </span>This method is called by trusted subclasses of ObjectInputStream that constructed ObjectInputStream using the protected no-arg constructor. The subclass is expected to provide an override method with the modifier "final". @<span style="background: #FFFF00">param obj object to be written to the underlying stream @throws IOException if there are I/O errors while writing to the underlying stream @</span>see #ObjectOutputStream() @see #writeObject(Object) @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeShort(int)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeShort_changed(int)" class="hiddenlink">void <b>writeShort(int)</b></a><br><br><blockquote>Writes a 16 bit short. @param data the short value to be written<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeStreamHeader()"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeStreamHeader_changed()" class="hiddenlink">void <b>writeStreamHeader()</b></a><br><br><blockquote>The writeStreamHeader method is provided so subclasses can append or prepend their own header to the stream. It writes the magic number and version to the stream.<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<A NAME="java.io.ObjectOutputStream.dmethod.writeUTF(String)"></A><a href="java.io.ObjectOutputStream.html" class="hiddenlink">Class <b>ObjectOutputStream</b></a>, <a href="java.io.ObjectOutputStream.html#java.io.ObjectOutputStream.writeUTF_changed(java.lang.String)" class="hiddenlink">void <b>writeUTF(String)</b></a><br><br><blockquote>Primitive data write of this String in UTF format. Note that there is a significant difference between writing a String into the stream as primitive data or as an Object. A String instance written by writeObject is written into the stream as a String initially. Future writeObject() calls write references to the string into the stream. @param <strike>str</strike><span style="background: #FFFF00">s</span> the String in UTF format<span style="background: #FFFF00"> @throws IOException if I/O errors occur while writing to the underlying stream</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectStreamClass!class"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a><br><br><blockquote>Serialization's descriptor for classes. It contains the name and serialVersionUID of the class. <br> The ObjectStreamClass for a specific class loaded in this Java VM can be found/created using the lookup method.<p> The algorithm to compute the SerialVersionUID is described in <a href="../../../guide/serialization/spec/class.doc4.html"> Object Serialization Specification Section 4.4 Stream Unique Identifiers</a>. @author Roger Riggs @version <strike>@(#)ObjectStreamClass.java </strike>1.<strike>45 97</strike><span style="background: #FFFF00">98 02</span>/<strike>08</strike><span style="background: #FFFF00">02</span>/<strike>03</strike><span style="background: #FFFF00">00</span> @see ObjectStreamField @see <a href="../../../guide/serialization/spec/class.doc.html"> Object Serialization Specification Section 4 Class Descriptors</a> @since JDK1.1</blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.forClass()"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.forClass_changed()" class="hiddenlink">Class <b>forClass()</b></a><br><br><blockquote>Return the class in the local VM that this version is mapped to. Null is returned if there is no corresponding local class.<span style="background: #FFFF00"> @return the <code>Class</code> instance that this descriptor represents</span></blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.getField(String)"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.getField_changed(java.lang.String)" class="hiddenlink">ObjectStreamField <b>getField(String)</b></a><br><br><blockquote>Get the field of this class by name. @<span style="background: #FFFF00">param name the name of the data field to look for @</span>return The ObjectStreamField object of the named field or null if there is no such named field.</blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.getFields()"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.getFields_changed()" class="hiddenlink">ObjectStreamField[] <b>getFields()</b></a><br><br><blockquote>Return an array of the fields of this serializable class. @return an array containing an element for each persistent field of this class. Returns an array of length zero if there are no fields. @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.getName()"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.getName_changed()" class="hiddenlink">String <b>getName()</b></a><br><br><blockquote>The name of the class described by this descriptor.<span style="background: #FFFF00"> @return a <code>String</code> representing the fully qualified name of the class</span></blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.getSerialVersionUID()"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.getSerialVersionUID_changed()" class="hiddenlink">long <b>getSerialVersionUID()</b></a><br><br><blockquote>Return the serialVersionUID for this class. The serialVersionUID defines a set of classes all with the same name that have evolved from a common root class and agree to be serialized and deserialized using a common format. NonSerializable classes have a serialVersionUID of 0L.<span style="background: #FFFF00"> @return the SUID of the class described by this descriptor</span></blockquote>
<A NAME="java.io.ObjectStreamClass.dmethod.lookup(Class)"></A><a href="java.io.ObjectStreamClass.html" class="hiddenlink">Class <b>ObjectStreamClass</b></a>, <a href="java.io.ObjectStreamClass.html#java.io.ObjectStreamClass.lookup_changed(java.lang.Class)" class="hiddenlink">ObjectStreamClass <b>lookup(Class)</b></a><br><br><blockquote>Find the descriptor for a class that can be serialized. Creates an ObjectStreamClass instance if one does not exist yet for class. Null is returned if the specified class does not implement java.io.Serializable or java.io.Externalizable.<span style="background: #FFFF00"> @param cl class for which to get the descriptor @return the class descriptor for the specified class</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectStreamConstants!class"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a><br><br><blockquote>Constants written into the Object Serialization Stream. @author unascribed @version 1.<strike>22 07</strike><span style="background: #FFFF00">29 02</span>/<strike>10</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK 1.1</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.PROTOCOL_VERSION_1"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.PROTOCOL_VERSION_1" class="hiddenlink">int <b>PROTOCOL_VERSION_1</b></a><br><br><blockquote>A Stream Protocol Version. <p> All externalizable data is written in JDK 1.1 external data format after calling this method. This version is needed to write streams containing Externalizable data that can be read by pre-JDK 1.1.6 JVMs. @see java.io.ObjectOutputStream#useProtocolVersion(int) @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.PROTOCOL_VERSION_2"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.PROTOCOL_VERSION_2" class="hiddenlink">int <b>PROTOCOL_VERSION_2</b></a><br><br><blockquote>A Stream Protocol Version. <p> This protocol is written by JVM 1.2. Externalizable data is written in block data mode and is terminated with TC_ENDBLOCKDATA. Externalizable classdescriptor flags has SC_BLOCK_DATA enabled. JVM 1.1.6 and greater can read this format change. Enables writing a nonSerializable class descriptor into the stream. The serialVersionUID of a nonSerializable class is set to 0L. @see java.io.ObjectOutputStream#useProtocolVersion(int) @see #SC_BLOCK_DATA @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.SC_BLOCK_DATA"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.SC_BLOCK_DATA" class="hiddenlink">byte <b>SC_BLOCK_DATA</b></a><br><br><blockquote>Bit mask for ObejctStreamClass flag. Indicates Externalizable data written in Block Data mode. Added for PROTOCOL_VERSION_2. @see #PROTOCOL_VERSION_2 @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.SUBCLASS_IMPLEMENTATION_PERMISSION"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.SUBCLASS_IMPLEMENTATION_PERMISSION" class="hiddenlink">SerializablePermission <b>SUBCLASS_IMPLEMENTATION_PERMISSION</b></a><br><br><blockquote>Enable overriding of readObject and writeObject. @see java.io.ObjectOutputStream#writeObjectOverride(Object) @see java.io.ObjectInputStream#readObjectOverride() @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.SUBSTITUTION_PERMISSION"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.SUBSTITUTION_PERMISSION" class="hiddenlink">SerializablePermission <b>SUBSTITUTION_PERMISSION</b></a><br><br><blockquote>Enable substitution of one object for another during serialization/deserialization. @see java.io.ObjectOutputStream#enableReplaceObject(boolean) @see java.io.ObjectInputStream#enableResolveObject(boolean) @since <strike>JDK </strike>1.2</blockquote>
<A NAME="java.io.ObjectStreamConstants.field.TC_ARRAY"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.TC_ARRAY" class="hiddenlink">byte <b>TC_ARRAY</b></a><br><br><blockquote>new Array<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.ObjectStreamConstants.field.TC_OBJECT"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.TC_OBJECT" class="hiddenlink">byte <b>TC_OBJECT</b></a><br><br><blockquote>new Object<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.ObjectStreamConstants.field.TC_STRING"></A><a href="java.io.ObjectStreamConstants.html" class="hiddenlink">Class <b>ObjectStreamConstants</b></a>, <a href="java.io.ObjectStreamConstants.html#java.io.ObjectStreamConstants.TC_STRING" class="hiddenlink">byte <b>TC_STRING</b></a><br><br><blockquote>new String<span style="background: #FFFF00">.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectStreamException!class"></A><a href="java.io.ObjectStreamException.html" class="hiddenlink">Class <b>ObjectStreamException</b></a><br><br><blockquote>Superclass of all exceptions specific to Object Stream classes. @author unascribed @version 1.<strike>7 09</strike><span style="background: #FFFF00">10 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.ObjectStreamException.ctor(String)"></A><a href="java.io.ObjectStreamException.html" class="hiddenlink">Class <b>ObjectStreamException</b></a>, <a href="java.io.ObjectStreamException.html#java.io.ObjectStreamException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>ObjectStreamException(String)</b></a><br><br><blockquote>Create an ObjectStreamException with the specified argument.<span style="background: #FFFF00"> @param classname the detailed message for the exception</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.ObjectStreamField!class"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a><br><br><blockquote>A description of a Serializable field from a Serializable class. An array of ObjectStreamFields is used to declare the Serializable fields of a class. @author Roger Riggs @version 1.<strike>25 04</strike><span style="background: #FFFF00">30 02</span>/<strike>30</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see ObjectStreamClass<span style="background: #FFFF00"> @since 1.2</span></blockquote>
<A NAME="java.io.ObjectStreamField.ctor(String, Class)"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.ctor_changed(java.lang.String, java.lang.Class)" class="hiddenlink">constructor <b>ObjectStreamField(String, Class)</b></a><br><br><blockquote>Create a Serializable field with the specified type. This field should be documented with a <code>serialField</code> tag.<span style="background: #FFFF00"> @param n the name of the serializable field @param clazz the <code>Class</code> object of the serializable field</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.getName()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.getName_changed()" class="hiddenlink">String <b>getName()</b></a><br><br><blockquote>Get the name of this field.<span style="background: #FFFF00"> @return a <code>String</code> representing the name of the serializable field</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.getOffset()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.getOffset_changed()" class="hiddenlink">int <b>getOffset()</b></a><br><br><blockquote>Offset of field within instance data.<span style="background: #FFFF00"> @return the offset of this field @see #setOffset</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.getType()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.getType_changed()" class="hiddenlink">Class <b>getType()</b></a><br><br><blockquote>Get the type of the field.<span style="background: #FFFF00"> @return the <code>Class</code> object of the serializable field</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.getTypeCode()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.getTypeCode_changed()" class="hiddenlink">char <b>getTypeCode()</b></a><br><br><blockquote>Returns character encoding of field type. The encoding is as follows: <blockquote><pre> B byte C char D double F float I int J long L class or interface S short Z boolean [ array </pre></blockquote><span style="background: #FFFF00"> @return the typecode of the serializable field</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.getTypeString()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.getTypeString_changed()" class="hiddenlink">String <b>getTypeString()</b></a><br><br><blockquote>Return the JVM type signature. @<strike>returns</strike><span style="background: #FFFF00">return</span> null if this field has a primitive type.</blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.isPrimitive()"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.isPrimitive_changed()" class="hiddenlink">boolean <b>isPrimitive()</b></a><br><br><blockquote>Return true if this field has a primitive type.<span style="background: #FFFF00"> @return true if and only if this field corresponds to a primitive type</span></blockquote>
<A NAME="java.io.ObjectStreamField.dmethod.setOffset(int)"></A><a href="java.io.ObjectStreamField.html" class="hiddenlink">Class <b>ObjectStreamField</b></a>, <a href="java.io.ObjectStreamField.html#java.io.ObjectStreamField.setOffset_changed(int)" class="hiddenlink">void <b>setOffset(int)</b></a><br><br><blockquote>Offset within instance data.<span style="background: #FFFF00"> @param offset the offset of the field @see #getOffset</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.OutputStream!class"></A><a href="java.io.OutputStream.html" class="hiddenlink">Class <b>OutputStream</b></a><br><br><blockquote>This abstract class is the superclass of all classes representing an output stream of bytes. An output stream accepts output bytes and sends them to some sink. <p> Applications that need to define a subclass of <code>OutputStream</code> must always provide at least a method that writes one byte of output. @author Arthur van Hoff @version 1.<strike>21 04</strike><span style="background: #FFFF00">23 02</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.BufferedOutputStream @see java.io.ByteArrayOutputStream @see java.io.DataOutputStream @see java.io.FilterOutputStream @see java.io.InputStream @see java.io.OutputStream#write(int) @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.OutputStreamWriter!class"></A><a href="java.io.OutputStreamWriter.html" class="hiddenlink">Class <b>OutputStreamWriter</b></a><br><br><blockquote><strike>Write</strike><span style="background: #FFFF00">An</span> <strike>characters to an output</strike><span style="background: #FFFF00">OutputStreamWriter</span> <strike>stream translating characters into bytes according</strike><span style="background: #FFFF00">is a bridge from character streams</span> to <strike>a specified</strike><span style="background: #FFFF00">byte</span> <strike>character</strike><span style="background: #FFFF00">streams:</span> <strike>encoding.</strike><span style="background: #FFFF00">Characters</span> <strike>Each OutputStreamWriter incorporates its own CharToByteConverter and is thus</strike><span style="background: #FFFF00">written to it are translated into bytes according to</span> a <strike>bridge from</strike><span style="background: #FFFF00">specified</span> <a href="../lang/package-summary.html#charenc">character <strike>streams to byte streams</strike><span style="background: #FFFF00">encoding</a></span>. <strike> </strike>The encoding <strike>used by</strike><span style="background: #FFFF00">that</span> <strike>an OutputStreamWriter</strike><span style="background: #FFFF00">it uses</span> may be specified by name <strike>by providing a CharToByteConverter </strike>or <strike>by accepting </strike>the <span style="background: #FFFF00">platform's </span>default encoding <strike>which is defined by the system</strike><span style="background: #FFFF00">may</span> <strike>property</strike><span style="background: #FFFF00">be</span> <strike>file.encoding</strike><span style="background: #FFFF00">accepted</span>. <p> Each invocation of a write() method causes the encoding converter to be invoked on the given character(s). The resulting bytes are accumulated in a buffer before being written to the underlying output stream. The size of this buffer may be specified but by default it is large enough for most purposes. Note that the characters passed to the write() methods are not buffered. <p><span style="background: #FFFF00"> </span>For top efficiency consider wrapping an OutputStreamWriter within a BufferedWriter so as to avoid frequent converter invocations. For example<span style="background: #FFFF00">:</span> <pre> Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); </pre> @see BufferedWriter @see OutputStream @<span style="background: #FFFF00">see <a href="../lang/package-summary.html#charenc">Character encodings</a> @</span>version 1.<strike>10 97</strike><span style="background: #FFFF00">28 02</span>/<strike>01</strike><span style="background: #FFFF00">02</span>/<strike>27</strike><span style="background: #FFFF00">00</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.OutputStreamWriter.ctor(OutputStream, String)"></A><a href="java.io.OutputStreamWriter.html" class="hiddenlink">Class <b>OutputStreamWriter</b></a>, <a href="java.io.OutputStreamWriter.html#java.io.OutputStreamWriter.ctor_changed(java.io.OutputStream, java.lang.String)" class="hiddenlink">constructor <b>OutputStreamWriter(OutputStream, String)</b></a><br><br><blockquote>Create an OutputStreamWriter that uses the named character encoding. @param out An OutputStream @param enc <strike>Name of the encoding to</strike><span style="background: #FFFF00">The name of a supported</span> <strike>be</strike><a href="../lang/package-summary.html#charenc"><span style="background: #FFFF00">character</span> <strike>used</strike><span style="background: #FFFF00">encoding</a></span> @exception UnsupportedEncodingException If the named encoding is not supported</blockquote>
<A NAME="java.io.OutputStreamWriter.dmethod.getEncoding()"></A><a href="java.io.OutputStreamWriter.html" class="hiddenlink">Class <b>OutputStreamWriter</b></a>, <a href="java.io.OutputStreamWriter.html#java.io.OutputStreamWriter.getEncoding_changed()" class="hiddenlink">String <b>getEncoding()</b></a><br><br><blockquote>Returns the canonical name of the character encoding being used by this stream. If this <code>OutputStreamWriter</code> was created with the <A HREF="http://java.sun.com/j2se/1.3/docs/api/#OutputStreamWriter(OutputStream.html" target="_top">String)</A> constructor <span style="background: #FFFF00">then </span>the returned encoding name being canonical may differ from the encoding name passed to the constructor. May return <code>null</code> if the stream has been closed.<span style="background: #FFFF00"> @return a String representing the encoding name or possibly <code>null</code> if the stream has been closed @see <a href="../lang/package-summary.html#charenc">Character encodings</a></span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PipedInputStream!class"></A><a href="java.io.PipedInputStream.html" class="hiddenlink">Class <b>PipedInputStream</b></a><br><br><blockquote>A piped input stream should be connected to a piped output stream; the piped input stream then provides whatever data bytes are written to the piped output stream. Typically data is read from a <code>PipedInputStream</code> object by one thread and data is written to the corresponding <code>PipedOutputStream</code> by some other thread. Attempting to use both objects from a single thread is not recommended as it may deadlock the thread. The piped input stream contains a buffer decoupling read operations from write operations within limits. @author James Gosling @version 1.<strike>28 07</strike><span style="background: #FFFF00">30 02</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.PipedOutputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PipedOutputStream!class"></A><a href="java.io.PipedOutputStream.html" class="hiddenlink">Class <b>PipedOutputStream</b></a><br><br><blockquote>A piped output stream can be connected to a piped input stream to create a communications pipe. The piped output stream is the sending end of the pipe. Typically data is written to a <code>PipedOutputStream</code> object by one thread and data is read from the connected <code>PipedInputStream</code> by some other thread. Attempting to use both objects from a single thread is not recommended as it may deadlock the thread. @author James Gosling @version 1.<strike>21 04</strike><span style="background: #FFFF00">23 02</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.PipedInputStream @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PipedReader!class"></A><a href="java.io.PipedReader.html" class="hiddenlink">Class <b>PipedReader</b></a><br><br><blockquote>Piped character-input streams. @version 1.<strike>10 98</strike><span style="background: #FFFF00">12 00</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>07</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PipedWriter!class"></A><a href="java.io.PipedWriter.html" class="hiddenlink">Class <b>PipedWriter</b></a><br><br><blockquote>Piped character-output streams. @version 1.<strike>10 98</strike><span style="background: #FFFF00">13 00</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>07</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PrintStream!class"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a><br><br><blockquote>A <code>PrintStream</code> adds functionality to another output stream namely the ability to print representations of various data values conveniently. Two other features are provided as well. Unlike other output streams a <code>PrintStream</code> never throws an <code>IOException</code>; instead exceptional situations merely set an internal flag that can be tested via the <code>checkError</code> method. Optionally a <code>PrintStream</code> can be created so as to flush automatically; this means that the <code>flush</code> method is automatically invoked after a byte array is written one of the <code>println</code> methods is invoked or a newline character or byte (<code>'\n'</code>) is written. <p> All characters printed by a <code>PrintStream</code> are converted into bytes using the platform's default character encoding. The <code{@link PrintWriter}</code> class should be used in situations that require writing characters rather than bytes. @version 1.<strike>18 98</strike><span style="background: #FFFF00">21 00</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>31</strike><span style="background: #FFFF00">02</span> @author Frank Yellin @author Mark Reinhold @since JDK1.0</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(Object)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(java.lang.Object)" class="hiddenlink">void <b>print(Object)</b></a><br><br><blockquote>Print an object. The string produced by the <code>{@link java.lang.String#valueOf(Object)}</code> method is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param obj The <code>Object</code> to be printed @see java.lang.Object#toString()</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(String)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(java.lang.String)" class="hiddenlink">void <b>print(String)</b></a><br><br><blockquote>Print a string. If the argument is <code>null</code> then the string <code>"null"</code> is printed. Otherwise the string's characters are converted into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param s The <code>String</code> to be printed</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(boolean)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(boolean)" class="hiddenlink">void <b>print(boolean)</b></a><br><br><blockquote>Print a boolean value. The string produced by <code>{@link java.lang.String#valueOf(boolean)}</code> is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param b The <code>boolean</code> to be printed</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(char)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(char)" class="hiddenlink">void <b>print(char)</b></a><br><br><blockquote>Print a character. The character is translated into one or more bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param c The <code>char</code> to be printed</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(char[])"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(char[])" class="hiddenlink">void <b>print(char[])</b></a><br><br><blockquote>Print an array of characters. The characters are converted into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param s The array of chars to be printed @throws NullPointerException If <code>s</code> is <code>null</code></blockquote>
<A NAME="java.io.PrintStream.dmethod.print(double)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(double)" class="hiddenlink">void <b>print(double)</b></a><br><br><blockquote>Print a double-precision floating-point number. The string produced by <code>{@link java.lang.String#valueOf(double)}</code> is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param d The <code>double</code> to be printed @see java.lang.Double#toString(double)</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(float)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(float)" class="hiddenlink">void <b>print(float)</b></a><br><br><blockquote>Print a floating-point number. The string produced by <code>{@link java.lang.String#valueOf(float)}</code> is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param f The <code>float</code> to be printed @see java.lang.Float#toString(float)</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(int)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(int)" class="hiddenlink">void <b>print(int)</b></a><br><br><blockquote>Print an integer. The string produced by <code>{@link java.lang.String#valueOf(int)}</code> is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param i The <code>int</code> to be printed @see java.lang.Integer#toString(int)</blockquote>
<A NAME="java.io.PrintStream.dmethod.print(long)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.print_changed(long)" class="hiddenlink">void <b>print(long)</b></a><br><br><blockquote>Print a long integer. The string produced by <code>{@link java.lang.String#valueOf(long)}</code> is translated into bytes according to the platform's default character encoding and these bytes are written in exactly the manner of the <code>{@link #write(int)}</code> method. @param l The <code>long</code> to be printed @see java.lang.Long#toString(long)</blockquote>
<A NAME="java.io.PrintStream.dmethod.println(Object)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(java.lang.Object)" class="hiddenlink">void <b>println(Object)</b></a><br><br><blockquote>Print an Object and then terminate the line. This method behaves as though it invokes <code>{@link #print(Object)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>Object</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(String)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(java.lang.String)" class="hiddenlink">void <b>println(String)</b></a><br><br><blockquote>Print a String and then terminate the line. This method behaves as though it invokes <code>{@link #print(String)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>String</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(boolean)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(boolean)" class="hiddenlink">void <b>println(boolean)</b></a><br><br><blockquote>Print a boolean and then terminate the line. This method behaves as though it invokes <code>{@link #print(boolean)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>boolean</code> to be printed</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(char)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(char)" class="hiddenlink">void <b>println(char)</b></a><br><br><blockquote>Print a character and then terminate the line. This method behaves as though it invokes <code>{@link #print(char)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>char</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(char[])"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(char[])" class="hiddenlink">void <b>println(char[])</b></a><br><br><blockquote>Print an array of characters and then terminate the line. This method behaves as though it invokes <code>{@link #print(char[])}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x an array of chars to print.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(double)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(double)" class="hiddenlink">void <b>println(double)</b></a><br><br><blockquote>Print a double and then terminate the line. This method behaves as though it invokes <code>{@link #print(double)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>double</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(float)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(float)" class="hiddenlink">void <b>println(float)</b></a><br><br><blockquote>Print a float and then terminate the line. This method behaves as though it invokes <code>{@link #print(float)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>float</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(int)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(int)" class="hiddenlink">void <b>println(int)</b></a><br><br><blockquote>Print an integer and then terminate the line. This method behaves as though it invokes <code>{@link #print(int)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x The <code>int</code> to be printed.</span></blockquote>
<A NAME="java.io.PrintStream.dmethod.println(long)"></A><a href="java.io.PrintStream.html" class="hiddenlink">Class <b>PrintStream</b></a>, <a href="java.io.PrintStream.html#java.io.PrintStream.println_changed(long)" class="hiddenlink">void <b>println(long)</b></a><br><br><blockquote>Print a long and then terminate the line. This method behaves as though it invokes <code>{@link #print(long)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x a The <code>long</code> to be printed.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PrintWriter!class"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a><br><br><blockquote>Print formatted representations of objects to a text-output stream. This class implements all of the print methods found in PrintStream. It does not contain methods for writing raw bytes for which a program should use unencoded byte streams. <p> Unlike the PrintStream class if automatic flushing is enabled it will be done only when one of the println() methods is invoked rather than whenever a newline character happens to be output. The println() methods use the platform's own notion of line separator rather than the newline character. <p> Methods in this class never throw I/O exceptions. The client may inquire as to whether any errors have occurred by invoking checkError(). @version 1.<strike>19 98</strike><span style="background: #FFFF00">24 02</span>/<strike>06</strike><span style="background: #FFFF00">02</span>/<strike>29</strike><span style="background: #FFFF00">00</span> @author Frank Yellin @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(Object)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(java.lang.Object)" class="hiddenlink">void <b>println(Object)</b></a><br><br><blockquote>Print an Object and then terminate the line. This method behaves as though it invokes <code>{@link #print(Object)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>Object</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(String)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(java.lang.String)" class="hiddenlink">void <b>println(String)</b></a><br><br><blockquote>Print a String and then terminate the line. This method behaves as though it invokes <code>{@link #print(String)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>String</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(boolean)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(boolean)" class="hiddenlink">void <b>println(boolean)</b></a><br><br><blockquote>Print a boolean value and then terminate the line. This method behaves as though it invokes <code>{@link #print(boolean)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>boolean</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(char)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(char)" class="hiddenlink">void <b>println(char)</b></a><br><br><blockquote>Print a character and then terminate the line. This method behaves as though it invokes <code>{@link #print(char)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>char</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(char[])"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(char[])" class="hiddenlink">void <b>println(char[])</b></a><br><br><blockquote>Print an array of characters and then terminate the line. This method behaves as though it invokes <code>{@link #print(char[])}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the array of <code>char</code> values to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(double)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(double)" class="hiddenlink">void <b>println(double)</b></a><br><br><blockquote>Print a double-precision floating-point number and then terminate the line. This method behaves as though it invokes <code>{@link #print(double)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>double</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(float)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(float)" class="hiddenlink">void <b>println(float)</b></a><br><br><blockquote>Print a floating-point number and then terminate the line. This method behaves as though it invokes <code>{@link #print(float)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>float</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(int)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(int)" class="hiddenlink">void <b>println(int)</b></a><br><br><blockquote>Print an integer and then terminate the line. This method behaves as though it invokes <code>{@link #print(int)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>int</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.dmethod.println(long)"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.println_changed(long)" class="hiddenlink">void <b>println(long)</b></a><br><br><blockquote>Print a long integer and then terminate the line. This method behaves as though it invokes <code>{@link #print(long)}</code> and then <code>{@link #println()}</code>.<span style="background: #FFFF00"> @param x the <code>long</code> value to be printed</span></blockquote>
<A NAME="java.io.PrintWriter.field.out"></A><a href="java.io.PrintWriter.html" class="hiddenlink">Class <b>PrintWriter</b></a>, <a href="java.io.PrintWriter.html#java.io.PrintWriter.out" class="hiddenlink">Writer <b>out</b></a><br><br><blockquote>The underlying character-output stream of this <code>PrintWriter</code>. @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PushbackInputStream!class"></A><a href="java.io.PushbackInputStream.html" class="hiddenlink">Class <b>PushbackInputStream</b></a><br><br><blockquote>A <code>PushbackInputStream</code> adds functionality to another input stream namely the ability to "push back" or "unread" one byte. This is useful in situations where it is convenient for a fragment of code to read an indefinite number of data bytes that are delimited by a particular byte value; after reading the terminating byte the code fragment can "unread" it so that the next read operation on the input stream will reread the byte that was pushed back. For example bytes representing the characters constituting an identifier might be terminated by a byte representing an operator character; a method whose job is to read just an identifier can read until it sees the operator and then push the operator back to be re-read. @author David Connelly @author Jonathan Payne @version 1.<strike>25 04</strike><span style="background: #FFFF00">31 02</span>/<strike>30</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<A NAME="java.io.PushbackInputStream.dmethod.skip(long)"></A><a href="java.io.PushbackInputStream.html" class="hiddenlink">Class <b>PushbackInputStream</b></a>, <a href="java.io.PushbackInputStream.html#java.io.PushbackInputStream.skip_changed(long)" class="hiddenlink">long <b>skip(long)</b></a><br><br><blockquote>Skips over and discards <code>n</code> bytes of data from this input stream. The <code>skip</code> method may for a variety of reasons end up skipping over some smaller number of bytes possibly zero. If <code>n</code> is negative no bytes are skipped. <p> The <code>skip</code> method of <code>PushbackInputStream</code> first skips over the bytes in the pushback buffer if any. It then calls the <code>skip</code> method of the underlying input stream if more bytes need to be skipped. The actual number of bytes skipped is returned. @param n the number of bytes to be skipped. @return the actual number of bytes skipped. @exception IOException if an I/O error occurs. @see java.io.FilterInputStream#in @see java.io.InputStream#skip(long n) @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.PushbackReader!class"></A><a href="java.io.PushbackReader.html" class="hiddenlink">Class <b>PushbackReader</b></a><br><br><blockquote>A character-stream reader that allows characters to be pushed back into the stream. @version 1.<strike>12 98</strike><span style="background: #FFFF00">14 00</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>07</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.RandomAccessFile!class"></A><a href="java.io.RandomAccessFile.html" class="hiddenlink">Class <b>RandomAccessFile</b></a><br><br><blockquote>Instances of this class support both reading and writing to a random access file. A random access file behaves like a large array of bytes stored in the file system. There is a kind of cursor or index into the implied array called the <em>file pointer</em>; input operations read bytes starting at the file pointer and advance the file pointer past the bytes read. If the random access file is created in read/write mode then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written. Output operations that write past the current end of the implied array cause the array to be extended. The file pointer can be read by the <code>getFilePointer</code> method and set by the <code>seek</code> method. <p> It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read an <code>EOFException</code> (which is a kind of <code>IOException</code>) is thrown. If any byte cannot be read for any reason other than end-of-file an <code>IOException</code> other than <code>EOFException</code> is thrown. In particular an <code>IOException</code> may be thrown if the stream has been closed. @author unascribed @version 1.<strike>50 09</strike><span style="background: #FFFF00">56 02</span>/<strike>24</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<A NAME="java.io.RandomAccessFile.dmethod.setLength(long)"></A><a href="java.io.RandomAccessFile.html" class="hiddenlink">Class <b>RandomAccessFile</b></a>, <a href="java.io.RandomAccessFile.html#java.io.RandomAccessFile.setLength_changed(long)" class="hiddenlink">void <b>setLength(long)</b></a><br><br><blockquote>Sets the length of this file. <p> If the present length of the file as returned by the <code>length</code> method is greater than the <code>newLength</code> argument then the file will be truncated. In this case if the file offset as returned by the <code>getFilePointer</code> method is greater then <code>newLength</code> then after this method returns the offset will be equal to <code>newLength</code>. <p> If the present length of the file as returned by the <code>length</code> method is smaller than the <code>newLength</code> argument then the file will be extended. In this case the contents of the extended portion of the file are not defined. @param newLength The desired length of the file @exception IOException If an I/O error occurs @since <strike>JDK1</strike><span style="background: #FFFF00">1</span>.2</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.Reader!class"></A><a href="java.io.Reader.html" class="hiddenlink">Class <b>Reader</b></a><br><br><blockquote>Abstract class for reading character streams. The only methods that a subclass must implement are read(char[] int int) and close(). Most subclasses however will override some of the methods defined here in order to provide higher efficiency additional functionality or both. @see BufferedReader @see LineNumberReader @see CharArrayReader @see InputStreamReader @see FileReader @see FilterReader @see PushbackReader @see PipedReader @see StringReader @see Writer @version 1.<strike>16 98</strike><span style="background: #FFFF00">21 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.Reader.ctor(Object)"></A><a href="java.io.Reader.html" class="hiddenlink">Class <b>Reader</b></a>, <a href="java.io.Reader.html#java.io.Reader.ctor_changed(java.lang.Object)" class="hiddenlink">constructor <b>Reader(Object)</b></a><br><br><blockquote>Create a new character-stream reader whose critical sections will synchronize on the given object.<span style="background: #FFFF00"> @param lock The Object to synchronize on.</span></blockquote>
<A NAME="java.io.Reader.dmethod.markSupported()"></A><a href="java.io.Reader.html" class="hiddenlink">Class <b>Reader</b></a>, <a href="java.io.Reader.html#java.io.Reader.markSupported_changed()" class="hiddenlink">boolean <b>markSupported()</b></a><br><br><blockquote>Tell whether this stream supports the mark() operation.<span style="background: #FFFF00"> The default implementation always returns false. Subclasses should override this method. @return true if and only if this stream supports the mark operation.</span></blockquote>
<A NAME="java.io.Reader.dmethod.read()"></A><a href="java.io.Reader.html" class="hiddenlink">Class <b>Reader</b></a>, <a href="java.io.Reader.html#java.io.Reader.read_changed()" class="hiddenlink">int <b>read()</b></a><br><br><blockquote>Read a single character. This method will block until a character is available an I/O error occurs or the end of the stream is reached. <p> Subclasses that intend to support efficient single-character input should override this method. @return The character read as an integer in the range 0 to <strike>16383</strike><span style="background: #FFFF00">65535</span> (<tt>0x00-0xffff</tt>) or -1 if the end of the stream has been reached @exception IOException If an I/O error occurs</blockquote>
<A NAME="java.io.Reader.dmethod.skip(long)"></A><a href="java.io.Reader.html" class="hiddenlink">Class <b>Reader</b></a>, <a href="java.io.Reader.html#java.io.Reader.skip_changed(long)" class="hiddenlink">long <b>skip(long)</b></a><br><br><blockquote>Skip characters. This method will block until some characters are available an I/O error occurs or the end of the stream is reached. @param n The number of characters to skip @return The number of characters actually skipped @exception <span style="background: #FFFF00">IllegalArgumentException If <code>n</code> is negative. @exception </span>IOException If an I/O error occurs</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.SequenceInputStream!class"></A><a href="java.io.SequenceInputStream.html" class="hiddenlink">Class <b>SequenceInputStream</b></a><br><br><blockquote>A <code>SequenceInputStream</code> represents the logical concatenation of other input streams. It starts out with an ordered collection of input streams and reads from the first one until end of file is reached whereupon it reads from the second one and so on until end of file is reached on the last of the contained input streams. @author Author van Hoff @version 1.<strike>20 06</strike><span style="background: #FFFF00">23 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.0</blockquote>
<A NAME="java.io.SequenceInputStream.dmethod.read(byte[], int, int)"></A><a href="java.io.SequenceInputStream.html" class="hiddenlink">Class <b>SequenceInputStream</b></a>, <a href="java.io.SequenceInputStream.html#java.io.SequenceInputStream.read_changed(byte[], int, int)" class="hiddenlink">int <b>read(byte[], int, int)</b></a><br><br><blockquote>Reads up to <code>len</code> bytes of data from this input stream into an array of bytes. This method blocks until at least 1 byte of input is available. If the first argument is <code>null</code> up to <code>len</code> bytes are read and discarded. <p> The <code>read</code> method of <code>SequenceInputStream</code> tries to read the data from the current substream. If it fails to read any characters because the substream has reached the end of the stream it calls the <code>close</code> method of the current substream and begins reading from the next substream. @param b the buffer into which the data is read. @param off the start offset of the data. @param len the maximum number of bytes read. @<span style="background: #FFFF00">return int the number of bytes read. @</span>exception IOException if an I/O error occurs.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.Serializable!class"></A><a href="java.io.Serializable.html" class="hiddenlink">Class <b>Serializable</b></a><br><br><blockquote>Serializability of a class is enabled by the class implementing the java.io.Serializable interface. Classes that do not implement this interface will not have any of their state serialized or deserialized. All subtypes of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves only to identify the semantics of being serializable. <p> To allow subtypes of non-serializable classes to be serialized the subtype may assume responsibility for saving and restoring the state of the supertype's public protected and (if accessible) package fields. The subtype may assume this responsibility only if the class it extends has an accessible no-arg constructor to initialize the class's state. It is an error to declare a class Serializable in this case. The error will be detected at runtime. <p> During deserialization the fields of non-serializable classes will be initialized using the public or protected no-arg constructor of the class. A no-arg constructor must be accessible to the subclass that is serializable. The fields of serializable subclasses will be restored from the stream. <p> When traversing a graph an object may be encountered that does not support the Serializable interface. In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object. <p> Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures: <p> <PRE> private void writeObject(java.io.ObjectOutputStream out) throws IOException private void readObject(java.io.ObjectInputStream in) throws IOException ClassNotFoundException; </PRE><p> The writeObject method is responsible for writing the state of the object for its particular class so that the corresponding readObject method can restore it. The default mechanism for saving the Object's fields can be invoked by calling out.defaultWriteObject. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput. <p> The readObject method is responsible for reading from the stream and restoring the classes fields. It may call in.defaultReadObject to invoke the default mechanism for restoring the object's non-static and non-transient fields. The defaultReadObject method uses information in the stream to assign the fields of the object saved in the stream with the correspondingly named fields in the current object. This handles the case when the class has evolved to add new fields. The method does not need to concern itself with the state belonging to its superclasses or subclasses. State is saved by writing the individual fields to the ObjectOutputStream using the writeObject method or by using the methods for primitive data types supported by DataOutput. <p> Serializable classes that need to designate an alternative object to be used when writing an object to the stream should implement this special method with the exact signature: <p> <PRE> ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException; </PRE><p> This writeReplace method is invoked by serialization if the method exists and it would be accessible from a method defined within the class of the object being serialized. Thus the method can have private protected and package-private access. Subclass access to this method follows java accessibility rules. <p> Classes that need to designate a replacement when an instance of it is read from the stream should implement this special method with the exact signatute.<p> <PRE> ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; </PRE><p> This readResolve method follows the same invocation rules and accessibility rules as writeReplace. @author unascribed @version 1.<strike>14 04</strike><span style="background: #FFFF00">16 02</span>/<strike>22</strike><span style="background: #FFFF00">02</span>/<strike>99</strike><span style="background: #FFFF00">00</span> @see java.io.ObjectOutputStream @see java.io.ObjectInputStream @see java.io.ObjectOutput @see java.io.ObjectInput @see java.io.Externalizable @since JDK1.1</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.SerializablePermission!class"></A><a href="java.io.SerializablePermission.html" class="hiddenlink">Class <b>SerializablePermission</b></a><br><br><blockquote>This class is for Serializable permissions. A SerializablePermission contains a name (also referred to as a "target name") but no actions list; you either have the named permission or you don't. <P> The target name is the name of the Serializable permission (see below). <P> The following table lists all the possible SerializablePermission target names and for each provides a description of what the permission allows and a discussion of the risks of granting code the permission. <P> <table border=1 cellpadding=5> <tr> <th>Permission Target Name</th> <th>What the Permission Allows</th> <th>Risks of Allowing this Permission</th> </tr> <tr> <td>enableSubclassImplementation</td> <td>Subclass implementation of ObjectOutputStream or ObjectInputStream to override the default serialization or deserialization respectively of objects</td> <td>Code can use this to serialize or deserialize classes in a purposefully malfeasant manner. For example during serialization malicious code can use this to purposefully store confidential private field data in a way easily accessible to attackers. Or during deserializaiton it could for example deserialize a class with all its private fields zeroed out.</td> </tr> <tr> <td>enableSubstitution</td> <td>Substitution of one object for another during serialization or deserialization</td> <td>This is dangerous because malicious code can replace the actual object with one which has incorrect or malignant data.</td> </tr> </table> @see java.security.BasicPermission @see java.security.Permission @see java.security.Permissions @see java.security.PermissionCollection @see java.lang.SecurityManager @version 1.<strike>2</strike><span style="background: #FFFF00">13 02/02/00</span> @author Joe Fialli<span style="background: #FFFF00"> @since 1.2</span></blockquote>
<A NAME="java.io.SerializablePermission.ctor(String, String)"></A><a href="java.io.SerializablePermission.html" class="hiddenlink">Class <b>SerializablePermission</b></a>, <a href="java.io.SerializablePermission.html#java.io.SerializablePermission.ctor_changed(java.lang.String, java.lang.String)" class="hiddenlink">constructor <b>SerializablePermission(String, String)</b></a><br><br><blockquote>Creates a new SerializablePermission object with the specified name. The name is the symbolic name of the SerializablePermission and the actions String is currently unused and should be null. This constructor exists for use by the <code>Policy</code> object to instantiate new Permission objects. @param name the name of the SerializablePermission.<span style="background: #FFFF00"> @param actions currently unused and must be set to null</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.StreamCorruptedException!class"></A><a href="java.io.StreamCorruptedException.html" class="hiddenlink">Class <b>StreamCorruptedException</b></a><br><br><blockquote>Thrown when control information that was read from an object stream violates internal consistency checks. @author unascribed @version 1.<strike>8 06</strike><span style="background: #FFFF00">11 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.StreamCorruptedException.ctor(String)"></A><a href="java.io.StreamCorruptedException.html" class="hiddenlink">Class <b>StreamCorruptedException</b></a>, <a href="java.io.StreamCorruptedException.html#java.io.StreamCorruptedException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>StreamCorruptedException(String)</b></a><br><br><blockquote>Create a StreamCorruptedException and list a reason why thrown.<span style="background: #FFFF00"> @param reason String describing the reason for the exception.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.StreamTokenizer!class"></A><a href="java.io.StreamTokenizer.html" class="hiddenlink">Class <b>StreamTokenizer</b></a><br><br><blockquote>The <code>StreamTokenizer</code> class takes an input stream and parses it into "tokens" allowing the tokens to be read one at a time. The parsing process is controlled by a table and a number of flags that can be set to various states. The stream tokenizer can recognize identifiers numbers quoted strings and various comment styles. <p> Each byte read from the input stream is regarded as a character in the range <code>'&#92;u0000'</code> through <code>'&#92;u00FF'</code>. The character value is used to look up five possible attributes of the character: <i>white space</i> <i>alphabetic</i> <i>numeric</i> <i>string quote</i> and <i>comment character</i>. Each character can have zero or more of these attributes. <p> In addition an instance has four flags. These flags indicate: <ul> <li>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens. <li>Whether C-style comments are to be recognized and skipped. <li>Whether C++-style comments are to be recognized and skipped. <li>Whether the characters of identifiers are converted to lowercase. </ul> <p> A typical application first constructs an instance of this class sets up the syntax tables and then repeatedly loops calling the <code>nextToken</code> method in each iteration of the loop until it returns the value <code>TT_EOF</code>. @author James Gosling @version 1.<strike>31 04</strike><span style="background: #FFFF00">36 02</span>/<strike>22</strike><span style="background: #FFFF00">02</span>/<strike>99</strike><span style="background: #FFFF00">00</span> @see java.io.StreamTokenizer#nextToken() @see java.io.StreamTokenizer#TT_EOF @since JDK1.0</blockquote>
<A NAME="java.io.StreamTokenizer.ctor(Reader)"></A><a href="java.io.StreamTokenizer.html" class="hiddenlink">Class <b>StreamTokenizer</b></a>, <a href="java.io.StreamTokenizer.html#java.io.StreamTokenizer.ctor_changed(java.io.Reader)" class="hiddenlink">constructor <b>StreamTokenizer(Reader)</b></a><br><br><blockquote>Create a tokenizer that parses the given character stream. @<span style="background: #FFFF00">param r a Reader object providing the input stream. @</span>since JDK1.1</blockquote>
<A NAME="java.io.StreamTokenizer.field.nval"></A><a href="java.io.StreamTokenizer.html" class="hiddenlink">Class <b>StreamTokenizer</b></a>, <a href="java.io.StreamTokenizer.html#java.io.StreamTokenizer.nval" class="hiddenlink">double <b>nval</b></a><br><br><blockquote>If the current token is a number this field contains the value of that number. The current token is a number when the value of the <code>ttype</code> field is <code>TT_NUMBER</code>. <p><span style="background: #FFFF00"> The initial value of this field is 0.0. </span>@see java.io.StreamTokenizer#TT_NUMBER @see java.io.StreamTokenizer#ttype</blockquote>
<A NAME="java.io.StreamTokenizer.field.sval"></A><a href="java.io.StreamTokenizer.html" class="hiddenlink">Class <b>StreamTokenizer</b></a>, <a href="java.io.StreamTokenizer.html#java.io.StreamTokenizer.sval" class="hiddenlink">String <b>sval</b></a><br><br><blockquote>If the current token is a word token this field contains a string giving the characters of the word token. When the current token is a quoted string token this field contains the body of the string. <p> The current token is a word when the value of the <code>ttype</code> field is <code>TT_WORD</code>. The current token is a quoted string token when the value of the <code>ttype</code> field is a quote character. <p><span style="background: #FFFF00"> The initial value of this field is null. </span>@see java.io.StreamTokenizer#quoteChar(int) @see java.io.StreamTokenizer#TT_WORD @see java.io.StreamTokenizer#ttype</blockquote>
<A NAME="java.io.StreamTokenizer.field.ttype"></A><a href="java.io.StreamTokenizer.html" class="hiddenlink">Class <b>StreamTokenizer</b></a>, <a href="java.io.StreamTokenizer.html#java.io.StreamTokenizer.ttype" class="hiddenlink">int <b>ttype</b></a><br><br><blockquote>After a call to the <code>nextToken</code> method this field contains the type of the token just read. For a single character token its value is the single character converted to an integer. For a quoted string token (see its value is the quote character. Otherwise its value is one of the following: <ul> <li><code>TT_WORD</code> indicates that the token is a word. <li><code>TT_NUMBER</code> indicates that the token is a number. <li><code>TT_EOL</code> indicates that the end of line has been read. The field can only have this value if the <code>eolIsSignificant</code> method has been called with the argument <code>true</code>. <li><code>TT_EOF</code> indicates that the end of the input stream has been reached. </ul> <p><span style="background: #FFFF00"> The initial value of this field is -4. </span>@see java.io.StreamTokenizer#eolIsSignificant(boolean) @see java.io.StreamTokenizer#nextToken() @see java.io.StreamTokenizer#quoteChar(int) @see java.io.StreamTokenizer#TT_EOF @see java.io.StreamTokenizer#TT_EOL @see java.io.StreamTokenizer#TT_NUMBER @see java.io.StreamTokenizer#TT_WORD</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.StringBufferInputStream!class"></A><a href="java.io.StringBufferInputStream.html" class="hiddenlink">Class <b>StringBufferInputStream</b></a><br><br><blockquote>This class allows an application to create an input stream in which the bytes read are supplied by the contents of a string. Applications can also read bytes from a byte array by using a <code>ByteArrayInputStream</code>. <p> Only the low eight bits of each character in the string are used by this class. @author Arthur van Hoff @version 1.<strike>20 06</strike><span style="background: #FFFF00">22 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.ByteArrayInputStream @see java.io.StringReader @since JDK1.0 @deprecated This class does not properly convert characters into bytes. As of JDK&nbsp;1.1 the preferred way to create a stream from a string is via the <code>StringReader</code> class.</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.StringReader!class"></A><a href="java.io.StringReader.html" class="hiddenlink">Class <b>StringReader</b></a><br><br><blockquote>A character stream whose source is a string. @version 1.<strike>12 98</strike><span style="background: #FFFF00">15 00</span>/<strike>07</strike><span style="background: #FFFF00">02</span>/<strike>08</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.StringReader.ctor(String)"></A><a href="java.io.StringReader.html" class="hiddenlink">Class <b>StringReader</b></a>, <a href="java.io.StringReader.html#java.io.StringReader.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>StringReader(String)</b></a><br><br><blockquote>Create a new string reader.<span style="background: #FFFF00"> @param s String providing the character stream.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.StringWriter!class"></A><a href="java.io.StringWriter.html" class="hiddenlink">Class <b>StringWriter</b></a><br><br><blockquote>A character stream that collects its output in a string buffer which can then be used to construct a string. @version 1.<strike>15 98</strike><span style="background: #FFFF00">18 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>30</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.StringWriter.ctor(int)"></A><a href="java.io.StringWriter.html" class="hiddenlink">Class <b>StringWriter</b></a>, <a href="java.io.StringWriter.html#java.io.StringWriter.ctor_changed(int)" class="hiddenlink">constructor <b>StringWriter(int)</b></a><br><br><blockquote>Create a new string writer using the specified initial string-buffer size.<span style="background: #FFFF00"> @param initialSize an int specifying the initial size of the buffer.</span></blockquote>
<A NAME="java.io.StringWriter.dmethod.getBuffer()"></A><a href="java.io.StringWriter.html" class="hiddenlink">Class <b>StringWriter</b></a>, <a href="java.io.StringWriter.html#java.io.StringWriter.getBuffer_changed()" class="hiddenlink">StringBuffer <b>getBuffer()</b></a><br><br><blockquote>Return the string buffer itself.<span style="background: #FFFF00"> @return StringBuffer holding the current buffer value.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.SyncFailedException.ctor(String)"></A><a href="java.io.SyncFailedException.html" class="hiddenlink">Class <b>SyncFailedException</b></a>, <a href="java.io.SyncFailedException.html#java.io.SyncFailedException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>SyncFailedException(String)</b></a><br><br><blockquote>Constructs an SyncFailedException with a detail message. A detail message is a String that describes this particular exception.<span style="background: #FFFF00"> @param desc a String describing the exception.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.UTFDataFormatException!class"></A><a href="java.io.UTFDataFormatException.html" class="hiddenlink">Class <b>UTFDataFormatException</b></a><br><br><blockquote>Signals that a malformed UTF-8 string has been read in a data input stream or by any class that implements the data input interface. See the <code>writeUTF</code> method for the format in which UTF-8 strings are read and written. @author Frank Yellin @version 1.<strike>7 06</strike><span style="background: #FFFF00">9 02</span>/<strike>29</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @see java.io.DataInput @see java.io.DataInputStream#readUTF(java.io.DataInput) @see java.io.IOException @since JDK1.0</blockquote>
<hr align="left" width="100%">
<A NAME="java.io.UnsupportedEncodingException!class"></A><a href="java.io.UnsupportedEncodingException.html" class="hiddenlink">Class <b>UnsupportedEncodingException</b></a><br><br><blockquote>The Character Encoding is not supported<span style="background: #FFFF00">.</span> @author Asmus Freytag @version 1.<strike>9 09</strike><span style="background: #FFFF00">13 02</span>/<strike>21</strike><span style="background: #FFFF00">02</span>/<strike>98</strike><span style="background: #FFFF00">00</span> @since JDK1.1</blockquote>
<A NAME="java.io.UnsupportedEncodingException.ctor()"></A><a href="java.io.UnsupportedEncodingException.html" class="hiddenlink">Class <b>UnsupportedEncodingException</b></a>, <a href="java.io.UnsupportedEncodingException.html#java.io.UnsupportedEncodingException.ctor_changed()" class="hiddenlink">constructor <b>UnsupportedEncodingException()</b></a><br><br><blockquote><strike>no detailed</strike><span style="background: #FFFF00">Constructs an</span> <span style="background: #FFFF00">UnsupportedEncodingException without a detail </span>message<span style="background: #FFFF00">.</span></blockquote>
<A NAME="java.io.UnsupportedEncodingException.ctor(String)"></A><a href="java.io.UnsupportedEncodingException.html" class="hiddenlink">Class <b>UnsupportedEncodingException</b></a>, <a href="java.io.UnsupportedEncodingException.html#java.io.UnsupportedEncodingException.ctor_changed(java.lang.String)" class="hiddenlink">constructor <b>UnsupportedEncodingException(String)</b></a><br><br><blockquote><strike>detailed</strike><span style="background: #FFFF00">Constructs</span> <span style="background: #FFFF00">an UnsupportedEncodingException with a detail </span>message<span style="background: #FFFF00">.</span> @param s <strike>- detailed</strike><span style="background: #FFFF00">Describes the</span> <strike>message</strike><span style="background: #FFFF00">reason for the exception.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.WriteAbortedException.ctor(String, Exception)"></A><a href="java.io.WriteAbortedException.html" class="hiddenlink">Class <b>WriteAbortedException</b></a>, <a href="java.io.WriteAbortedException.html#java.io.WriteAbortedException.ctor_changed(java.lang.String, java.lang.Exception)" class="hiddenlink">constructor <b>WriteAbortedException(String, Exception)</b></a><br><br><blockquote>Thrown during a read operation when one of the ObjectStreamExceptions was thrown during a write operation. The exception that terminated the write can be found in the detail field. The stream is reset to it's initial state andd all references to objects already deserialized are discarded.<span style="background: #FFFF00"> @param s String describing the exception. @param ex Exception causing the abort.</span></blockquote>
<hr align="left" width="100%">
<A NAME="java.io.Writer!class"></A><a href="java.io.Writer.html" class="hiddenlink">Class <b>Writer</b></a><br><br><blockquote>Abstract class for writing to character streams. The only methods that a subclass must implement are write(char[] int int) flush() and close(). Most subclasses however will override some of the methods defined here in order to provide higher efficiency additional functionality or both. @see Writer @see BufferedWriter @see CharArrayWriter @see FilterWriter @see OutputStreamWriter @see FileWriter @see PipedWriter @see PrintWriter @see StringWriter @see Reader @version 1.<strike>16 98</strike><span style="background: #FFFF00">19 00</span>/<strike>09</strike><span style="background: #FFFF00">02</span>/<strike>21</strike><span style="background: #FFFF00">02</span> @author Mark Reinhold @since JDK1.1</blockquote>
<A NAME="java.io.Writer.ctor(Object)"></A><a href="java.io.Writer.html" class="hiddenlink">Class <b>Writer</b></a>, <a href="java.io.Writer.html#java.io.Writer.ctor_changed(java.lang.Object)" class="hiddenlink">constructor <b>Writer(Object)</b></a><br><br><blockquote>Create a new character-stream writer whose critical sections will synchronize on the given object.<span style="background: #FFFF00"> @param lock Object to synchronize on.</span></blockquote>
<A NAME="java.io.Writer.dmethod.write(int)"></A><a href="java.io.Writer.html" class="hiddenlink">Class <b>Writer</b></a>, <a href="java.io.Writer.html#java.io.Writer.write_changed(int)" class="hiddenlink">void <b>write(int)</b></a><br><br><blockquote>Write a single character. The character to be written is contained in the 16 low-order bits of the given integer value; the 16 high-order bits are ignored. <p> Subclasses that intend to support efficient single-character output should override this method. @<span style="background: #FFFF00">param c int specifying a character to be written. @</span>exception IOException If an I/O error occurs</blockquote>
<hr align="left" width="100%">

</BODY>
</HTML>

<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>FAQ - OpenGL.org</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.21.3" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki_132/opensearch_desc.php" title="OpenGL.org (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://www.opengl.org/wiki_132/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="OpenGL.org Atom feed" href="/wiki_132/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://www.opengl.org/wiki_132/load.php?debug=false&amp;lang=en&amp;modules=ext.geshi.local%7Cmediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://www.opengl.org/wiki_132/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: opengl_org_wiki-mw_:resourceloader:filter:minify-css:7:7bdb5e33a796a5bad00b9bce5b4b4d17 */</style>

<script src="http://www.opengl.org/wiki_132/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"FAQ","wgTitle":"FAQ","wgCurRevisionId":11395,"wgArticleId":1410,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"FAQ","wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"expandablesearch":true,"footercleanup":false,"sectioneditlinks":false,"experiments":true},"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"templateEditor":false,"templates":false,"preview":true,"previewDialog":false,"publish":false,"toc":false},"wgTrackingToken":"1fb283ab7db2d91c942b196091ee90dd","wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":0,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,
"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"vector-simplesearch":1,"useeditwarning":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: opengl_org_wiki-mw_:resourceloader:filter:minify-js:7:3e6684f81edb6d679384a28a851ddd69 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000ff;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #666666;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es1 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es2 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es3 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es4 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es5 {color: #006699; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #FF0000;}
.cpp.source-cpp .nu0 {color: #0000dd;}
.cpp.source-cpp .nu6 {color: #208080;}
.cpp.source-cpp .nu8 {color: #208080;}
.cpp.source-cpp .nu12 {color: #208080;}
.cpp.source-cpp .nu16 {color:#800080;}
.cpp.source-cpp .nu17 {color:#800080;}
.cpp.source-cpp .nu18 {color:#800080;}
.cpp.source-cpp .nu19 {color:#800080;}
.cpp.source-cpp .me1 {color: #007788;}
.cpp.source-cpp .me2 {color: #007788;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki_132/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-FAQ skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">FAQ</span></h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OpenGL.org</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table class="metadata plainlinks stub" style="background: #CCF; border: 1px solid black;">
<tr>
<td>This article contains inaccurate information. Further details can be found on the <a href="/wiki/Talk:FAQ" title="Talk:FAQ">talk page</a>.</td>
</tr>
</table>
<table class="metadata plainlinks stub" style="background: #FFE; border: 1px solid black;">
<tr>
<td>This article needs proper formatting or improved descriptions. Further details can be found on the <a href="/wiki/Talk:FAQ" title="Talk:FAQ">talk page</a>.</td>
</tr>
</table>
<p>Welcome to the FAQ</p>
<table id="toc" class="toc">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#What_is_OpenGL.3F"><span class="tocnumber">1</span> <span class="toctext">What is OpenGL?</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#What_is_NOT_OpenGL.3F"><span class="tocnumber">2</span> <span class="toctext">What is NOT OpenGL?</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Who_maintains_the_OpenGL_specification.3F"><span class="tocnumber">3</span> <span class="toctext">Who maintains the OpenGL specification?</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Is_OpenGL_Open_Source.3F"><span class="tocnumber">4</span> <span class="toctext">Is OpenGL Open Source?</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Where_can_I_download_OpenGL.3F"><span class="tocnumber">5</span> <span class="toctext">Where can I download OpenGL?</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Where_can_I_download_OpenGL.3F_.232"><span class="tocnumber">6</span> <span class="toctext">Where can I download OpenGL? #2</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Is_there_an_OpenGL_SDK.3F"><span class="tocnumber">7</span> <span class="toctext">Is there an OpenGL SDK?</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#What_platforms_have_GL.3F"><span class="tocnumber">8</span> <span class="toctext">What platforms have GL?</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#What_is_an_OpenGL_context_and_why_do_you_need_a_window_to_do_GL_rendering.3F"><span class="tocnumber">9</span> <span class="toctext">What is an OpenGL context and why do you need a window to do GL rendering?</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#How_do_I_do_offscreen_rendering.3F"><span class="tocnumber">10</span> <span class="toctext">How do I do offscreen rendering?</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#How_Does_It_Work_On_Windows.3F"><span class="tocnumber">11</span> <span class="toctext">How Does It Work On Windows?</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#How_do_I_tell_what_version_of_OpenGL_I.27m_using.3F"><span class="tocnumber">12</span> <span class="toctext">How do I tell what version of OpenGL I'm using?</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Why_is_my_GL_version_only_1.4_or_lower.3F"><span class="tocnumber">13</span> <span class="toctext">Why is my GL version only 1.4 or lower?</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Are_glTranslate.2FglRotate.2FglScale_hardware_accelerated.3F"><span class="tocnumber">14</span> <span class="toctext">Are glTranslate/glRotate/glScale hardware accelerated?</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Do_modern_GPUs_still_support_the_fixed-function_pipeline.3F"><span class="tocnumber">15</span> <span class="toctext">Do modern GPUs still support the fixed-function pipeline?</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#How_to_render_in_pixel_space"><span class="tocnumber">16</span> <span class="toctext">How to render in pixel space</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Fullscreen_quad"><span class="tocnumber">17</span> <span class="toctext">Fullscreen quad</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#Multi_indexed_rendering"><span class="tocnumber">18</span> <span class="toctext">Multi indexed rendering</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#See_also"><span class="tocnumber">18.1</span> <span class="toctext">See also</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="#Drawing_A_Cube"><span class="tocnumber">19</span> <span class="toctext">Drawing A Cube</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#glClear_and_glScissor"><span class="tocnumber">20</span> <span class="toctext">glClear and glScissor</span></a></li>
<li class="toclevel-1 tocsection-22"><a href="#Masking"><span class="tocnumber">21</span> <span class="toctext">Masking</span></a></li>
<li class="toclevel-1 tocsection-23"><a href="#glGetError_.28or_.22How_do_I_check_for_GL_errors.3F.29"><span class="tocnumber">22</span> <span class="toctext">glGetError (or "How do I check for GL errors?)</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#What_3D_file_format_should_I_use.3F"><span class="tocnumber">23</span> <span class="toctext">What 3D file format should I use?</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Memory_Usage"><span class="tocnumber">24</span> <span class="toctext">Memory Usage</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Who_manages_memory.3F_How_does_OpenGL_manage_memory.3F"><span class="tocnumber">25</span> <span class="toctext">Who manages memory? How does OpenGL manage memory?</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#Should_I_use_display_lists.2C_vertex_arrays_or_vertex_buffer_objects.3F"><span class="tocnumber">26</span> <span class="toctext">Should I use display lists, vertex arrays or vertex buffer objects?</span></a></li>
<li class="toclevel-1 tocsection-28"><a href="#What_does_Unresolved_External_Symbol_mean.3F"><span class="tocnumber">27</span> <span class="toctext">What does <i>Unresolved External Symbol</i> mean?</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="#What_does_Not_Declared_In_This_Scope_mean.3F"><span class="tocnumber">28</span> <span class="toctext">What does <i>Not Declared In This Scope</i> mean?</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="#Why_limit_to_8_lights.3F"><span class="tocnumber">29</span> <span class="toctext">Why limit to 8 lights?</span></a></li>
<li class="toclevel-1 tocsection-31"><a href="#Can_I_precompile_my_shaders.3F"><span class="tocnumber">30</span> <span class="toctext">Can I precompile my shaders?</span></a></li>
<li class="toclevel-1 tocsection-32"><a href="#Many_Small_2D_Textures"><span class="tocnumber">31</span> <span class="toctext">Many Small 2D Textures</span></a></li>
<li class="toclevel-1 tocsection-33"><a href="#Font_Rendering_and_Text_Rendering"><span class="tocnumber">32</span> <span class="toctext">Font Rendering and Text Rendering</span></a></li>
<li class="toclevel-1 tocsection-34"><a href="#What_is_GLU.3F"><span class="tocnumber">33</span> <span class="toctext">What is GLU?</span></a></li>
</ul>
</td>
</tr>
</table>
<h3> <span class="mw-headline" id="What_is_OpenGL.3F">What is OpenGL?</span></h3>
<p>OpenGL stands for Open Graphics Library. It is a specification of an API for rendering graphics, usually in 3D. OpenGL implementations are libraries that implement the API defined by the specification.</p>
<p>Graphics cards usually have an OpenGL implementation. Because the OpenGL specification is not platform-specific, it is possible to write an application that will be possible to use against many different types of graphics cards. It also increases the chance that the application will continue to work when new hardware will become available.</p>
<h3> <span class="mw-headline" id="What_is_NOT_OpenGL.3F">What is NOT OpenGL?</span></h3>
<p>The OpenGL API <i>only</i> deals with rendering graphics. OpenGL does not provide functions for animations, timing, file IO, image file format processing, GUI, and so forth. OpenGL is concerned only about rendering.</p>
<p>GLUT is not OpenGL. It is not a part of OpenGL; it is simply a library that is used by some users to create an OpenGL window.</p>
<h3> <span class="mw-headline" id="Who_maintains_the_OpenGL_specification.3F">Who maintains the OpenGL specification?</span></h3>
<p>The specification is maintained by <a href="/wiki/OpenGL_Architectural_Review_Board" title="OpenGL Architectural Review Board">OpenGL Architectural Review Board</a> or ARB.</p>
<h3> <span class="mw-headline" id="Is_OpenGL_Open_Source.3F">Is OpenGL Open Source?</span></h3>
<p>No, OpenGL doesn't have any source code. GL is a specification which can be found on this website. It describes the interface the programmer uses and expected behavior. OpenGL is an open <i>specification</i>. Anyone can download the spec for free. This is as opposed to ISO standards and specifications, which cost money to access.</p>
<p>There is an implementation of GL that is Open Source and it is called <a rel="nofollow" class="external text" href="http://www.mesa3d.org">Mesa3D</a> It <a rel="nofollow" class="external text" href="http://www.mesa3d.org/intro.html">announces itself</a> as implementing <a href="/wiki/History_of_OpenGL#OpenGL_3.0_.282008.29" title="History of OpenGL">OpenGL 3.0</a> and <a href="/wiki/GLSL" title="GLSL" class="mw-redirect">GLSL</a> 1.30.</p>
<h3> <span class="mw-headline" id="Where_can_I_download_OpenGL.3F">Where can I download OpenGL?</span></h3>
<p>Just like the "Open Source?" section explains, OpenGL is not a software product. it is a specification.</p>
<p>On Mac OS X, Apple's OpenGL implementation is included.</p>
<p>On Windows, companies like nVidia and AMD/ATI use the spec to write their own implementation, so OpenGL is included in the drivers that they supply. For laptop owners, however, you'll need to visit the manufacturer of your laptop and download the drivers from them.</p>
<h3> <span class="mw-headline" id="Where_can_I_download_OpenGL.3F_.232">Where can I download OpenGL? #2</span></h3>
<p>Updating your graphics drivers is usually enough to get the latest OpenGL implementation for your graphics hardware. This is sufficient for those who want to use applications that require OpenGL.</p>
<p>For programmers, installing drivers is generally insufficient. You will need to load the OpenGL function pointers, either <a href="/wiki/Load_OpenGL_Functions" title="Load OpenGL Functions">manually</a> or <a href="/wiki/Extension_Loading_Library" title="Extension Loading Library" class="mw-redirect">automatically with a library</a>. More information on this can be found in the <a href="/wiki/Getting_started" title="Getting started" class="mw-redirect">Getting started</a> page.</p>
<h3> <span class="mw-headline" id="Is_there_an_OpenGL_SDK.3F">Is there an OpenGL SDK?</span></h3>
<p>There is no actual OpenGL SDK. There is a collection of websites, some (outdated) documentation, and links to tutorials, all found <a rel="nofollow" class="external text" href="http://www.opengl.org/wiki/Getting_started#SDK">here</a>. But it is not an SDK of the kind you are thinking about.</p>
<p>NVIDIA and ATI have their own SDKs, both of which have various example code for OpenGL.</p>
<h3> <span class="mw-headline" id="What_platforms_have_GL.3F">What platforms have GL?</span></h3>
<ul>
<li>Windows: 95 and above</li>
<li>Mac OSX: all versions</li>
<li>Linux: OpenGL is provided by open source drives and MESA library, or by proprietary drivers.</li>
<li>FreeBSD: OpenGL is provided by open source drivers and MESA library or proprietary Nvidia drivers.</li>
</ul>
<p>OpenGL ES is often supported on embedded systems, but OpenGL ES is a different API from regular OpenGL.</p>
<h3> <span class="mw-headline" id="What_is_an_OpenGL_context_and_why_do_you_need_a_window_to_do_GL_rendering.3F">What is an OpenGL context and why do you need a window to do GL rendering?</span></h3>
<div class="rellink" style="margin-left: 1.5em; font-style: italic;">Main article: <a href="/wiki/OpenGL_context" title="OpenGL context" class="mw-redirect">OpenGL context</a></div>
<p><br />
The GL context comprises resources (driver resources in RAM, texture IDs assigned, VBO IDs assigned, enabled states (<span class="tpl-enum">GL_BLEND​</span>, <span class="tpl-enum">GL_DEPTH_TEST​</span>) and many other things). Think of the GL context as some memory allocated by the driver to store some information about the state of your GL program.</p>
<p>You must create a GL context in order for your GL function calls to make sense. You can't just write a minimal program such as this:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc, <span class="kw4">char</span> <span class="sy2">**</span>argv<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">char</span> <span class="sy2">*</span>GL_version<span class="sy1">=</span><span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span>glGetString<span class="br0">(</span>GL_VERSION<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">char</span> <span class="sy2">*</span>GL_vendor<span class="sy1">=</span><span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span>glGetString<span class="br0">(</span>GL_VENDOR<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">char</span> <span class="sy2">*</span>GL_renderer<span class="sy1">=</span><span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span>glGetString<span class="br0">(</span>GL_RENDERER<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>In the above, the programmer simply wants to get information about this system (without rendering anything) but it simply won't work because no communication has been established with the GL driver. The GL driver also needs to allocate resources with respect to the window such as a backbuffer. Based on the pixelformat you have chosen, there can be a color buffer with some format such as <span class="tpl-enum">GL_BGRA8​</span>. There may or may not be a depth buffer. The depth might contain 24 bits. There might be a 8 bit stencil. There might be an accumulation buffer. Perhaps the pixelformat you have chosen can do multisampling. Up until now, no one has introduced a windowless context.</p>
<p>You must create a window. You must select a pixelformat. You must create a GL context. You must make the GL context current (<span class="tpl-code">wglMakeCurrent​</span> for Windows and <span class="tpl-code">glXMakeCurrent​</span> for *nix).</p>
<h3> <span class="mw-headline" id="How_do_I_do_offscreen_rendering.3F">How do I do offscreen rendering?</span></h3>
<p>Some people want to do offscreen rendering and they don't want to show a window to the user. The only solution is to create a window and make it invisible, select a pixelformat, create a GL context, make the context current. Now you can make GL function calls. You should make a <a href="/wiki/Framebuffer_Object" title="Framebuffer Object">FBO</a> and render to that. If you chose to not create a FBO and you prefer to use the backbuffer, there is a risk that it won't work.</p>
<ul>
<li><a rel="nofollow" class="external free" href="http://www.opengl.org/wiki/Common_Mistakes#The_Pixel_Ownership_Problem">http://www.opengl.org/wiki/Common_Mistakes#The_Pixel_Ownership_Problem</a></li>
<li><a rel="nofollow" class="external free" href="http://www.opengl.org/wiki/Common_Mistakes#The_Object_Oriented_Language_Problem">http://www.opengl.org/wiki/Common_Mistakes#The_Object_Oriented_Language_Problem</a></li>
<li><a rel="nofollow" class="external free" href="http://www.opengl.org/wiki/Platform_specifics">http://www.opengl.org/wiki/Platform_specifics</a></li>
</ul>
<h3> <span class="mw-headline" id="How_Does_It_Work_On_Windows.3F">How Does It Work On Windows?</span></h3>
<p>All Windows versions support OpenGL.</p>
<p>When you compile an application, you link with <span class="tpl-code">opengl32.dll​</span> (even on Win64).</p>
<p>When you run your program, <span class="tpl-code">opengl32.dll​</span> gets loaded and it checks in the Windows registry if there is a true GL driver. If there is, it will load it. For example, ATI's GL driver name starts with <span class="tpl-code">atioglxx.dll​</span> and NVIDIA's GL driver is <span class="tpl-code">nvoglv32.dll​</span>. The actual names can change from release versions.</p>
<p>The Microsoft Windows DLL <span class="tpl-code">opengl32.dll​</span> only directly exposes <b>OpenGL 1.1</b> functions. To gain access to functions from higher GL versions, you must load these function pointers manually with <span class="tpl-code">wglGetProcAddress​</span>. The <a href="/wiki/Load_OpenGL_Functions" title="Load OpenGL Functions">details of this process is explained</a>.</p>
<p>There are several helper libraries for this, doing what is commonly called <a href="/wiki/Extension_Loading_Library" title="Extension Loading Library" class="mw-redirect">Extension Loading Libraries</a>.</p>
<p>The important thing to know is that <span class="tpl-code">opengl32.dll​</span> belongs to Microsoft. No one can modify it. You <i>must not</i> replace it. You <i>must not</i> ship your application with this file. You <i>must not</i> ship <span class="tpl-code">nvoglv32.dll​</span> or any other system file either.</p>
<p>It is the responsibility of the user to install the driver made available from Dell, HP, nVidia, ATI/AMD, Intel, SiS, and whatever. Though feel free to remind them to do so.</p>
<h3> <span class="mw-headline" id="How_do_I_tell_what_version_of_OpenGL_I.27m_using.3F">How do I tell what version of OpenGL I'm using?</span></h3>
<p>Use the function <a href="/wiki/GLAPI/glGetString" title="GLAPI/glGetString">glGetString</a>, with <code>GL_VERSION</code> passed as argument. This will return a null-terminated string. Be careful when copying this string into a fixed-length buffer, as it can be fairly long.</p>
<p>Alternatively, you can use <code>glGetIntegerv(GL_MAJOR_VERSION, *)</code> and <code>glGetIntegerv(GL_MINOR_VERSION, *)</code>. These require GL 3.0 or greater.</p>
<p>In order to get the latest version that your GPU supports, make sure that you update your video drivers. GL support is included in your video card's drivers. Also, you might notice that your GL version is for example 2.1. How can you get the latest version? It depends on your GPU. It is possible that your GPU doesn't support anything higher therefore the manufacturer of you video card doesn't provide a higher version. In that case, you can either buy a new video card or try Mesa3D (which is a software renderer) <a rel="nofollow" class="external free" href="http://www.mesa3d.org">http://www.mesa3d.org</a></p>
<h3> <span class="mw-headline" id="Why_is_my_GL_version_only_1.4_or_lower.3F">Why is my GL version only 1.4 or lower?</span></h3>
<p>There are three reasons you may get an unexpectedly low OpenGL version.</p>
<p>On Windows, you might get a low GL version if, during <a href="/wiki/Creating_an_OpenGL_Context" title="Creating an OpenGL Context" class="mw-redirect">context creation</a>, you use an unaccelerated pixel format. This means you get the default implementation of OpenGL which is version 1.1.</p>
<p>The solution to this is to be more careful in your pixel format selection. More information can be found at <a href="/wiki/Platform_specifics:_Windows" title="Platform specifics: Windows">Platform_specifics:_Windows</a> and other parts of the Wiki.</p>
<p>The other reason is that the makers of your video card (and therefore the makers of your video drivers) do not provide an up-to-date OpenGL implementation. There are a number of defunct graphics card vendors out there. However, of the non-defunct ones, this is most likely to happen with Intel's integrated GPUs.</p>
<p>Intel does not provide a proper, up-to-date OpenGL implementation for their integrated GPUs. There is nothing that can be done about this. NVIDIA and ATI provide good support for their integrated GPUs.</p>
<p>Another reason is that you haven't installed your video card drivers after installing your OS.</p>
<p>Be sure to query OpenGL with <span class="tpl-code"><a href="/wiki/GLAPI/glGetString" title="GLAPI/glGetString">glGetString</a>​</span> and make sure the returned values make sense.</p>
<h3> <span class="mw-headline" id="Are_glTranslate.2FglRotate.2FglScale_hardware_accelerated.3F">Are glTranslate/glRotate/glScale hardware accelerated?</span></h3>
<p>No, there are no known GPUs that execute this. These functions are <a href="/wiki/Legacy_OpenGL" title="Legacy OpenGL">deprecated in GL 3.0</a>. You should have your own math library, build your own matrix, upload your matrix to the shader. There are some <a href="/wiki/Related_toolkits_and_APIs" title="Related toolkits and APIs">libraries</a> which you can use for this.</p>
<h3> <span class="mw-headline" id="Do_modern_GPUs_still_support_the_fixed-function_pipeline.3F">Do modern GPUs still support the fixed-function pipeline?</span></h3>
<div class="rellink" style="margin-left: 1.5em; font-style: italic;">Main article: <a href="/wiki/Legacy_OpenGL" title="Legacy OpenGL">Legacy OpenGL</a></div>
<p>Modern GPUs no longer provide specialized hardware for the purpose of doing specific calculations in the OpenGL pipeline. Everything is done with shaders. In order to preserve compatibility, the GL driver generates a shader which emulates the fixed functionality.</p>
<p>Among many others, a simple example is rendering a primitive using one function call to submit each vertex attribute separately, e.g. <span class="tpl-code">glVertex3f(1.f, 0.f, 0.f)​</span>, inside a <span class="tpl-code">glBegin()​</span> and <span class="tpl-code">glEnd()​</span> statement. Using shaders, you have to first define all vertex attributes in a local memory buffer, create a buffer object, and then transfer the vertex attributes using <span class="tpl-code"><a href="/wiki/GLAPI/glBufferData" title="GLAPI/glBufferData">glBufferData</a>​</span>, <span class="tpl-code"><a href="/wiki/GLAPI/glBufferSubData" title="GLAPI/glBufferSubData">glBufferSubData</a>​</span> or by mapping the buffer using <span class="tpl-code"><a href="/wiki/GLAPI/glMapBuffer" title="GLAPI/glMapBuffer">glMapBuffer</a>​</span> or <span class="tpl-code"><a href="/wiki/GLAPI/glMapBufferRange" title="GLAPI/glMapBufferRange">glMapBufferRange</a>​</span>. Shaders will then be able to use the data in the buffer object's data store for rendering.</p>
<h3> <span class="mw-headline" id="How_to_render_in_pixel_space">How to render in pixel space</span></h3>
<p>Setup a certain projection matrix:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
  glMatrixMode<span class="br0">(</span>GL_PROJECTION<span class="br0">)</span><span class="sy4">;</span>
  glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  glOrtho<span class="br0">(</span><span class="nu16">0.0</span>, WindowWidth, <span class="nu16">0.0</span>, WindowHeight, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">//Setup modelview to identity if you don't need GL to move around objects for you</span>
  glMatrixMode<span class="br0">(</span>GL_MODELVIEW<span class="br0">)</span><span class="sy4">;</span>
  glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>Notice that y axis goes from bottom to top because of the glOrtho call. You can swap bottom and top parameters if you want y to go from top to bottom. make sure you render your polygons in the right order so that GL doesn't cull them or just call glDisable(GL_CULL_FACE).</p>
<h3> <span class="mw-headline" id="Fullscreen_quad">Fullscreen quad</span></h3>
<p>Users seem to ask often how to render a fullscreen quad. What should the projection matrix look like?</p>
<p>The projection matrix should be an identity matrix. In old GL, you can call glMatrixMode(GL_PROJECTION) and glLoadIdentity() and glMatrixMode(GL_MODELVIEW) and glLoadIdentity().</p>
<p>In shader based GL, the GLSL shader doesn't even need a matrix. You can just do this</p>
<pre>
 #version 110
 void main()
 {
   gl_Position = gl_Vertex;   //Just output the incoming vertex
 }
</pre>
<p>The vertices for your quad (or 2 triangles) need to be {-1.0, -1.0, 0.0}, {1.0, -1.0, 0.0}, {1.0, 1.0, 0.0}, {-1.0, 1.0, 0.0}.</p>
<h3> <span class="mw-headline" id="Multi_indexed_rendering">Multi indexed rendering</span></h3>
<p>What this means is that each <a href="/wiki/Vertex_Attribute" title="Vertex Attribute">Vertex Attribute</a> (position, normal, etc) has its own index array. OpenGL (and Direct3D, for that matter) do not support this.</p>
<p>It is up to you the user to adjust your data format so that there is only one index array, which samples from multiple attribute arrays. To do this, you will need to duplicate some attribute data so that all of the attribute lists are the same size.</p>
<p>Quite often, this question is asked by those wanting to use the OBJ file format:</p>
<pre>
<tt> v 1.52284 39.3701 1.01523
 v 36.7365 17.6068 1.01523
 v 12.4045 17.6068 -32.475
 and so on ...
 n 0.137265 0.985501 -0.0997287
 n 0.894427 0.447214 -8.16501e-08
 n 0.276393 0.447214 -0.850651
 and so on ...
 t 0.6 1
 t 0.5 0.647584
 t 0.7 0.647584
 and so on ...
 f 102/102/102 84/84/84 158/158/158 
 f 158/158/158 84/84/84 83/83/83 
 f 158/158/158 83/83/83 159/159/159 
 and so on ...
</tt>
</pre>
<p>The lines that start with an f are the faces. As you can see, each vertex has 3 indices, one for vertex, normal, texcoord. In the example above, luckily the index for each {vertex, normal, texcoord} is identical but you will also encounter cases where they are not. You would have to expand such cases. Example&#160;:</p>
<pre>
<tt> f 1/1/1 2/2/2 3/2/2
 f 5/5/5 6/6/6 3/4/5
</tt>
</pre>
<p>so the group 3/2/2 and 3/4/5 are considered a difference vertex entirely even though they both access vertex 3.</p>
<p>You will need to do post-processing on OBJ files before you can use them. This means that the vertex count, the normal count, the texcoord count and whatever other attributes you have have, the count must be the same for all. Example&#160;: If you have 10 vertices, then you must have 10 normals to go along with them. You can't have 10 vertices and 7 normals.</p>
<p>You have 3 options&#160;: either you allocate separate arrays for each of your attributes or you create a single array for your attributes and you interleave the vertex and normals and texcoords or you create a single array and you don't interleave (example&#160;: you put all your vertices at the start of the array, then all the normals, then all the texcoords, etc). There are other pages on this Wiki that explain all that in more detail.</p>
<h4> <span class="mw-headline" id="See_also">See also</span></h4>
<ul>
<li><a href="/wiki/Vertex_Specification" title="Vertex Specification">Vertex Specification</a></li>
</ul>
<h3> <span class="mw-headline" id="Drawing_A_Cube">Drawing A Cube</span></h3>
<p>This question comes up often since there seems to be a lot of users rendering a lot of cubes. Just like the above section explains, OpenGL supports one index for a <a href="/wiki/Vertex_Attribute" title="Vertex Attribute">Vertex Attribute</a> (a vertex attribute is position, normal, texcoord, etc).</p>
<p>Since a cube's face is flat, a user would want flat shading on each face. This means having 1 normal per face. However, GL wants 1 normal per vertex. The best solution is as the above section explains, duplicate the vertex because once one of the attributes is different, it is considered a completely different vertex. Another alternative is to do the following&#160;:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
<span class="co1">//The following code is for GL 2.0</span>
<span class="co1">//Render face 1</span>
glNormal3fv<span class="br0">(</span>mynormal1<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">//Set your face normal</span>
glBindBuffer<span class="br0">(</span>GL_ARRAY_BUFFER, VertexVBOID<span class="br0">)</span><span class="sy4">;</span>
glEnableClientState<span class="br0">(</span>GL_VERTEX_ARRAY<span class="br0">)</span><span class="sy4">;</span>
glVertexPointer<span class="br0">(</span><span class="nu0">3</span>, GL_FLOAT, <span class="kw3">sizeof</span><span class="br0">(</span>MyVertex<span class="br0">)</span>, BUFFER_OFFSET<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>   <span class="co1">//The starting point of the VBO, for the vertices</span>
glClientActiveTexture<span class="br0">(</span>GL_TEXTURE0<span class="br0">)</span><span class="sy4">;</span>
glEnableClientState<span class="br0">(</span>GL_TEXTURE_COORD_ARRAY<span class="br0">)</span><span class="sy4">;</span>
glTexCoordPointer<span class="br0">(</span><span class="nu0">2</span>, GL_FLOAT, <span class="kw3">sizeof</span><span class="br0">(</span>MyVertex<span class="br0">)</span>, BUFFER_OFFSET<span class="br0">(</span><span class="nu0">12</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>   <span class="co1">//The starting point of texcoords, 12 bytes away</span>
glBindBuffer<span class="br0">(</span>GL_ELEMENT_ARRAY_BUFFER, IndexVBOID<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">//Bind the IBO</span>
glDrawElements<span class="br0">(</span>GL_QUADS, <span class="nu0">4</span>, GL_UNSIGNED_SHORT, BUFFER_OFFSET<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="co1">//Render face 2</span>
glNormal3fv<span class="br0">(</span>mynormal2<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">//Set your face normal</span>
<span class="co1">//We can just call glDrawElements since the rest of the setup is already done above</span>
glDrawElements<span class="br0">(</span>GL_QUADS, <span class="nu0">4</span>, GL_UNSIGNED_SHORT, BUFFER_OFFSET<span class="br0">(</span><span class="nu0">16</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="co1">//.... and render face 3 and 4 and 5 and 6</span>
</pre></div>
</div>
<p>In the above code, the disadvantage becomes clear. We can only render 1 quad at a time. It requires 6 calls to glDrawElements just to render a single cube. Another problem is that you are using glNormal3fv which doesn't fetch its data from a VBO!</p>
<p>So what are the savings? For each face, you only needed memory space for 1 normal. Your savings are = 3 normals * 3 floats * 4 bytes_per_float * 6 faces = 216 bytes saved per cube.</p>
<h3> <span class="mw-headline" id="glClear_and_glScissor">glClear and glScissor</span></h3>
<p><span class="tpl-code"><a href="/wiki/GLAPI/glScissor" title="GLAPI/glScissor">glScissor</a>​</span> is one of the few functions that affects on how <span class="tpl-code"><a href="/wiki/GLAPI/glClear" title="GLAPI/glClear">glClear</a>​</span> operates. If you want to clear only a region of the back buffer, then call glScissor and also <span class="tpl-code"><a href="/wiki/GLAPI/glEnable" title="GLAPI/glEnable">glEnable(GL_SCISSOR_TEST)</a>​</span>.</p>
<p>Alternatively, if you have used the scissor test and forgot to glDisable(GL_SCISSOR_TEST), then you might wonder why glClear isn't working the way you want to.</p>
<h3> <span class="mw-headline" id="Masking">Masking</span></h3>
<p>Pay attention to glColorMask, glStencilMask and glDepthMask. For example, if you disable depth writes by calling glDepthMask(FALSE), then <b>all calls to glClear will not clear the depth buffer.</b></p>
<h3> <span class="mw-headline" id="glGetError_.28or_.22How_do_I_check_for_GL_errors.3F.29">glGetError (or "How do I check for GL errors?)</span></h3>
<div class="rellink" style="margin-left: 1.5em; font-style: italic;">Main article: <a href="/wiki/GL_Error_Codes" title="GL Error Codes" class="mw-redirect">GL Error Codes</a></div>
<p>OpenGL keeps a set of <i>error flags</i>, and each call to <code><a href="/wiki/GLAPI/glGetError" title="GLAPI/glGetError">glGetError()</a></code> tests and clears one of those flags. When there are no more error flags set, then <code>glGetError()</code> returns <code>GL_NO_ERROR</code>.</p>
<p>This helper function can be used to query all previously fired OpenGL errors:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
<span class="kw4">int</span> CheckGLErrors<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">int</span> errCount <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
  <span class="kw1">for</span><span class="br0">(</span>GLenum currError <span class="sy1">=</span> glGetError<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> currError <span class="sy3">!</span><span class="sy1">=</span> GL_NO_ERROR<span class="sy4">;</span> currError <span class="sy1">=</span> glGetError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
  <span class="br0">{</span>
    <span class="co1">//Do something with `currError`.</span>
    <span class="sy2">++</span>errCount<span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">return</span> errCount<span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>This requires active polling for errors. Doing so can incur a performance penalty, so it is best to limit this to debug builds where possible.</p>
<p>The extension <a rel="nofollow" class="external text" href="http://www.opengl.org/registry/specs/ARB/debug_output.txt">ARB_debug_output</a> provides an alternative mechanism that can offer error handling without explicit polling. The overhead for this can be significant, and it is only available if the OpenGL context is created with the <span class="tpl-code">CONTEXT_DEBUG_BIT_ARB​</span> flag.</p>
<p>This became a core feature in OpenGL 4.3, with <a rel="nofollow" class="external text" href="http://www.opengl.org/registry/specs/KHR/debug.txt">KHR_debug</a>. This feature is always available, but non-debug contexts are not required to actually log message.</p>
<h3> <span class="mw-headline" id="What_3D_file_format_should_I_use.3F">What 3D file format should I use?</span></h3>
<p>Newcomers often wonder what 3D file format for their mesh data to use for their project.</p>
<p>OpenGL does not load files; therefore, you can use any mesh format you wish. This also means that you must provide the appropriate loading code yourself; OpenGL won't help you.</p>
<p>There are several file format alternatives, with different capabilities. All of these formats (and more) can be loaded by the <a href="/wiki/Open_Asset_Import" title="Open Asset Import" class="mw-redirect">Open Asset Import</a> library.</p>
<dl>
<dt><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj</a></dt>
<dd>This is a simple text format for mesh data. Each .obj file holds a single mesh. Obj files can reference material files, stored in the less-frequently-used <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Wavefront_.obj_file#Material_template_library">.mtl format</a>. Meshes in this format may only contain positions, normals and optionally a single texture coordinate.</dd>
<dt><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/.3ds">Autodesk .3ds</a></dt>
<dd>This is a binary mesh format. This format contains materials and can store multiple named meshes in a single file.</dd>
<dt><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/MD2_%28file_format%29">Quake 2 .md2</a> and <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/MD3_%28file_format%29">Quake 3 .md3</a></dt>
<dd>These are binary mesh formats. The formats do not contain material information, and they only technically store a single mesh. They do have support for keyframe animation, so a single mesh file would contain all of the animation keyframes, as well as animation data.</dd>
<dt><a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/COLLADA">COLLADA</a></dt>
<dd>This is an XML-based mesh file format. It can store pretty much <i>anything</i>; it is primarily used for document exchange between different 3D modelling packages.</dd>
</dl>
<h3> <span class="mw-headline" id="Memory_Usage">Memory Usage</span></h3>
<p>It seems to be common to think that there is a memory leak in the OpenGL driver. Some users write simple programs such as this</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
  glClear<span class="br0">(</span>...<span class="br0">)</span><span class="sy4">;</span>
  SwapBuffers<span class="br0">(</span>...<span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>and they observe that their memory usage goes up each time their Display function is called. That is normal. The driver might allocate some memory space and since the driver is basically a black box, we don't know what it is doing. The driver might be doing some work at optimizing in a secondary thread or preparing some buffering area. We don't know what it is doing, but there is no memory leak.</p>
<p>Some users call <tt>glDeleteTextures</tt> or <tt>glDeleteLists</tt> or one of the other delete functions and they notice that memory usage doesn't go down. You can't do anything about it. The driver does its own memory management and it might choose not to deallocate for the time being. Therefore, this is not a memory leak either.</p>
<h3> <span class="mw-headline" id="Who_manages_memory.3F_How_does_OpenGL_manage_memory.3F">Who manages memory? How does OpenGL manage memory?</span></h3>
<p>Graphics cards have limited memory, if you exceed it by allocating many <a href="/wiki/Buffer_Object" title="Buffer Object">buffer objects</a> and textures and other GL resources, the driver can store some of it in system RAM. As you use those resources, the driver can swap in and out of VRAM resources as needed. Of course, this slows down rendering. The amount of RAM storage is also limited for the driver and it might return a <tt>GL_OUT_OF_MEMORY</tt> when you call <tt>glGetError()</tt>. It might even return a <tt>GL_OUT_OF_MEMORY</tt> if you have plenty of VRAM and RAM available and you try to allocate a really large buffer object that the driver doesn't like.</p>
<p>The purpose of this section is to answer those who want to know what happens when they allocate resources and the video card runs out of VRAM. This behavior is not documented in the GL specification because it doesn't concern itself with system resources and system design. System design can differ and GL tries to remain system neutral. Some systems don't have a video card. Some systems have an integrated CPU/GPU with shared RAM.</p>
<h3> <span class="mw-headline" id="Should_I_use_display_lists.2C_vertex_arrays_or_vertex_buffer_objects.3F">Should I use display lists, vertex arrays or vertex buffer objects?</span></h3>
<div class="rellink" style="margin-left: 1.5em; font-style: italic;">Main article: <a href="/wiki/Vertex_Specification" title="Vertex Specification">Vertex Specification</a></div>
<p>Display lists and vertex arrays have been with GL since the beginning. Vertex buffer objects were introduced with GL 1.5. Although they can all be used to render primitives, they are not the same and have disctinct properties:</p>
<ul>
<li>A display list is a series of well defined GL commands which may be optimized in terms of execution and data transfer to video memory when the list is created. Commands and data in the list stored in server or video memory and are retrieved and executed when the list is called. For instance, specifying vertex attributes using a vertex array will likely cause the GL to store the data in video memory for fast access. Display lists are static, so mapping display lists to dynamically changing data is not possible. The advantage is that execution time is generally very fast in comparison to some alternatives.</li>
</ul>
<ul>
<li>Vertex arrays allow for vertex specification in one shot using an array of attributes. This avoid using immediate mode constructs which possibly pass each attribute vertex by vertex and thus lead to a high number of API call and to data transfer attribute by attribute. Vertex arrays allow for dynamic vertex specification. However, since data is stored in client memory, i.e. system memory managed by the application, it has to be transferred to the GL every time as well.</li>
</ul>
<ul>
<li>Vertex buffer objects are, if the GL can do so, stored in video memory - just like display lists. Thus you avoid having to re-transfer every frame. However, unlike display lists, you can dynamically updated vertex buffer objects. Also, you get the advantage of the very low number of API calls necessary to actually render.</li>
</ul>
<p>Both display lists and vertex arrays are <a href="/wiki/Legacy_OpenGL" title="Legacy OpenGL">legacy OpenGL</a> features. <a href="/wiki/Vertex_Specification" title="Vertex Specification">Vertex specification</a> is now mostly done with vertex buffer objects and vertex array objects in modern OpenGL. As a general advice, you should refrain from using legacy constructs in new OpenGL applications.</p>
<p><b>If and only if</b> there is a requirement to maintain existing legacy code and there is no way to rewrite the rendering system, using display lists can be quite advantageous in comparison to vertex arrays for static data. If dynamic updates are required, there is no way arround vertex arrays. If immediate mode constructs like <span class="tpl-code">glBegin()​</span> are found, they can be replaces by either display lists or vertex arrays to improve performance in many real cases where the number of vertices is usually hundreds or thousands per object.</p>
<h3> <span class="mw-headline" id="What_does_Unresolved_External_Symbol_mean.3F">What does <i>Unresolved External Symbol</i> mean?</span></h3>
<p>Some newcomers try to compile their GL program and get linker errors such as:</p>
<pre>
  error LNK2001: unresolved external symbol _glBegin
</pre>
<p>and similar linker errors related to other GL functions and perhaps GLU functions and other functions from other libraries.</p>
<p>The example given above is specific to Microsoft Visual C++ but you can get linker errors from other linkers as well. In order for the linker to do its job, it needs to know which library file it should search.</p>
<p>For VC++ 2010, you could click on Project from the menu. Select Properties. From that properties dialog box, on the left side, drop the Configuration Properties. Drop Linker. Click on Input. On the right side, it says Additional Dependencies. Type the name of the library file followed by a colon. For OpenGL, it would be opengl32.lib. For GLU, it would be glu32.lib.</p>
<p>Alternatively, you can add these lines:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
   <span class="co2">#pragma comment(lib, "opengl32.lib")</span>
   <span class="co2">#pragma comment(lib, "glu32.lib")</span>
</pre></div>
</div>
<p>to your .cpp files, which will force the libraries to be included. These only work on compilers that support this use of #pragma.</p>
<p>Obviously, we can't list what you need to do for each IDE. You need to search the internet or your manuals. You need to know how to use your IDE and your particular programming language.</p>
<p>In the case of gcc, a user types this command on the CLI&#160;:</p>
<pre>
  gcc -lGL -lglut myprogram.c -o myprogram
</pre>
<p>and CLI shows</p>
<pre>
 /tmp/ccCQkTKm.o:myprogram.c:function display: error: undefined reference to 'gluLookAt'
</pre>
<p>That's because you are using GLU and you did not link again the GLU library. The command you should type is&#160;:</p>
<pre>
  gcc -lGL -lGLU -lglut myprogram.c -o myprogram
</pre>
<h3> <span class="mw-headline" id="What_does_Not_Declared_In_This_Scope_mean.3F">What does <i>Not Declared In This Scope</i> mean?</span></h3>
<p>Some newcomers try to compile their GL program and get compile errors such as:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">
  GL_TEXTURE_3D was not declared in <span class="kw3">this</span> scope
</pre></div>
</div>
<p>This happens because the compiler has no idea what GL_TEXTURE_3D is since it was not declared anywhere.</p>
<p>You probably have not included a proper OpenGL header. <span class="tpl-code">gl.h​</span> may not include all of the stuff you need. You should use an <a href="/wiki/OpenGL_Loading_Library" title="OpenGL Loading Library">OpenGL Loading Library</a>; otherwise, you will have to use <span class="tpl-code">glext.h​</span>, found in <a rel="nofollow" class="external text" href="http://www.opengl.org/registry/#headers">the OpenGL Registry</a>. This also means you need to <a href="/wiki/Load_OpenGL_Functions" title="Load OpenGL Functions">manually load OpenGL functions</a>.</p>
<h3> <span class="mw-headline" id="Why_limit_to_8_lights.3F">Why limit to 8 lights?</span></h3>
<p>The OpenGL fixed-function pipeline has the concept of a maximum number of lights to render with. Shaders do not have any lights; you may use shaders to render any number of lights, but you must build this framework within the tools that shaders give you.</p>
<p>Within fixed-function OpenGL, it is often asked why GL supports a maximum of 8 lights. That is not true, GL doesn't impose a maximum of 8 lights. It imposes a minimum of 8 lights. Your driver/GPU combo is allowed to support more than 8 but most of them limit themselves to 8. The reason for that is that it doesn't become noticeable when there are more than 3 or 4 lights shining on the same surface. So in fact, 8 is an excessive number.</p>
<p>Example, if you have a city and you have street lights, you probably need more than 8 street lights. The solution is to subdivide your city streets in sections where only 3 lights effect each surface. It is up to you, the artist, to make it look good.</p>
<p>Example, if you are doing particle effects where each particle is a light source and you have perhaps 1000 particles, that is actually an insane number of lights for a real time renderer for old hardware (example&#160;: hardware that supports GL 1.5). You can get away with it with just 1 light for the entire group of particles.</p>
<p>If you do really want to have more than 8 lights, you can do it with a multipass approach. Render your object with 8 lights on. Then enable blending and enable additive blending (<code><a href="/wiki/GLAPI/glBlendFunc" title="GLAPI/glBlendFunc" class="mw-redirect">glBlendFunc</a>(GL_ONE, GL_ONE)</code>) and then render your object again. You might want to set your depth test to GL_LEQUAL.</p>
<p>Now let's look at it in a different perspective. Did old game use lights? Actually they did not. Many old games used light maps for static surfaces. For a moving object, they computed the lighting themselves or it was precomputed (aka. light volume).</p>
<h3> <span class="mw-headline" id="Can_I_precompile_my_shaders.3F">Can I precompile my shaders?</span></h3>
<p>GL 4.1 adds the ability to compile the shader and you get to download the shader binary from the GL driver, however, these binaries are GPU and driver specific. There is no guarantee they will work on other GPUs. There is no guarantee that they will work once the user upgrades or downgrades the driver. The purpose of this feature is to compile once and store on the hard drive for future runs. They avoid the compile and link time in future runs of your application. However, driver updates may change the version of these shaders, which will force you to recompile shaders from scratch.</p>
<p>If you ship your application with precompiled shaders, you have to include the source code format also. That way you can do the compilation the usual way if loading of the precompiled files fails.</p>
<p>Note that the extension to do this, <a rel="nofollow" class="external text" href="http://www.opengl.org/registry/specs/ARB/get_program_binary.txt">ARB_get_program_binary</a>, is widely available on pre-4.1 hardware. So you do not need 4.x-class hardware to use it.</p>
<h3> <span class="mw-headline" id="Many_Small_2D_Textures">Many Small 2D Textures</span></h3>
<p>This technique is also called a texture atlas.</p>
<p>Some users ask about putting together many smaller 2D textures inside one big 2D texture (1024 x 1024 or something larger). This way, you can avoid a call to glBindTexture and perhaps gain some performance. Yes, you can do that but you also have to watch out for the texture coordinates on your models. You also have to watch out for texture filtering because a linear filter can cause texel bleed (neighboring sub-texture gets sampled).</p>
<p>Another solution is to put those small textures in one 3D texture (GL_TEXTURE_3D which is part of GL 1.3 and above) as long as all the 2D textures are the same size. The problem of texture filtering still is present in this case in case you use linear filtering. There is no problem in the S and T direction but the problem is present between the texture layers.</p>
<p>Another solution is to make use of 2D texture array (GL_TEXTURE_2D_ARRAY which is part of GL 3.0 and above). This solves the problem that is present in the case of using a 3D texture as described above, however, the texture sizes must all be the same.</p>
<h3> <span class="mw-headline" id="Font_Rendering_and_Text_Rendering">Font Rendering and Text Rendering</span></h3>
<p>GL doesn't render text because GL is a low level library. It handles the basics such as rendering points, lines and triangles and whatever technique that might get introduced in the future. For rendering text, you either need a 3rd party library or do it yourself.</p>
<p>One of the simplest methods is to create a texture with all the characters on it. Then, render many quads on your screen and texture map the characters.</p>
<p>You could also have a texture with full sentences. Then, render a quad and texture it.</p>
<p>You could also use the features of your OS and get access to the fonts and make texture out of it. Then, texture map some quads.</p>
<p>Windows offers certain functions for text rendering but these are old and should probably not be used these days. See <span class="tpl-code"><a href="/wiki_132/index.php?title=GLAPI/wglUseFontBitmaps&amp;action=edit&amp;redlink=1" class="new" title="GLAPI/wglUseFontBitmaps (page does not exist)">wglUseFontBitmaps</a>​</span> and <span class="tpl-code"><a href="/wiki_132/index.php?title=GLAPI/wglUseFontOutlines&amp;action=edit&amp;redlink=1" class="new" title="GLAPI/wglUseFontOutlines (page does not exist)">wglUseFontOutlines</a>​</span>.</p>
<p>The old FAQ explains the above well. It also has links to 3rd party libraries. <a rel="nofollow" class="external free" href="http://www.opengl.org/archives/resources/faq/technical/#indx0170">http://www.opengl.org/archives/resources/faq/technical/#indx0170</a></p>
<h3> <span class="mw-headline" id="What_is_GLU.3F">What is GLU?</span></h3>
<p>GLU stands for <i>OpenGL utility library</i> and provides convenience functions layered on <a href="/wiki/Legacy_OpenGL" title="Legacy OpenGL">legacy OpenGL</a> features. Popular examples of GLU functionality are</p>
<pre>
gluLooktAt()
</pre>
<p>and</p>
<pre>
gluPerspective()
</pre>
<p>which in principle ease the process of calculating a view- and projection matrix to be used during rendering. However, both functions use and/or are to be used in the context of a legacy feature called the matrix stack and corresponding matrix manipulation functions which make them unfit or illegal in modern OpenGL applications which don't intend to use deprecated or removed functionality.</p>
<p>If you're writing an application which uses modern OpenGL, i.e. core OpenGL 3.0 or higher, it is recommended to either write your own code or use a 3rd party library which either isn't layered on OpenGL at all or uses OpenGL 3.0 or higher core features. A list of suitable 3rd party libraries can be found <a href="/wiki/Related_toolkits_and_APIs" title="Related toolkits and APIs">here</a>.</p>
<p>If you still plan on using GLU, you should know that Windows provides glu32.dll. It provides GLU version 1.2. Your compiler should come with glu32.lib or glu32.a. You should also know that the latest version of GLU is 1.3. You can download the entire package that Mesa3D provides (<a rel="nofollow" class="external free" href="http://www.mesa3d.org">http://www.mesa3d.org</a>). Inside, you will find the source code for GLU 1.3 and you must compile it yourself. Remember that you must not replace Microsoft's glu32.dll. It is considered a system file and you must never overwrite system files.</p>

<!-- 
NewPP limit report
Preprocessor visited node count: 653/1000000
Preprocessor generated node count: 1699/1000000
Post?expand include size: 3786/2097152 bytes
Template argument size: 1237/2097152 bytes
Highest expansion depth: 4/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key opengl_org_wiki-mw_:pcache:idhash:1410-0!*!0!!en!*!* and timestamp 20131213210826 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://www.opengl.org/wiki_132/index.php?title=FAQ&amp;oldid=11395">http://www.opengl.org/wiki_132/index.php?title=FAQ&amp;oldid=11395</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks catlinks-allhidden'></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<!-- header -->
			<div id="mw-head">
				
<!-- 0 -->
<div id="p-personal" role="navigation" class="">
	<h3>Personal tools</h3>
	<ul>
<li id="pt-createaccount"><a href="/wiki_132/index.php?title=Special:UserLogin&amp;returnto=FAQ&amp;type=signup">Create account</a></li><li id="pt-login"><a href="/wiki_132/index.php?title=Special:UserLogin&amp;returnto=FAQ" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>	</ul>
</div>

<!-- /0 -->
				<div id="left-navigation">
					
<!-- 0 -->
<div id="p-namespaces" role="navigation" class="vectorTabs">
	<h3>Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/FAQ"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="/wiki/Talk:FAQ"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
				</div>
				<div id="right-navigation">
					
<!-- 0 -->
<div id="p-views" role="navigation" class="vectorTabs">
	<h3>Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/wiki/FAQ" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="/wiki_132/index.php?title=FAQ&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/wiki_132/index.php?title=FAQ&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet">
	<h3><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="/wiki_132/index.php" id="searchform">
				<div>
			<input type="search" name="search" title="Search OpenGL.org [f]" accesskey="f" id="searchInput" />			<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />			<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />					<input type='hidden' name="title" value="Special:Search"/>
		</div>
	</form>
</div>

<!-- /2 -->
				</div>
			</div>
			<!-- /header -->
			<!-- panel -->
			<div id="mw-panel">
				<!-- logo -->
					<div id="p-logo" role="banner"><a style="background-image: url(/wiki_132/images/opengl_wiki.gif);" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" role="navigation" id='p-navigation'>
	<h3>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-OpenGL-News"><a href="http://opengl.org/" rel="nofollow">OpenGL News</a></li>
			<li id="n-OpenGL-Forums"><a href="http://opengl.org/discussion_boards" rel="nofollow">OpenGL Forums</a></li>
			<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-help"><a href="/wiki/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" role="navigation" id='p-tb'>
	<h3>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/FAQ" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/FAQ" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="/wiki_132/index.php?title=FAQ&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="/wiki_132/index.php?title=FAQ&amp;oldid=11395" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="/wiki_132/index.php?title=FAQ&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
			<!-- /panel -->
		</div>
		<!-- footer -->
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 27 November 2013, at 12:02.</li>
											<li id="footer-info-viewcount">This page has been accessed 227,949 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/OpenGL.org:Privacy_policy" title="OpenGL.org:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/OpenGL.org:About" title="OpenGL.org:About">About OpenGL.org</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/OpenGL.org:General_disclaimer" title="OpenGL.org:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="/wiki_132/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.expandableSearch","ext.UserBuckets","ext.articleFeedback.startup","skins.vector.js"], null, true);
}</script>
<script src="http://www.opengl.org/wiki_132/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<!-- Served in 0.258 secs. -->
	</body>
</html>

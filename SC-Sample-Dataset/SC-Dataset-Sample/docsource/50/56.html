<!DOCTYPE html>
<!--[if IE 6]>
<html id="ie6" lang="en">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="en">
<!--<![endif]-->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt Replacements) | hassancseku</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="http://hassancseku.wordpress.com/xmlrpc.php" />
<!--[if lt IE 9]>
<script src="http://s1.wp.com/wp-content/themes/pub/itheme2/js/html5.js?m=1317755580g" type="text/javascript"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="hassancseku &raquo; Feed" href="http://hassancseku.wordpress.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="hassancseku &raquo; Comments Feed" href="http://hassancseku.wordpress.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="hassancseku &raquo; jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt&nbsp;Replacements) Comments Feed" href="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/feed/" />
<script type="text/javascript">
/* <![CDATA[ */
function addLoadEvent(func){var oldonload=window.onload;if(typeof window.onload!='function'){window.onload=func;}else{window.onload=function(){oldonload();func();}}}
/* ]]> */
</script>
<link rel='stylesheet' id='all-css-0' href='http://s1.wp.com/_static/??-eJx9j90OwiAMhV9IrD/L3I3xWdiowFYoGZDFt5dgjEuWedXT5us5LSxBDOwT+gQui0BZWx+B7IQRRkxBDpOo3XGI8QArvCfWvwXWGhXnJJ5MxAssVmlMm6VVhgttGbsgU5WmJG1DVnzgWNxJ2hliehFu2GTQlatD7sFWfdkBd0yNnK3X37pnbxrQxL2kf7af7yMUBDSzmlGq+tzD3c/Xrr2dLl3Tjm+XuY33' type='text/css' media='all' />
<link rel='stylesheet' id='print-css-0' href='http://s0.wp.com/wp-content/mu-plugins/global-print/global-print.css?m=1335386953g' type='text/css' media='print' />
<script type='text/javascript'>
/* <![CDATA[ */
var LoggedOutFollow = {"invalid_email":"Your subscription did not succeed, please try again with a valid email address."};
/* ]]> */
</script>
<script type='text/javascript' src='http://s0.wp.com/_static/??-eJyFkNEKwjAMRX/IrpsT8UX8lq3LSmrb1Ka1zK93gwmKgz0lJIccbmQJQpFP4JM0LB31aEFkhtjpeSbQj1QZPsiZQ69sHoAX0DwyxGktu4BwqGOXoHLoP/CXNRAnB8yzcmP7q0L/RCi7mIEUOnUXERhff1d7S1oEmzV6lnOvYaCcxEjWUpEFBw1pK5Qi55avRAh2WsPc3LVpL+e6aY/1ybwBqEN9cw=='></script>
<link rel='stylesheet' id='all-css-0' href='http://s2.wp.com/wp-content/mu-plugins/highlander-comments/style.css?m=1377793621g' type='text/css' media='all' />
<!--[if lt IE 8]>
<link rel='stylesheet' id='highlander-comments-ie7-css'  href='http://s2.wp.com/wp-content/mu-plugins/highlander-comments/style-ie7.css?m=1351637563g&#038;ver=20110606' type='text/css' media='all' />
<![endif]-->
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://hassancseku.wordpress.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://hassancseku.wordpress.com/wp-includes/wlwmanifest.xml" /> 
<link rel='next' title='Read Excel File in&nbsp;CakePhp' href='http://hassancseku.wordpress.com/2011/11/27/read-excel-file-in-cakephp/' />
<meta name="generator" content="WordPress.com" />
<link rel='canonical' href='http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/' />
<link rel='shortlink' href='http://wp.me/p21icj-6' />
<link rel="alternate" type="application/json+oembed" href="http://public-api.wordpress.com/oembed/1.0/?format=json&amp;url=http%3A%2F%2Fhassancseku.wordpress.com%2F2011%2F11%2F27%2Fjquery-alert-dialogs-alert-confirm-prompt-replacements%2F&amp;for=wpcom-auto-discovery" /><link rel="alternate" type="application/xml+oembed" href="http://public-api.wordpress.com/oembed/1.0/?format=xml&amp;url=http%3A%2F%2Fhassancseku.wordpress.com%2F2011%2F11%2F27%2Fjquery-alert-dialogs-alert-confirm-prompt-replacements%2F&amp;for=wpcom-auto-discovery" />
<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article" />
<meta property="og:title" content="jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt Replacements)" />
<meta property="og:url" content="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/" />
<meta property="og:description" content="Overview This jQuery plugin aims to replace the basic functionality provided by the standard JavaScript alert(), confirm(), and prompt() functions. What’s the benefit of using custom methods? Well,..." />
<meta property="og:site_name" content="hassancseku" />
<meta property="og:image" content="http://wordpress.com/i/blank.jpg?m=1383295312g" />
<meta name="twitter:site" content="@wordpressdotcom" />
<meta name="twitter:card" content="summary" />
<meta property="fb:app_id" content="249643311490" />
<meta property="article:publisher" content="https://www.facebook.com/WordPresscom" />
<link rel="shortcut icon" type="image/x-icon" href="http://s2.wp.com/i/favicon.ico?m=1311975824g" sizes="16x16 24x24 32x32 48x48" />
<link rel="icon" type="image/x-icon" href="http://s2.wp.com/i/favicon.ico?m=1311975824g" sizes="16x16 24x24 32x32 48x48" />
<link rel="apple-touch-icon-precomposed" href="http://s0.wp.com/i/webclip.png?m=1355642671g" />
<link rel='openid.server' href='http://hassancseku.wordpress.com/?openidserver=1' />
<link rel='openid.delegate' href='http://hassancseku.wordpress.com/' />
<link rel="search" type="application/opensearchdescription+xml" href="http://hassancseku.wordpress.com/osd.xml" title="hassancseku" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wordpress.com/opensearch.xml" title="WordPress.com" />
		<style>
		/* <![CDATA[ */
		/* Block: reblog */
		
		.reblog-from img                   { margin: 0 10px 0 0; vertical-align: middle; padding: 0; border: 0; }
		.reblogger-note img.avatar         { float: left; padding: 0; border: 0; }
		.reblogger-note-content            { margin: 0 0 20px; }
		
		.wpcom-reblog-snapshot .reblog-from img {
		margin: 0 .5em 0 0;
		padding: 0;
		border: 0;
		}
		
		.wpcom-reblog-snapshot .reblogger-note img.avatar {
		float: left;
		padding: 0;
		border: 0;
		margin: 0 .5em 0 0;
		}
		
		.reblog-post .wpcom-enhanced-excerpt-content { border-left: 3px solid #eee; padding-left: 15px; }
		.reblog-post ul.thumb-list         { display: block; list-style: none; margin: 2px 0; padding: 0; clear: both; }
		.reblog-post ul.thumb-list li      { display: inline; margin: 0; padding: 0 1px; border: 0; }
		.reblog-post ul.thumb-list li a    { margin: 0; padding: 0; border: 0; }
		.reblog-post ul.thumb-list li img  { margin: 0; padding: 0; border: 0; }
		
		.reblog-post .wpcom-enhanced-excerpt { clear: both; }
		
		.reblog-post .wpcom-enhanced-excerpt address,
		.reblog-post .wpcom-enhanced-excerpt li,
		.reblog-post .wpcom-enhanced-excerpt h1,
		.reblog-post .wpcom-enhanced-excerpt h2,
		.reblog-post .wpcom-enhanced-excerpt h3,
		.reblog-post .wpcom-enhanced-excerpt h4,
		.reblog-post .wpcom-enhanced-excerpt h5,
		.reblog-post .wpcom-enhanced-excerpt h6,
		.reblog-post .wpcom-enhanced-excerpt p { font-size: 100% !important; }
		
		.reblog-post .wpcom-enhanced-excerpt blockquote,
		.reblog-post .wpcom-enhanced-excerpt pre,
		.reblog-post .wpcom-enhanced-excerpt code,
		.reblog-post .wpcom-enhanced-excerpt q { font-size: 98% !important; }
		
		.wpcom-reblog-snapshot {
		margin-bottom: 1em;
		}
		
		.wpcom-reblog-snapshot p.reblog-from {
		margin: 0 0 1em 0;
		}
		
		.wpcom-reblog-snapshot p.reblogger-headline {
		line-height: 32px;
		margin: 0 0 1em 0;
		}
		
		/* Optional notes */
		.wpcom-reblog-snapshot .reblogger-note {
		border-bottom: 1px solid #ddd;
		border-bottom: 1px solid rgba(0,0,0,.1);
		margin: 0 0 1em 0;
		padding: 0 0 1em 0;
		overflow: hidden;
		}
		
		.wpcom-reblog-snapshot p.reblogger-headline {
		line-height: 32px;
		margin: 0 0 1em 0;
		}
		
		.wpcom-reblog-snapshot .reblogger-note-content {
		margin: 0;
		padding: 0;
		}
		
		.wpcom-reblog-snapshot .reblogger-note-content blockquote {
		font-style: normal;
		font-weight: normal;
		font-size: 1em;
		padding: 2px 1em 6px 1em;
		background: rgba(0,0,0,.1);
		margin: 0;
		position: relative;
		}
		
		.wpcom-reblog-snapshot .reblogger-note-content blockquote p:last-child {
		margin-bottom: 0;
		}
		
		

		/* ]]> */
		</style>
		<meta name="application-name" content="hassancseku" /><meta name="msapplication-window" content="width=device-width;height=device-height" /><meta name="msapplication-tooltip" content="Just another WordPress.com site" /><meta name="msapplication-task" content="name=Subscribe;action-uri=http://hassancseku.wordpress.com/feed/;icon-uri=http://s2.wp.com/i/favicon.ico" /><meta name="msapplication-task" content="name=Sign up for a free blog;action-uri=http://wordpress.com/signup/;icon-uri=http://s2.wp.com/i/favicon.ico" /><meta name="msapplication-task" content="name=WordPress.com Support;action-uri=http://support.wordpress.com/;icon-uri=http://s2.wp.com/i/favicon.ico" /><meta name="msapplication-task" content="name=WordPress.com Forums;action-uri=http://forums.wordpress.com/;icon-uri=http://s2.wp.com/i/favicon.ico" /><meta name="title" content="jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt&nbsp;Replacements) | hassancseku on WordPress.com" />
<meta name="description" content="Overview This jQuery plugin aims to replace the basic functionality provided by the standard JavaScript alert(), confirm(), and prompt() functions. What’s the benefit of using custom methods? Well, a few good reasons, really. These are completely customizable via CSS (which can make your apps look much more professional) ou can set a custom title for&hellip;" />
	<style type="text/css">
			#site-title,
		#site-description {
			position: absolute !important;
			clip: rect(1px 1px 1px 1px); /* IE6, IE7 */
			clip: rect(1px, 1px, 1px, 1px);
		}
		</style>
	<style type="text/css" id="custom-background-css">
body.custom-background { background-image: url('http://hassancseku.files.wordpress.com/2012/02/img_1130.jpg'); background-repeat: no-repeat; background-position: top left; background-attachment: scroll; }
</style>

<script type='text/javascript' src='http://partner.googleadservices.com/gampad/google_service.js'>
</script>
<script type='text/javascript'>
if ( typeof GS_googleAddAdSenseService == 'function' ) { GS_googleAddAdSenseService("ca-pub-3443918307802676"); }
if ( typeof GS_googleEnableAllServices == 'function' ) { GS_googleEnableAllServices() };
</script>
<script type="text/javascript" src="http://c.amazon-adsystem.com/aax2/amzn_ads.js"></script>
<script type="text/javascript">
try { amznads.getAds("3033","300x250"); } catch(e) { /* ignore */ }
</script>
<script type="text/javascript">
var amznKeys = amznads.getKeys();
if (typeof amznKeys != "undefined" && amznKeys != "") { for (var i =0; i < amznKeys.length; i++) { var key = amznKeys[i]; GA_googleAddAttr("amzn", key);} }
document.close();
</script>
<script type='text/javascript'>
if ( typeof GA_googleAddSlot == 'function' ) { GA_googleAddSlot("ca-pub-3443918307802676", "wpcom_below_post"); }
</script>
<script type='text/javascript'>
if ( typeof GA_googleFetchAds == 'function' ) { GA_googleFetchAds(); }
</script>

<script type="text/javascript">
var wpcom_ads = { bid: 29860955, pt: 'permalink', wa: 0, as: 0, domain: 'hassancseku.wordpress.com', url: 'http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/', gid: '', };
</script>
<style id="syntaxhighlighteranchor"></style>
<script type="text/javascript">
	window.google_analytics_uacct = "UA-52447-2";
</script>

<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-52447-2']);
	_gaq.push(['_setDomainName', 'wordpress.com']);
	_gaq.push(['_initData']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
	})();
</script>
</head>

<body class="single single-post postid-6 single-format-standard custom-background mp6 single-author highlander-enabled highlander-light">
<div id="page" class="hfeed">
	<header id="masthead" role="banner">
		<hgroup>
			<h1 id="site-title"><a href="http://hassancseku.wordpress.com/" title="hassancseku" rel="home">hassancseku</a></h1>
			<h2 id="site-description">Just another WordPress.com site</h2>
		</hgroup>

				<nav id="access" role="navigation">
			<h1 class="assistive-text section-heading">Main menu</h1>
			<div class="assistive-text skip-link"><a href="#content" title="Skip to content">Skip to content</a></div>

			<div class="menu-top_menu-container"><ul id="menu-top_menu" class="menu"><li id="menu-item-90" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-90"><a href="http://hassancseku.wordpress.com/">Home</a></li>
<li id="menu-item-43" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-43"><a href="http://hassancseku.wordpress.com/category/cakephp/">CakePhp</a></li>
<li id="menu-item-45" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-45"><a href="http://hassancseku.wordpress.com/category/jquery/">JQUERY</a></li>
<li id="menu-item-46" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-46"><a title="Software Engineering" href="http://hassancseku.wordpress.com/category/software-engineering/">Software Engineering</a>
<ul class="sub-menu">
	<li id="menu-item-44" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-44"><a>SQA</a></li>
</ul>
</li>
<li id="menu-item-67" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-67"><a href="http://hassancseku.wordpress.com/photo-gallary/">Photo Gallary</a></li>
<li id="menu-item-42" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-42"><a title="About Md.Mahamudul Hassan" href="http://hassancseku.wordpress.com/about/">About</a></li>
</ul></div>		</nav><!-- #access -->
	</header><!-- #masthead -->

	<div id="main">
		<div id="primary">
			<div id="content" role="main">

			
					<nav id="nav-above">
		<h1 class="assistive-text section-heading">Post navigation</h1>

	
				<div class="nav-next"><a href="http://hassancseku.wordpress.com/2011/11/27/read-excel-file-in-cakephp/" rel="next">Read Excel File in&nbsp;CakePhp <span class="meta-nav">&rarr;</span></a></div>
	
	</nav><!-- #nav-above -->
	
				
<article id="post-6" class="post-6 post type-post status-publish format-standard hentry category-jquery">
	<header class="entry-header">
		
		<div class="post-date">
					<span class="month">Nov</span>
			<span class="day">27</span>
			<span class="year">2011</span>
				</div>

				
							<h1 class="entry-title">
									jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt&nbsp;Replacements)							</h1>
			</header><!-- .entry-header -->

		<div class="entry-content">
		<h2 id="overview">Overview</h2>
<p>This jQuery plugin aims to replace the basic functionality provided by the standard JavaScript <strong>alert()</strong>, <strong>confirm()</strong>, and <strong>prompt()</strong> functions. What’s the benefit of using custom methods? Well, a few good reasons, really.</p>
<ul>
<li>These are completely customizable via CSS (which can make your apps<br />
look much more professional)</li>
<li>ou can set a custom title for each dialog</li>
<li>IE7 users get an ugly warning and usually have to reload the page if<br />
you use a regular <strong>prompt()</strong></li>
</ul>
<p>These methods <em>simulate</em> a true modal dialog box. They will automatically reposition themselves if you resize the browser window (unlike many existing dialog/lightbox-style plugins). If you include the <a href="http://ui.jquery.com/" rel="external">jQuery UI</a> <a href="http://docs.jquery.com/UI/Draggable" rel="external">Draggable plugin</a>, the dialogs can be moved by dragging their title bars. Everything you need to produce the dialogs in the demonstration is included in the download.</p>
<p><em>Update: this plugin has been archived and is no longer actively maintained. We recommend <a href="http://jqueryui.com/demos/dialog/">jQuery UI’s dialog widget</a> for similar functionality.</em></p>
<h2>Usage</h2>
<p>This plugin utilizes the <strong>$.alerts</strong> namespace, but there are<br />
three built-in shortcut functions that make implementation easier:</p>
<ul>
<li>jAlert(<em>message, [title, callback]</em>)</li>
<li>jConfirm(<em>message, [title, callback]</em>)</li>
<li>jPrompt(<em>message, [value, title, callback]</em>)</li>
</ul>
<p>Unlike their native JavaScript counterparts, you can use HTML in the <strong>message</strong> parameter. To specify a newline, you can use either <strong>\n </strong>or <strong>&lt;br /&gt;</strong>. These methods do not return the same values as <strong>confirm()</strong> and <strong>prompt()</strong>. You must<br />
access the resulting values using a <em>callback</em> function.</p>
<h2>Code:</h2>
<p><em><strong>jquery.alerts.css</strong></em></p>
<p>#popup_container {<br />
font-family: Arial, sans-serif;<br />
font-size: 12px;<br />
min-width: 300px; /* Dialog will be no smaller than this */<br />
max-width: 600px; /* Dialog will wrap after this width */<br />
background: #FFF;<br />
border: solid 5px #999;<br />
color: #000;<br />
-moz-border-radius: 5px;<br />
-webkit-border-radius: 5px;<br />
border-radius: 5px;<br />
}</p>
<p>#popup_title {<br />
font-size: 14px;<br />
font-weight: bold;<br />
text-align: center;<br />
line-height: 1.75em;<br />
color: #666;<br />
background: #CCC url(images/title.gif) top repeat-x;<br />
border: solid 1px #FFF;<br />
border-bottom: solid 1px #999;<br />
cursor: default;<br />
padding: 0em;<br />
margin: 0em;<br />
}</p>
<p>#popup_content {<br />
background: 16px 16px no-repeat url(images/info.gif);<br />
padding: 1em 1.75em;<br />
margin: 0em;<br />
}</p>
<p>#popup_content.alert {<br />
background-image: url(images/info.gif);<br />
}</p>
<p>#popup_content.confirm {<br />
background-image: url(images/important.gif);<br />
}</p>
<p>#popup_content.prompt {<br />
background-image: url(images/help.gif);<br />
}</p>
<p>#popup_message {<br />
padding-left: 48px;<br />
}</p>
<p>#popup_panel {<br />
text-align: center;<br />
margin: 1em 0em 0em 1em;<br />
}</p>
<p>#popup_prompt {<br />
margin: .5em 0em;<br />
}</p>
<p>jquery.alerts.js</p>
<p>// jQuery Alert Dialogs Plugin<br />
//</p>
<p>// Usage:<br />
//        jAlert( message, [title, callback] )<br />
//        jConfirm( message, [title, callback] )<br />
//        jPrompt( message, [value, title, callback] )<br />
//</p>
<p>(function($) {</p>
<p>$.alerts = {</p>
<p>// These properties can be read/written by accessing $.alerts.propertyName from your scripts at any time</p>
<p>verticalOffset: -75,                // vertical offset of the dialog from center screen, in pixels<br />
horizontalOffset: 0,                // horizontal offset of the dialog from center screen, in pixels/<br />
repositionOnResize: true,           // re-centers the dialog on window resize<br />
overlayOpacity: .01,                // transparency level of overlay<br />
overlayColor: &#8216;#FFF&#8217;,               // base color of overlay<br />
draggable: true,                    // make the dialogs draggable (requires UI Draggables plugin)<br />
okButton: &#8216;&amp;nbsp;OK&amp;nbsp;&#8217;,         // text for the OK button<br />
cancelButton: &#8216;&amp;nbsp;Cancel&amp;nbsp;&#8217;, // text for the Cancel button<br />
dialogClass: null,                  // if specified, this class will be applied to all dialogs</p>
<p>// Public methods</p>
<p>alert: function(message, title, callback) {<br />
if( title == null ) title = &#8216;Alert&#8217;;<br />
$.alerts._show(title, message, null, &#8216;alert&#8217;, function(result) {<br />
if( callback ) callback(result);<br />
});<br />
},</p>
<p>confirm: function(message, title, callback) {<br />
if( title == null ) title = &#8216;Confirm&#8217;;<br />
$.alerts._show(title, message, null, &#8216;confirm&#8217;, function(result) {<br />
if( callback ) callback(result);<br />
});<br />
},</p>
<p>prompt: function(message, value, title, callback) {<br />
if( title == null ) title = &#8216;Prompt&#8217;;<br />
$.alerts._show(title, message, value, &#8216;prompt&#8217;, function(result) {<br />
if( callback ) callback(result);<br />
});<br />
},</p>
<p>// Private methods</p>
<p>_show: function(title, msg, value, type, callback) {</p>
<p>$.alerts._hide();<br />
$.alerts._overlay(&#8216;show&#8217;);</p>
<p>$(&#8220;BODY&#8221;).append(<br />
&#8216;&lt;div id=&#8221;popup_container&#8221;&gt;&#8217; +<br />
&#8216;&lt;h1 id=&#8221;popup_title&#8221;&gt;&lt;/h1&gt;&#8217; +<br />
&#8216;&lt;div id=&#8221;popup_content&#8221;&gt;&#8217; +<br />
&#8216;&lt;div id=&#8221;popup_message&#8221;&gt;&lt;/div&gt;&#8217; +<br />
&#8216;&lt;/div&gt;&#8217; +<br />
&#8216;&lt;/div&gt;&#8217;);</p>
<p>if( $.alerts.dialogClass ) $(&#8220;#popup_container&#8221;).addClass($.alerts.dialogClass);</p>
<p>// IE6 Fix<br />
var pos = ($.browser.msie &amp;&amp; parseInt($.browser.version) &lt;= 6 ) ? &#8216;absolute&#8217; : &#8216;fixed&#8217;;</p>
<p>$(&#8220;#popup_container&#8221;).css({<br />
position: pos,<br />
zIndex: 99999,<br />
padding: 0,<br />
margin: 0<br />
});</p>
<p>$(&#8220;#popup_title&#8221;).text(title);<br />
$(&#8220;#popup_content&#8221;).addClass(type);<br />
$(&#8220;#popup_message&#8221;).text(msg);<br />
$(&#8220;#popup_message&#8221;).html( $(&#8220;#popup_message&#8221;).text().replace(/\n/g, &#8216;&lt;br /&gt;&#8217;) );</p>
<p>$(&#8220;#popup_container&#8221;).css({<br />
minWidth: $(&#8220;#popup_container&#8221;).outerWidth(),<br />
maxWidth: $(&#8220;#popup_container&#8221;).outerWidth()<br />
});</p>
<p>$.alerts._reposition();<br />
$.alerts._maintainPosition(true);</p>
<p>switch( type ) {<br />
case &#8216;alert&#8217;:<br />
$(&#8220;#popup_message&#8221;).after(&#8216;&lt;div id=&#8221;popup_panel&#8221;&gt;&lt;input type=&#8221;button&#8221; value=&#8221;&#8216; + $.alerts.okButton + &#8216;&#8221; id=&#8221;popup_ok&#8221; /&gt;&lt;/div&gt;&#8217;);<br />
$(&#8220;#popup_ok&#8221;).click( function() {<br />
$.alerts._hide();<br />
callback(true);<br />
});<br />
$(&#8220;#popup_ok&#8221;).focus().keypress( function(e) {<br />
if( e.keyCode == 13 || e.keyCode == 27 ) $(&#8220;#popup_ok&#8221;).trigger(&#8216;click&#8217;);<br />
});<br />
break;<br />
case &#8216;confirm&#8217;:<br />
$(&#8220;#popup_message&#8221;).after(&#8216;&lt;div id=&#8221;popup_panel&#8221;&gt;&lt;input type=&#8221;button&#8221; value=&#8221;&#8216; + $.alerts.okButton + &#8216;&#8221; id=&#8221;popup_ok&#8221; /&gt; &lt;input type=&#8221;button&#8221; value=&#8221;&#8216; + $.alerts.cancelButton + &#8216;&#8221; id=&#8221;popup_cancel&#8221; /&gt;&lt;/div&gt;&#8217;);<br />
$(&#8220;#popup_ok&#8221;).click( function() {<br />
$.alerts._hide();<br />
if( callback ) callback(true);<br />
});<br />
$(&#8220;#popup_cancel&#8221;).click( function() {<br />
$.alerts._hide();<br />
if( callback ) callback(false);<br />
});<br />
$(&#8220;#popup_ok&#8221;).focus();<br />
$(&#8220;#popup_ok, #popup_cancel&#8221;).keypress( function(e) {<br />
if( e.keyCode == 13 ) $(&#8220;#popup_ok&#8221;).trigger(&#8216;click&#8217;);<br />
if( e.keyCode == 27 ) $(&#8220;#popup_cancel&#8221;).trigger(&#8216;click&#8217;);<br />
});<br />
break;<br />
case &#8216;prompt&#8217;:<br />
$(&#8220;#popup_message&#8221;).append(&#8216;&lt;br /&gt;&lt;input type=&#8221;text&#8221; size=&#8221;30&#8243; id=&#8221;popup_prompt&#8221; /&gt;&#8217;).after(&#8216;&lt;div id=&#8221;popup_panel&#8221;&gt;&lt;input type=&#8221;button&#8221; value=&#8221;&#8216; + $.alerts.okButton + &#8216;&#8221; id=&#8221;popup_ok&#8221; /&gt; &lt;input type=&#8221;button&#8221; value=&#8221;&#8216; + $.alerts.cancelButton + &#8216;&#8221; id=&#8221;popup_cancel&#8221; /&gt;&lt;/div&gt;&#8217;);<br />
$(&#8220;#popup_prompt&#8221;).width( $(&#8220;#popup_message&#8221;).width() );<br />
$(&#8220;#popup_ok&#8221;).click( function() {<br />
var val = $(&#8220;#popup_prompt&#8221;).val();<br />
$.alerts._hide();<br />
if( callback ) callback( val );<br />
});<br />
$(&#8220;#popup_cancel&#8221;).click( function() {<br />
$.alerts._hide();<br />
if( callback ) callback( null );<br />
});<br />
$(&#8220;#popup_prompt, #popup_ok, #popup_cancel&#8221;).keypress( function(e) {<br />
if( e.keyCode == 13 ) $(&#8220;#popup_ok&#8221;).trigger(&#8216;click&#8217;);<br />
if( e.keyCode == 27 ) $(&#8220;#popup_cancel&#8221;).trigger(&#8216;click&#8217;);<br />
});<br />
if( value ) $(&#8220;#popup_prompt&#8221;).val(value);<br />
$(&#8220;#popup_prompt&#8221;).focus().select();<br />
break;<br />
}</p>
<p>// Make draggable<br />
if( $.alerts.draggable ) {<br />
try {<br />
$(&#8220;#popup_container&#8221;).draggable({ handle: $(&#8220;#popup_title&#8221;) });<br />
$(&#8220;#popup_title&#8221;).css({ cursor: &#8216;move&#8217; });<br />
} catch(e) { /* requires jQuery UI draggables */ }<br />
}<br />
},</p>
<p>_hide: function() {<br />
$(&#8220;#popup_container&#8221;).remove();<br />
$.alerts._overlay(&#8216;hide&#8217;);<br />
$.alerts._maintainPosition(false);<br />
},</p>
<p>_overlay: function(status) {<br />
switch( status ) {<br />
case &#8216;show&#8217;:<br />
$.alerts._overlay(&#8216;hide&#8217;);<br />
$(&#8220;BODY&#8221;).append(&#8216;&lt;div id=&#8221;popup_overlay&#8221;&gt;&lt;/div&gt;&#8217;);<br />
$(&#8220;#popup_overlay&#8221;).css({<br />
position: &#8216;absolute&#8217;,<br />
zIndex: 99998,<br />
top: &#8217;0px&#8217;,<br />
left: &#8217;0px&#8217;,<br />
width: &#8217;100%&#8217;,<br />
height: $(document).height(),<br />
background: $.alerts.overlayColor,<br />
opacity: $.alerts.overlayOpacity<br />
});<br />
break;<br />
case &#8216;hide&#8217;:<br />
$(&#8220;#popup_overlay&#8221;).remove();<br />
break;<br />
}<br />
},</p>
<p>_reposition: function() {<br />
var top = (($(window).height() / 2) &#8211; ($(&#8220;#popup_container&#8221;).outerHeight() / 2)) + $.alerts.verticalOffset;<br />
var left = (($(window).width() / 2) &#8211; ($(&#8220;#popup_container&#8221;).outerWidth() / 2)) + $.alerts.horizontalOffset;<br />
if( top &lt; 0 ) top = 0;<br />
if( left &lt; 0 ) left = 0;</p>
<p>// IE6 fix<br />
if( $.browser.msie &amp;&amp; parseInt($.browser.version) &lt;= 6 ) top = top + $(window).scrollTop();</p>
<p>$(&#8220;#popup_container&#8221;).css({<br />
top: top + &#8216;px&#8217;,<br />
left: left + &#8216;px&#8217;<br />
});<br />
$(&#8220;#popup_overlay&#8221;).height( $(document).height() );<br />
},</p>
<p>_maintainPosition: function(status) {<br />
if( $.alerts.repositionOnResize ) {<br />
switch(status) {<br />
case true:<br />
$(window).bind(&#8216;resize&#8217;, $.alerts._reposition);<br />
break;<br />
case false:<br />
$(window).unbind(&#8216;resize&#8217;, $.alerts._reposition);<br />
break;<br />
}<br />
}<br />
}</p>
<p>}</p>
<p>// Shortuct functions<br />
jAlert = function(message, title, callback) {<br />
$.alerts.alert(message, title, callback);<br />
}</p>
<p>jConfirm = function(message, title, callback) {<br />
$.alerts.confirm(message, title, callback);<br />
};</p>
<p>jPrompt = function(message, value, title, callback) {<br />
$.alerts.prompt(message, value, title, callback);<br />
};</p>
<p>})(jQuery);</p>
<p><strong>jalert.html</strong></p>
<p>&lt;!DOCTYPE html PUBLIC &#8220;-//W3C//DTD XHTML 1.0 Transitional//EN&#8221; &#8220;<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&#8221;&#038;gt" rel="nofollow">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&#8221;&#038;gt</a>;<br />
&lt;html xmlns=&#8221;<a href="http://www.w3.org/1999/xhtml&#8221;&#038;gt" rel="nofollow">http://www.w3.org/1999/xhtml&#8221;&#038;gt</a>;<br />
&lt;head&gt;<br />
&lt;title&gt;jQuery Alert&lt;/title&gt;<br />
&lt;meta http-equiv=&#8221;Content-Type&#8221; content=&#8221;text/html;charset=UTF-8&#8243; /&gt;<br />
&lt;meta name=&#8221;description&#8221; content=&#8221;This is a demonstration page.&#8221; /&gt;<br />
&lt;meta name=&#8221;keywords&#8221; content=&#8221;alert, confirm, prompt, demo&#8221; /&gt;</p>
<p>&lt;style type=&#8221;text/css&#8221;&gt;<br />
BODY,<br />
HTML {<br />
padding: 0px;<br />
margin: 0px;<br />
}<br />
BODY {<br />
font-family: Arial, Helvetica, sans-serif;<br />
font-size: 12px;<br />
background: #FFF;<br />
padding: 15px;<br />
}</p>
<p>H1 {<br />
font-size: 20px;<br />
font-weight: normal;<br />
}</p>
<p>H2 {<br />
font-size: 16px;<br />
font-weight: normal;<br />
}</p>
<p>FIELDSET {<br />
border: solid 1px #CCC;<br />
-moz-border-radius: 16px;<br />
-webkit-border-radius: 16px;<br />
border-radius: 16px;<br />
padding: 1em 2em;<br />
margin: 1em 0em;<br />
}</p>
<p>LEGEND {<br />
color: #666;<br />
font-size: 16px;<br />
padding: 0em .5em;<br />
}</p>
<p>PRE {<br />
font-family: &#8220;Courier New&#8221;, monospace;<br />
font-size: 11px;<br />
color: #666;<br />
background: #F8F8F8;<br />
padding: 1em;<br />
-moz-border-radius: 8px;<br />
-webkit-border-radius: 8px;<br />
border-radius: 8px;<br />
}</p>
<p>/* Custom dialog styles */<br />
#popup_container.style_1 {<br />
font-family: Georgia, serif;<br />
color: #A4C6E2;<br />
background: #005294;<br />
border-color: #113F66;<br />
}</p>
<p>#popup_container.style_1 #popup_title {<br />
color: #FFF;<br />
font-weight: normal;<br />
text-align: left;<br />
background: #76A5CC;<br />
border: solid 1px #005294;<br />
padding-left: 1em;<br />
}</p>
<p>#popup_container.style_1 #popup_content {<br />
background: none;<br />
}</p>
<p>#popup_container.style_1 #popup_message {<br />
padding-left: 0em;<br />
}</p>
<p>#popup_container.style_1 INPUT[type='button'] {<br />
border: outset 2px #76A5CC;<br />
color: #A4C6E2;<br />
background: #3778AE;<br />
}</p>
<p>&lt;/style&gt;</p>
<p>&lt;!&#8211; Dependencies &#8211;&gt;</p>
<p>&lt;script src=&#8221;jquery.js&#8221; type=&#8221;text/javascript&#8221;&gt;&lt;/script&gt;<br />
&lt;!&#8211;&lt;script src=&#8221;jquery.ui.draggable.js&#8221; type=&#8221;text/javascript&#8221;&gt;&lt;/script&gt;&#8211;&gt;</p>
<p>&lt;!&#8211; Core files &#8211;&gt;<br />
&lt;script src=&#8221;jquery.alerts.js&#8221; type=&#8221;text/javascript&#8221;&gt;&lt;/script&gt;<br />
&lt;link href=&#8221;jquery.alerts.css&#8221; rel=&#8221;stylesheet&#8221; type=&#8221;text/css&#8221; media=&#8221;screen&#8221; /&gt;</p>
<p>&lt;!&#8211; Example script &#8211;&gt;<br />
&lt;script type=&#8221;text/javascript&#8221;&gt;</p>
<p>$(document).ready( function() {</p>
<p>$(&#8220;#alert_button&#8221;).click( function() {<br />
jAlert(&#8216;This is a custom alert box&#8217;, &#8216;Alert Dialog&#8217;);<br />
});</p>
<p>$(&#8220;#confirm_button&#8221;).click( function() {<br />
jConfirm(&#8216;Can you confirm this?&#8217;, &#8216;Confirmation Dialog&#8217;, function(r) {<br />
jAlert(&#8216;Confirmed: &#8216; + r, &#8216;Confirmation Results&#8217;);<br />
});<br />
});</p>
<p>$(&#8220;#prompt_button&#8221;).click( function() {<br />
jPrompt(&#8216;Type something:&#8217;, &#8216;Prefilled value&#8217;, &#8216;Prompt Dialog&#8217;, function(r) {<br />
if( r ) alert(&#8216;You entered &#8216; + r);<br />
});<br />
});</p>
<p>$(&#8220;#alert_button_with_html&#8221;).click( function() {<br />
jAlert(&#8216;You can use HTML, such as &lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italics&lt;/em&gt;, and &lt;u&gt;underline&lt;/u&gt;!&#8217;);<br />
});</p>
<p>$(&#8220;.alert_style_example&#8221;).click( function() {<br />
$.alerts.dialogClass = $(this).attr(&#8216;id&#8217;); // set custom style class<br />
jAlert(&#8216;This is the custom class called &amp;ldquo;style_1&amp;rdquo;&#8217;, &#8216;Custom Styles&#8217;, function() {<br />
$.alerts.dialogClass = null; // reset to default<br />
});<br />
});<br />
});</p>
<p>&lt;/script&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h1&gt;&lt;a href=&#8221;<a href="http://abeautifulsite.net/2008/12/jquery-alert-dialogs/&#8221;&gt;&#038;laquo" rel="nofollow">http://abeautifulsite.net/2008/12/jquery-alert-dialogs/&#8221;&gt;&#038;laquo</a>; jQuery Alert Dialogs (Alert, Confirm, &amp;amp; Prompt Replacements)&lt;/a&gt;&lt;/h1&gt;</p>
<p>&lt;h2&gt;Alert&lt;/h2&gt;</p>
<p>&lt;fieldset&gt;<br />
&lt;legend&gt;Alert&lt;/legend&gt;</p>
<p>&lt;pre&gt;<br />
jAlert(&#8216;This is a custom alert box&#8217;, &#8216;Alert Dialog&#8217;);<br />
&lt;/pre&gt;<br />
&lt;p&gt;<br />
&lt;input id=&#8221;alert_button&#8221; type=&#8221;button&#8221; value=&#8221;Show Alert&#8221; /&gt;<br />
&lt;/p&gt;<br />
&lt;/fieldset&gt;</p>
<p>&lt;fieldset&gt;<br />
&lt;legend&gt;Confirm&lt;/legend&gt;<br />
&lt;pre&gt;</p>
<p>jConfirm(&#8216;Can you confirm this?&#8217;, &#8216;Confirmation Dialog&#8217;, function(r) {<br />
jAlert(&#8216;Confirmed: &#8216; + r, &#8216;Confirmation Results&#8217;);<br />
});<br />
&lt;/pre&gt;<br />
&lt;p&gt;<br />
&lt;input id=&#8221;confirm_button&#8221; type=&#8221;button&#8221; value=&#8221;Show Confirm&#8221; /&gt;<br />
&lt;/p&gt;<br />
&lt;/fieldset&gt;</p>
<p>&lt;fieldset&gt;<br />
&lt;legend&gt;Prompt&lt;/legend&gt;<br />
&lt;pre&gt;<br />
jPrompt(&#8216;Type something:&#8217;, &#8216;Prefilled value&#8217;, &#8216;Prompt Dialog&#8217;, function(r) {<br />
if( r ) alert(&#8216;You entered &#8216; + r);<br />
});</p>
<p>&lt;/pre&gt;<br />
&lt;p&gt;<br />
&lt;input id=&#8221;prompt_button&#8221; type=&#8221;button&#8221; value=&#8221;Show Prompt&#8221; /&gt;<br />
&lt;/p&gt;<br />
&lt;/fieldset&gt;</p>
<p>&lt;h2&gt;Additional Examples&lt;/h2&gt;<br />
&lt;fieldset&gt;<br />
&lt;legend&gt;With HTML&lt;/legend&gt;</p>
<p>&lt;pre&gt;<br />
jAlert(&#8216;You can use HTML, such as &lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italics&lt;/em&gt;, and &lt;u&gt;underline&lt;/u&gt;!&#8217;);<br />
&lt;/pre&gt;<br />
&lt;p&gt;<br />
&lt;input id=&#8221;alert_button_with_html&#8221; type=&#8221;button&#8221; value=&#8221;Show Alert&#8221; /&gt;<br />
&lt;/p&gt;<br />
&lt;/fieldset&gt;</p>
<p>&lt;fieldset&gt;<br />
&lt;legend&gt;Alternate Styles&lt;/legend&gt;<br />
&lt;p&gt;<br />
By changing the value of the &lt;samp&gt;$.alerts.dialogClass&lt;/samp&gt; property (and creating<br />
your own CSS class), you can changes the style of your dialogs:<br />
&lt;/p&gt;</p>
<p>&lt;p&gt;<br />
&lt;input id=&#8221;style_1&#8243; type=&#8221;button&#8221; value=&#8221;Style 1&#8243; /&gt;</p>
<p>&lt;/p&gt;</p>
<p>&lt;p&gt;<br />
View the plugin source for additional properties that can be modifed at runtime.<br />
&lt;/p&gt;<br />
&lt;/fieldset&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p><em><strong>jquery.js</strong></em></p>
<p>/*!<br />
* jQuery JavaScript Library v1.7<br />
* <a href="http://jquery.com/" rel="nofollow">http://jquery.com/</a><br />
*<br />
* Copyright 2011, John Resig<br />
* Dual licensed under the MIT or GPL Version 2 licenses.<br />
* <a href="http://jquery.org/license" rel="nofollow">http://jquery.org/license</a><br />
*<br />
* Includes Sizzle.js<br />
* <a href="http://sizzlejs.com/" rel="nofollow">http://sizzlejs.com/</a><br />
* Copyright 2011, The Dojo Foundation<br />
* Released under the MIT, BSD, and GPL Licenses.<br />
*<br />
* Date: Thu Nov 3 16:18:21 2011 -0400<br />
*/<br />
(function( window, undefined ) {</p>
<p>// Use the correct document accordingly with window argument (sandbox)<br />
var document = window.document,<br />
navigator = window.navigator,<br />
location = window.location;<br />
var jQuery = (function() {</p>
<p>// Define a local copy of jQuery<br />
var jQuery = function( selector, context ) {<br />
// The jQuery object is actually just the init constructor &#8216;enhanced&#8217;<br />
return new jQuery.fn.init( selector, context, rootjQuery );<br />
},</p>
<p>// Map over jQuery in case of overwrite<br />
_jQuery = window.jQuery,</p>
<p>// Map over the $ in case of overwrite<br />
_$ = window.$,</p>
<p>// A central reference to the root jQuery(document)<br />
rootjQuery,</p>
<p>// A simple way to check for HTML strings or ID strings<br />
// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)<br />
quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/,</p>
<p>// Check if a string has a non-whitespace character in it<br />
rnotwhite = /\S/,</p>
<p>// Used for trimming whitespace<br />
trimLeft = /^\s+/,<br />
trimRight = /\s+$/,</p>
<p>// Check for digits<br />
rdigit = /\d/,</p>
<p>// Match a standalone tag<br />
rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,</p>
<p>// JSON RegExp<br />
rvalidchars = /^[\],:{}\s]*$/,<br />
rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,<br />
rvalidtokens = /&#8221;[^"\\\n\r]*&#8221;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,<br />
rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,</p>
<p>// Useragent RegExp<br />
rwebkit = /(webkit)[ \/]([\w.]+)/,<br />
ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,<br />
rmsie = /(msie) ([\w.]+)/,<br />
rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,</p>
<p>// Matches dashed string for camelizing<br />
rdashAlpha = /-([a-z]|[0-9])/ig,<br />
rmsPrefix = /^-ms-/,</p>
<p>// Used by jQuery.camelCase as callback to replace()<br />
fcamelCase = function( all, letter ) {<br />
return ( letter + &#8220;&#8221; ).toUpperCase();<br />
},</p>
<p>// Keep a UserAgent string for use with jQuery.browser<br />
userAgent = navigator.userAgent,</p>
<p>// For matching the engine and version of the browser<br />
browserMatch,</p>
<p>// The deferred used on DOM ready<br />
readyList,</p>
<p>// The ready event handler<br />
DOMContentLoaded,</p>
<p>// Save a reference to some core methods<br />
toString = Object.prototype.toString,<br />
hasOwn = Object.prototype.hasOwnProperty,<br />
push = Array.prototype.push,<br />
slice = Array.prototype.slice,<br />
trim = String.prototype.trim,<br />
indexOf = Array.prototype.indexOf,</p>
<p>// [[Class]] -&gt; type pairs<br />
class2type = {};</p>
<p>jQuery.fn = jQuery.prototype = {<br />
constructor: jQuery,<br />
init: function( selector, context, rootjQuery ) {<br />
var match, elem, ret, doc;</p>
<p>// Handle $(&#8220;&#8221;), $(null), or $(undefined)<br />
if ( !selector ) {<br />
return this;<br />
}</p>
<p>// Handle $(DOMElement)<br />
if ( selector.nodeType ) {<br />
this.context = this[0] = selector;<br />
this.length = 1;<br />
return this;<br />
}</p>
<p>// The body element only exists once, optimize finding it<br />
if ( selector === &#8220;body&#8221; &amp;&amp; !context &amp;&amp; document.body ) {<br />
this.context = document;<br />
this[0] = document.body;<br />
this.selector = selector;<br />
this.length = 1;<br />
return this;<br />
}</p>
<p>// Handle HTML strings<br />
if ( typeof selector === &#8220;string&#8221; ) {<br />
// Are we dealing with HTML string or an ID?<br />
if ( selector.charAt(0) === &#8220;&lt;&#8221; &amp;&amp; selector.charAt( selector.length &#8211; 1 ) === &#8220;&gt;&#8221; &amp;&amp; selector.length &gt;= 3 ) {<br />
// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check<br />
match = [ null, selector, null ];</p>
<p>} else {<br />
match = quickExpr.exec( selector );<br />
}</p>
<p>// Verify a match, and that no context was specified for #id<br />
if ( match &amp;&amp; (match[1] || !context) ) {</p>
<p>// HANDLE: $(html) -&gt; $(array)<br />
if ( match[1] ) {<br />
context = context instanceof jQuery ? context[0] : context;<br />
doc = ( context ? context.ownerDocument || context : document );</p>
<p>// If a single string is passed in and it&#8217;s a single tag<br />
// just do a createElement and skip the rest<br />
ret = rsingleTag.exec( selector );</p>
<p>if ( ret ) {<br />
if ( jQuery.isPlainObject( context ) ) {<br />
selector = [ document.createElement( ret[1] ) ];<br />
jQuery.fn.attr.call( selector, context, true );</p>
<p>} else {<br />
selector = [ doc.createElement( ret[1] ) ];<br />
}</p>
<p>} else {<br />
ret = jQuery.buildFragment( [ match[1] ], [ doc ] );<br />
selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;<br />
}</p>
<p>return jQuery.merge( this, selector );</p>
<p>// HANDLE: $(&#8220;#id&#8221;)<br />
} else {<br />
elem = document.getElementById( match[2] );</p>
<p>// Check parentNode to catch when Blackberry 4.6 returns<br />
// nodes that are no longer in the document #6963<br />
if ( elem &amp;&amp; elem.parentNode ) {<br />
// Handle the case where IE and Opera return items<br />
// by name instead of ID<br />
if ( elem.id !== match[2] ) {<br />
return rootjQuery.find( selector );<br />
}</p>
<p>// Otherwise, we inject the element directly into the jQuery object<br />
this.length = 1;<br />
this[0] = elem;<br />
}</p>
<p>this.context = document;<br />
this.selector = selector;<br />
return this;<br />
}</p>
<p>// HANDLE: $(expr, $(&#8230;))<br />
} else if ( !context || context.jquery ) {<br />
return ( context || rootjQuery ).find( selector );</p>
<p>// HANDLE: $(expr, context)<br />
// (which is just equivalent to: $(context).find(expr)<br />
} else {<br />
return this.constructor( context ).find( selector );<br />
}</p>
<p>// HANDLE: $(function)<br />
// Shortcut for document ready<br />
} else if ( jQuery.isFunction( selector ) ) {<br />
return rootjQuery.ready( selector );<br />
}</p>
<p>if ( selector.selector !== undefined ) {<br />
this.selector = selector.selector;<br />
this.context = selector.context;<br />
}</p>
<p>return jQuery.makeArray( selector, this );<br />
},</p>
<p>// Start with an empty selector<br />
selector: &#8220;&#8221;,</p>
<p>// The current version of jQuery being used<br />
jquery: &#8220;1.7&#8243;,</p>
<p>// The default length of a jQuery object is 0<br />
length: 0,</p>
<p>// The number of elements contained in the matched element set<br />
size: function() {<br />
return this.length;<br />
},</p>
<p>toArray: function() {<br />
return slice.call( this, 0 );<br />
},</p>
<p>// Get the Nth element in the matched element set OR<br />
// Get the whole matched element set as a clean array<br />
get: function( num ) {<br />
return num == null ?</p>
<p>// Return a &#8216;clean&#8217; array<br />
this.toArray() :</p>
<p>// Return just the object<br />
( num &lt; 0 ? this[ this.length + num ] : this[ num ] );<br />
},</p>
<p>// Take an array of elements and push it onto the stack<br />
// (returning the new matched element set)<br />
pushStack: function( elems, name, selector ) {<br />
// Build a new jQuery matched element set<br />
var ret = this.constructor();</p>
<p>if ( jQuery.isArray( elems ) ) {<br />
push.apply( ret, elems );</p>
<p>} else {<br />
jQuery.merge( ret, elems );<br />
}</p>
<p>// Add the old object onto the stack (as a reference)<br />
ret.prevObject = this;</p>
<p>ret.context = this.context;</p>
<p>if ( name === &#8220;find&#8221; ) {<br />
ret.selector = this.selector + ( this.selector ? &#8221; &#8221; : &#8220;&#8221; ) + selector;<br />
} else if ( name ) {<br />
ret.selector = this.selector + &#8220;.&#8221; + name + &#8220;(&#8221; + selector + &#8220;)&#8221;;<br />
}</p>
<p>// Return the newly-formed element set<br />
return ret;<br />
},</p>
<p>// Execute a callback for every element in the matched set.<br />
// (You can seed the arguments with an array of args, but this is<br />
// only used internally.)<br />
each: function( callback, args ) {<br />
return jQuery.each( this, callback, args );<br />
},</p>
<p>ready: function( fn ) {<br />
// Attach the listeners<br />
jQuery.bindReady();</p>
<p>// Add the callback<br />
readyList.add( fn );</p>
<p>return this;<br />
},</p>
<p>eq: function( i ) {<br />
return i === -1 ?<br />
this.slice( i ) :<br />
this.slice( i, +i + 1 );<br />
},</p>
<p>first: function() {<br />
return this.eq( 0 );<br />
},</p>
<p>last: function() {<br />
return this.eq( -1 );<br />
},</p>
<p>slice: function() {<br />
return this.pushStack( slice.apply( this, arguments ),<br />
&#8220;slice&#8221;, slice.call(arguments).join(&#8220;,&#8221;) );<br />
},</p>
<p>map: function( callback ) {<br />
return this.pushStack( jQuery.map(this, function( elem, i ) {<br />
return callback.call( elem, i, elem );<br />
}));<br />
},</p>
<p>end: function() {<br />
return this.prevObject || this.constructor(null);<br />
},</p>
<p>// For internal use only.<br />
// Behaves like an Array&#8217;s method, not like a jQuery method.<br />
push: push,<br />
sort: [].sort,<br />
splice: [].splice<br />
};</p>
<p>// Give the init function the jQuery prototype for later instantiation<br />
jQuery.fn.init.prototype = jQuery.fn;</p>
<p>jQuery.extend = jQuery.fn.extend = function() {<br />
var options, name, src, copy, copyIsArray, clone,<br />
target = arguments[0] || {},<br />
i = 1,<br />
length = arguments.length,<br />
deep = false;</p>
<p>// Handle a deep copy situation<br />
if ( typeof target === &#8220;boolean&#8221; ) {<br />
deep = target;<br />
target = arguments[1] || {};<br />
// skip the boolean and the target<br />
i = 2;<br />
}</p>
<p>// Handle case when target is a string or something (possible in deep copy)<br />
if ( typeof target !== &#8220;object&#8221; &amp;&amp; !jQuery.isFunction(target) ) {<br />
target = {};<br />
}</p>
<p>// extend jQuery itself if only one argument is passed<br />
if ( length === i ) {<br />
target = this;<br />
&#8211;i;<br />
}</p>
<p>for ( ; i &lt; length; i++ ) {<br />
// Only deal with non-null/undefined values<br />
if ( (options = arguments[ i ]) != null ) {<br />
// Extend the base object<br />
for ( name in options ) {<br />
src = target[ name ];<br />
copy = options[ name ];</p>
<p>// Prevent never-ending loop<br />
if ( target === copy ) {<br />
continue;<br />
}</p>
<p>// Recurse if we&#8217;re merging plain objects or arrays<br />
if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {<br />
if ( copyIsArray ) {<br />
copyIsArray = false;<br />
clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</p>
<p>} else {<br />
clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};<br />
}</p>
<p>// Never move original objects, clone them<br />
target[ name ] = jQuery.extend( deep, clone, copy );</p>
<p>// Don&#8217;t bring in undefined values<br />
} else if ( copy !== undefined ) {<br />
target[ name ] = copy;<br />
}<br />
}<br />
}<br />
}</p>
<p>// Return the modified object<br />
return target;<br />
};</p>
<p>jQuery.extend({<br />
noConflict: function( deep ) {<br />
if ( window.$ === jQuery ) {<br />
window.$ = _$;<br />
}</p>
<p>if ( deep &amp;&amp; window.jQuery === jQuery ) {<br />
window.jQuery = _jQuery;<br />
}</p>
<p>return jQuery;<br />
},</p>
<p>// Is the DOM ready to be used? Set to true once it occurs.<br />
isReady: false,</p>
<p>// A counter to track how many items to wait for before<br />
// the ready event fires. See #6781<br />
readyWait: 1,</p>
<p>// Hold (or release) the ready event<br />
holdReady: function( hold ) {<br />
if ( hold ) {<br />
jQuery.readyWait++;<br />
} else {<br />
jQuery.ready( true );<br />
}<br />
},</p>
<p>// Handle when the DOM is ready<br />
ready: function( wait ) {<br />
// Either a released hold or an DOMready/load event and not yet ready<br />
if ( (wait === true &amp;&amp; !&#8211;jQuery.readyWait) || (wait !== true &amp;&amp; !jQuery.isReady) ) {<br />
// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).<br />
if ( !document.body ) {<br />
return setTimeout( jQuery.ready, 1 );<br />
}</p>
<p>// Remember that the DOM is ready<br />
jQuery.isReady = true;</p>
<p>// If a normal DOM Ready event fired, decrement, and wait if need be<br />
if ( wait !== true &amp;&amp; &#8211;jQuery.readyWait &gt; 0 ) {<br />
return;<br />
}</p>
<p>// If there are functions bound, to execute<br />
readyList.fireWith( document, [ jQuery ] );</p>
<p>// Trigger any bound ready events<br />
if ( jQuery.fn.trigger ) {<br />
jQuery( document ).trigger( &#8220;ready&#8221; ).unbind( &#8220;ready&#8221; );<br />
}<br />
}<br />
},</p>
<p>bindReady: function() {<br />
if ( readyList ) {<br />
return;<br />
}</p>
<p>readyList = jQuery.Callbacks( &#8220;once memory&#8221; );</p>
<p>// Catch cases where $(document).ready() is called after the<br />
// browser event has already occurred.<br />
if ( document.readyState === &#8220;complete&#8221; ) {<br />
// Handle it asynchronously to allow scripts the opportunity to delay ready<br />
return setTimeout( jQuery.ready, 1 );<br />
}</p>
<p>// Mozilla, Opera and webkit nightlies currently support this event<br />
if ( document.addEventListener ) {<br />
// Use the handy event callback<br />
document.addEventListener( &#8220;DOMContentLoaded&#8221;, DOMContentLoaded, false );</p>
<p>// A fallback to window.onload, that will always work<br />
window.addEventListener( &#8220;load&#8221;, jQuery.ready, false );</p>
<p>// If IE event model is used<br />
} else if ( document.attachEvent ) {<br />
// ensure firing before onload,<br />
// maybe late but safe also for iframes<br />
document.attachEvent( &#8220;onreadystatechange&#8221;, DOMContentLoaded );</p>
<p>// A fallback to window.onload, that will always work<br />
window.attachEvent( &#8220;onload&#8221;, jQuery.ready );</p>
<p>// If IE and not a frame<br />
// continually check to see if the document is ready<br />
var toplevel = false;</p>
<p>try {<br />
toplevel = window.frameElement == null;<br />
} catch(e) {}</p>
<p>if ( document.documentElement.doScroll &amp;&amp; toplevel ) {<br />
doScrollCheck();<br />
}<br />
}<br />
},</p>
<p>// See test/unit/core.js for details concerning isFunction.<br />
// Since version 1.3, DOM methods and functions like alert<br />
// aren&#8217;t supported. They return false on IE (#2968).<br />
isFunction: function( obj ) {<br />
return jQuery.type(obj) === &#8220;function&#8221;;<br />
},</p>
<p>isArray: Array.isArray || function( obj ) {<br />
return jQuery.type(obj) === &#8220;array&#8221;;<br />
},</p>
<p>// A crude way of determining if an object is a window<br />
isWindow: function( obj ) {<br />
return obj &amp;&amp; typeof obj === &#8220;object&#8221; &amp;&amp; &#8220;setInterval&#8221; in obj;<br />
},</p>
<p>isNumeric: function( obj ) {<br />
return obj != null &amp;&amp; rdigit.test( obj ) &amp;&amp; !isNaN( obj );<br />
},</p>
<p>type: function( obj ) {<br />
return obj == null ?<br />
String( obj ) :<br />
class2type[ toString.call(obj) ] || &#8220;object&#8221;;<br />
},</p>
<p>isPlainObject: function( obj ) {<br />
// Must be an Object.<br />
// Because of IE, we also have to check the presence of the constructor property.<br />
// Make sure that DOM nodes and window objects don&#8217;t pass through, as well<br />
if ( !obj || jQuery.type(obj) !== &#8220;object&#8221; || obj.nodeType || jQuery.isWindow( obj ) ) {<br />
return false;<br />
}</p>
<p>try {<br />
// Not own constructor property must be Object<br />
if ( obj.constructor &amp;&amp;<br />
!hasOwn.call(obj, &#8220;constructor&#8221;) &amp;&amp;<br />
!hasOwn.call(obj.constructor.prototype, &#8220;isPrototypeOf&#8221;) ) {<br />
return false;<br />
}<br />
} catch ( e ) {<br />
// IE8,9 Will throw exceptions on certain host objects #9897<br />
return false;<br />
}</p>
<p>// Own properties are enumerated firstly, so to speed up,<br />
// if last one is own, then all properties are own.</p>
<p>var key;<br />
for ( key in obj ) {}</p>
<p>return key === undefined || hasOwn.call( obj, key );<br />
},</p>
<p>isEmptyObject: function( obj ) {<br />
for ( var name in obj ) {<br />
return false;<br />
}<br />
return true;<br />
},</p>
<p>error: function( msg ) {<br />
throw msg;<br />
},</p>
<p>parseJSON: function( data ) {<br />
if ( typeof data !== &#8220;string&#8221; || !data ) {<br />
return null;<br />
}</p>
<p>// Make sure leading/trailing whitespace is removed (IE can&#8217;t handle it)<br />
data = jQuery.trim( data );</p>
<p>// Attempt to parse using the native JSON parser first<br />
if ( window.JSON &amp;&amp; window.JSON.parse ) {<br />
return window.JSON.parse( data );<br />
}</p>
<p>// Make sure the incoming data is actual JSON<br />
// Logic borrowed from <a href="http://json.org/json2.js" rel="nofollow">http://json.org/json2.js</a><br />
if ( rvalidchars.test( data.replace( rvalidescape, &#8220;@&#8221; )<br />
.replace( rvalidtokens, &#8220;]&#8221; )<br />
.replace( rvalidbraces, &#8220;&#8221;)) ) {</p>
<p>return ( new Function( &#8220;return &#8221; + data ) )();</p>
<p>}<br />
jQuery.error( &#8220;Invalid JSON: &#8221; + data );<br />
},</p>
<p>// Cross-browser xml parsing<br />
parseXML: function( data ) {<br />
var xml, tmp;<br />
try {<br />
if ( window.DOMParser ) { // Standard<br />
tmp = new DOMParser();<br />
xml = tmp.parseFromString( data , &#8220;text/xml&#8221; );<br />
} else { // IE<br />
xml = new ActiveXObject( &#8220;Microsoft.XMLDOM&#8221; );<br />
xml.async = &#8220;false&#8221;;<br />
xml.loadXML( data );<br />
}<br />
} catch( e ) {<br />
xml = undefined;<br />
}<br />
if ( !xml || !xml.documentElement || xml.getElementsByTagName( &#8220;parsererror&#8221; ).length ) {<br />
jQuery.error( &#8220;Invalid XML: &#8221; + data );<br />
}<br />
return xml;<br />
},</p>
<p>noop: function() {},</p>
<p>// Evaluates a script in a global context<br />
// Workarounds based on findings by Jim Driscoll<br />
// <a href="http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context" rel="nofollow">http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context</a><br />
globalEval: function( data ) {<br />
if ( data &amp;&amp; rnotwhite.test( data ) ) {<br />
// We use execScript on Internet Explorer<br />
// We use an anonymous function so that context is window<br />
// rather than jQuery in Firefox<br />
( window.execScript || function( data ) {<br />
window[ "eval" ].call( window, data );<br />
} )( data );<br />
}<br />
},</p>
<p>// Convert dashed to camelCase; used by the css and data modules<br />
// Microsoft forgot to hump their vendor prefix (#9572)<br />
camelCase: function( string ) {<br />
return string.replace( rmsPrefix, &#8220;ms-&#8221; ).replace( rdashAlpha, fcamelCase );<br />
},</p>
<p>nodeName: function( elem, name ) {<br />
return elem.nodeName &amp;&amp; elem.nodeName.toUpperCase() === name.toUpperCase();<br />
},</p>
<p>// args is for internal usage only<br />
each: function( object, callback, args ) {<br />
var name, i = 0,<br />
length = object.length,<br />
isObj = length === undefined || jQuery.isFunction( object );</p>
<p>if ( args ) {<br />
if ( isObj ) {<br />
for ( name in object ) {<br />
if ( callback.apply( object[ name ], args ) === false ) {<br />
break;<br />
}<br />
}<br />
} else {<br />
for ( ; i &lt; length; ) {<br />
if ( callback.apply( object[ i++ ], args ) === false ) {<br />
break;<br />
}<br />
}<br />
}</p>
<p>// A special, fast, case for the most common use of each<br />
} else {<br />
if ( isObj ) {<br />
for ( name in object ) {<br />
if ( callback.call( object[ name ], name, object[ name ] ) === false ) {<br />
break;<br />
}<br />
}<br />
} else {<br />
for ( ; i &lt; length; ) {<br />
if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {<br />
break;<br />
}<br />
}<br />
}<br />
}</p>
<p>return object;<br />
},</p>
<p>// Use native String.trim function wherever possible<br />
trim: trim ?<br />
function( text ) {<br />
return text == null ?<br />
&#8220;&#8221; :<br />
trim.call( text );<br />
} :</p>
<p>// Otherwise use our own trimming functionality<br />
function( text ) {<br />
return text == null ?<br />
&#8220;&#8221; :<br />
text.toString().replace( trimLeft, &#8220;&#8221; ).replace( trimRight, &#8220;&#8221; );<br />
},</p>
<p>// results is for internal usage only<br />
makeArray: function( array, results ) {<br />
var ret = results || [];</p>
<p>if ( array != null ) {<br />
// The window, strings (and functions) also have &#8216;length&#8217;<br />
// The extra typeof function check is to prevent crashes<br />
// in Safari 2 (See: #3039)<br />
// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930<br />
var type = jQuery.type( array );</p>
<p>if ( array.length == null || type === &#8220;string&#8221; || type === &#8220;function&#8221; || type === &#8220;regexp&#8221; || jQuery.isWindow( array ) ) {<br />
push.call( ret, array );<br />
} else {<br />
jQuery.merge( ret, array );<br />
}<br />
}</p>
<p>return ret;<br />
},</p>
<p>inArray: function( elem, array, i ) {<br />
var len;</p>
<p>if ( array ) {<br />
if ( indexOf ) {<br />
return indexOf.call( array, elem, i );<br />
}</p>
<p>len = array.length;<br />
i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;</p>
<p>for ( ; i &lt; len; i++ ) {<br />
// Skip accessing in sparse arrays<br />
if ( i in array &amp;&amp; array[ i ] === elem ) {<br />
return i;<br />
}<br />
}<br />
}</p>
<p>return -1;<br />
},</p>
<p>merge: function( first, second ) {<br />
var i = first.length,<br />
j = 0;</p>
<p>if ( typeof second.length === &#8220;number&#8221; ) {<br />
for ( var l = second.length; j &lt; l; j++ ) {<br />
first[ i++ ] = second[ j ];<br />
}</p>
<p>} else {<br />
while ( second[j] !== undefined ) {<br />
first[ i++ ] = second[ j++ ];<br />
}<br />
}</p>
<p>first.length = i;</p>
<p>return first;<br />
},</p>
<p>grep: function( elems, callback, inv ) {<br />
var ret = [], retVal;<br />
inv = !!inv;</p>
<p>// Go through the array, only saving the items<br />
// that pass the validator function<br />
for ( var i = 0, length = elems.length; i &lt; length; i++ ) {<br />
retVal = !!callback( elems[ i ], i );<br />
if ( inv !== retVal ) {<br />
ret.push( elems[ i ] );<br />
}<br />
}</p>
<p>return ret;<br />
},</p>
<p>// arg is for internal usage only<br />
map: function( elems, callback, arg ) {<br />
var value, key, ret = [],<br />
i = 0,<br />
length = elems.length,<br />
// jquery objects are treated as arrays<br />
isArray = elems instanceof jQuery || length !== undefined &amp;&amp; typeof length === &#8220;number&#8221; &amp;&amp; ( ( length &gt; 0 &amp;&amp; elems[ 0 ] &amp;&amp; elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;</p>
<p>// Go through the array, translating each of the items to their<br />
if ( isArray ) {<br />
for ( ; i &lt; length; i++ ) {<br />
value = callback( elems[ i ], i, arg );</p>
<p>if ( value != null ) {<br />
ret[ ret.length ] = value;<br />
}<br />
}</p>
<p>// Go through every key on the object,<br />
} else {<br />
for ( key in elems ) {<br />
value = callback( elems[ key ], key, arg );</p>
<p>if ( value != null ) {<br />
ret[ ret.length ] = value;<br />
}<br />
}<br />
}</p>
<p>// Flatten any nested arrays<br />
return ret.concat.apply( [], ret );<br />
},</p>
<p>// A global GUID counter for objects<br />
guid: 1,</p>
<p>// Bind a function to a context, optionally partially applying any<br />
// arguments.<br />
proxy: function( fn, context ) {<br />
if ( typeof context === &#8220;string&#8221; ) {<br />
var tmp = fn[ context ];<br />
context = fn;<br />
fn = tmp;<br />
}</p>
<p>// Quick check to determine if target is callable, in the spec<br />
// this throws a TypeError, but we will just return undefined.<br />
if ( !jQuery.isFunction( fn ) ) {<br />
return undefined;<br />
}</p>
<p>// Simulated bind<br />
var args = slice.call( arguments, 2 ),<br />
proxy = function() {<br />
return fn.apply( context, args.concat( slice.call( arguments ) ) );<br />
};</p>
<p>// Set the guid of unique handler to the same of original handler, so it can be removed<br />
proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;</p>
<p>return proxy;<br />
},</p>
<p>// Mutifunctional method to get and set values to a collection<br />
// The value/s can optionally be executed if it&#8217;s a function<br />
access: function( elems, key, value, exec, fn, pass ) {<br />
var length = elems.length;</p>
<p>// Setting many attributes<br />
if ( typeof key === &#8220;object&#8221; ) {<br />
for ( var k in key ) {<br />
jQuery.access( elems, k, key[k], exec, fn, value );<br />
}<br />
return elems;<br />
}</p>
<p>// Setting one attribute<br />
if ( value !== undefined ) {<br />
// Optionally, function values get executed if exec is true<br />
exec = !pass &amp;&amp; exec &amp;&amp; jQuery.isFunction(value);</p>
<p>for ( var i = 0; i &lt; length; i++ ) {<br />
fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );<br />
}</p>
<p>return elems;<br />
}</p>
<p>// Getting an attribute<br />
return length ? fn( elems[0], key ) : undefined;<br />
},</p>
<p>now: function() {<br />
return ( new Date() ).getTime();<br />
},</p>
<p>// Use of jQuery.browser is frowned upon.<br />
// More details: <a href="http://docs.jquery.com/Utilities/jQuery.browser" rel="nofollow">http://docs.jquery.com/Utilities/jQuery.browser</a><br />
uaMatch: function( ua ) {<br />
ua = ua.toLowerCase();</p>
<p>var match = rwebkit.exec( ua ) ||<br />
ropera.exec( ua ) ||<br />
rmsie.exec( ua ) ||<br />
ua.indexOf(&#8220;compatible&#8221;) &lt; 0 &amp;&amp; rmozilla.exec( ua ) ||<br />
[];</p>
<p>return { browser: match[1] || &#8220;&#8221;, version: match[2] || &#8220;0&#8243; };<br />
},</p>
<p>sub: function() {<br />
function jQuerySub( selector, context ) {<br />
return new jQuerySub.fn.init( selector, context );<br />
}<br />
jQuery.extend( true, jQuerySub, this );<br />
jQuerySub.superclass = this;<br />
jQuerySub.fn = jQuerySub.prototype = this();<br />
jQuerySub.fn.constructor = jQuerySub;<br />
jQuerySub.sub = this.sub;<br />
jQuerySub.fn.init = function init( selector, context ) {<br />
if ( context &amp;&amp; context instanceof jQuery &amp;&amp; !(context instanceof jQuerySub) ) {<br />
context = jQuerySub( context );<br />
}</p>
<p>return jQuery.fn.init.call( this, selector, context, rootjQuerySub );<br />
};<br />
jQuerySub.fn.init.prototype = jQuerySub.fn;<br />
var rootjQuerySub = jQuerySub(document);<br />
return jQuerySub;<br />
},</p>
<p>browser: {}<br />
});</p>
<p>// Populate the class2type map<br />
jQuery.each(&#8220;Boolean Number String Function Array Date RegExp Object&#8221;.split(&#8221; &#8220;), function(i, name) {<br />
class2type[ "[object " + name + "]&#8221; ] = name.toLowerCase();<br />
});</p>
<p>browserMatch = jQuery.uaMatch( userAgent );<br />
if ( browserMatch.browser ) {<br />
jQuery.browser[ browserMatch.browser ] = true;<br />
jQuery.browser.version = browserMatch.version;<br />
}</p>
<p>// Deprecated, use jQuery.browser.webkit instead<br />
if ( jQuery.browser.webkit ) {<br />
jQuery.browser.safari = true;<br />
}</p>
<p>// IE doesn&#8217;t match non-breaking spaces with \s<br />
if ( rnotwhite.test( &#8220;\xA0&#8243; ) ) {<br />
trimLeft = /^[\s\xA0]+/;<br />
trimRight = /[\s\xA0]+$/;<br />
}</p>
<p>// All jQuery objects should point back to these<br />
rootjQuery = jQuery(document);</p>
<p>// Cleanup functions for the document ready method<br />
if ( document.addEventListener ) {<br />
DOMContentLoaded = function() {<br />
document.removeEventListener( &#8220;DOMContentLoaded&#8221;, DOMContentLoaded, false );<br />
jQuery.ready();<br />
};</p>
<p>} else if ( document.attachEvent ) {<br />
DOMContentLoaded = function() {<br />
// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).<br />
if ( document.readyState === &#8220;complete&#8221; ) {<br />
document.detachEvent( &#8220;onreadystatechange&#8221;, DOMContentLoaded );<br />
jQuery.ready();<br />
}<br />
};<br />
}</p>
<p>// The DOM ready check for Internet Explorer<br />
function doScrollCheck() {<br />
if ( jQuery.isReady ) {<br />
return;<br />
}</p>
<p>try {<br />
// If IE is used, use the trick by Diego Perini<br />
// <a href="http://javascript.nwbox.com/IEContentLoaded/" rel="nofollow">http://javascript.nwbox.com/IEContentLoaded/</a><br />
document.documentElement.doScroll(&#8220;left&#8221;);<br />
} catch(e) {<br />
setTimeout( doScrollCheck, 1 );<br />
return;<br />
}</p>
<p>// and execute any waiting functions<br />
jQuery.ready();<br />
}</p>
<p>// Expose jQuery as an AMD module, but only for AMD loaders that<br />
// understand the issues with loading multiple versions of jQuery<br />
// in a page that all might call define(). The loader will indicate<br />
// they have special allowances for multiple jQuery versions by<br />
// specifying define.amd.jQuery = true. Register as a named module,<br />
// since jQuery can be concatenated with other files that may use define,<br />
// but not use a proper concatenation script that understands anonymous<br />
// AMD modules. A named AMD is safest and most robust way to register.<br />
// Lowercase jquery is used because AMD module names are derived from<br />
// file names, and jQuery is normally delivered in a lowercase file name.<br />
if ( typeof define === &#8220;function&#8221; &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) {<br />
define( &#8220;jquery&#8221;, [], function () { return jQuery; } );<br />
}</p>
<p>return jQuery;</p>
<p>})();</p>
<p>// String to Object flags format cache<br />
var flagsCache = {};</p>
<p>// Convert String-formatted flags into Object-formatted ones and store in cache<br />
function createFlags( flags ) {<br />
var object = flagsCache[ flags ] = {},<br />
i, length;<br />
flags = flags.split( /\s+/ );<br />
for ( i = 0, length = flags.length; i &lt; length; i++ ) {<br />
object[ flags[i] ] = true;<br />
}<br />
return object;<br />
}</p>
<p>/*<br />
* Create a callback list using the following parameters:<br />
*<br />
*    flags:    an optional list of space-separated flags that will change how<br />
*            the callback list behaves<br />
*<br />
* By default a callback list will act like an event callback list and can be<br />
* &#8220;fired&#8221; multiple times.<br />
*<br />
* Possible flags:<br />
*<br />
*    once:            will ensure the callback list can only be fired once (like a Deferred)<br />
*<br />
*    memory:            will keep track of previous values and will call any callback added<br />
*                    after the list has been fired right away with the latest &#8220;memorized&#8221;<br />
*                    values (like a Deferred)<br />
*<br />
*    unique:            will ensure a callback can only be added once (no duplicate in the list)<br />
*<br />
*    stopOnFalse:    interrupt callings when a callback returns false<br />
*<br />
*/<br />
jQuery.Callbacks = function( flags ) {</p>
<p>// Convert flags from String-formatted to Object-formatted<br />
// (we check in cache first)<br />
flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};</p>
<p>var // Actual callback list<br />
list = [],<br />
// Stack of fire calls for repeatable lists<br />
stack = [],<br />
// Last fire value (for non-forgettable lists)<br />
memory,<br />
// Flag to know if list is currently firing<br />
firing,<br />
// First callback to fire (used internally by add and fireWith)<br />
firingStart,<br />
// End of the loop when firing<br />
firingLength,<br />
// Index of currently firing callback (modified by remove if needed)<br />
firingIndex,<br />
// Add one or several callbacks to the list<br />
add = function( args ) {<br />
var i,<br />
length,<br />
elem,<br />
type,<br />
actual;<br />
for ( i = 0, length = args.length; i &lt; length; i++ ) {<br />
elem = args[ i ];<br />
type = jQuery.type( elem );<br />
if ( type === &#8220;array&#8221; ) {<br />
// Inspect recursively<br />
add( elem );<br />
} else if ( type === &#8220;function&#8221; ) {<br />
// Add if not in unique mode and callback is not in<br />
if ( !flags.unique || !self.has( elem ) ) {<br />
list.push( elem );<br />
}<br />
}<br />
}<br />
},<br />
// Fire callbacks<br />
fire = function( context, args ) {<br />
args = args || [];<br />
memory = !flags.memory || [ context, args ];<br />
firing = true;<br />
firingIndex = firingStart || 0;<br />
firingStart = 0;<br />
firingLength = list.length;<br />
for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {<br />
if ( list[ firingIndex ].apply( context, args ) === false &amp;&amp; flags.stopOnFalse ) {<br />
memory = true; // Mark as halted<br />
break;<br />
}<br />
}<br />
firing = false;<br />
if ( list ) {<br />
if ( !flags.once ) {<br />
if ( stack &amp;&amp; stack.length ) {<br />
memory = stack.shift();<br />
self.fireWith( memory[ 0 ], memory[ 1 ] );<br />
}<br />
} else if ( memory === true ) {<br />
self.disable();<br />
} else {<br />
list = [];<br />
}<br />
}<br />
},<br />
// Actual Callbacks object<br />
self = {<br />
// Add a callback or a collection of callbacks to the list<br />
add: function() {<br />
if ( list ) {<br />
var length = list.length;<br />
add( arguments );<br />
// Do we need to add the callbacks to the<br />
// current firing batch?<br />
if ( firing ) {<br />
firingLength = list.length;<br />
// With memory, if we&#8217;re not firing then<br />
// we should call right away, unless previous<br />
// firing was halted (stopOnFalse)<br />
} else if ( memory &amp;&amp; memory !== true ) {<br />
firingStart = length;<br />
fire( memory[ 0 ], memory[ 1 ] );<br />
}<br />
}<br />
return this;<br />
},<br />
// Remove a callback from the list<br />
remove: function() {<br />
if ( list ) {<br />
var args = arguments,<br />
argIndex = 0,<br />
argLength = args.length;<br />
for ( ; argIndex &lt; argLength ; argIndex++ ) {<br />
for ( var i = 0; i &lt; list.length; i++ ) {<br />
if ( args[ argIndex ] === list[ i ] ) {<br />
// Handle firingIndex and firingLength<br />
if ( firing ) {<br />
if ( i &lt;= firingLength ) {<br />
firingLength&#8211;;<br />
if ( i &lt;= firingIndex ) {<br />
firingIndex&#8211;;<br />
}<br />
}<br />
}<br />
// Remove the element<br />
list.splice( i&#8211;, 1 );<br />
// If we have some unicity property then<br />
// we only need to do this once<br />
if ( flags.unique ) {<br />
break;<br />
}<br />
}<br />
}<br />
}<br />
}<br />
return this;<br />
},<br />
// Control if a given callback is in the list<br />
has: function( fn ) {<br />
if ( list ) {<br />
var i = 0,<br />
length = list.length;<br />
for ( ; i &lt; length; i++ ) {<br />
if ( fn === list[ i ] ) {<br />
return true;<br />
}<br />
}<br />
}<br />
return false;<br />
},<br />
// Remove all callbacks from the list<br />
empty: function() {<br />
list = [];<br />
return this;<br />
},<br />
// Have the list do nothing anymore<br />
disable: function() {<br />
list = stack = memory = undefined;<br />
return this;<br />
},<br />
// Is it disabled?<br />
disabled: function() {<br />
return !list;<br />
},<br />
// Lock the list in its current state<br />
lock: function() {<br />
stack = undefined;<br />
if ( !memory || memory === true ) {<br />
self.disable();<br />
}<br />
return this;<br />
},<br />
// Is it locked?<br />
locked: function() {<br />
return !stack;<br />
},<br />
// Call all callbacks with the given context and arguments<br />
fireWith: function( context, args ) {<br />
if ( stack ) {<br />
if ( firing ) {<br />
if ( !flags.once ) {<br />
stack.push( [ context, args ] );<br />
}<br />
} else if ( !( flags.once &amp;&amp; memory ) ) {<br />
fire( context, args );<br />
}<br />
}<br />
return this;<br />
},<br />
// Call all the callbacks with the given arguments<br />
fire: function() {<br />
self.fireWith( this, arguments );<br />
return this;<br />
},<br />
// To know if the callbacks have already been called at least once<br />
fired: function() {<br />
return !!memory;<br />
}<br />
};</p>
<p>return self;<br />
};</p>
<p>var // Static reference to slice<br />
sliceDeferred = [].slice;</p>
<p>jQuery.extend({</p>
<p>Deferred: function( func ) {<br />
var doneList = jQuery.Callbacks( &#8220;once memory&#8221; ),<br />
failList = jQuery.Callbacks( &#8220;once memory&#8221; ),<br />
progressList = jQuery.Callbacks( &#8220;memory&#8221; ),<br />
state = &#8220;pending&#8221;,<br />
lists = {<br />
resolve: doneList,<br />
reject: failList,<br />
notify: progressList<br />
},<br />
promise = {<br />
done: doneList.add,<br />
fail: failList.add,<br />
progress: progressList.add,</p>
<p>state: function() {<br />
return state;<br />
},</p>
<p>// Deprecated<br />
isResolved: doneList.fired,<br />
isRejected: failList.fired,</p>
<p>then: function( doneCallbacks, failCallbacks, progressCallbacks ) {<br />
deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );<br />
return this;<br />
},<br />
always: function() {<br />
return deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );<br />
},<br />
pipe: function( fnDone, fnFail, fnProgress ) {<br />
return jQuery.Deferred(function( newDefer ) {<br />
jQuery.each( {<br />
done: [ fnDone, "resolve" ],<br />
fail: [ fnFail, "reject" ],<br />
progress: [ fnProgress, "notify" ]<br />
}, function( handler, data ) {<br />
var fn = data[ 0 ],<br />
action = data[ 1 ],<br />
returned;<br />
if ( jQuery.isFunction( fn ) ) {<br />
deferred[ handler ](function() {<br />
returned = fn.apply( this, arguments );<br />
if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {<br />
returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );<br />
} else {<br />
newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );<br />
}<br />
});<br />
} else {<br />
deferred[ handler ]( newDefer[ action ] );<br />
}<br />
});<br />
}).promise();<br />
},<br />
// Get a promise for this deferred<br />
// If obj is provided, the promise aspect is added to the object<br />
promise: function( obj ) {<br />
if ( obj == null ) {<br />
obj = promise;<br />
} else {<br />
for ( var key in promise ) {<br />
obj[ key ] = promise[ key ];<br />
}<br />
}<br />
return obj;<br />
}<br />
},<br />
deferred = promise.promise({}),<br />
key;</p>
<p>for ( key in lists ) {<br />
deferred[ key ] = lists[ key ].fire;<br />
deferred[ key + "With" ] = lists[ key ].fireWith;<br />
}</p>
<p>// Handle state<br />
deferred.done( function() {<br />
state = &#8220;resolved&#8221;;<br />
}, failList.disable, progressList.lock ).fail( function() {<br />
state = &#8220;rejected&#8221;;<br />
}, doneList.disable, progressList.lock );</p>
<p>// Call given func if any<br />
if ( func ) {<br />
func.call( deferred, deferred );<br />
}</p>
<p>// All done!<br />
return deferred;<br />
},</p>
<p>// Deferred helper<br />
when: function( firstParam ) {<br />
var args = sliceDeferred.call( arguments, 0 ),<br />
i = 0,<br />
length = args.length,<br />
pValues = new Array( length ),<br />
count = length,<br />
pCount = length,<br />
deferred = length &lt;= 1 &amp;&amp; firstParam &amp;&amp; jQuery.isFunction( firstParam.promise ) ?<br />
firstParam :<br />
jQuery.Deferred(),<br />
promise = deferred.promise();<br />
function resolveFunc( i ) {<br />
return function( value ) {<br />
args[ i ] = arguments.length &gt; 1 ? sliceDeferred.call( arguments, 0 ) : value;<br />
if ( !( &#8211;count ) ) {<br />
deferred.resolveWith( deferred, args );<br />
}<br />
};<br />
}<br />
function progressFunc( i ) {<br />
return function( value ) {<br />
pValues[ i ] = arguments.length &gt; 1 ? sliceDeferred.call( arguments, 0 ) : value;<br />
deferred.notifyWith( promise, pValues );<br />
};<br />
}<br />
if ( length &gt; 1 ) {<br />
for ( ; i &lt; length; i++ ) {<br />
if ( args[ i ] &amp;&amp; args[ i ].promise &amp;&amp; jQuery.isFunction( args[ i ].promise ) ) {<br />
args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );<br />
} else {<br />
&#8211;count;<br />
}<br />
}<br />
if ( !count ) {<br />
deferred.resolveWith( deferred, args );<br />
}<br />
} else if ( deferred !== firstParam ) {<br />
deferred.resolveWith( deferred, length ? [ firstParam ] : [] );<br />
}<br />
return promise;<br />
}<br />
});</p>
<p>jQuery.support = (function() {</p>
<p>var div = document.createElement( &#8220;div&#8221; ),<br />
documentElement = document.documentElement,<br />
all,<br />
a,<br />
select,<br />
opt,<br />
input,<br />
marginDiv,<br />
support,<br />
fragment,<br />
body,<br />
testElementParent,<br />
testElement,<br />
testElementStyle,<br />
tds,<br />
events,<br />
eventName,<br />
i,<br />
isSupported;</p>
<p>// Preliminary tests<br />
div.setAttribute(&#8220;className&#8221;, &#8220;t&#8221;);<br />
div.innerHTML = &#8220;   &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&#8217;/a&#8217; style=&#8217;top:1px;float:left;opacity:.55;&#8217;&gt;a&lt;/a&gt;&lt;input type=&#8217;checkbox&#8217;/&gt;&lt;nav&gt;&lt;/nav&gt;&#8221;;</p>
<p>all = div.getElementsByTagName( &#8220;*&#8221; );<br />
a = div.getElementsByTagName( &#8220;a&#8221; )[ 0 ];</p>
<p>// Can&#8217;t get basic test support<br />
if ( !all || !all.length || !a ) {<br />
return {};<br />
}</p>
<p>// First batch of supports tests<br />
select = document.createElement( &#8220;select&#8221; );<br />
opt = select.appendChild( document.createElement(&#8220;option&#8221;) );<br />
input = div.getElementsByTagName( &#8220;input&#8221; )[ 0 ];</p>
<p>support = {<br />
// IE strips leading whitespace when .innerHTML is used<br />
leadingWhitespace: ( div.firstChild.nodeType === 3 ),</p>
<p>// Make sure that tbody elements aren&#8217;t automatically inserted<br />
// IE will insert them into empty tables<br />
tbody: !div.getElementsByTagName( &#8220;tbody&#8221; ).length,</p>
<p>// Make sure that link elements get serialized correctly by innerHTML<br />
// This requires a wrapper element in IE<br />
htmlSerialize: !!div.getElementsByTagName( &#8220;link&#8221; ).length,</p>
<p>// Get the style information from getAttribute<br />
// (IE uses .cssText instead)<br />
style: /top/.test( a.getAttribute(&#8220;style&#8221;) ),</p>
<p>// Make sure that URLs aren&#8217;t manipulated<br />
// (IE normalizes it by default)<br />
hrefNormalized: ( a.getAttribute( &#8220;href&#8221; ) === &#8220;/a&#8221; ),</p>
<p>// Make sure that element opacity exists<br />
// (IE uses filter instead)<br />
// Use a regex to work around a WebKit issue. See #5145<br />
opacity: /^0.55/.test( a.style.opacity ),</p>
<p>// Verify style float existence<br />
// (IE uses styleFloat instead of cssFloat)<br />
cssFloat: !!a.style.cssFloat,</p>
<p>// Make sure unknown elements (like HTML5 elems) are handled appropriately<br />
unknownElems: !!div.getElementsByTagName( &#8220;nav&#8221; ).length,</p>
<p>// Make sure that if no value is specified for a checkbox<br />
// that it defaults to &#8220;on&#8221;.<br />
// (WebKit defaults to &#8220;&#8221; instead)<br />
checkOn: ( input.value === &#8220;on&#8221; ),</p>
<p>// Make sure that a selected-by-default option has a working selected property.<br />
// (WebKit defaults to false instead of true, IE too, if it&#8217;s in an optgroup)<br />
optSelected: opt.selected,</p>
<p>// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)<br />
getSetAttribute: div.className !== &#8220;t&#8221;,</p>
<p>// Tests for enctype support on a form(#6743)<br />
enctype: !!document.createElement(&#8220;form&#8221;).enctype,</p>
<p>// Will be defined later<br />
submitBubbles: true,<br />
changeBubbles: true,<br />
focusinBubbles: false,<br />
deleteExpando: true,<br />
noCloneEvent: true,<br />
inlineBlockNeedsLayout: false,<br />
shrinkWrapBlocks: false,<br />
reliableMarginRight: true<br />
};</p>
<p>// Make sure checked status is properly cloned<br />
input.checked = true;<br />
support.noCloneChecked = input.cloneNode( true ).checked;</p>
<p>// Make sure that the options inside disabled selects aren&#8217;t marked as disabled<br />
// (WebKit marks them as disabled)<br />
select.disabled = true;<br />
support.optDisabled = !opt.disabled;</p>
<p>// Test to see if it&#8217;s possible to delete an expando from an element<br />
// Fails in Internet Explorer<br />
try {<br />
delete div.test;<br />
} catch( e ) {<br />
support.deleteExpando = false;<br />
}</p>
<p>if ( !div.addEventListener &amp;&amp; div.attachEvent &amp;&amp; div.fireEvent ) {<br />
div.attachEvent( &#8220;onclick&#8221;, function() {<br />
// Cloning a node shouldn&#8217;t copy over any<br />
// bound event handlers (IE does this)<br />
support.noCloneEvent = false;<br />
});<br />
div.cloneNode( true ).fireEvent( &#8220;onclick&#8221; );<br />
}</p>
<p>// Check if a radio maintains its value<br />
// after being appended to the DOM<br />
input = document.createElement(&#8220;input&#8221;);<br />
input.value = &#8220;t&#8221;;<br />
input.setAttribute(&#8220;type&#8221;, &#8220;radio&#8221;);<br />
support.radioValue = input.value === &#8220;t&#8221;;</p>
<p>input.setAttribute(&#8220;checked&#8221;, &#8220;checked&#8221;);<br />
div.appendChild( input );<br />
fragment = document.createDocumentFragment();<br />
fragment.appendChild( div.lastChild );</p>
<p>// WebKit doesn&#8217;t clone checked state correctly in fragments<br />
support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;</p>
<p>div.innerHTML = &#8220;&#8221;;</p>
<p>// Figure out if the W3C box model works as expected<br />
div.style.width = div.style.paddingLeft = &#8220;1px&#8221;;</p>
<p>// We don&#8217;t want to do body-related feature tests on frameset<br />
// documents, which lack a body. So we use<br />
// document.getElementsByTagName(&#8220;body&#8221;)[0], which is undefined in<br />
// frameset documents, while document.body isn’t. (7398)<br />
body = document.getElementsByTagName(&#8220;body&#8221;)[ 0 ];<br />
// We use our own, invisible, body unless the body is already present<br />
// in which case we use a div (#9239)<br />
testElement = document.createElement( body ? &#8220;div&#8221; : &#8220;body&#8221; );<br />
testElementStyle = {<br />
visibility: &#8220;hidden&#8221;,<br />
width: 0,<br />
height: 0,<br />
border: 0,<br />
margin: 0,<br />
background: &#8220;none&#8221;<br />
};<br />
if ( body ) {<br />
jQuery.extend( testElementStyle, {<br />
position: &#8220;absolute&#8221;,<br />
left: &#8220;-999px&#8221;,<br />
top: &#8220;-999px&#8221;<br />
});<br />
}<br />
for ( i in testElementStyle ) {<br />
testElement.style[ i ] = testElementStyle[ i ];<br />
}<br />
testElement.appendChild( div );<br />
testElementParent = body || documentElement;<br />
testElementParent.insertBefore( testElement, testElementParent.firstChild );</p>
<p>// Check if a disconnected checkbox will retain its checked<br />
// value of true after appended to the DOM (IE6/7)<br />
support.appendChecked = input.checked;</p>
<p>support.boxModel = div.offsetWidth === 2;</p>
<p>if ( &#8220;zoom&#8221; in div.style ) {<br />
// Check if natively block-level elements act like inline-block<br />
// elements when setting their display to &#8216;inline&#8217; and giving<br />
// them layout<br />
// (IE &lt; 8 does this)<br />
div.style.display = &#8220;inline&#8221;;<br />
div.style.zoom = 1;<br />
support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );</p>
<p>// Check if elements with layout shrink-wrap their children<br />
// (IE 6 does this)<br />
div.style.display = &#8220;&#8221;;<br />
div.innerHTML = &#8220;&lt;div style=&#8217;width:4px;&#8217;&gt;&lt;/div&gt;&#8221;;<br />
support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );<br />
}</p>
<p>div.innerHTML = &#8220;&lt;table&gt;&lt;tr&gt;&lt;td style=&#8217;padding:0;border:0;display:none&#8217;&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#8221;;<br />
tds = div.getElementsByTagName( &#8220;td&#8221; );</p>
<p>// Check if table cells still have offsetWidth/Height when they are set<br />
// to display:none and there are still other visible table cells in a<br />
// table row; if so, offsetWidth/Height are not reliable for use when<br />
// determining if an element has been hidden directly using<br />
// display:none (it is still safe to use offsets if a parent element is<br />
// hidden; don safety goggles and see bug #4512 for more information).<br />
// (only IE 8 fails this test)<br />
isSupported = ( tds[ 0 ].offsetHeight === 0 );</p>
<p>tds[ 0 ].style.display = &#8220;&#8221;;<br />
tds[ 1 ].style.display = &#8220;none&#8221;;</p>
<p>// Check if empty table cells still have offsetWidth/Height<br />
// (IE &lt; 8 fail this test)<br />
support.reliableHiddenOffsets = isSupported &amp;&amp; ( tds[ 0 ].offsetHeight === 0 );<br />
div.innerHTML = &#8220;&#8221;;</p>
<p>// Check if div with explicit width and no margin-right incorrectly<br />
// gets computed margin-right based on width of container. For more<br />
// info see bug #3333<br />
// Fails in WebKit before Feb 2011 nightlies<br />
// WebKit Bug 13343 &#8211; getComputedStyle returns wrong value for margin-right<br />
if ( document.defaultView &amp;&amp; document.defaultView.getComputedStyle ) {<br />
marginDiv = document.createElement( &#8220;div&#8221; );<br />
marginDiv.style.width = &#8220;0&#8243;;<br />
marginDiv.style.marginRight = &#8220;0&#8243;;<br />
div.appendChild( marginDiv );<br />
support.reliableMarginRight =<br />
( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;<br />
}</p>
<p>// Technique from Juriy Zaytsev<br />
// <a href="http://perfectionkills.com/detecting-event-support-without-browser-sniffing/" rel="nofollow">http://perfectionkills.com/detecting-event-support-without-browser-sniffing/</a><br />
// We only care about the case where non-standard event systems<br />
// are used, namely in IE. Short-circuiting here helps us to<br />
// avoid an eval call (in setAttribute) which can cause CSP<br />
// to go haywire. See: <a href="https://developer.mozilla.org/en/Security/CSP" rel="nofollow">https://developer.mozilla.org/en/Security/CSP</a><br />
if ( div.attachEvent ) {<br />
for( i in {<br />
submit: 1,<br />
change: 1,<br />
focusin: 1<br />
} ) {<br />
eventName = &#8220;on&#8221; + i;<br />
isSupported = ( eventName in div );<br />
if ( !isSupported ) {<br />
div.setAttribute( eventName, &#8220;return;&#8221; );<br />
isSupported = ( typeof div[ eventName ] === &#8220;function&#8221; );<br />
}<br />
support[ i + "Bubbles" ] = isSupported;<br />
}<br />
}</p>
<p>// Run fixed position tests at doc ready to avoid a crash<br />
// related to the invisible body in IE8<br />
jQuery(function() {<br />
var container, outer, inner, table, td, offsetSupport,<br />
conMarginTop = 1,<br />
ptlm = &#8220;position:absolute;top:0;left:0;width:1px;height:1px;margin:0;&#8221;,<br />
vb = &#8220;visibility:hidden;border:0;&#8221;,<br />
style = &#8220;style=&#8217;&#8221; + ptlm + &#8220;border:5px solid #000;padding:0;&#8217;&#8221;,<br />
html = &#8220;&lt;div &#8221; + style + &#8220;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&#8221; +<br />
&#8220;&lt;table &#8221; + style + &#8221; cellpadding=&#8217;0&#8242; cellspacing=&#8217;0&#8242;&gt;&#8221; +<br />
&#8220;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#8221;;</p>
<p>// Reconstruct a container<br />
body = document.getElementsByTagName(&#8220;body&#8221;)[0];<br />
if ( !body ) {<br />
// Return for frameset docs that don&#8217;t have a body<br />
// These tests cannot be done<br />
return;<br />
}</p>
<p>container = document.createElement(&#8220;div&#8221;);<br />
container.style.cssText = vb + &#8220;width:0;height:0;position:static;top:0;margin-top:&#8221; + conMarginTop + &#8220;px&#8221;;<br />
body.insertBefore( container, body.firstChild );</p>
<p>// Construct a test element<br />
testElement = document.createElement(&#8220;div&#8221;);<br />
testElement.style.cssText = ptlm + vb;</p>
<p>testElement.innerHTML = html;<br />
container.appendChild( testElement );<br />
outer = testElement.firstChild;<br />
inner = outer.firstChild;<br />
td = outer.nextSibling.firstChild.firstChild;</p>
<p>offsetSupport = {<br />
doesNotAddBorder: ( inner.offsetTop !== 5 ),<br />
doesAddBorderForTableAndCells: ( td.offsetTop === 5 )<br />
};</p>
<p>inner.style.position = &#8220;fixed&#8221;;<br />
inner.style.top = &#8220;20px&#8221;;</p>
<p>// safari subtracts parent border width here which is 5px<br />
offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );<br />
inner.style.position = inner.style.top = &#8220;&#8221;;</p>
<p>outer.style.overflow = &#8220;hidden&#8221;;<br />
outer.style.position = &#8220;relative&#8221;;</p>
<p>offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );<br />
offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );</p>
<p>body.removeChild( container );<br />
testElement = container = null;</p>
<p>jQuery.extend( support, offsetSupport );<br />
});</p>
<p>testElement.innerHTML = &#8220;&#8221;;<br />
testElementParent.removeChild( testElement );</p>
<p>// Null connected elements to avoid leaks in IE<br />
testElement = fragment = select = opt = body = marginDiv = div = input = null;</p>
<p>return support;<br />
})();</p>
<p>// Keep track of boxModel<br />
jQuery.boxModel = jQuery.support.boxModel;</p>
<p>var rbrace = /^(?:\{.*\}|\[.*\])$/,<br />
rmultiDash = /([A-Z])/g;</p>
<p>jQuery.extend({<br />
cache: {},</p>
<p>// Please use with caution<br />
uuid: 0,</p>
<p>// Unique for each copy of jQuery on the page<br />
// Non-digits removed to match rinlinejQuery<br />
expando: &#8220;jQuery&#8221; + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, &#8220;&#8221; ),</p>
<p>// The following elements throw uncatchable exceptions if you<br />
// attempt to add expando properties to them.<br />
noData: {<br />
&#8220;embed&#8221;: true,<br />
// Ban all objects except for Flash (which handle expandos)<br />
&#8220;object&#8221;: &#8220;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&#8243;,<br />
&#8220;applet&#8221;: true<br />
},</p>
<p>hasData: function( elem ) {<br />
elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];<br />
return !!elem &amp;&amp; !isEmptyDataObject( elem );<br />
},</p>
<p>data: function( elem, name, data, pvt /* Internal Use Only */ ) {<br />
if ( !jQuery.acceptData( elem ) ) {<br />
return;<br />
}</p>
<p>var privateCache, thisCache, ret,<br />
internalKey = jQuery.expando,<br />
getByName = typeof name === &#8220;string&#8221;,</p>
<p>// We have to handle DOM nodes and JS objects differently because IE6-7<br />
// can&#8217;t GC object references properly across the DOM-JS boundary<br />
isNode = elem.nodeType,</p>
<p>// Only DOM nodes need the global jQuery cache; JS object data is<br />
// attached directly to the object so GC can occur automatically<br />
cache = isNode ? jQuery.cache : elem,</p>
<p>// Only defining an ID for JS objects if its cache already exists allows<br />
// the code to shortcut on the same path as a DOM node with no cache<br />
id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] &amp;&amp; jQuery.expando,<br />
isEvents = name === &#8220;events&#8221;;</p>
<p>// Avoid doing any more work than we need to when trying to get data on an<br />
// object that has no data at all<br />
if ( (!id || !cache[id] || (!isEvents &amp;&amp; !pvt &amp;&amp; !cache[id].data)) &amp;&amp; getByName &amp;&amp; data === undefined ) {<br />
return;<br />
}</p>
<p>if ( !id ) {<br />
// Only DOM nodes need a new unique ID for each element since their data<br />
// ends up in the global cache<br />
if ( isNode ) {<br />
elem[ jQuery.expando ] = id = ++jQuery.uuid;<br />
} else {<br />
id = jQuery.expando;<br />
}<br />
}</p>
<p>if ( !cache[ id ] ) {<br />
cache[ id ] = {};</p>
<p>// Avoids exposing jQuery metadata on plain JS objects when the object<br />
// is serialized using JSON.stringify<br />
if ( !isNode ) {<br />
cache[ id ].toJSON = jQuery.noop;<br />
}<br />
}</p>
<p>// An object can be passed to jQuery.data instead of a key/value pair; this gets<br />
// shallow copied over onto the existing cache<br />
if ( typeof name === &#8220;object&#8221; || typeof name === &#8220;function&#8221; ) {<br />
if ( pvt ) {<br />
cache[ id ] = jQuery.extend( cache[ id ], name );<br />
} else {<br />
cache[ id ].data = jQuery.extend( cache[ id ].data, name );<br />
}<br />
}</p>
<p>privateCache = thisCache = cache[ id ];</p>
<p>// jQuery data() is stored in a separate object inside the object&#8217;s internal data<br />
// cache in order to avoid key collisions between internal data and user-defined<br />
// data.<br />
if ( !pvt ) {<br />
if ( !thisCache.data ) {<br />
thisCache.data = {};<br />
}</p>
<p>thisCache = thisCache.data;<br />
}</p>
<p>if ( data !== undefined ) {<br />
thisCache[ jQuery.camelCase( name ) ] = data;<br />
}</p>
<p>// Users should not attempt to inspect the internal events object using jQuery.data,<br />
// it is undocumented and subject to change. But does anyone listen? No.<br />
if ( isEvents &amp;&amp; !thisCache[ name ] ) {<br />
return privateCache.events;<br />
}</p>
<p>// Check for both converted-to-camel and non-converted data property names<br />
// If a data property was specified<br />
if ( getByName ) {</p>
<p>// First Try to find as-is property data<br />
ret = thisCache[ name ];</p>
<p>// Test for null|undefined property data<br />
if ( ret == null ) {</p>
<p>// Try to find the camelCased property<br />
ret = thisCache[ jQuery.camelCase( name ) ];<br />
}<br />
} else {<br />
ret = thisCache;<br />
}</p>
<p>return ret;<br />
},</p>
<p>removeData: function( elem, name, pvt /* Internal Use Only */ ) {<br />
if ( !jQuery.acceptData( elem ) ) {<br />
return;<br />
}</p>
<p>var thisCache, i, l,</p>
<p>// Reference to internal data cache key<br />
internalKey = jQuery.expando,</p>
<p>isNode = elem.nodeType,</p>
<p>// See jQuery.data for more information<br />
cache = isNode ? jQuery.cache : elem,</p>
<p>// See jQuery.data for more information<br />
id = isNode ? elem[ jQuery.expando ] : jQuery.expando;</p>
<p>// If there is already no cache entry for this object, there is no<br />
// purpose in continuing<br />
if ( !cache[ id ] ) {<br />
return;<br />
}</p>
<p>if ( name ) {</p>
<p>thisCache = pvt ? cache[ id ] : cache[ id ].data;</p>
<p>if ( thisCache ) {</p>
<p>// Support space separated names<br />
if ( jQuery.isArray( name ) ) {<br />
name = name;<br />
} else if ( name in thisCache ) {<br />
name = [ name ];<br />
} else {</p>
<p>// split the camel cased version by spaces<br />
name = jQuery.camelCase( name );<br />
if ( name in thisCache ) {<br />
name = [ name ];<br />
} else {<br />
name = name.split( &#8221; &#8221; );<br />
}<br />
}</p>
<p>for ( i = 0, l = name.length; i &lt; l; i++ ) {<br />
delete thisCache[ name[i] ];<br />
}</p>
<p>// If there is no data left in the cache, we want to continue<br />
// and let the cache object itself get destroyed<br />
if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {<br />
return;<br />
}<br />
}<br />
}</p>
<p>// See jQuery.data for more information<br />
if ( !pvt ) {<br />
delete cache[ id ].data;</p>
<p>// Don&#8217;t destroy the parent cache unless the internal data object<br />
// had been the only thing left in it<br />
if ( !isEmptyDataObject(cache[ id ]) ) {<br />
return;<br />
}<br />
}</p>
<p>// Browsers that fail expando deletion also refuse to delete expandos on<br />
// the window, but it will allow it on all other JS objects; other browsers<br />
// don&#8217;t care<br />
// Ensure that `cache` is not a window object #10080<br />
if ( jQuery.support.deleteExpando || !cache.setInterval ) {<br />
delete cache[ id ];<br />
} else {<br />
cache[ id ] = null;<br />
}</p>
<p>// We destroyed the cache and need to eliminate the expando on the node to avoid<br />
// false lookups in the cache for entries that no longer exist<br />
if ( isNode ) {<br />
// IE does not allow us to delete expando properties from nodes,<br />
// nor does it have a removeAttribute function on Document nodes;<br />
// we must handle all of these cases<br />
if ( jQuery.support.deleteExpando ) {<br />
delete elem[ jQuery.expando ];<br />
} else if ( elem.removeAttribute ) {<br />
elem.removeAttribute( jQuery.expando );<br />
} else {<br />
elem[ jQuery.expando ] = null;<br />
}<br />
}<br />
},</p>
<p>// For internal use only.<br />
_data: function( elem, name, data ) {<br />
return jQuery.data( elem, name, data, true );<br />
},</p>
<p>// A method for determining if a DOM node can handle the data expando<br />
acceptData: function( elem ) {<br />
if ( elem.nodeName ) {<br />
var match = jQuery.noData[ elem.nodeName.toLowerCase() ];</p>
<p>if ( match ) {<br />
return !(match === true || elem.getAttribute(&#8220;classid&#8221;) !== match);<br />
}<br />
}</p>
<p>return true;<br />
}<br />
});</p>
<p>jQuery.fn.extend({<br />
data: function( key, value ) {<br />
var parts, attr, name,<br />
data = null;</p>
<p>if ( typeof key === &#8220;undefined&#8221; ) {<br />
if ( this.length ) {<br />
data = jQuery.data( this[0] );</p>
<p>if ( this[0].nodeType === 1 &amp;&amp; !jQuery._data( this[0], &#8220;parsedAttrs&#8221; ) ) {<br />
attr = this[0].attributes;<br />
for ( var i = 0, l = attr.length; i &lt; l; i++ ) {<br />
name = attr[i].name;</p>
<p>if ( name.indexOf( &#8220;data-&#8221; ) === 0 ) {<br />
name = jQuery.camelCase( name.substring(5) );</p>
<p>dataAttr( this[0], name, data[ name ] );<br />
}<br />
}<br />
jQuery._data( this[0], &#8220;parsedAttrs&#8221;, true );<br />
}<br />
}</p>
<p>return data;</p>
<p>} else if ( typeof key === &#8220;object&#8221; ) {<br />
return this.each(function() {<br />
jQuery.data( this, key );<br />
});<br />
}</p>
<p>parts = key.split(&#8220;.&#8221;);<br />
parts[1] = parts[1] ? &#8220;.&#8221; + parts[1] : &#8220;&#8221;;</p>
<p>if ( value === undefined ) {<br />
data = this.triggerHandler(&#8220;getData&#8221; + parts[1] + &#8220;!&#8221;, [parts[0]]);</p>
<p>// Try to fetch any internally stored data first<br />
if ( data === undefined &amp;&amp; this.length ) {<br />
data = jQuery.data( this[0], key );<br />
data = dataAttr( this[0], key, data );<br />
}</p>
<p>return data === undefined &amp;&amp; parts[1] ?<br />
this.data( parts[0] ) :<br />
data;</p>
<p>} else {<br />
return this.each(function() {<br />
var $this = jQuery( this ),<br />
args = [ parts[0], value ];</p>
<p>$this.triggerHandler( &#8220;setData&#8221; + parts[1] + &#8220;!&#8221;, args );<br />
jQuery.data( this, key, value );<br />
$this.triggerHandler( &#8220;changeData&#8221; + parts[1] + &#8220;!&#8221;, args );<br />
});<br />
}<br />
},</p>
<p>removeData: function( key ) {<br />
return this.each(function() {<br />
jQuery.removeData( this, key );<br />
});<br />
}<br />
});</p>
<p>function dataAttr( elem, key, data ) {<br />
// If nothing was found internally, try to fetch any<br />
// data from the HTML5 data-* attribute<br />
if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {</p>
<p>var name = &#8220;data-&#8221; + key.replace( rmultiDash, &#8220;-$1&#8243; ).toLowerCase();</p>
<p>data = elem.getAttribute( name );</p>
<p>if ( typeof data === &#8220;string&#8221; ) {<br />
try {<br />
data = data === &#8220;true&#8221; ? true :<br />
data === &#8220;false&#8221; ? false :<br />
data === &#8220;null&#8221; ? null :<br />
jQuery.isNumeric( data ) ? parseFloat( data ) :<br />
rbrace.test( data ) ? jQuery.parseJSON( data ) :<br />
data;<br />
} catch( e ) {}</p>
<p>// Make sure we set the data so it isn&#8217;t changed later<br />
jQuery.data( elem, key, data );</p>
<p>} else {<br />
data = undefined;<br />
}<br />
}</p>
<p>return data;<br />
}</p>
<p>// checks a cache object for emptiness<br />
function isEmptyDataObject( obj ) {<br />
for ( var name in obj ) {</p>
<p>// if the public data object is empty, the private is still empty<br />
if ( name === &#8220;data&#8221; &amp;&amp; jQuery.isEmptyObject( obj[name] ) ) {<br />
continue;<br />
}<br />
if ( name !== &#8220;toJSON&#8221; ) {<br />
return false;<br />
}<br />
}</p>
<p>return true;<br />
}</p>
<p>function handleQueueMarkDefer( elem, type, src ) {<br />
var deferDataKey = type + &#8220;defer&#8221;,<br />
queueDataKey = type + &#8220;queue&#8221;,<br />
markDataKey = type + &#8220;mark&#8221;,<br />
defer = jQuery._data( elem, deferDataKey );<br />
if ( defer &amp;&amp;<br />
( src === &#8220;queue&#8221; || !jQuery._data(elem, queueDataKey) ) &amp;&amp;<br />
( src === &#8220;mark&#8221; || !jQuery._data(elem, markDataKey) ) ) {<br />
// Give room for hard-coded callbacks to fire first<br />
// and eventually mark/queue something else on the element<br />
setTimeout( function() {<br />
if ( !jQuery._data( elem, queueDataKey ) &amp;&amp;<br />
!jQuery._data( elem, markDataKey ) ) {<br />
jQuery.removeData( elem, deferDataKey, true );<br />
defer.fire();<br />
}<br />
}, 0 );<br />
}<br />
}</p>
<p>jQuery.extend({</p>
<p>_mark: function( elem, type ) {<br />
if ( elem ) {<br />
type = ( type || &#8220;fx&#8221; ) + &#8220;mark&#8221;;<br />
jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );<br />
}<br />
},</p>
<p>_unmark: function( force, elem, type ) {<br />
if ( force !== true ) {<br />
type = elem;<br />
elem = force;<br />
force = false;<br />
}<br />
if ( elem ) {<br />
type = type || &#8220;fx&#8221;;<br />
var key = type + &#8220;mark&#8221;,<br />
count = force ? 0 : ( (jQuery._data( elem, key ) || 1) &#8211; 1 );<br />
if ( count ) {<br />
jQuery._data( elem, key, count );<br />
} else {<br />
jQuery.removeData( elem, key, true );<br />
handleQueueMarkDefer( elem, type, &#8220;mark&#8221; );<br />
}<br />
}<br />
},</p>
<p>queue: function( elem, type, data ) {<br />
var q;<br />
if ( elem ) {<br />
type = ( type || &#8220;fx&#8221; ) + &#8220;queue&#8221;;<br />
q = jQuery._data( elem, type );</p>
<p>// Speed up dequeue by getting out quickly if this is just a lookup<br />
if ( data ) {<br />
if ( !q || jQuery.isArray(data) ) {<br />
q = jQuery._data( elem, type, jQuery.makeArray(data) );<br />
} else {<br />
q.push( data );<br />
}<br />
}<br />
return q || [];<br />
}<br />
},</p>
<p>dequeue: function( elem, type ) {<br />
type = type || &#8220;fx&#8221;;</p>
<p>var queue = jQuery.queue( elem, type ),<br />
fn = queue.shift(),<br />
hooks = {};</p>
<p>// If the fx queue is dequeued, always remove the progress sentinel<br />
if ( fn === &#8220;inprogress&#8221; ) {<br />
fn = queue.shift();<br />
}</p>
<p>if ( fn ) {<br />
// Add a progress sentinel to prevent the fx queue from being<br />
// automatically dequeued<br />
if ( type === &#8220;fx&#8221; ) {<br />
queue.unshift( &#8220;inprogress&#8221; );<br />
}</p>
<p>jQuery._data( elem, type + &#8220;.run&#8221;, hooks );<br />
fn.call( elem, function() {<br />
jQuery.dequeue( elem, type );<br />
}, hooks );<br />
}</p>
<p>if ( !queue.length ) {<br />
jQuery.removeData( elem, type + &#8220;queue &#8221; + type + &#8220;.run&#8221;, true );<br />
handleQueueMarkDefer( elem, type, &#8220;queue&#8221; );<br />
}<br />
}<br />
});</p>
<p>jQuery.fn.extend({<br />
queue: function( type, data ) {<br />
if ( typeof type !== &#8220;string&#8221; ) {<br />
data = type;<br />
type = &#8220;fx&#8221;;<br />
}</p>
<p>if ( data === undefined ) {<br />
return jQuery.queue( this[0], type );<br />
}<br />
return this.each(function() {<br />
var queue = jQuery.queue( this, type, data );</p>
<p>if ( type === &#8220;fx&#8221; &amp;&amp; queue[0] !== &#8220;inprogress&#8221; ) {<br />
jQuery.dequeue( this, type );<br />
}<br />
});<br />
},<br />
dequeue: function( type ) {<br />
return this.each(function() {<br />
jQuery.dequeue( this, type );<br />
});<br />
},<br />
// Based off of the plugin by Clint Helfers, with permission.<br />
// <a href="http://blindsignals.com/index.php/2009/07/jquery-delay/" rel="nofollow">http://blindsignals.com/index.php/2009/07/jquery-delay/</a><br />
delay: function( time, type ) {<br />
time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;<br />
type = type || &#8220;fx&#8221;;</p>
<p>return this.queue( type, function( next, hooks ) {<br />
var timeout = setTimeout( next, time );<br />
hooks.stop = function() {<br />
clearTimeout( timeout );<br />
};<br />
});<br />
},<br />
clearQueue: function( type ) {<br />
return this.queue( type || &#8220;fx&#8221;, [] );<br />
},<br />
// Get a promise resolved when queues of a certain type<br />
// are emptied (fx is the type by default)<br />
promise: function( type, object ) {<br />
if ( typeof type !== &#8220;string&#8221; ) {<br />
object = type;<br />
type = undefined;<br />
}<br />
type = type || &#8220;fx&#8221;;<br />
var defer = jQuery.Deferred(),<br />
elements = this,<br />
i = elements.length,<br />
count = 1,<br />
deferDataKey = type + &#8220;defer&#8221;,<br />
queueDataKey = type + &#8220;queue&#8221;,<br />
markDataKey = type + &#8220;mark&#8221;,<br />
tmp;<br />
function resolve() {<br />
if ( !( &#8211;count ) ) {<br />
defer.resolveWith( elements, [ elements ] );<br />
}<br />
}<br />
while( i&#8211; ) {<br />
if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||<br />
( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||<br />
jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &amp;&amp;<br />
jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( &#8220;once memory&#8221; ), true ) )) {<br />
count++;<br />
tmp.add( resolve );<br />
}<br />
}<br />
resolve();<br />
return defer.promise();<br />
}<br />
});</p>
<p>var rclass = /[\n\t\r]/g,<br />
rspace = /\s+/,<br />
rreturn = /\r/g,<br />
rtype = /^(?:button|input)$/i,<br />
rfocusable = /^(?:button|input|object|select|textarea)$/i,<br />
rclickable = /^a(?:rea)?$/i,<br />
rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,<br />
getSetAttribute = jQuery.support.getSetAttribute,<br />
nodeHook, boolHook, fixSpecified;</p>
<p>jQuery.fn.extend({<br />
attr: function( name, value ) {<br />
return jQuery.access( this, name, value, true, jQuery.attr );<br />
},</p>
<p>removeAttr: function( name ) {<br />
return this.each(function() {<br />
jQuery.removeAttr( this, name );<br />
});<br />
},</p>
<p>prop: function( name, value ) {<br />
return jQuery.access( this, name, value, true, jQuery.prop );<br />
},</p>
<p>removeProp: function( name ) {<br />
name = jQuery.propFix[ name ] || name;<br />
return this.each(function() {<br />
// try/catch handles cases where IE balks (such as removing a property on window)<br />
try {<br />
this[ name ] = undefined;<br />
delete this[ name ];<br />
} catch( e ) {}<br />
});<br />
},</p>
<p>addClass: function( value ) {<br />
var classNames, i, l, elem,<br />
setClass, c, cl;</p>
<p>if ( jQuery.isFunction( value ) ) {<br />
return this.each(function( j ) {<br />
jQuery( this ).addClass( value.call(this, j, this.className) );<br />
});<br />
}</p>
<p>if ( value &amp;&amp; typeof value === &#8220;string&#8221; ) {<br />
classNames = value.split( rspace );</p>
<p>for ( i = 0, l = this.length; i &lt; l; i++ ) {<br />
elem = this[ i ];</p>
<p>if ( elem.nodeType === 1 ) {<br />
if ( !elem.className &amp;&amp; classNames.length === 1 ) {<br />
elem.className = value;</p>
<p>} else {<br />
setClass = &#8221; &#8221; + elem.className + &#8221; &#8220;;</p>
<p>for ( c = 0, cl = classNames.length; c &lt; cl; c++ ) {<br />
if ( !~setClass.indexOf( &#8221; &#8221; + classNames[ c ] + &#8221; &#8221; ) ) {<br />
setClass += classNames[ c ] + &#8221; &#8220;;<br />
}<br />
}<br />
elem.className = jQuery.trim( setClass );<br />
}<br />
}<br />
}<br />
}</p>
<p>return this;<br />
},</p>
<p>removeClass: function( value ) {<br />
var classNames, i, l, elem, className, c, cl;</p>
<p>if ( jQuery.isFunction( value ) ) {<br />
return this.each(function( j ) {<br />
jQuery( this ).removeClass( value.call(this, j, this.className) );<br />
});<br />
}</p>
<p>if ( (value &amp;&amp; typeof value === &#8220;string&#8221;) || value === undefined ) {<br />
classNames = ( value || &#8220;&#8221; ).split( rspace );</p>
<p>for ( i = 0, l = this.length; i &lt; l; i++ ) {<br />
elem = this[ i ];</p>
<p>if ( elem.nodeType === 1 &amp;&amp; elem.className ) {<br />
if ( value ) {<br />
className = (&#8221; &#8221; + elem.className + &#8221; &#8220;).replace( rclass, &#8221; &#8221; );<br />
for ( c = 0, cl = classNames.length; c &lt; cl; c++ ) {<br />
className = className.replace(&#8221; &#8221; + classNames[ c ] + &#8221; &#8220;, &#8221; &#8220;);<br />
}<br />
elem.className = jQuery.trim( className );</p>
<p>} else {<br />
elem.className = &#8220;&#8221;;<br />
}<br />
}<br />
}<br />
}</p>
<p>return this;<br />
},</p>
<p>toggleClass: function( value, stateVal ) {<br />
var type = typeof value,<br />
isBool = typeof stateVal === &#8220;boolean&#8221;;</p>
<p>if ( jQuery.isFunction( value ) ) {<br />
return this.each(function( i ) {<br />
jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );<br />
});<br />
}</p>
<p>return this.each(function() {<br />
if ( type === &#8220;string&#8221; ) {<br />
// toggle individual class names<br />
var className,<br />
i = 0,<br />
self = jQuery( this ),<br />
state = stateVal,<br />
classNames = value.split( rspace );</p>
<p>while ( (className = classNames[ i++ ]) ) {<br />
// check each className given, space seperated list<br />
state = isBool ? state : !self.hasClass( className );<br />
self[ state ? "addClass" : "removeClass" ]( className );<br />
}</p>
<p>} else if ( type === &#8220;undefined&#8221; || type === &#8220;boolean&#8221; ) {<br />
if ( this.className ) {<br />
// store className if set<br />
jQuery._data( this, &#8220;__className__&#8221;, this.className );<br />
}</p>
<p>// toggle whole className<br />
this.className = this.className || value === false ? &#8220;&#8221; : jQuery._data( this, &#8220;__className__&#8221; ) || &#8220;&#8221;;<br />
}<br />
});<br />
},</p>
<p>hasClass: function( selector ) {<br />
var className = &#8221; &#8221; + selector + &#8221; &#8220;,<br />
i = 0,<br />
l = this.length;<br />
for ( ; i &lt; l; i++ ) {<br />
if ( this[i].nodeType === 1 &amp;&amp; (&#8221; &#8221; + this[i].className + &#8221; &#8220;).replace(rclass, &#8221; &#8220;).indexOf( className ) &gt; -1 ) {<br />
return true;<br />
}<br />
}</p>
<p>return false;<br />
},</p>
<p>val: function( value ) {<br />
var hooks, ret, isFunction,<br />
elem = this[0];</p>
<p>if ( !arguments.length ) {<br />
if ( elem ) {<br />
hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];</p>
<p>if ( hooks &amp;&amp; &#8220;get&#8221; in hooks &amp;&amp; (ret = hooks.get( elem, &#8220;value&#8221; )) !== undefined ) {<br />
return ret;<br />
}</p>
<p>ret = elem.value;</p>
<p>return typeof ret === &#8220;string&#8221; ?<br />
// handle most common string cases<br />
ret.replace(rreturn, &#8220;&#8221;) :<br />
// handle cases where value is null/undef or number<br />
ret == null ? &#8220;&#8221; : ret;<br />
}</p>
<p>return undefined;<br />
}</p>
<p>isFunction = jQuery.isFunction( value );</p>
<p>return this.each(function( i ) {<br />
var self = jQuery(this), val;</p>
<p>if ( this.nodeType !== 1 ) {<br />
return;<br />
}</p>
<p>if ( isFunction ) {<br />
val = value.call( this, i, self.val() );<br />
} else {<br />
val = value;<br />
}</p>
<p>// Treat null/undefined as &#8220;&#8221;; convert numbers to string<br />
if ( val == null ) {<br />
val = &#8220;&#8221;;<br />
} else if ( typeof val === &#8220;number&#8221; ) {<br />
val += &#8220;&#8221;;<br />
} else if ( jQuery.isArray( val ) ) {<br />
val = jQuery.map(val, function ( value ) {<br />
return value == null ? &#8220;&#8221; : value + &#8220;&#8221;;<br />
});<br />
}</p>
<p>hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];</p>
<p>// If set returns undefined, fall back to normal setting<br />
if ( !hooks || !(&#8220;set&#8221; in hooks) || hooks.set( this, val, &#8220;value&#8221; ) === undefined ) {<br />
this.value = val;<br />
}<br />
});<br />
}<br />
});</p>
<p>jQuery.extend({<br />
valHooks: {<br />
option: {<br />
get: function( elem ) {<br />
// attributes.value is undefined in Blackberry 4.7 but<br />
// uses .value. See #6932<br />
var val = elem.attributes.value;<br />
return !val || val.specified ? elem.value : elem.text;<br />
}<br />
},<br />
select: {<br />
get: function( elem ) {<br />
var value, i, max, option,<br />
index = elem.selectedIndex,<br />
values = [],<br />
options = elem.options,<br />
one = elem.type === &#8220;select-one&#8221;;</p>
<p>// Nothing was selected<br />
if ( index &lt; 0 ) {<br />
return null;<br />
}</p>
<p>// Loop through all the selected options<br />
i = one ? index : 0;<br />
max = one ? index + 1 : options.length;<br />
for ( ; i &lt; max; i++ ) {<br />
option = options[ i ];</p>
<p>// Don&#8217;t return options that are disabled or in a disabled optgroup<br />
if ( option.selected &amp;&amp; (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(&#8220;disabled&#8221;) === null) &amp;&amp;<br />
(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &#8220;optgroup&#8221; )) ) {</p>
<p>// Get the specific value for the option<br />
value = jQuery( option ).val();</p>
<p>// We don&#8217;t need an array for one selects<br />
if ( one ) {<br />
return value;<br />
}</p>
<p>// Multi-Selects return an array<br />
values.push( value );<br />
}<br />
}</p>
<p>// Fixes Bug #2551 &#8212; select.val() broken in IE after form.reset()<br />
if ( one &amp;&amp; !values.length &amp;&amp; options.length ) {<br />
return jQuery( options[ index ] ).val();<br />
}</p>
<p>return values;<br />
},</p>
<p>set: function( elem, value ) {<br />
var values = jQuery.makeArray( value );</p>
<p>jQuery(elem).find(&#8220;option&#8221;).each(function() {<br />
this.selected = jQuery.inArray( jQuery(this).val(), values ) &gt;= 0;<br />
});</p>
<p>if ( !values.length ) {<br />
elem.selectedIndex = -1;<br />
}<br />
return values;<br />
}<br />
}<br />
},</p>
<p>attrFn: {<br />
val: true,<br />
css: true,<br />
html: true,<br />
text: true,<br />
data: true,<br />
width: true,<br />
height: true,<br />
offset: true<br />
},</p>
<p>attr: function( elem, name, value, pass ) {<br />
var ret, hooks, notxml,<br />
nType = elem.nodeType;</p>
<p>// don&#8217;t get/set attributes on text, comment and attribute nodes<br />
if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {<br />
return undefined;<br />
}</p>
<p>if ( pass &amp;&amp; name in jQuery.attrFn ) {<br />
return jQuery( elem )[ name ]( value );<br />
}</p>
<p>// Fallback to prop when attributes are not supported<br />
if ( !(&#8220;getAttribute&#8221; in elem) ) {<br />
return jQuery.prop( elem, name, value );<br />
}</p>
<p>notxml = nType !== 1 || !jQuery.isXMLDoc( elem );</p>
<p>// All attributes are lowercase<br />
// Grab necessary hook if one is defined<br />
if ( notxml ) {<br />
name = name.toLowerCase();<br />
hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );<br />
}</p>
<p>if ( value !== undefined ) {</p>
<p>if ( value === null ) {<br />
jQuery.removeAttr( elem, name );<br />
return undefined;</p>
<p>} else if ( hooks &amp;&amp; &#8220;set&#8221; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {<br />
return ret;</p>
<p>} else {<br />
elem.setAttribute( name, &#8220;&#8221; + value );<br />
return value;<br />
}</p>
<p>} else if ( hooks &amp;&amp; &#8220;get&#8221; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {<br />
return ret;</p>
<p>} else {</p>
<p>ret = elem.getAttribute( name );</p>
<p>// Non-existent attributes return null, we normalize to undefined<br />
return ret === null ?<br />
undefined :<br />
ret;<br />
}<br />
},</p>
<p>removeAttr: function( elem, value ) {<br />
var propName, attrNames, name, l,<br />
i = 0;</p>
<p>if ( elem.nodeType === 1 ) {<br />
attrNames = ( value || &#8220;&#8221; ).split( rspace );<br />
l = attrNames.length;</p>
<p>for ( ; i &lt; l; i++ ) {<br />
name = attrNames[ i ].toLowerCase();<br />
propName = jQuery.propFix[ name ] || name;</p>
<p>// See #9699 for explanation of this approach (setting first, then removal)<br />
jQuery.attr( elem, name, &#8220;&#8221; );<br />
elem.removeAttribute( getSetAttribute ? name : propName );</p>
<p>// Set corresponding property to false for boolean attributes<br />
if ( rboolean.test( name ) &amp;&amp; propName in elem ) {<br />
elem[ propName ] = false;<br />
}<br />
}<br />
}<br />
},</p>
<p>attrHooks: {<br />
type: {<br />
set: function( elem, value ) {<br />
// We can&#8217;t allow the type property to be changed (since it causes problems in IE)<br />
if ( rtype.test( elem.nodeName ) &amp;&amp; elem.parentNode ) {<br />
jQuery.error( &#8220;type property can&#8217;t be changed&#8221; );<br />
} else if ( !jQuery.support.radioValue &amp;&amp; value === &#8220;radio&#8221; &amp;&amp; jQuery.nodeName(elem, &#8220;input&#8221;) ) {<br />
// Setting the type on a radio button after the value resets the value in IE6-9<br />
// Reset value to it&#8217;s default in case type is set after value<br />
// This is for element creation<br />
var val = elem.value;<br />
elem.setAttribute( &#8220;type&#8221;, value );<br />
if ( val ) {<br />
elem.value = val;<br />
}<br />
return value;<br />
}<br />
}<br />
},<br />
// Use the value property for back compat<br />
// Use the nodeHook for button elements in IE6/7 (#1954)<br />
value: {<br />
get: function( elem, name ) {<br />
if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &#8220;button&#8221; ) ) {<br />
return nodeHook.get( elem, name );<br />
}<br />
return name in elem ?<br />
elem.value :<br />
null;<br />
},<br />
set: function( elem, value, name ) {<br />
if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &#8220;button&#8221; ) ) {<br />
return nodeHook.set( elem, value, name );<br />
}<br />
// Does not return so that setAttribute is also used<br />
elem.value = value;<br />
}<br />
}<br />
},</p>
<p>propFix: {<br />
tabindex: &#8220;tabIndex&#8221;,<br />
readonly: &#8220;readOnly&#8221;,<br />
&#8220;for&#8221;: &#8220;htmlFor&#8221;,<br />
&#8220;class&#8221;: &#8220;className&#8221;,<br />
maxlength: &#8220;maxLength&#8221;,<br />
cellspacing: &#8220;cellSpacing&#8221;,<br />
cellpadding: &#8220;cellPadding&#8221;,<br />
rowspan: &#8220;rowSpan&#8221;,<br />
colspan: &#8220;colSpan&#8221;,<br />
usemap: &#8220;useMap&#8221;,<br />
frameborder: &#8220;frameBorder&#8221;,<br />
contenteditable: &#8220;contentEditable&#8221;<br />
},</p>
<p>prop: function( elem, name, value ) {<br />
var ret, hooks, notxml,<br />
nType = elem.nodeType;</p>
<p>// don&#8217;t get/set properties on text, comment and attribute nodes<br />
if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {<br />
return undefined;<br />
}</p>
<p>notxml = nType !== 1 || !jQuery.isXMLDoc( elem );</p>
<p>if ( notxml ) {<br />
// Fix name and attach hooks<br />
name = jQuery.propFix[ name ] || name;<br />
hooks = jQuery.propHooks[ name ];<br />
}</p>
<p>if ( value !== undefined ) {<br />
if ( hooks &amp;&amp; &#8220;set&#8221; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {<br />
return ret;</p>
<p>} else {<br />
return ( elem[ name ] = value );<br />
}</p>
<p>} else {<br />
if ( hooks &amp;&amp; &#8220;get&#8221; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {<br />
return ret;</p>
<p>} else {<br />
return elem[ name ];<br />
}<br />
}<br />
},</p>
<p>propHooks: {<br />
tabIndex: {<br />
get: function( elem ) {<br />
// elem.tabIndex doesn&#8217;t always return the correct value when it hasn&#8217;t been explicitly set<br />
// <a href="http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/" rel="nofollow">http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/</a><br />
var attributeNode = elem.getAttributeNode(&#8220;tabindex&#8221;);</p>
<p>return attributeNode &amp;&amp; attributeNode.specified ?<br />
parseInt( attributeNode.value, 10 ) :<br />
rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ?<br />
0 :<br />
undefined;<br />
}<br />
}<br />
}<br />
});</p>
<p>// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)<br />
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;</p>
<p>// Hook for boolean attributes<br />
boolHook = {<br />
get: function( elem, name ) {<br />
// Align boolean attributes with corresponding properties<br />
// Fall back to attribute presence where some booleans are not supported<br />
var attrNode,<br />
property = jQuery.prop( elem, name );<br />
return property === true || typeof property !== &#8220;boolean&#8221; &amp;&amp; ( attrNode = elem.getAttributeNode(name) ) &amp;&amp; attrNode.nodeValue !== false ?<br />
name.toLowerCase() :<br />
undefined;<br />
},<br />
set: function( elem, value, name ) {<br />
var propName;<br />
if ( value === false ) {<br />
// Remove boolean attributes when set to false<br />
jQuery.removeAttr( elem, name );<br />
} else {<br />
// value is true since we know at this point it&#8217;s type boolean and not false<br />
// Set boolean attributes to the same name and set the DOM property<br />
propName = jQuery.propFix[ name ] || name;<br />
if ( propName in elem ) {<br />
// Only set the IDL specifically if it already exists on the element<br />
elem[ propName ] = true;<br />
}</p>
<p>elem.setAttribute( name, name.toLowerCase() );<br />
}<br />
return name;<br />
}<br />
};</p>
<p>// IE6/7 do not support getting/setting some attributes with get/setAttribute<br />
if ( !getSetAttribute ) {</p>
<p>fixSpecified = {<br />
name: true,<br />
id: true<br />
};</p>
<p>// Use this for any attribute in IE6/7<br />
// This fixes almost every IE6/7 issue<br />
nodeHook = jQuery.valHooks.button = {<br />
get: function( elem, name ) {<br />
var ret;<br />
ret = elem.getAttributeNode( name );<br />
return ret &amp;&amp; ( fixSpecified[ name ] ? ret.nodeValue !== &#8220;&#8221; : ret.specified ) ?<br />
ret.nodeValue :<br />
undefined;<br />
},<br />
set: function( elem, value, name ) {<br />
// Set the existing or create a new attribute node<br />
var ret = elem.getAttributeNode( name );<br />
if ( !ret ) {<br />
ret = document.createAttribute( name );<br />
elem.setAttributeNode( ret );<br />
}<br />
return ( ret.nodeValue = value + &#8220;&#8221; );<br />
}<br />
};</p>
<p>// Apply the nodeHook to tabindex<br />
jQuery.attrHooks.tabindex.set = nodeHook.set;</p>
<p>// Set width and height to auto instead of 0 on empty string( Bug #8150 )<br />
// This is for removals<br />
jQuery.each([ "width", "height" ], function( i, name ) {<br />
jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {<br />
set: function( elem, value ) {<br />
if ( value === &#8220;&#8221; ) {<br />
elem.setAttribute( name, &#8220;auto&#8221; );<br />
return value;<br />
}<br />
}<br />
});<br />
});</p>
<p>// Set contenteditable to false on removals(#10429)<br />
// Setting to empty string throws an error as an invalid value<br />
jQuery.attrHooks.contenteditable = {<br />
get: nodeHook.get,<br />
set: function( elem, value, name ) {<br />
if ( value === &#8220;&#8221; ) {<br />
value = &#8220;false&#8221;;<br />
}<br />
nodeHook.set( elem, value, name );<br />
}<br />
};<br />
}</p>
<p>// Some attributes require a special call on IE<br />
if ( !jQuery.support.hrefNormalized ) {<br />
jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {<br />
jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {<br />
get: function( elem ) {<br />
var ret = elem.getAttribute( name, 2 );<br />
return ret === null ? undefined : ret;<br />
}<br />
});<br />
});<br />
}</p>
<p>if ( !jQuery.support.style ) {<br />
jQuery.attrHooks.style = {<br />
get: function( elem ) {<br />
// Return undefined in the case of empty string<br />
// Normalize to lowercase since IE uppercases css property names<br />
return elem.style.cssText.toLowerCase() || undefined;<br />
},<br />
set: function( elem, value ) {<br />
return ( elem.style.cssText = &#8220;&#8221; + value );<br />
}<br />
};<br />
}</p>
<p>// Safari mis-reports the default selected property of an option<br />
// Accessing the parent&#8217;s selectedIndex property fixes it<br />
if ( !jQuery.support.optSelected ) {<br />
jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {<br />
get: function( elem ) {<br />
var parent = elem.parentNode;</p>
<p>if ( parent ) {<br />
parent.selectedIndex;</p>
<p>// Make sure that it also works with optgroups, see #5701<br />
if ( parent.parentNode ) {<br />
parent.parentNode.selectedIndex;<br />
}<br />
}<br />
return null;<br />
}<br />
});<br />
}</p>
<p>// IE6/7 call enctype encoding<br />
if ( !jQuery.support.enctype ) {<br />
jQuery.propFix.enctype = &#8220;encoding&#8221;;<br />
}</p>
<p>// Radios and checkboxes getter/setter<br />
if ( !jQuery.support.checkOn ) {<br />
jQuery.each([ "radio", "checkbox" ], function() {<br />
jQuery.valHooks[ this ] = {<br />
get: function( elem ) {<br />
// Handle the case where in Webkit &#8220;&#8221; is returned instead of &#8220;on&#8221; if a value isn&#8217;t specified<br />
return elem.getAttribute(&#8220;value&#8221;) === null ? &#8220;on&#8221; : elem.value;<br />
}<br />
};<br />
});<br />
}<br />
jQuery.each([ "radio", "checkbox" ], function() {<br />
jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {<br />
set: function( elem, value ) {<br />
if ( jQuery.isArray( value ) ) {<br />
return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );<br />
}<br />
}<br />
});<br />
});</p>
<p>var rnamespaces = /\.(.*)$/,<br />
rformElems = /^(?:textarea|input|select)$/i,<br />
rperiod = /\./g,<br />
rspaces = / /g,<br />
rescape = /[^\w\s.|`]/g,<br />
rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,<br />
rhoverHack = /\bhover(\.\S+)?/,<br />
rkeyEvent = /^key/,<br />
rmouseEvent = /^(?:mouse|contextmenu)|click/,<br />
rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,<br />
quickParse = function( selector ) {<br />
var quick = rquickIs.exec( selector );<br />
if ( quick ) {<br />
//   0  1    2   3<br />
// [ _, tag, id, class ]<br />
quick[1] = ( quick[1] || &#8220;&#8221; ).toLowerCase();<br />
quick[3] = quick[3] &amp;&amp; new RegExp( &#8220;(?:^|\\s)&#8221; + quick[3] + &#8220;(?:\\s|$)&#8221; );<br />
}<br />
return quick;<br />
},<br />
quickIs = function( elem, m ) {<br />
return (<br />
(!m[1] || elem.nodeName.toLowerCase() === m[1]) &amp;&amp;<br />
(!m[2] || elem.id === m[2]) &amp;&amp;<br />
(!m[3] || m[3].test( elem.className ))<br />
);<br />
},<br />
hoverHack = function( events ) {<br />
return jQuery.event.special.hover ? events : events.replace( rhoverHack, &#8220;mouseenter$1 mouseleave$1&#8243; );<br />
};</p>
<p>/*<br />
* Helper functions for managing events &#8212; not part of the public interface.<br />
* Props to Dean Edwards&#8217; addEvent library for many of the ideas.<br />
*/<br />
jQuery.event = {</p>
<p>add: function( elem, types, handler, data, selector ) {</p>
<p>var elemData, eventHandle, events,<br />
t, tns, type, namespaces, handleObj,<br />
handleObjIn, quick, handlers, special;</p>
<p>// Don&#8217;t attach events to noData or text/comment nodes (allow plain objects tho)<br />
if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {<br />
return;<br />
}</p>
<p>// Caller can pass in an object of custom data in lieu of the handler<br />
if ( handler.handler ) {<br />
handleObjIn = handler;<br />
handler = handleObjIn.handler;<br />
}</p>
<p>// Make sure that the handler has a unique ID, used to find/remove it later<br />
if ( !handler.guid ) {<br />
handler.guid = jQuery.guid++;<br />
}</p>
<p>// Init the element&#8217;s event structure and main handler, if this is the first<br />
events = elemData.events;<br />
if ( !events ) {<br />
elemData.events = events = {};<br />
}<br />
eventHandle = elemData.handle;<br />
if ( !eventHandle ) {<br />
elemData.handle = eventHandle = function( e ) {<br />
// Discard the second event of a jQuery.event.trigger() and<br />
// when an event is called after a page has unloaded<br />
return typeof jQuery !== &#8220;undefined&#8221; &amp;&amp; (!e || jQuery.event.triggered !== e.type) ?<br />
jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :<br />
undefined;<br />
};<br />
// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events<br />
eventHandle.elem = elem;<br />
}</p>
<p>// Handle multiple events separated by a space<br />
// jQuery(&#8230;).bind(&#8220;mouseover mouseout&#8221;, fn);<br />
types = hoverHack(types).split( &#8221; &#8221; );<br />
for ( t = 0; t &lt; types.length; t++ ) {</p>
<p>tns = rtypenamespace.exec( types[t] ) || [];<br />
type = tns[1];<br />
namespaces = ( tns[2] || &#8220;&#8221; ).split( &#8220;.&#8221; ).sort();</p>
<p>// If event changes its type, use the special event handlers for the changed type<br />
special = jQuery.event.special[ type ] || {};</p>
<p>// If selector defined, determine special event api type, otherwise given type<br />
type = ( selector ? special.delegateType : special.bindType ) || type;</p>
<p>// Update special based on newly reset type<br />
special = jQuery.event.special[ type ] || {};</p>
<p>// handleObj is passed to all event handlers<br />
handleObj = jQuery.extend({<br />
type: type,<br />
origType: tns[1],<br />
data: data,<br />
handler: handler,<br />
guid: handler.guid,<br />
selector: selector,<br />
namespace: namespaces.join(&#8220;.&#8221;)<br />
}, handleObjIn );</p>
<p>// Delegated event; pre-analyze selector so it&#8217;s processed quickly on event dispatch<br />
if ( selector ) {<br />
handleObj.quick = quickParse( selector );<br />
if ( !handleObj.quick &amp;&amp; jQuery.expr.match.POS.test( selector ) ) {<br />
handleObj.isPositional = true;<br />
}<br />
}</p>
<p>// Init the event handler queue if we&#8217;re the first<br />
handlers = events[ type ];<br />
if ( !handlers ) {<br />
handlers = events[ type ] = [];<br />
handlers.delegateCount = 0;</p>
<p>// Only use addEventListener/attachEvent if the special events handler returns false<br />
if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {<br />
// Bind the global event handler to the element<br />
if ( elem.addEventListener ) {<br />
elem.addEventListener( type, eventHandle, false );</p>
<p>} else if ( elem.attachEvent ) {<br />
elem.attachEvent( &#8220;on&#8221; + type, eventHandle );<br />
}<br />
}<br />
}</p>
<p>if ( special.add ) {<br />
special.add.call( elem, handleObj );</p>
<p>if ( !handleObj.handler.guid ) {<br />
handleObj.handler.guid = handler.guid;<br />
}<br />
}</p>
<p>// Add to the element&#8217;s handler list, delegates in front<br />
if ( selector ) {<br />
handlers.splice( handlers.delegateCount++, 0, handleObj );<br />
} else {<br />
handlers.push( handleObj );<br />
}</p>
<p>// Keep track of which events have ever been used, for event optimization<br />
jQuery.event.global[ type ] = true;<br />
}</p>
<p>// Nullify elem to prevent memory leaks in IE<br />
elem = null;<br />
},</p>
<p>global: {},</p>
<p>// Detach an event or set of events from an element<br />
remove: function( elem, types, handler, selector ) {</p>
<p>var elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem ),<br />
t, tns, type, namespaces, origCount,<br />
j, events, special, handle, eventType, handleObj;</p>
<p>if ( !elemData || !(events = elemData.events) ) {<br />
return;<br />
}</p>
<p>// Once for each type.namespace in types; type may be omitted<br />
types = hoverHack( types || &#8220;&#8221; ).split(&#8221; &#8220;);<br />
for ( t = 0; t &lt; types.length; t++ ) {<br />
tns = rtypenamespace.exec( types[t] ) || [];<br />
type = tns[1];<br />
namespaces = tns[2];</p>
<p>// Unbind all events (on this namespace, if provided) for the element<br />
if ( !type ) {<br />
namespaces = namespaces? &#8220;.&#8221; + namespaces : &#8220;&#8221;;<br />
for ( j in events ) {<br />
jQuery.event.remove( elem, j + namespaces, handler, selector );<br />
}<br />
return;<br />
}</p>
<p>special = jQuery.event.special[ type ] || {};<br />
type = ( selector? special.delegateType : special.bindType ) || type;<br />
eventType = events[ type ] || [];<br />
origCount = eventType.length;<br />
namespaces = namespaces ? new RegExp(&#8220;(^|\\.)&#8221; + namespaces.split(&#8220;.&#8221;).sort().join(&#8220;\\.(?:.*\\.)?&#8221;) + &#8220;(\\.|$)&#8221;) : null;</p>
<p>// Only need to loop for special events or selective removal<br />
if ( handler || namespaces || selector || special.remove ) {<br />
for ( j = 0; j &lt; eventType.length; j++ ) {<br />
handleObj = eventType[ j ];</p>
<p>if ( !handler || handler.guid === handleObj.guid ) {<br />
if ( !namespaces || namespaces.test( handleObj.namespace ) ) {<br />
if ( !selector || selector === handleObj.selector || selector === &#8220;**&#8221; &amp;&amp; handleObj.selector ) {<br />
eventType.splice( j&#8211;, 1 );</p>
<p>if ( handleObj.selector ) {<br />
eventType.delegateCount&#8211;;<br />
}<br />
if ( special.remove ) {<br />
special.remove.call( elem, handleObj );<br />
}<br />
}<br />
}<br />
}<br />
}<br />
} else {<br />
// Removing all events<br />
eventType.length = 0;<br />
}</p>
<p>// Remove generic event handler if we removed something and no more handlers exist<br />
// (avoids potential for endless recursion during removal of special event handlers)<br />
if ( eventType.length === 0 &amp;&amp; origCount !== eventType.length ) {<br />
if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {<br />
jQuery.removeEvent( elem, type, elemData.handle );<br />
}</p>
<p>delete events[ type ];<br />
}<br />
}</p>
<p>// Remove the expando if it&#8217;s no longer used<br />
if ( jQuery.isEmptyObject( events ) ) {<br />
handle = elemData.handle;<br />
if ( handle ) {<br />
handle.elem = null;<br />
}</p>
<p>// removeData also checks for emptiness and clears the expando if empty<br />
// so use it instead of delete<br />
jQuery.removeData( elem, [ "events", "handle" ], true );<br />
}<br />
},</p>
<p>// Events that are safe to short-circuit if no handlers are attached.<br />
// Native DOM events should not be added, they may have inline handlers.<br />
customEvent: {<br />
&#8220;getData&#8221;: true,<br />
&#8220;setData&#8221;: true,<br />
&#8220;changeData&#8221;: true<br />
},</p>
<p>trigger: function( event, data, elem, onlyHandlers ) {<br />
// Don&#8217;t do events on text and comment nodes<br />
if ( elem &amp;&amp; (elem.nodeType === 3 || elem.nodeType === 8) ) {<br />
return;<br />
}</p>
<p>// Event object or event type<br />
var type = event.type || event,<br />
namespaces = [],<br />
cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;</p>
<p>if ( type.indexOf( &#8220;!&#8221; ) &gt;= 0 ) {<br />
// Exclusive events trigger only for the exact event (no namespaces)<br />
type = type.slice(0, -1);<br />
exclusive = true;<br />
}</p>
<p>if ( type.indexOf( &#8220;.&#8221; ) &gt;= 0 ) {<br />
// Namespaced trigger; create a regexp to match event type in handle()<br />
namespaces = type.split(&#8220;.&#8221;);<br />
type = namespaces.shift();<br />
namespaces.sort();<br />
}</p>
<p>if ( (!elem || jQuery.event.customEvent[ type ]) &amp;&amp; !jQuery.event.global[ type ] ) {<br />
// No jQuery handlers for this event type, and it can&#8217;t have inline handlers<br />
return;<br />
}</p>
<p>// Caller can pass in an Event, Object, or just an event type string<br />
event = typeof event === &#8220;object&#8221; ?<br />
// jQuery.Event object<br />
event[ jQuery.expando ] ? event :<br />
// Object literal<br />
new jQuery.Event( type, event ) :<br />
// Just the event type (string)<br />
new jQuery.Event( type );</p>
<p>event.type = type;<br />
event.isTrigger = true;<br />
event.exclusive = exclusive;<br />
event.namespace = namespaces.join( &#8220;.&#8221; );<br />
event.namespace_re = event.namespace? new RegExp(&#8220;(^|\\.)&#8221; + namespaces.join(&#8220;\\.(?:.*\\.)?&#8221;) + &#8220;(\\.|$)&#8221;) : null;<br />
ontype = type.indexOf( &#8220;:&#8221; ) &lt; 0 ? &#8220;on&#8221; + type : &#8220;&#8221;;</p>
<p>// triggerHandler() and global events don&#8217;t bubble or run the default action<br />
if ( onlyHandlers || !elem ) {<br />
event.preventDefault();<br />
}</p>
<p>// Handle a global trigger<br />
if ( !elem ) {</p>
<p>// TODO: Stop taunting the data cache; remove global events and always attach to document<br />
cache = jQuery.cache;<br />
for ( i in cache ) {<br />
if ( cache[ i ].events &amp;&amp; cache[ i ].events[ type ] ) {<br />
jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );<br />
}<br />
}<br />
return;<br />
}</p>
<p>// Clean up the event in case it is being reused<br />
event.result = undefined;<br />
if ( !event.target ) {<br />
event.target = elem;<br />
}</p>
<p>// Clone any incoming data and prepend the event, creating the handler arg list<br />
data = data != null ? jQuery.makeArray( data ) : [];<br />
data.unshift( event );</p>
<p>// Allow special events to draw outside the lines<br />
special = jQuery.event.special[ type ] || {};<br />
if ( special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {<br />
return;<br />
}</p>
<p>// Determine event propagation path in advance, per W3C events spec (#9951)<br />
// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)<br />
eventPath = [[ elem, special.bindType || type ]];<br />
if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {</p>
<p>bubbleType = special.delegateType || type;<br />
old = null;<br />
for ( cur = elem.parentNode; cur; cur = cur.parentNode ) {<br />
eventPath.push([ cur, bubbleType ]);<br />
old = cur;<br />
}</p>
<p>// Only add window if we got to document (e.g., not plain obj or detached DOM)<br />
if ( old &amp;&amp; old === elem.ownerDocument ) {<br />
eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);<br />
}<br />
}</p>
<p>// Fire handlers on the event path<br />
for ( i = 0; i &lt; eventPath.length; i++ ) {</p>
<p>cur = eventPath[i][0];<br />
event.type = eventPath[i][1];</p>
<p>handle = ( jQuery._data( cur, &#8220;events&#8221; ) || {} )[ event.type ] &amp;&amp; jQuery._data( cur, &#8220;handle&#8221; );<br />
if ( handle ) {<br />
handle.apply( cur, data );<br />
}<br />
handle = ontype &amp;&amp; cur[ ontype ];<br />
if ( handle &amp;&amp; jQuery.acceptData( cur ) ) {<br />
handle.apply( cur, data );<br />
}</p>
<p>if ( event.isPropagationStopped() ) {<br />
break;<br />
}<br />
}<br />
event.type = type;</p>
<p>// If nobody prevented the default action, do it now<br />
if ( !event.isDefaultPrevented() ) {</p>
<p>if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &amp;&amp;<br />
!(type === &#8220;click&#8221; &amp;&amp; jQuery.nodeName( elem, &#8220;a&#8221; )) &amp;&amp; jQuery.acceptData( elem ) ) {</p>
<p>// Call a native DOM method on the target with the same name name as the event.<br />
// Can&#8217;t use an .isFunction() check here because IE6/7 fails that test.<br />
// Don&#8217;t do default actions on window, that&#8217;s where global variables be (#6170)<br />
// IE&lt;9 dies on focus/blur to hidden element (#1486)<br />
if ( ontype &amp;&amp; elem[ type ] &amp;&amp; ((type !== &#8220;focus&#8221; &amp;&amp; type !== &#8220;blur&#8221;) || event.target.offsetWidth !== 0) &amp;&amp; !jQuery.isWindow( elem ) ) {</p>
<p>// Don&#8217;t re-trigger an onFOO event when we call its FOO() method<br />
old = elem[ ontype ];</p>
<p>if ( old ) {<br />
elem[ ontype ] = null;<br />
}</p>
<p>// Prevent re-triggering of the same event, since we already bubbled it above<br />
jQuery.event.triggered = type;<br />
elem[ type ]();<br />
jQuery.event.triggered = undefined;</p>
<p>if ( old ) {<br />
elem[ ontype ] = old;<br />
}<br />
}<br />
}<br />
}</p>
<p>return event.result;<br />
},</p>
<p>dispatch: function( event ) {</p>
<p>// Make a writable jQuery.Event from the native event object<br />
event = jQuery.event.fix( event || window.event );</p>
<p>var handlers = ( (jQuery._data( this, &#8220;events&#8221; ) || {} )[ event.type ] || []),<br />
delegateCount = handlers.delegateCount,<br />
args = [].slice.call( arguments, 0 ),<br />
run_all = !event.exclusive &amp;&amp; !event.namespace,<br />
specialHandle = ( jQuery.event.special[ event.type ] || {} ).handle,<br />
handlerQueue = [],<br />
i, j, cur, ret, selMatch, matched, matches, handleObj, sel, hit, related;</p>
<p>// Use the fix-ed jQuery.Event rather than the (read-only) native event<br />
args[0] = event;<br />
event.delegateTarget = this;</p>
<p>// Determine handlers that should run if there are delegated events<br />
// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)<br />
if ( delegateCount &amp;&amp; !event.target.disabled &amp;&amp; !(event.button &amp;&amp; event.type === &#8220;click&#8221;) ) {</p>
<p>for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {<br />
selMatch = {};<br />
matches = [];<br />
for ( i = 0; i &lt; delegateCount; i++ ) {<br />
handleObj = handlers[ i ];<br />
sel = handleObj.selector;<br />
hit = selMatch[ sel ];</p>
<p>if ( handleObj.isPositional ) {<br />
// Since .is() does not work for positionals; see <a href="http://jsfiddle.net/eJ4yd/3/" rel="nofollow">http://jsfiddle.net/eJ4yd/3/</a><br />
hit = ( hit || (selMatch[ sel ] = jQuery( sel )) ).index( cur ) &gt;= 0;<br />
} else if ( hit === undefined ) {<br />
hit = selMatch[ sel ] = ( handleObj.quick ? quickIs( cur, handleObj.quick ) : jQuery( cur ).is( sel ) );<br />
}<br />
if ( hit ) {<br />
matches.push( handleObj );<br />
}<br />
}<br />
if ( matches.length ) {<br />
handlerQueue.push({ elem: cur, matches: matches });<br />
}<br />
}<br />
}</p>
<p>// Add the remaining (directly-bound) handlers<br />
if ( handlers.length &gt; delegateCount ) {<br />
handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });<br />
}</p>
<p>// Run delegates first; they may want to stop propagation beneath us<br />
for ( i = 0; i &lt; handlerQueue.length &amp;&amp; !event.isPropagationStopped(); i++ ) {<br />
matched = handlerQueue[ i ];<br />
event.currentTarget = matched.elem;</p>
<p>for ( j = 0; j &lt; matched.matches.length &amp;&amp; !event.isImmediatePropagationStopped(); j++ ) {<br />
handleObj = matched.matches[ j ];</p>
<p>// Triggered event must either 1) be non-exclusive and have no namespace, or<br />
// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).<br />
if ( run_all || (!event.namespace &amp;&amp; !handleObj.namespace) || event.namespace_re &amp;&amp; event.namespace_re.test( handleObj.namespace ) ) {</p>
<p>event.data = handleObj.data;<br />
event.handleObj = handleObj;</p>
<p>ret = ( specialHandle || handleObj.handler ).apply( matched.elem, args );</p>
<p>if ( ret !== undefined ) {<br />
event.result = ret;<br />
if ( ret === false ) {<br />
event.preventDefault();<br />
event.stopPropagation();<br />
}<br />
}<br />
}<br />
}<br />
}</p>
<p>return event.result;<br />
},</p>
<p>// Includes some event props shared by KeyEvent and MouseEvent<br />
// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***<br />
props: &#8220;attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&#8221;.split(&#8221; &#8220;),</p>
<p>fixHooks: {},</p>
<p>keyHooks: {<br />
props: &#8220;char charCode key keyCode&#8221;.split(&#8221; &#8220;),<br />
filter: function( event, original ) {</p>
<p>// Add which for key events<br />
if ( event.which == null ) {<br />
event.which = original.charCode != null ? original.charCode : original.keyCode;<br />
}</p>
<p>return event;<br />
}<br />
},</p>
<p>mouseHooks: {<br />
props: &#8220;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement wheelDelta&#8221;.split(&#8221; &#8220;),<br />
filter: function( event, original ) {<br />
var eventDoc, doc, body,<br />
button = original.button,<br />
fromElement = original.fromElement;</p>
<p>// Calculate pageX/Y if missing and clientX/Y available<br />
if ( event.pageX == null &amp;&amp; original.clientX != null ) {<br />
eventDoc = event.target.ownerDocument || document;<br />
doc = eventDoc.documentElement;<br />
body = eventDoc.body;</p>
<p>event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) &#8211; ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );<br />
event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) &#8211; ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );<br />
}</p>
<p>// Add relatedTarget, if necessary<br />
if ( !event.relatedTarget &amp;&amp; fromElement ) {<br />
event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;<br />
}</p>
<p>// Add which for click: 1 === left; 2 === middle; 3 === right<br />
// Note: button is not normalized, so don&#8217;t use it<br />
if ( !event.which &amp;&amp; button !== undefined ) {<br />
event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );<br />
}</p>
<p>return event;<br />
}<br />
},</p>
<p>fix: function( event ) {<br />
if ( event[ jQuery.expando ] ) {<br />
return event;<br />
}</p>
<p>// Create a writable copy of the event object and normalize some properties<br />
var i, prop,<br />
originalEvent = event,<br />
fixHook = jQuery.event.fixHooks[ event.type ] || {},<br />
copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;</p>
<p>event = jQuery.Event( originalEvent );</p>
<p>for ( i = copy.length; i; ) {<br />
prop = copy[ --i ];<br />
event[ prop ] = originalEvent[ prop ];<br />
}</p>
<p>// Fix target property, if necessary (#1925, IE 6/7/8 &amp; Safari2)<br />
if ( !event.target ) {<br />
event.target = originalEvent.srcElement || document;<br />
}</p>
<p>// Target should not be a text node (#504, Safari)<br />
if ( event.target.nodeType === 3 ) {<br />
event.target = event.target.parentNode;<br />
}</p>
<p>// For mouse/key events; add metaKey if it&#8217;s not there (#3368, IE6/7/8)<br />
if ( event.metaKey === undefined ) {<br />
event.metaKey = event.ctrlKey;<br />
}</p>
<p>return fixHook.filter? fixHook.filter( event, originalEvent ) : event;<br />
},</p>
<p>special: {<br />
ready: {<br />
// Make sure the ready event is setup<br />
setup: jQuery.bindReady<br />
},</p>
<p>focus: {<br />
delegateType: &#8220;focusin&#8221;,<br />
noBubble: true<br />
},<br />
blur: {<br />
delegateType: &#8220;focusout&#8221;,<br />
noBubble: true<br />
},</p>
<p>beforeunload: {<br />
setup: function( data, namespaces, eventHandle ) {<br />
// We only want to do this special case on windows<br />
if ( jQuery.isWindow( this ) ) {<br />
this.onbeforeunload = eventHandle;<br />
}<br />
},</p>
<p>teardown: function( namespaces, eventHandle ) {<br />
if ( this.onbeforeunload === eventHandle ) {<br />
this.onbeforeunload = null;<br />
}<br />
}<br />
}<br />
},</p>
<p>simulate: function( type, elem, event, bubble ) {<br />
// Piggyback on a donor event to simulate a different one.<br />
// Fake originalEvent to avoid donor&#8217;s stopPropagation, but if the<br />
// simulated event prevents default then we do the same on the donor.<br />
var e = jQuery.extend(<br />
new jQuery.Event(),<br />
event,<br />
{ type: type,<br />
isSimulated: true,<br />
originalEvent: {}<br />
}<br />
);<br />
if ( bubble ) {<br />
jQuery.event.trigger( e, null, elem );<br />
} else {<br />
jQuery.event.dispatch.call( elem, e );<br />
}<br />
if ( e.isDefaultPrevented() ) {<br />
event.preventDefault();<br />
}<br />
}<br />
};</p>
<p>// Some plugins are using, but it&#8217;s undocumented/deprecated and will be removed.<br />
// The 1.7 special event interface should provide all the hooks needed now.<br />
jQuery.event.handle = jQuery.event.dispatch;</p>
<p>jQuery.removeEvent = document.removeEventListener ?<br />
function( elem, type, handle ) {<br />
if ( elem.removeEventListener ) {<br />
elem.removeEventListener( type, handle, false );<br />
}<br />
} :<br />
function( elem, type, handle ) {<br />
if ( elem.detachEvent ) {<br />
elem.detachEvent( &#8220;on&#8221; + type, handle );<br />
}<br />
};</p>
<p>jQuery.Event = function( src, props ) {<br />
// Allow instantiation without the &#8216;new&#8217; keyword<br />
if ( !(this instanceof jQuery.Event) ) {<br />
return new jQuery.Event( src, props );<br />
}</p>
<p>// Event object<br />
if ( src &amp;&amp; src.type ) {<br />
this.originalEvent = src;<br />
this.type = src.type;</p>
<p>// Events bubbling up the document may have been marked as prevented<br />
// by a handler lower down the tree; reflect the correct value.<br />
this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||<br />
src.getPreventDefault &amp;&amp; src.getPreventDefault() ) ? returnTrue : returnFalse;</p>
<p>// Event type<br />
} else {<br />
this.type = src;<br />
}</p>
<p>// Put explicitly provided properties onto the event object<br />
if ( props ) {<br />
jQuery.extend( this, props );<br />
}</p>
<p>// Create a timestamp if incoming event doesn&#8217;t have one<br />
this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();</p>
<p>// Mark it as fixed<br />
this[ jQuery.expando ] = true;<br />
};</p>
<p>function returnFalse() {<br />
return false;<br />
}<br />
function returnTrue() {<br />
return true;<br />
}</p>
<p>// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding<br />
// <a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html" rel="nofollow">http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</a><br />
jQuery.Event.prototype = {<br />
preventDefault: function() {<br />
this.isDefaultPrevented = returnTrue;</p>
<p>var e = this.originalEvent;<br />
if ( !e ) {<br />
return;<br />
}</p>
<p>// if preventDefault exists run it on the original event<br />
if ( e.preventDefault ) {<br />
e.preventDefault();</p>
<p>// otherwise set the returnValue property of the original event to false (IE)<br />
} else {<br />
e.returnValue = false;<br />
}<br />
},<br />
stopPropagation: function() {<br />
this.isPropagationStopped = returnTrue;</p>
<p>var e = this.originalEvent;<br />
if ( !e ) {<br />
return;<br />
}<br />
// if stopPropagation exists run it on the original event<br />
if ( e.stopPropagation ) {<br />
e.stopPropagation();<br />
}<br />
// otherwise set the cancelBubble property of the original event to true (IE)<br />
e.cancelBubble = true;<br />
},<br />
stopImmediatePropagation: function() {<br />
this.isImmediatePropagationStopped = returnTrue;<br />
this.stopPropagation();<br />
},<br />
isDefaultPrevented: returnFalse,<br />
isPropagationStopped: returnFalse,<br />
isImmediatePropagationStopped: returnFalse<br />
};</p>
<p>// Create mouseenter/leave events using mouseover/out and event-time checks<br />
jQuery.each({<br />
mouseenter: &#8220;mouseover&#8221;,<br />
mouseleave: &#8220;mouseout&#8221;<br />
}, function( orig, fix ) {<br />
jQuery.event.special[ orig ] = jQuery.event.special[ fix ] = {<br />
delegateType: fix,<br />
bindType: fix,</p>
<p>handle: function( event ) {<br />
var target = this,<br />
related = event.relatedTarget,<br />
handleObj = event.handleObj,<br />
selector = handleObj.selector,<br />
oldType, ret;</p>
<p>// For a real mouseover/out, always call the handler; for<br />
// mousenter/leave call the handler if related is outside the target.<br />
// NB: No relatedTarget if the mouse left/entered the browser window<br />
if ( !related || handleObj.origType === event.type || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {<br />
oldType = event.type;<br />
event.type = handleObj.origType;<br />
ret = handleObj.handler.apply( this, arguments );<br />
event.type = oldType;<br />
}<br />
return ret;<br />
}<br />
};<br />
});</p>
<p>// IE submit delegation<br />
if ( !jQuery.support.submitBubbles ) {</p>
<p>jQuery.event.special.submit = {<br />
setup: function() {<br />
// Only need this for delegated form submit events<br />
if ( jQuery.nodeName( this, &#8220;form&#8221; ) ) {<br />
return false;<br />
}</p>
<p>// Lazy-add a submit handler when a descendant form may potentially be submitted<br />
jQuery.event.add( this, &#8220;click._submit keypress._submit&#8221;, function( e ) {<br />
// Node name check avoids a VML-related crash in IE (#9807)<br />
var elem = e.target,<br />
form = jQuery.nodeName( elem, &#8220;input&#8221; ) || jQuery.nodeName( elem, &#8220;button&#8221; ) ? elem.form : undefined;<br />
if ( form &amp;&amp; !form._submit_attached ) {<br />
jQuery.event.add( form, &#8220;submit._submit&#8221;, function( event ) {<br />
// Form was submitted, bubble the event up the tree<br />
if ( this.parentNode ) {<br />
jQuery.event.simulate( &#8220;submit&#8221;, this.parentNode, event, true );<br />
}<br />
});<br />
form._submit_attached = true;<br />
}<br />
});<br />
// return undefined since we don&#8217;t need an event listener<br />
},</p>
<p>teardown: function() {<br />
// Only need this for delegated form submit events<br />
if ( jQuery.nodeName( this, &#8220;form&#8221; ) ) {<br />
return false;<br />
}</p>
<p>// Remove delegated handlers; cleanData eventually reaps submit handlers attached above<br />
jQuery.event.remove( this, &#8220;._submit&#8221; );<br />
}<br />
};<br />
}</p>
<p>// IE change delegation and checkbox/radio fix<br />
if ( !jQuery.support.changeBubbles ) {</p>
<p>jQuery.event.special.change = {</p>
<p>setup: function() {</p>
<p>if ( rformElems.test( this.nodeName ) ) {<br />
// IE doesn&#8217;t fire change on a check/radio until blur; trigger it on click<br />
// after a propertychange. Eat the blur-change in special.change.handle.<br />
// This still fires onchange a second time for check/radio after blur.<br />
if ( this.type === &#8220;checkbox&#8221; || this.type === &#8220;radio&#8221; ) {<br />
jQuery.event.add( this, &#8220;propertychange._change&#8221;, function( event ) {<br />
if ( event.originalEvent.propertyName === &#8220;checked&#8221; ) {<br />
this._just_changed = true;<br />
}<br />
});<br />
jQuery.event.add( this, &#8220;click._change&#8221;, function( event ) {<br />
if ( this._just_changed ) {<br />
this._just_changed = false;<br />
jQuery.event.simulate( &#8220;change&#8221;, this, event, true );<br />
}<br />
});<br />
}<br />
return false;<br />
}<br />
// Delegated event; lazy-add a change handler on descendant inputs<br />
jQuery.event.add( this, &#8220;beforeactivate._change&#8221;, function( e ) {<br />
var elem = e.target;</p>
<p>if ( rformElems.test( elem.nodeName ) &amp;&amp; !elem._change_attached ) {<br />
jQuery.event.add( elem, &#8220;change._change&#8221;, function( event ) {<br />
if ( this.parentNode &amp;&amp; !event.isSimulated ) {<br />
jQuery.event.simulate( &#8220;change&#8221;, this.parentNode, event, true );<br />
}<br />
});<br />
elem._change_attached = true;<br />
}<br />
});<br />
},</p>
<p>handle: function( event ) {<br />
var elem = event.target;</p>
<p>// Swallow native change events from checkbox/radio, we already triggered them above<br />
if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== &#8220;radio&#8221; &amp;&amp; elem.type !== &#8220;checkbox&#8221;) ) {<br />
return event.handleObj.handler.apply( this, arguments );<br />
}<br />
},</p>
<p>teardown: function() {<br />
jQuery.event.remove( this, &#8220;._change&#8221; );</p>
<p>return rformElems.test( this.nodeName );<br />
}<br />
};<br />
}</p>
<p>// Create &#8220;bubbling&#8221; focus and blur events<br />
if ( !jQuery.support.focusinBubbles ) {<br />
jQuery.each({ focus: &#8220;focusin&#8221;, blur: &#8220;focusout&#8221; }, function( orig, fix ) {</p>
<p>// Attach a single capturing handler while someone wants focusin/focusout<br />
var attaches = 0,<br />
handler = function( event ) {<br />
jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );<br />
};</p>
<p>jQuery.event.special[ fix ] = {<br />
setup: function() {<br />
if ( attaches++ === 0 ) {<br />
document.addEventListener( orig, handler, true );<br />
}<br />
},<br />
teardown: function() {<br />
if ( &#8211;attaches === 0 ) {<br />
document.removeEventListener( orig, handler, true );<br />
}<br />
}<br />
};<br />
});<br />
}</p>
<p>jQuery.fn.extend({</p>
<p>on: function( types, selector, data, fn, /*INTERNAL*/ one ) {<br />
var origFn, type;</p>
<p>// Types can be a map of types/handlers<br />
if ( typeof types === &#8220;object&#8221; ) {<br />
// ( types-Object, selector, data )<br />
if ( typeof selector !== &#8220;string&#8221; ) {<br />
// ( types-Object, data )<br />
data = selector;<br />
selector = undefined;<br />
}<br />
for ( type in types ) {<br />
this.on( type, selector, data, types[ type ], one );<br />
}<br />
return this;<br />
}</p>
<p>if ( data == null &amp;&amp; fn == null ) {<br />
// ( types, fn )<br />
fn = selector;<br />
data = selector = undefined;<br />
} else if ( fn == null ) {<br />
if ( typeof selector === &#8220;string&#8221; ) {<br />
// ( types, selector, fn )<br />
fn = data;<br />
data = undefined;<br />
} else {<br />
// ( types, data, fn )<br />
fn = data;<br />
data = selector;<br />
selector = undefined;<br />
}<br />
}<br />
if ( fn === false ) {<br />
fn = returnFalse;<br />
} else if ( !fn ) {<br />
return this;<br />
}</p>
<p>if ( one === 1 ) {<br />
origFn = fn;<br />
fn = function( event ) {<br />
// Can use an empty set, since event contains the info<br />
jQuery().off( event );<br />
return origFn.apply( this, arguments );<br />
};<br />
// Use same guid so caller can remove using origFn<br />
fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );<br />
}<br />
return this.each( function() {<br />
jQuery.event.add( this, types, fn, data, selector );<br />
});<br />
},<br />
one: function( types, selector, data, fn ) {<br />
return this.on.call( this, types, selector, data, fn, 1 );<br />
},<br />
off: function( types, selector, fn ) {<br />
if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {<br />
// ( event )  dispatched jQuery.Event<br />
var handleObj = types.handleObj;<br />
jQuery( types.delegateTarget ).off(<br />
handleObj.namespace? handleObj.type + &#8220;.&#8221; + handleObj.namespace : handleObj.type,<br />
handleObj.selector,<br />
handleObj.handler<br />
);<br />
return this;<br />
}<br />
if ( typeof types === &#8220;object&#8221; ) {<br />
// ( types-object [, selector] )<br />
for ( var type in types ) {<br />
this.off( type, selector, types[ type ] );<br />
}<br />
return this;<br />
}<br />
if ( selector === false || typeof selector === &#8220;function&#8221; ) {<br />
// ( types [, fn] )<br />
fn = selector;<br />
selector = undefined;<br />
}<br />
if ( fn === false ) {<br />
fn = returnFalse;<br />
}<br />
return this.each(function() {<br />
jQuery.event.remove( this, types, fn, selector );<br />
});<br />
},</p>
<p>bind: function( types, data, fn ) {<br />
return this.on( types, null, data, fn );<br />
},<br />
unbind: function( types, fn ) {<br />
return this.off( types, null, fn );<br />
},</p>
<p>live: function( types, data, fn ) {<br />
jQuery( this.context ).on( types, this.selector, data, fn );<br />
return this;<br />
},<br />
die: function( types, fn ) {<br />
jQuery( this.context ).off( types, this.selector || &#8220;**&#8221;, fn );<br />
return this;<br />
},</p>
<p>delegate: function( selector, types, data, fn ) {<br />
return this.on( types, selector, data, fn );<br />
},<br />
undelegate: function( selector, types, fn ) {<br />
// ( namespace ) or ( selector, types [, fn] )<br />
return arguments.length == 1? this.off( selector, &#8220;**&#8221; ) : this.off( types, selector, fn );<br />
},</p>
<p>trigger: function( type, data ) {<br />
return this.each(function() {<br />
jQuery.event.trigger( type, data, this );<br />
});<br />
},<br />
triggerHandler: function( type, data ) {<br />
if ( this[0] ) {<br />
return jQuery.event.trigger( type, data, this[0], true );<br />
}<br />
},</p>
<p>toggle: function( fn ) {<br />
// Save reference to arguments for access in closure<br />
var args = arguments,<br />
guid = fn.guid || jQuery.guid++,<br />
i = 0,<br />
toggler = function( event ) {<br />
// Figure out which function to execute<br />
var lastToggle = ( jQuery._data( this, &#8220;lastToggle&#8221; + fn.guid ) || 0 ) % i;<br />
jQuery._data( this, &#8220;lastToggle&#8221; + fn.guid, lastToggle + 1 );</p>
<p>// Make sure that clicks stop<br />
event.preventDefault();</p>
<p>// and execute the function<br />
return args[ lastToggle ].apply( this, arguments ) || false;<br />
};</p>
<p>// link all the functions, so any of them can unbind this click handler<br />
toggler.guid = guid;<br />
while ( i &lt; args.length ) {<br />
args[ i++ ].guid = guid;<br />
}</p>
<p>return this.click( toggler );<br />
},</p>
<p>hover: function( fnOver, fnOut ) {<br />
return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );<br />
}<br />
});</p>
<p>jQuery.each( (&#8220;blur focus focusin focusout load resize scroll unload click dblclick &#8221; +<br />
&#8220;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &#8221; +<br />
&#8220;change select submit keydown keypress keyup error contextmenu&#8221;).split(&#8221; &#8220;), function( i, name ) {</p>
<p>// Handle event binding<br />
jQuery.fn[ name ] = function( data, fn ) {<br />
if ( fn == null ) {<br />
fn = data;<br />
data = null;<br />
}</p>
<p>return arguments.length &gt; 0 ?<br />
this.bind( name, data, fn ) :<br />
this.trigger( name );<br />
};</p>
<p>if ( jQuery.attrFn ) {<br />
jQuery.attrFn[ name ] = true;<br />
}</p>
<p>if ( rkeyEvent.test( name ) ) {<br />
jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;<br />
}</p>
<p>if ( rmouseEvent.test( name ) ) {<br />
jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;<br />
}<br />
});</p>
<p>/*!<br />
* Sizzle CSS Selector Engine<br />
*  Copyright 2011, The Dojo Foundation<br />
*  Released under the MIT, BSD, and GPL Licenses.<br />
*  More information: <a href="http://sizzlejs.com/" rel="nofollow">http://sizzlejs.com/</a><br />
*/<br />
(function(){</p>
<p>var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]&#8216;&#8221;]+)+\]|\\.|[^ &gt;+~,(\[\\]+)+|[&gt;+~])(\s*,\s*)?((?:.|\r|\n)*)/g,<br />
expando = &#8220;sizcache&#8221; + (Math.random() + &#8221;).replace(&#8216;.&#8217;, &#8221;),<br />
done = 0,<br />
toString = Object.prototype.toString,<br />
hasDuplicate = false,<br />
baseHasDuplicate = true,<br />
rBackslash = /\\/g,<br />
rReturn = /\r\n/g,<br />
rNonWord = /\W/;</p>
<p>// Here we check if the JavaScript engine is using some sort of<br />
// optimization where it does not always call our comparision<br />
// function. If that is the case, discard the hasDuplicate value.<br />
//   Thus far that includes Google Chrome.<br />
[0, 0].sort(function() {<br />
baseHasDuplicate = false;<br />
return 0;<br />
});</p>
<p>var Sizzle = function( selector, context, results, seed ) {<br />
results = results || [];<br />
context = context || document;</p>
<p>var origContext = context;</p>
<p>if ( context.nodeType !== 1 &amp;&amp; context.nodeType !== 9 ) {<br />
return [];<br />
}</p>
<p>if ( !selector || typeof selector !== &#8220;string&#8221; ) {<br />
return results;<br />
}</p>
<p>var m, set, checkSet, extra, ret, cur, pop, i,<br />
prune = true,<br />
contextXML = Sizzle.isXML( context ),<br />
parts = [],<br />
soFar = selector;</p>
<p>// Reset the position of the chunker regexp (start from head)<br />
do {<br />
chunker.exec( &#8220;&#8221; );<br />
m = chunker.exec( soFar );</p>
<p>if ( m ) {<br />
soFar = m[3];</p>
<p>parts.push( m[1] );</p>
<p>if ( m[2] ) {<br />
extra = m[3];<br />
break;<br />
}<br />
}<br />
} while ( m );</p>
<p>if ( parts.length &gt; 1 &amp;&amp; origPOS.exec( selector ) ) {</p>
<p>if ( parts.length === 2 &amp;&amp; Expr.relative[ parts[0] ] ) {<br />
set = posProcess( parts[0] + parts[1], context, seed );</p>
<p>} else {<br />
set = Expr.relative[ parts[0] ] ?<br />
[ context ] :<br />
Sizzle( parts.shift(), context );</p>
<p>while ( parts.length ) {<br />
selector = parts.shift();</p>
<p>if ( Expr.relative[ selector ] ) {<br />
selector += parts.shift();<br />
}</p>
<p>set = posProcess( selector, set, seed );<br />
}<br />
}</p>
<p>} else {<br />
// Take a shortcut and set the context if the root selector is an ID<br />
// (but not if it&#8217;ll be faster if the inner selector is an ID)<br />
if ( !seed &amp;&amp; parts.length &gt; 1 &amp;&amp; context.nodeType === 9 &amp;&amp; !contextXML &amp;&amp;<br />
Expr.match.ID.test(parts[0]) &amp;&amp; !Expr.match.ID.test(parts[parts.length - 1]) ) {</p>
<p>ret = Sizzle.find( parts.shift(), context, contextXML );<br />
context = ret.expr ?<br />
Sizzle.filter( ret.expr, ret.set )[0] :<br />
ret.set[0];<br />
}</p>
<p>if ( context ) {<br />
ret = seed ?<br />
{ expr: parts.pop(), set: makeArray(seed) } :<br />
Sizzle.find( parts.pop(), parts.length === 1 &amp;&amp; (parts[0] === &#8220;~&#8221; || parts[0] === &#8220;+&#8221;) &amp;&amp; context.parentNode ? context.parentNode : context, contextXML );</p>
<p>set = ret.expr ?<br />
Sizzle.filter( ret.expr, ret.set ) :<br />
ret.set;</p>
<p>if ( parts.length &gt; 0 ) {<br />
checkSet = makeArray( set );</p>
<p>} else {<br />
prune = false;<br />
}</p>
<p>while ( parts.length ) {<br />
cur = parts.pop();<br />
pop = cur;</p>
<p>if ( !Expr.relative[ cur ] ) {<br />
cur = &#8220;&#8221;;<br />
} else {<br />
pop = parts.pop();<br />
}</p>
<p>if ( pop == null ) {<br />
pop = context;<br />
}</p>
<p>Expr.relative[ cur ]( checkSet, pop, contextXML );<br />
}</p>
<p>} else {<br />
checkSet = parts = [];<br />
}<br />
}</p>
<p>if ( !checkSet ) {<br />
checkSet = set;<br />
}</p>
<p>if ( !checkSet ) {<br />
Sizzle.error( cur || selector );<br />
}</p>
<p>if ( toString.call(checkSet) === &#8220;[object Array]&#8221; ) {<br />
if ( !prune ) {<br />
results.push.apply( results, checkSet );</p>
<p>} else if ( context &amp;&amp; context.nodeType === 1 ) {<br />
for ( i = 0; checkSet[i] != null; i++ ) {<br />
if ( checkSet[i] &amp;&amp; (checkSet[i] === true || checkSet[i].nodeType === 1 &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {<br />
results.push( set[i] );<br />
}<br />
}</p>
<p>} else {<br />
for ( i = 0; checkSet[i] != null; i++ ) {<br />
if ( checkSet[i] &amp;&amp; checkSet[i].nodeType === 1 ) {<br />
results.push( set[i] );<br />
}<br />
}<br />
}</p>
<p>} else {<br />
makeArray( checkSet, results );<br />
}</p>
<p>if ( extra ) {<br />
Sizzle( extra, origContext, results, seed );<br />
Sizzle.uniqueSort( results );<br />
}</p>
<p>return results;<br />
};</p>
<p>Sizzle.uniqueSort = function( results ) {<br />
if ( sortOrder ) {<br />
hasDuplicate = baseHasDuplicate;<br />
results.sort( sortOrder );</p>
<p>if ( hasDuplicate ) {<br />
for ( var i = 1; i &lt; results.length; i++ ) {<br />
if ( results[i] === results[ i - 1 ] ) {<br />
results.splice( i&#8211;, 1 );<br />
}<br />
}<br />
}<br />
}</p>
<p>return results;<br />
};</p>
<p>Sizzle.matches = function( expr, set ) {<br />
return Sizzle( expr, null, null, set );<br />
};</p>
<p>Sizzle.matchesSelector = function( node, expr ) {<br />
return Sizzle( expr, null, null, [node] ).length &gt; 0;<br />
};</p>
<p>Sizzle.find = function( expr, context, isXML ) {<br />
var set, i, len, match, type, left;</p>
<p>if ( !expr ) {<br />
return [];<br />
}</p>
<p>for ( i = 0, len = Expr.order.length; i &lt; len; i++ ) {<br />
type = Expr.order[i];</p>
<p>if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {<br />
left = match[1];<br />
match.splice( 1, 1 );</p>
<p>if ( left.substr( left.length &#8211; 1 ) !== &#8220;\\&#8221; ) {<br />
match[1] = (match[1] || &#8220;&#8221;).replace( rBackslash, &#8220;&#8221; );<br />
set = Expr.find[ type ]( match, context, isXML );</p>
<p>if ( set != null ) {<br />
expr = expr.replace( Expr.match[ type ], &#8220;&#8221; );<br />
break;<br />
}<br />
}<br />
}<br />
}</p>
<p>if ( !set ) {<br />
set = typeof context.getElementsByTagName !== &#8220;undefined&#8221; ?<br />
context.getElementsByTagName( &#8220;*&#8221; ) :<br />
[];<br />
}</p>
<p>return { set: set, expr: expr };<br />
};</p>
<p>Sizzle.filter = function( expr, set, inplace, not ) {<br />
var match, anyFound,<br />
type, found, item, filter, left,<br />
i, pass,<br />
old = expr,<br />
result = [],<br />
curLoop = set,<br />
isXMLFilter = set &amp;&amp; set[0] &amp;&amp; Sizzle.isXML( set[0] );</p>
<p>while ( expr &amp;&amp; set.length ) {<br />
for ( type in Expr.filter ) {<br />
if ( (match = Expr.leftMatch[ type ].exec( expr )) != null &amp;&amp; match[2] ) {<br />
filter = Expr.filter[ type ];<br />
left = match[1];</p>
<p>anyFound = false;</p>
<p>match.splice(1,1);</p>
<p>if ( left.substr( left.length &#8211; 1 ) === &#8220;\\&#8221; ) {<br />
continue;<br />
}</p>
<p>if ( curLoop === result ) {<br />
result = [];<br />
}</p>
<p>if ( Expr.preFilter[ type ] ) {<br />
match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );</p>
<p>if ( !match ) {<br />
anyFound = found = true;</p>
<p>} else if ( match === true ) {<br />
continue;<br />
}<br />
}</p>
<p>if ( match ) {<br />
for ( i = 0; (item = curLoop[i]) != null; i++ ) {<br />
if ( item ) {<br />
found = filter( item, match, i, curLoop );<br />
pass = not ^ found;</p>
<p>if ( inplace &amp;&amp; found != null ) {<br />
if ( pass ) {<br />
anyFound = true;</p>
<p>} else {<br />
curLoop[i] = false;<br />
}</p>
<p>} else if ( pass ) {<br />
result.push( item );<br />
anyFound = true;<br />
}<br />
}<br />
}<br />
}</p>
<p>if ( found !== undefined ) {<br />
if ( !inplace ) {<br />
curLoop = result;<br />
}</p>
<p>expr = expr.replace( Expr.match[ type ], &#8220;&#8221; );</p>
<p>if ( !anyFound ) {<br />
return [];<br />
}</p>
<p>break;<br />
}<br />
}<br />
}</p>
<p>// Improper expression<br />
if ( expr === old ) {<br />
if ( anyFound == null ) {<br />
Sizzle.error( expr );</p>
<p>} else {<br />
break;<br />
}<br />
}</p>
<p>old = expr;<br />
}</p>
<p>return curLoop;<br />
};</p>
<p>Sizzle.error = function( msg ) {<br />
throw &#8220;Syntax error, unrecognized expression: &#8221; + msg;<br />
};</p>
<p>/**<br />
* Utility function for retreiving the text value of an array of DOM nodes<br />
* @param {Array|Element} elem<br />
*/<br />
var getText = Sizzle.getText = function( elem ) {<br />
var i, node,<br />
nodeType = elem.nodeType,<br />
ret = &#8220;&#8221;;</p>
<p>if ( nodeType ) {<br />
if ( nodeType === 1 ) {<br />
// Use textContent || innerText for elements<br />
if ( typeof elem.textContent === &#8216;string&#8217; ) {<br />
return elem.textContent;<br />
} else if ( typeof elem.innerText === &#8216;string&#8217; ) {<br />
// Replace IE&#8217;s carriage returns<br />
return elem.innerText.replace( rReturn, &#8221; );<br />
} else {<br />
// Traverse it&#8217;s children<br />
for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {<br />
ret += getText( elem );<br />
}<br />
}<br />
} else if ( nodeType === 3 || nodeType === 4 ) {<br />
return elem.nodeValue;<br />
}<br />
} else {</p>
<p>// If no nodeType, this is expected to be an array<br />
for ( i = 0; (node = elem[i]); i++ ) {<br />
// Do not traverse comment nodes<br />
if ( node.nodeType !== 8 ) {<br />
ret += getText( node );<br />
}<br />
}<br />
}<br />
return ret;<br />
};</p>
<p>var Expr = Sizzle.selectors = {<br />
order: [ "ID", "NAME", "TAG" ],</p>
<p>match: {<br />
ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,<br />
CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,<br />
NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,<br />
ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,<br />
TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,<br />
CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,<br />
POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,<br />
PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/<br />
},</p>
<p>leftMatch: {},</p>
<p>attrMap: {<br />
&#8220;class&#8221;: &#8220;className&#8221;,<br />
&#8220;for&#8221;: &#8220;htmlFor&#8221;<br />
},</p>
<p>attrHandle: {<br />
href: function( elem ) {<br />
return elem.getAttribute( &#8220;href&#8221; );<br />
},<br />
type: function( elem ) {<br />
return elem.getAttribute( &#8220;type&#8221; );<br />
}<br />
},</p>
<p>relative: {<br />
&#8220;+&#8221;: function(checkSet, part){<br />
var isPartStr = typeof part === &#8220;string&#8221;,<br />
isTag = isPartStr &amp;&amp; !rNonWord.test( part ),<br />
isPartStrNotTag = isPartStr &amp;&amp; !isTag;</p>
<p>if ( isTag ) {<br />
part = part.toLowerCase();<br />
}</p>
<p>for ( var i = 0, l = checkSet.length, elem; i &lt; l; i++ ) {<br />
if ( (elem = checkSet[i]) ) {<br />
while ( (elem = elem.previousSibling) &amp;&amp; elem.nodeType !== 1 ) {}</p>
<p>checkSet[i] = isPartStrNotTag || elem &amp;&amp; elem.nodeName.toLowerCase() === part ?<br />
elem || false :<br />
elem === part;<br />
}<br />
}</p>
<p>if ( isPartStrNotTag ) {<br />
Sizzle.filter( part, checkSet, true );<br />
}<br />
},</p>
<p>&#8220;&gt;&#8221;: function( checkSet, part ) {<br />
var elem,<br />
isPartStr = typeof part === &#8220;string&#8221;,<br />
i = 0,<br />
l = checkSet.length;</p>
<p>if ( isPartStr &amp;&amp; !rNonWord.test( part ) ) {<br />
part = part.toLowerCase();</p>
<p>for ( ; i &lt; l; i++ ) {<br />
elem = checkSet[i];</p>
<p>if ( elem ) {<br />
var parent = elem.parentNode;<br />
checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;<br />
}<br />
}</p>
<p>} else {<br />
for ( ; i &lt; l; i++ ) {<br />
elem = checkSet[i];</p>
<p>if ( elem ) {<br />
checkSet[i] = isPartStr ?<br />
elem.parentNode :<br />
elem.parentNode === part;<br />
}<br />
}</p>
<p>if ( isPartStr ) {<br />
Sizzle.filter( part, checkSet, true );<br />
}<br />
}<br />
},</p>
<p>&#8220;&#8221;: function(checkSet, part, isXML){<br />
var nodeCheck,<br />
doneName = done++,<br />
checkFn = dirCheck;</p>
<p>if ( typeof part === &#8220;string&#8221; &amp;&amp; !rNonWord.test( part ) ) {<br />
part = part.toLowerCase();<br />
nodeCheck = part;<br />
checkFn = dirNodeCheck;<br />
}</p>
<p>checkFn( &#8220;parentNode&#8221;, part, doneName, checkSet, nodeCheck, isXML );<br />
},</p>
<p>&#8220;~&#8221;: function( checkSet, part, isXML ) {<br />
var nodeCheck,<br />
doneName = done++,<br />
checkFn = dirCheck;</p>
<p>if ( typeof part === &#8220;string&#8221; &amp;&amp; !rNonWord.test( part ) ) {<br />
part = part.toLowerCase();<br />
nodeCheck = part;<br />
checkFn = dirNodeCheck;<br />
}</p>
<p>checkFn( &#8220;previousSibling&#8221;, part, doneName, checkSet, nodeCheck, isXML );<br />
}<br />
},</p>
<p>find: {<br />
ID: function( match, context, isXML ) {<br />
if ( typeof context.getElementById !== &#8220;undefined&#8221; &amp;&amp; !isXML ) {<br />
var m = context.getElementById(match[1]);<br />
// Check parentNode to catch when Blackberry 4.6 returns<br />
// nodes that are no longer in the document #6963<br />
return m &amp;&amp; m.parentNode ? [m] : [];<br />
}<br />
},</p>
<p>NAME: function( match, context ) {<br />
if ( typeof context.getElementsByName !== &#8220;undefined&#8221; ) {<br />
var ret = [],<br />
results = context.getElementsByName( match[1] );</p>
<p>for ( var i = 0, l = results.length; i &lt; l; i++ ) {<br />
if ( results[i].getAttribute(&#8220;name&#8221;) === match[1] ) {<br />
ret.push( results[i] );<br />
}<br />
}</p>
<p>return ret.length === 0 ? null : ret;<br />
}<br />
},</p>
<p>TAG: function( match, context ) {<br />
if ( typeof context.getElementsByTagName !== &#8220;undefined&#8221; ) {<br />
return context.getElementsByTagName( match[1] );<br />
}<br />
}<br />
},<br />
preFilter: {<br />
CLASS: function( match, curLoop, inplace, result, not, isXML ) {<br />
match = &#8221; &#8221; + match[1].replace( rBackslash, &#8220;&#8221; ) + &#8221; &#8220;;</p>
<p>if ( isXML ) {<br />
return match;<br />
}</p>
<p>for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {<br />
if ( elem ) {<br />
if ( not ^ (elem.className &amp;&amp; (&#8221; &#8221; + elem.className + &#8221; &#8220;).replace(/[\t\n\r]/g, &#8221; &#8220;).indexOf(match) &gt;= 0) ) {<br />
if ( !inplace ) {<br />
result.push( elem );<br />
}</p>
<p>} else if ( inplace ) {<br />
curLoop[i] = false;<br />
}<br />
}<br />
}</p>
<p>return false;<br />
},</p>
<p>ID: function( match ) {<br />
return match[1].replace( rBackslash, &#8220;&#8221; );<br />
},</p>
<p>TAG: function( match, curLoop ) {<br />
return match[1].replace( rBackslash, &#8220;&#8221; ).toLowerCase();<br />
},</p>
<p>CHILD: function( match ) {<br />
if ( match[1] === &#8220;nth&#8221; ) {<br />
if ( !match[2] ) {<br />
Sizzle.error( match[0] );<br />
}</p>
<p>match[2] = match[2].replace(/^\+|\s*/g, &#8221;);</p>
<p>// parse equations like &#8216;even&#8217;, &#8216;odd&#8217;, &#8217;5&#8242;, &#8217;2n&#8217;, &#8217;3n+2&#8242;, &#8217;4n-1&#8242;, &#8216;-n+6&#8242;<br />
var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(<br />
match[2] === &#8220;even&#8221; &amp;&amp; &#8220;2n&#8221; || match[2] === &#8220;odd&#8221; &amp;&amp; &#8220;2n+1&#8243; ||<br />
!/\D/.test( match[2] ) &amp;&amp; &#8220;0n+&#8221; + match[2] || match[2]);</p>
<p>// calculate the numbers (first)n+(last) including if they are negative<br />
match[2] = (test[1] + (test[2] || 1)) &#8211; 0;<br />
match[3] = test[3] &#8211; 0;<br />
}<br />
else if ( match[2] ) {<br />
Sizzle.error( match[0] );<br />
}</p>
<p>// TODO: Move to normal caching system<br />
match[0] = done++;</p>
<p>return match;<br />
},</p>
<p>ATTR: function( match, curLoop, inplace, result, not, isXML ) {<br />
var name = match[1] = match[1].replace( rBackslash, &#8220;&#8221; );</p>
<p>if ( !isXML &amp;&amp; Expr.attrMap[name] ) {<br />
match[1] = Expr.attrMap[name];<br />
}</p>
<p>// Handle if an un-quoted value was used<br />
match[4] = ( match[4] || match[5] || &#8220;&#8221; ).replace( rBackslash, &#8220;&#8221; );</p>
<p>if ( match[2] === &#8220;~=&#8221; ) {<br />
match[4] = &#8221; &#8221; + match[4] + &#8221; &#8220;;<br />
}</p>
<p>return match;<br />
},</p>
<p>PSEUDO: function( match, curLoop, inplace, result, not ) {<br />
if ( match[1] === &#8220;not&#8221; ) {<br />
// If we&#8217;re dealing with a complex expression, or a simple one<br />
if ( ( chunker.exec(match[3]) || &#8220;&#8221; ).length &gt; 1 || /^\w/.test(match[3]) ) {<br />
match[3] = Sizzle(match[3], null, null, curLoop);</p>
<p>} else {<br />
var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);</p>
<p>if ( !inplace ) {<br />
result.push.apply( result, ret );<br />
}</p>
<p>return false;<br />
}</p>
<p>} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {<br />
return true;<br />
}</p>
<p>return match;<br />
},</p>
<p>POS: function( match ) {<br />
match.unshift( true );</p>
<p>return match;<br />
}<br />
},</p>
<p>filters: {<br />
enabled: function( elem ) {<br />
return elem.disabled === false &amp;&amp; elem.type !== &#8220;hidden&#8221;;<br />
},</p>
<p>disabled: function( elem ) {<br />
return elem.disabled === true;<br />
},</p>
<p>checked: function( elem ) {<br />
return elem.checked === true;<br />
},</p>
<p>selected: function( elem ) {<br />
// Accessing this property makes selected-by-default<br />
// options in Safari work properly<br />
if ( elem.parentNode ) {<br />
elem.parentNode.selectedIndex;<br />
}</p>
<p>return elem.selected === true;<br />
},</p>
<p>parent: function( elem ) {<br />
return !!elem.firstChild;<br />
},</p>
<p>empty: function( elem ) {<br />
return !elem.firstChild;<br />
},</p>
<p>has: function( elem, i, match ) {<br />
return !!Sizzle( match[3], elem ).length;<br />
},</p>
<p>header: function( elem ) {<br />
return (/h\d/i).test( elem.nodeName );<br />
},</p>
<p>text: function( elem ) {<br />
var attr = elem.getAttribute( &#8220;type&#8221; ), type = elem.type;<br />
// IE6 and 7 will map elem.type to &#8216;text&#8217; for new HTML5 types (search, etc)<br />
// use getAttribute instead to test this case<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;text&#8221; === type &amp;&amp; ( attr === type || attr === null );<br />
},</p>
<p>radio: function( elem ) {<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;radio&#8221; === elem.type;<br />
},</p>
<p>checkbox: function( elem ) {<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;checkbox&#8221; === elem.type;<br />
},</p>
<p>file: function( elem ) {<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;file&#8221; === elem.type;<br />
},</p>
<p>password: function( elem ) {<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;password&#8221; === elem.type;<br />
},</p>
<p>submit: function( elem ) {<br />
var name = elem.nodeName.toLowerCase();<br />
return (name === &#8220;input&#8221; || name === &#8220;button&#8221;) &amp;&amp; &#8220;submit&#8221; === elem.type;<br />
},</p>
<p>image: function( elem ) {<br />
return elem.nodeName.toLowerCase() === &#8220;input&#8221; &amp;&amp; &#8220;image&#8221; === elem.type;<br />
},</p>
<p>reset: function( elem ) {<br />
var name = elem.nodeName.toLowerCase();<br />
return (name === &#8220;input&#8221; || name === &#8220;button&#8221;) &amp;&amp; &#8220;reset&#8221; === elem.type;<br />
},</p>
<p>button: function( elem ) {<br />
var name = elem.nodeName.toLowerCase();<br />
return name === &#8220;input&#8221; &amp;&amp; &#8220;button&#8221; === elem.type || name === &#8220;button&#8221;;<br />
},</p>
<p>input: function( elem ) {<br />
return (/input|select|textarea|button/i).test( elem.nodeName );<br />
},</p>
<p>focus: function( elem ) {<br />
return elem === elem.ownerDocument.activeElement;<br />
}<br />
},<br />
setFilters: {<br />
first: function( elem, i ) {<br />
return i === 0;<br />
},</p>
<p>last: function( elem, i, match, array ) {<br />
return i === array.length &#8211; 1;<br />
},</p>
<p>even: function( elem, i ) {<br />
return i % 2 === 0;<br />
},</p>
<p>odd: function( elem, i ) {<br />
return i % 2 === 1;<br />
},</p>
<p>lt: function( elem, i, match ) {<br />
return i &lt; match[3] &#8211; 0;<br />
},</p>
<p>gt: function( elem, i, match ) {<br />
return i &gt; match[3] &#8211; 0;<br />
},</p>
<p>nth: function( elem, i, match ) {<br />
return match[3] &#8211; 0 === i;<br />
},</p>
<p>eq: function( elem, i, match ) {<br />
return match[3] &#8211; 0 === i;<br />
}<br />
},<br />
filter: {<br />
PSEUDO: function( elem, match, i, array ) {<br />
var name = match[1],<br />
filter = Expr.filters[ name ];</p>
<p>if ( filter ) {<br />
return filter( elem, i, match, array );</p>
<p>} else if ( name === &#8220;contains&#8221; ) {<br />
return (elem.textContent || elem.innerText || getText([ elem ]) || &#8220;&#8221;).indexOf(match[3]) &gt;= 0;</p>
<p>} else if ( name === &#8220;not&#8221; ) {<br />
var not = match[3];</p>
<p>for ( var j = 0, l = not.length; j &lt; l; j++ ) {<br />
if ( not[j] === elem ) {<br />
return false;<br />
}<br />
}</p>
<p>return true;</p>
<p>} else {<br />
Sizzle.error( name );<br />
}<br />
},</p>
<p>CHILD: function( elem, match ) {<br />
var first, last,<br />
doneName, parent, cache,<br />
count, diff,<br />
type = match[1],<br />
node = elem;</p>
<p>switch ( type ) {<br />
case &#8220;only&#8221;:<br />
case &#8220;first&#8221;:<br />
while ( (node = node.previousSibling) )     {<br />
if ( node.nodeType === 1 ) {<br />
return false;<br />
}<br />
}</p>
<p>if ( type === &#8220;first&#8221; ) {<br />
return true;<br />
}</p>
<p>node = elem;</p>
<p>case &#8220;last&#8221;:<br />
while ( (node = node.nextSibling) )     {<br />
if ( node.nodeType === 1 ) {<br />
return false;<br />
}<br />
}</p>
<p>return true;</p>
<p>case &#8220;nth&#8221;:<br />
first = match[2];<br />
last = match[3];</p>
<p>if ( first === 1 &amp;&amp; last === 0 ) {<br />
return true;<br />
}</p>
<p>doneName = match[0];<br />
parent = elem.parentNode;</p>
<p>if ( parent &amp;&amp; (parent[ expando ] !== doneName || !elem.nodeIndex) ) {<br />
count = 0;</p>
<p>for ( node = parent.firstChild; node; node = node.nextSibling ) {<br />
if ( node.nodeType === 1 ) {<br />
node.nodeIndex = ++count;<br />
}<br />
}</p>
<p>parent[ expando ] = doneName;<br />
}</p>
<p>diff = elem.nodeIndex &#8211; last;</p>
<p>if ( first === 0 ) {<br />
return diff === 0;</p>
<p>} else {<br />
return ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );<br />
}<br />
}<br />
},</p>
<p>ID: function( elem, match ) {<br />
return elem.nodeType === 1 &amp;&amp; elem.getAttribute(&#8220;id&#8221;) === match;<br />
},</p>
<p>TAG: function( elem, match ) {<br />
return (match === &#8220;*&#8221; &amp;&amp; elem.nodeType === 1) || !!elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === match;<br />
},</p>
<p>CLASS: function( elem, match ) {<br />
return (&#8221; &#8221; + (elem.className || elem.getAttribute(&#8220;class&#8221;)) + &#8221; &#8220;)<br />
.indexOf( match ) &gt; -1;<br />
},</p>
<p>ATTR: function( elem, match ) {<br />
var name = match[1],<br />
result = Sizzle.attr ?<br />
Sizzle.attr( elem, name ) :<br />
Expr.attrHandle[ name ] ?<br />
Expr.attrHandle[ name ]( elem ) :<br />
elem[ name ] != null ?<br />
elem[ name ] :<br />
elem.getAttribute( name ),<br />
value = result + &#8220;&#8221;,<br />
type = match[2],<br />
check = match[4];</p>
<p>return result == null ?<br />
type === &#8220;!=&#8221; :<br />
!type &amp;&amp; Sizzle.attr ?<br />
result != null :<br />
type === &#8220;=&#8221; ?<br />
value === check :<br />
type === &#8220;*=&#8221; ?<br />
value.indexOf(check) &gt;= 0 :<br />
type === &#8220;~=&#8221; ?<br />
(&#8221; &#8221; + value + &#8221; &#8220;).indexOf(check) &gt;= 0 :<br />
!check ?<br />
value &amp;&amp; result !== false :<br />
type === &#8220;!=&#8221; ?<br />
value !== check :<br />
type === &#8220;^=&#8221; ?<br />
value.indexOf(check) === 0 :<br />
type === &#8220;$=&#8221; ?<br />
value.substr(value.length &#8211; check.length) === check :<br />
type === &#8220;|=&#8221; ?<br />
value === check || value.substr(0, check.length + 1) === check + &#8220;-&#8221; :<br />
false;<br />
},</p>
<p>POS: function( elem, match, i, array ) {<br />
var name = match[2],<br />
filter = Expr.setFilters[ name ];</p>
<p>if ( filter ) {<br />
return filter( elem, i, match, array );<br />
}<br />
}<br />
}<br />
};</p>
<p>var origPOS = Expr.match.POS,<br />
fescape = function(all, num){<br />
return &#8220;\\&#8221; + (num &#8211; 0 + 1);<br />
};</p>
<p>for ( var type in Expr.match ) {<br />
Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );<br />
Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );<br />
}</p>
<p>var makeArray = function( array, results ) {<br />
array = Array.prototype.slice.call( array, 0 );</p>
<p>if ( results ) {<br />
results.push.apply( results, array );<br />
return results;<br />
}</p>
<p>return array;<br />
};</p>
<p>// Perform a simple check to determine if the browser is capable of<br />
// converting a NodeList to an array using builtin methods.<br />
// Also verifies that the returned array holds DOM nodes<br />
// (which is not the case in the Blackberry browser)<br />
try {<br />
Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;</p>
<p>// Provide a fallback method if it does not work<br />
} catch( e ) {<br />
makeArray = function( array, results ) {<br />
var i = 0,<br />
ret = results || [];</p>
<p>if ( toString.call(array) === &#8220;[object Array]&#8221; ) {<br />
Array.prototype.push.apply( ret, array );</p>
<p>} else {<br />
if ( typeof array.length === &#8220;number&#8221; ) {<br />
for ( var l = array.length; i &lt; l; i++ ) {<br />
ret.push( array[i] );<br />
}</p>
<p>} else {<br />
for ( ; array[i]; i++ ) {<br />
ret.push( array[i] );<br />
}<br />
}<br />
}</p>
<p>return ret;<br />
};<br />
}</p>
<p>var sortOrder, siblingCheck;</p>
<p>if ( document.documentElement.compareDocumentPosition ) {<br />
sortOrder = function( a, b ) {<br />
if ( a === b ) {<br />
hasDuplicate = true;<br />
return 0;<br />
}</p>
<p>if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {<br />
return a.compareDocumentPosition ? -1 : 1;<br />
}</p>
<p>return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1;<br />
};</p>
<p>} else {<br />
sortOrder = function( a, b ) {<br />
// The nodes are identical, we can exit early<br />
if ( a === b ) {<br />
hasDuplicate = true;<br />
return 0;</p>
<p>// Fallback to using sourceIndex (in IE) if it&#8217;s available on both nodes<br />
} else if ( a.sourceIndex &amp;&amp; b.sourceIndex ) {<br />
return a.sourceIndex &#8211; b.sourceIndex;<br />
}</p>
<p>var al, bl,<br />
ap = [],<br />
bp = [],<br />
aup = a.parentNode,<br />
bup = b.parentNode,<br />
cur = aup;</p>
<p>// If the nodes are siblings (or identical) we can do a quick check<br />
if ( aup === bup ) {<br />
return siblingCheck( a, b );</p>
<p>// If no parents were found then the nodes are disconnected<br />
} else if ( !aup ) {<br />
return -1;</p>
<p>} else if ( !bup ) {<br />
return 1;<br />
}</p>
<p>// Otherwise they&#8217;re somewhere else in the tree so we need<br />
// to build up a full list of the parentNodes for comparison<br />
while ( cur ) {<br />
ap.unshift( cur );<br />
cur = cur.parentNode;<br />
}</p>
<p>cur = bup;</p>
<p>while ( cur ) {<br />
bp.unshift( cur );<br />
cur = cur.parentNode;<br />
}</p>
<p>al = ap.length;<br />
bl = bp.length;</p>
<p>// Start walking down the tree looking for a discrepancy<br />
for ( var i = 0; i &lt; al &amp;&amp; i &lt; bl; i++ ) {<br />
if ( ap[i] !== bp[i] ) {<br />
return siblingCheck( ap[i], bp[i] );<br />
}<br />
}</p>
<p>// We ended someplace up the tree so do a sibling check<br />
return i === al ?<br />
siblingCheck( a, bp[i], -1 ) :<br />
siblingCheck( ap[i], b, 1 );<br />
};</p>
<p>siblingCheck = function( a, b, ret ) {<br />
if ( a === b ) {<br />
return ret;<br />
}</p>
<p>var cur = a.nextSibling;</p>
<p>while ( cur ) {<br />
if ( cur === b ) {<br />
return -1;<br />
}</p>
<p>cur = cur.nextSibling;<br />
}</p>
<p>return 1;<br />
};<br />
}</p>
<p>// Check to see if the browser returns elements by name when<br />
// querying by getElementById (and provide a workaround)<br />
(function(){<br />
// We&#8217;re going to inject a fake input element with a specified name<br />
var form = document.createElement(&#8220;div&#8221;),<br />
id = &#8220;script&#8221; + (new Date()).getTime(),<br />
root = document.documentElement;</p>
<p>form.innerHTML = &#8220;&lt;a name=&#8217;&#8221; + id + &#8220;&#8216;/&gt;&#8221;;</p>
<p>// Inject it into the root element, check its status, and remove it quickly<br />
root.insertBefore( form, root.firstChild );</p>
<p>// The workaround has to do additional checks after a getElementById<br />
// Which slows things down for other browsers (hence the branching)<br />
if ( document.getElementById( id ) ) {<br />
Expr.find.ID = function( match, context, isXML ) {<br />
if ( typeof context.getElementById !== &#8220;undefined&#8221; &amp;&amp; !isXML ) {<br />
var m = context.getElementById(match[1]);</p>
<p>return m ?<br />
m.id === match[1] || typeof m.getAttributeNode !== &#8220;undefined&#8221; &amp;&amp; m.getAttributeNode(&#8220;id&#8221;).nodeValue === match[1] ?<br />
[m] :<br />
undefined :<br />
[];<br />
}<br />
};</p>
<p>Expr.filter.ID = function( elem, match ) {<br />
var node = typeof elem.getAttributeNode !== &#8220;undefined&#8221; &amp;&amp; elem.getAttributeNode(&#8220;id&#8221;);</p>
<p>return elem.nodeType === 1 &amp;&amp; node &amp;&amp; node.nodeValue === match;<br />
};<br />
}</p>
<p>root.removeChild( form );</p>
<p>// release memory in IE<br />
root = form = null;<br />
})();</p>
<p>(function(){<br />
// Check to see if the browser returns only elements<br />
// when doing getElementsByTagName(&#8220;*&#8221;)</p>
<p>// Create a fake element<br />
var div = document.createElement(&#8220;div&#8221;);<br />
div.appendChild( document.createComment(&#8220;&#8221;) );</p>
<p>// Make sure no comments are found<br />
if ( div.getElementsByTagName(&#8220;*&#8221;).length &gt; 0 ) {<br />
Expr.find.TAG = function( match, context ) {<br />
var results = context.getElementsByTagName( match[1] );</p>
<p>// Filter out possible comments<br />
if ( match[1] === &#8220;*&#8221; ) {<br />
var tmp = [];</p>
<p>for ( var i = 0; results[i]; i++ ) {<br />
if ( results[i].nodeType === 1 ) {<br />
tmp.push( results[i] );<br />
}<br />
}</p>
<p>results = tmp;<br />
}</p>
<p>return results;<br />
};<br />
}</p>
<p>// Check to see if an attribute returns normalized href attributes<br />
div.innerHTML = &#8220;&lt;a href=&#8217;#'&gt;&lt;/a&gt;&#8221;;</p>
<p>if ( div.firstChild &amp;&amp; typeof div.firstChild.getAttribute !== &#8220;undefined&#8221; &amp;&amp;<br />
div.firstChild.getAttribute(&#8220;href&#8221;) !== &#8220;#&#8221; ) {</p>
<p>Expr.attrHandle.href = function( elem ) {<br />
return elem.getAttribute( &#8220;href&#8221;, 2 );<br />
};<br />
}</p>
<p>// release memory in IE<br />
div = null;<br />
})();</p>
<p>if ( document.querySelectorAll ) {<br />
(function(){<br />
var oldSizzle = Sizzle,<br />
div = document.createElement(&#8220;div&#8221;),<br />
id = &#8220;__sizzle__&#8221;;</p>
<p>div.innerHTML = &#8220;&lt;p class=&#8217;TEST&#8217;&gt;&lt;/p&gt;&#8221;;</p>
<p>// Safari can&#8217;t handle uppercase or unicode characters when<br />
// in quirks mode.<br />
if ( div.querySelectorAll &amp;&amp; div.querySelectorAll(&#8220;.TEST&#8221;).length === 0 ) {<br />
return;<br />
}</p>
<p>Sizzle = function( query, context, extra, seed ) {<br />
context = context || document;</p>
<p>// Only use querySelectorAll on non-XML documents<br />
// (ID selectors don&#8217;t work in non-HTML documents)<br />
if ( !seed &amp;&amp; !Sizzle.isXML(context) ) {<br />
// See if we find a selector to speed up<br />
var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );</p>
<p>if ( match &amp;&amp; (context.nodeType === 1 || context.nodeType === 9) ) {<br />
// Speed-up: Sizzle(&#8220;TAG&#8221;)<br />
if ( match[1] ) {<br />
return makeArray( context.getElementsByTagName( query ), extra );</p>
<p>// Speed-up: Sizzle(&#8220;.CLASS&#8221;)<br />
} else if ( match[2] &amp;&amp; Expr.find.CLASS &amp;&amp; context.getElementsByClassName ) {<br />
return makeArray( context.getElementsByClassName( match[2] ), extra );<br />
}<br />
}</p>
<p>if ( context.nodeType === 9 ) {<br />
// Speed-up: Sizzle(&#8220;body&#8221;)<br />
// The body element only exists once, optimize finding it<br />
if ( query === &#8220;body&#8221; &amp;&amp; context.body ) {<br />
return makeArray( [ context.body ], extra );</p>
<p>// Speed-up: Sizzle(&#8220;#ID&#8221;)<br />
} else if ( match &amp;&amp; match[3] ) {<br />
var elem = context.getElementById( match[3] );</p>
<p>// Check parentNode to catch when Blackberry 4.6 returns<br />
// nodes that are no longer in the document #6963<br />
if ( elem &amp;&amp; elem.parentNode ) {<br />
// Handle the case where IE and Opera return items<br />
// by name instead of ID<br />
if ( elem.id === match[3] ) {<br />
return makeArray( [ elem ], extra );<br />
}</p>
<p>} else {<br />
return makeArray( [], extra );<br />
}<br />
}</p>
<p>try {<br />
return makeArray( context.querySelectorAll(query), extra );<br />
} catch(qsaError) {}</p>
<p>// qSA works strangely on Element-rooted queries<br />
// We can work around this by specifying an extra ID on the root<br />
// and working up from there (Thanks to Andrew Dupont for the technique)<br />
// IE 8 doesn&#8217;t work on object elements<br />
} else if ( context.nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &#8220;object&#8221; ) {<br />
var oldContext = context,<br />
old = context.getAttribute( &#8220;id&#8221; ),<br />
nid = old || id,<br />
hasParent = context.parentNode,<br />
relativeHierarchySelector = /^\s*[+~]/.test( query );</p>
<p>if ( !old ) {<br />
context.setAttribute( &#8220;id&#8221;, nid );<br />
} else {<br />
nid = nid.replace( /&#8217;/g, &#8220;\\$&amp;&#8221; );<br />
}<br />
if ( relativeHierarchySelector &amp;&amp; hasParent ) {<br />
context = context.parentNode;<br />
}</p>
<p>try {<br />
if ( !relativeHierarchySelector || hasParent ) {<br />
return makeArray( context.querySelectorAll( &#8220;[id='" + nid + "'] &#8221; + query ), extra );<br />
}</p>
<p>} catch(pseudoError) {<br />
} finally {<br />
if ( !old ) {<br />
oldContext.removeAttribute( &#8220;id&#8221; );<br />
}<br />
}<br />
}<br />
}</p>
<p>return oldSizzle(query, context, extra, seed);<br />
};</p>
<p>for ( var prop in oldSizzle ) {<br />
Sizzle[ prop ] = oldSizzle[ prop ];<br />
}</p>
<p>// release memory in IE<br />
div = null;<br />
})();<br />
}</p>
<p>(function(){<br />
var html = document.documentElement,<br />
matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;</p>
<p>if ( matches ) {<br />
// Check to see if it&#8217;s possible to do matchesSelector<br />
// on a disconnected node (IE 9 fails this)<br />
var disconnectedMatch = !matches.call( document.createElement( &#8220;div&#8221; ), &#8220;div&#8221; ),<br />
pseudoWorks = false;</p>
<p>try {<br />
// This should fail with an exception<br />
// Gecko does not error, returns false instead<br />
matches.call( document.documentElement, &#8220;[test!='']:sizzle&#8221; );</p>
<p>} catch( pseudoError ) {<br />
pseudoWorks = true;<br />
}</p>
<p>Sizzle.matchesSelector = function( node, expr ) {<br />
// Make sure that attribute selectors are quoted<br />
expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, &#8220;=&#8217;$1&#8242;]&#8221;);</p>
<p>if ( !Sizzle.isXML( node ) ) {<br />
try {<br />
if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) &amp;&amp; !/!=/.test( expr ) ) {<br />
var ret = matches.call( node, expr );</p>
<p>// IE 9&#8242;s matchesSelector returns false on disconnected nodes<br />
if ( ret || !disconnectedMatch ||<br />
// As well, disconnected nodes are said to be in a document<br />
// fragment in IE 9, so check for that<br />
node.document &amp;&amp; node.document.nodeType !== 11 ) {<br />
return ret;<br />
}<br />
}<br />
} catch(e) {}<br />
}</p>
<p>return Sizzle(expr, null, null, [node]).length &gt; 0;<br />
};<br />
}<br />
})();</p>
<p>(function(){<br />
var div = document.createElement(&#8220;div&#8221;);</p>
<p>div.innerHTML = &#8220;&lt;div class=&#8217;test e&#8217;&gt;&lt;/div&gt;&lt;div class=&#8217;test&#8217;&gt;&lt;/div&gt;&#8221;;</p>
<p>// Opera can&#8217;t find a second classname (in 9.6)<br />
// Also, make sure that getElementsByClassName actually exists<br />
if ( !div.getElementsByClassName || div.getElementsByClassName(&#8220;e&#8221;).length === 0 ) {<br />
return;<br />
}</p>
<p>// Safari caches class attributes, doesn&#8217;t catch changes (in 3.2)<br />
div.lastChild.className = &#8220;e&#8221;;</p>
<p>if ( div.getElementsByClassName(&#8220;e&#8221;).length === 1 ) {<br />
return;<br />
}</p>
<p>Expr.order.splice(1, 0, &#8220;CLASS&#8221;);<br />
Expr.find.CLASS = function( match, context, isXML ) {<br />
if ( typeof context.getElementsByClassName !== &#8220;undefined&#8221; &amp;&amp; !isXML ) {<br />
return context.getElementsByClassName(match[1]);<br />
}<br />
};</p>
<p>// release memory in IE<br />
div = null;<br />
})();</p>
<p>function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {<br />
for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {<br />
var elem = checkSet[i];</p>
<p>if ( elem ) {<br />
var match = false;</p>
<p>elem = elem[dir];</p>
<p>while ( elem ) {<br />
if ( elem[ expando ] === doneName ) {<br />
match = checkSet[elem.sizset];<br />
break;<br />
}</p>
<p>if ( elem.nodeType === 1 &amp;&amp; !isXML ){<br />
elem[ expando ] = doneName;<br />
elem.sizset = i;<br />
}</p>
<p>if ( elem.nodeName.toLowerCase() === cur ) {<br />
match = elem;<br />
break;<br />
}</p>
<p>elem = elem[dir];<br />
}</p>
<p>checkSet[i] = match;<br />
}<br />
}<br />
}</p>
<p>function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {<br />
for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {<br />
var elem = checkSet[i];</p>
<p>if ( elem ) {<br />
var match = false;</p>
<p>elem = elem[dir];</p>
<p>while ( elem ) {<br />
if ( elem[ expando ] === doneName ) {<br />
match = checkSet[elem.sizset];<br />
break;<br />
}</p>
<p>if ( elem.nodeType === 1 ) {<br />
if ( !isXML ) {<br />
elem[ expando ] = doneName;<br />
elem.sizset = i;<br />
}</p>
<p>if ( typeof cur !== &#8220;string&#8221; ) {<br />
if ( elem === cur ) {<br />
match = true;<br />
break;<br />
}</p>
<p>} else if ( Sizzle.filter( cur, [elem] ).length &gt; 0 ) {<br />
match = elem;<br />
break;<br />
}<br />
}</p>
<p>elem = elem[dir];<br />
}</p>
<p>checkSet[i] = match;<br />
}<br />
}<br />
}</p>
<p>if ( document.documentElement.contains ) {<br />
Sizzle.contains = function( a, b ) {<br />
return a !== b &amp;&amp; (a.contains ? a.contains(b) : true);<br />
};</p>
<p>} else if ( document.documentElement.compareDocumentPosition ) {<br />
Sizzle.contains = function( a, b ) {<br />
return !!(a.compareDocumentPosition(b) &amp; 16);<br />
};</p>
<p>} else {<br />
Sizzle.contains = function() {<br />
return false;<br />
};<br />
}</p>
<p>Sizzle.isXML = function( elem ) {<br />
// documentElement is verified for cases where it doesn&#8217;t yet exist<br />
// (such as loading iframes in IE &#8211; #4833)<br />
var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;</p>
<p>return documentElement ? documentElement.nodeName !== &#8220;HTML&#8221; : false;<br />
};</p>
<p>var posProcess = function( selector, context, seed ) {<br />
var match,<br />
tmpSet = [],<br />
later = &#8220;&#8221;,<br />
root = context.nodeType ? [context] : context;</p>
<p>// Position selectors must be done after the filter<br />
// And so must :not(positional) so we move all PSEUDOs to the end<br />
while ( (match = Expr.match.PSEUDO.exec( selector )) ) {<br />
later += match[0];<br />
selector = selector.replace( Expr.match.PSEUDO, &#8220;&#8221; );<br />
}</p>
<p>selector = Expr.relative[selector] ? selector + &#8220;*&#8221; : selector;</p>
<p>for ( var i = 0, l = root.length; i &lt; l; i++ ) {<br />
Sizzle( selector, root[i], tmpSet, seed );<br />
}</p>
<p>return Sizzle.filter( later, tmpSet );<br />
};</p>
<p>// EXPOSE<br />
// Override sizzle attribute retrieval<br />
Sizzle.attr = jQuery.attr;<br />
Sizzle.selectors.attrMap = {};<br />
jQuery.find = Sizzle;<br />
jQuery.expr = Sizzle.selectors;<br />
jQuery.expr[":"] = jQuery.expr.filters;<br />
jQuery.unique = Sizzle.uniqueSort;<br />
jQuery.text = Sizzle.getText;<br />
jQuery.isXMLDoc = Sizzle.isXML;<br />
jQuery.contains = Sizzle.contains;</p>
<p>})();</p>
<p>var runtil = /Until$/,<br />
rparentsprev = /^(?:parents|prevUntil|prevAll)/,<br />
// Note: This RegExp should be improved, or likely pulled from Sizzle<br />
rmultiselector = /,/,<br />
isSimple = /^.[^:#\[\.,]*$/,<br />
slice = Array.prototype.slice,<br />
POS = jQuery.expr.match.POS,<br />
// methods guaranteed to produce a unique set when starting from a unique set<br />
guaranteedUnique = {<br />
children: true,<br />
contents: true,<br />
next: true,<br />
prev: true<br />
};</p>
<p>jQuery.fn.extend({<br />
find: function( selector ) {<br />
var self = this,<br />
i, l;</p>
<p>if ( typeof selector !== &#8220;string&#8221; ) {<br />
return jQuery( selector ).filter(function() {<br />
for ( i = 0, l = self.length; i &lt; l; i++ ) {<br />
if ( jQuery.contains( self[ i ], this ) ) {<br />
return true;<br />
}<br />
}<br />
});<br />
}</p>
<p>var ret = this.pushStack( &#8220;&#8221;, &#8220;find&#8221;, selector ),<br />
length, n, r;</p>
<p>for ( i = 0, l = this.length; i &lt; l; i++ ) {<br />
length = ret.length;<br />
jQuery.find( selector, this[i], ret );</p>
<p>if ( i &gt; 0 ) {<br />
// Make sure that the results are unique<br />
for ( n = length; n &lt; ret.length; n++ ) {<br />
for ( r = 0; r &lt; length; r++ ) {<br />
if ( ret[r] === ret[n] ) {<br />
ret.splice(n&#8211;, 1);<br />
break;<br />
}<br />
}<br />
}<br />
}<br />
}</p>
<p>return ret;<br />
},</p>
<p>has: function( target ) {<br />
var targets = jQuery( target );<br />
return this.filter(function() {<br />
for ( var i = 0, l = targets.length; i &lt; l; i++ ) {<br />
if ( jQuery.contains( this, targets[i] ) ) {<br />
return true;<br />
}<br />
}<br />
});<br />
},</p>
<p>not: function( selector ) {<br />
return this.pushStack( winnow(this, selector, false), &#8220;not&#8221;, selector);<br />
},</p>
<p>filter: function( selector ) {<br />
return this.pushStack( winnow(this, selector, true), &#8220;filter&#8221;, selector );<br />
},</p>
<p>is: function( selector ) {<br />
return !!selector &amp;&amp; (<br />
typeof selector === &#8220;string&#8221; ?<br />
// If this is a positional selector, check membership in the returned set<br />
// so $(&#8220;p:first&#8221;).is(&#8220;p:last&#8221;) won&#8217;t return true for a doc with two &#8220;p&#8221;.<br />
POS.test( selector ) ?<br />
jQuery( selector, this.context ).index( this[0] ) &gt;= 0 :<br />
jQuery.filter( selector, this ).length &gt; 0 :<br />
this.filter( selector ).length &gt; 0 );<br />
},</p>
<p>closest: function( selectors, context ) {<br />
var ret = [], i, l, cur = this[0];</p>
<p>// Array (deprecated as of jQuery 1.7)<br />
if ( jQuery.isArray( selectors ) ) {<br />
var level = 1;</p>
<p>while ( cur &amp;&amp; cur.ownerDocument &amp;&amp; cur !== context ) {<br />
for ( i = 0; i &lt; selectors.length; i++ ) {</p>
<p>if ( jQuery( cur ).is( selectors[ i ] ) ) {<br />
ret.push({ selector: selectors[ i ], elem: cur, level: level });<br />
}<br />
}</p>
<p>cur = cur.parentNode;<br />
level++;<br />
}</p>
<p>return ret;<br />
}</p>
<p>// String<br />
var pos = POS.test( selectors ) || typeof selectors !== &#8220;string&#8221; ?<br />
jQuery( selectors, context || this.context ) :<br />
0;</p>
<p>for ( i = 0, l = this.length; i &lt; l; i++ ) {<br />
cur = this[i];</p>
<p>while ( cur ) {<br />
if ( pos ? pos.index(cur) &gt; -1 : jQuery.find.matchesSelector(cur, selectors) ) {<br />
ret.push( cur );<br />
break;</p>
<p>} else {<br />
cur = cur.parentNode;<br />
if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {<br />
break;<br />
}<br />
}<br />
}<br />
}</p>
<p>ret = ret.length &gt; 1 ? jQuery.unique( ret ) : ret;</p>
<p>return this.pushStack( ret, &#8220;closest&#8221;, selectors );<br />
},</p>
<p>// Determine the position of an element within<br />
// the matched set of elements<br />
index: function( elem ) {</p>
<p>// No argument, return index in parent<br />
if ( !elem ) {<br />
return ( this[0] &amp;&amp; this[0].parentNode ) ? this.prevAll().length : -1;<br />
}</p>
<p>// index in selector<br />
if ( typeof elem === &#8220;string&#8221; ) {<br />
return jQuery.inArray( this[0], jQuery( elem ) );<br />
}</p>
<p>// Locate the position of the desired element<br />
return jQuery.inArray(<br />
// If it receives a jQuery object, the first element is used<br />
elem.jquery ? elem[0] : elem, this );<br />
},</p>
<p>add: function( selector, context ) {<br />
var set = typeof selector === &#8220;string&#8221; ?<br />
jQuery( selector, context ) :<br />
jQuery.makeArray( selector &amp;&amp; selector.nodeType ? [ selector ] : selector ),<br />
all = jQuery.merge( this.get(), set );</p>
<p>return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?<br />
all :<br />
jQuery.unique( all ) );<br />
},</p>
<p>andSelf: function() {<br />
return this.add( this.prevObject );<br />
}<br />
});</p>
<p>// A painfully simple check to see if an element is disconnected<br />
// from a document (should be improved, where feasible).<br />
function isDisconnected( node ) {<br />
return !node || !node.parentNode || node.parentNode.nodeType === 11;<br />
}</p>
<p>jQuery.each({<br />
parent: function( elem ) {<br />
var parent = elem.parentNode;<br />
return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;<br />
},<br />
parents: function( elem ) {<br />
return jQuery.dir( elem, &#8220;parentNode&#8221; );<br />
},<br />
parentsUntil: function( elem, i, until ) {<br />
return jQuery.dir( elem, &#8220;parentNode&#8221;, until );<br />
},<br />
next: function( elem ) {<br />
return jQuery.nth( elem, 2, &#8220;nextSibling&#8221; );<br />
},<br />
prev: function( elem ) {<br />
return jQuery.nth( elem, 2, &#8220;previousSibling&#8221; );<br />
},<br />
nextAll: function( elem ) {<br />
return jQuery.dir( elem, &#8220;nextSibling&#8221; );<br />
},<br />
prevAll: function( elem ) {<br />
return jQuery.dir( elem, &#8220;previousSibling&#8221; );<br />
},<br />
nextUntil: function( elem, i, until ) {<br />
return jQuery.dir( elem, &#8220;nextSibling&#8221;, until );<br />
},<br />
prevUntil: function( elem, i, until ) {<br />
return jQuery.dir( elem, &#8220;previousSibling&#8221;, until );<br />
},<br />
siblings: function( elem ) {<br />
return jQuery.sibling( elem.parentNode.firstChild, elem );<br />
},<br />
children: function( elem ) {<br />
return jQuery.sibling( elem.firstChild );<br />
},<br />
contents: function( elem ) {<br />
return jQuery.nodeName( elem, &#8220;iframe&#8221; ) ?<br />
elem.contentDocument || elem.contentWindow.document :<br />
jQuery.makeArray( elem.childNodes );<br />
}<br />
}, function( name, fn ) {<br />
jQuery.fn[ name ] = function( until, selector ) {<br />
var ret = jQuery.map( this, fn, until ),<br />
// The variable &#8216;args&#8217; was introduced in<br />
// <a href="https://github.com/jquery/jquery/commit/52a0238" rel="nofollow">https://github.com/jquery/jquery/commit/52a0238</a><br />
// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.<br />
// <a href="http://code.google.com/p/v8/issues/detail?id=1050" rel="nofollow">http://code.google.com/p/v8/issues/detail?id=1050</a><br />
args = slice.call(arguments);</p>
<p>if ( !runtil.test( name ) ) {<br />
selector = until;<br />
}</p>
<p>if ( selector &amp;&amp; typeof selector === &#8220;string&#8221; ) {<br />
ret = jQuery.filter( selector, ret );<br />
}</p>
<p>ret = this.length &gt; 1 &amp;&amp; !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;</p>
<p>if ( (this.length &gt; 1 || rmultiselector.test( selector )) &amp;&amp; rparentsprev.test( name ) ) {<br />
ret = ret.reverse();<br />
}</p>
<p>return this.pushStack( ret, name, args.join(&#8220;,&#8221;) );<br />
};<br />
});</p>
<p>jQuery.extend({<br />
filter: function( expr, elems, not ) {<br />
if ( not ) {<br />
expr = &#8220;:not(&#8221; + expr + &#8220;)&#8221;;<br />
}</p>
<p>return elems.length === 1 ?<br />
jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :<br />
jQuery.find.matches(expr, elems);<br />
},</p>
<p>dir: function( elem, dir, until ) {<br />
var matched = [],<br />
cur = elem[ dir ];</p>
<p>while ( cur &amp;&amp; cur.nodeType !== 9 &amp;&amp; (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {<br />
if ( cur.nodeType === 1 ) {<br />
matched.push( cur );<br />
}<br />
cur = cur[dir];<br />
}<br />
return matched;<br />
},</p>
<p>nth: function( cur, result, dir, elem ) {<br />
result = result || 1;<br />
var num = 0;</p>
<p>for ( ; cur; cur = cur[dir] ) {<br />
if ( cur.nodeType === 1 &amp;&amp; ++num === result ) {<br />
break;<br />
}<br />
}</p>
<p>return cur;<br />
},</p>
<p>sibling: function( n, elem ) {<br />
var r = [];</p>
<p>for ( ; n; n = n.nextSibling ) {<br />
if ( n.nodeType === 1 &amp;&amp; n !== elem ) {<br />
r.push( n );<br />
}<br />
}</p>
<p>return r;<br />
}<br />
});</p>
<p>// Implement the identical functionality for filter and not<br />
function winnow( elements, qualifier, keep ) {</p>
<p>// Can&#8217;t pass null or undefined to indexOf in Firefox 4<br />
// Set to 0 to skip string check<br />
qualifier = qualifier || 0;</p>
<p>if ( jQuery.isFunction( qualifier ) ) {<br />
return jQuery.grep(elements, function( elem, i ) {<br />
var retVal = !!qualifier.call( elem, i, elem );<br />
return retVal === keep;<br />
});</p>
<p>} else if ( qualifier.nodeType ) {<br />
return jQuery.grep(elements, function( elem, i ) {<br />
return ( elem === qualifier ) === keep;<br />
});</p>
<p>} else if ( typeof qualifier === &#8220;string&#8221; ) {<br />
var filtered = jQuery.grep(elements, function( elem ) {<br />
return elem.nodeType === 1;<br />
});</p>
<p>if ( isSimple.test( qualifier ) ) {<br />
return jQuery.filter(qualifier, filtered, !keep);<br />
} else {<br />
qualifier = jQuery.filter( qualifier, filtered );<br />
}<br />
}</p>
<p>return jQuery.grep(elements, function( elem, i ) {<br />
return ( jQuery.inArray( elem, qualifier ) &gt;= 0 ) === keep;<br />
});<br />
}</p>
<p>function createSafeFragment( document ) {<br />
var list = nodeNames.split( &#8221; &#8221; ),<br />
safeFrag = document.createDocumentFragment();</p>
<p>if ( safeFrag.createElement ) {<br />
while ( list.length ) {<br />
safeFrag.createElement(<br />
list.pop()<br />
);<br />
}<br />
}<br />
return safeFrag;<br />
}</p>
<p>var nodeNames = &#8220;abbr article aside audio canvas datalist details figcaption figure footer &#8221; +<br />
&#8220;header hgroup mark meter nav output progress section summary time video&#8221;,<br />
rinlinejQuery = / jQuery\d+=&#8221;(?:\d+|null)&#8221;/g,<br />
rleadingWhitespace = /^\s+/,<br />
rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/ig,<br />
rtagName = /&lt;([\w:]+)/,<br />
rtbody = /&lt;tbody/i,<br />
rhtml = /&lt;|&amp;#?\w+;/,<br />
rnoInnerhtml = /&lt;(?:script|style)/i,<br />
rnocache = /&lt;(?:script|object|embed|option|style)/i,<br />
rnoshimcache = new RegExp(&#8220;&lt;(?:&#8221; + nodeNames.replace(&#8221; &#8220;, &#8220;|&#8221;) + &#8220;)&#8221;, &#8220;i&#8221;),<br />
// checked=&#8221;checked&#8221; or checked<br />
rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,<br />
rscriptType = /\/(java|ecma)script/i,<br />
rcleanScript = /^\s*&lt;!(?:\[CDATA\[|\-\-)/,<br />
wrapMap = {<br />
option: [ 1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;" ],<br />
legend: [ 1, "&lt;fieldset&gt;", "&lt;/fieldset&gt;" ],<br />
thead: [ 1, "&lt;table&gt;", "&lt;/table&gt;" ],<br />
tr: [ 2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;" ],<br />
td: [ 3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" ],<br />
col: [ 2, "&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;" ],<br />
area: [ 1, "&lt;map&gt;", "&lt;/map&gt;" ],<br />
_default: [ 0, "", "" ]<br />
},<br />
safeFragment = createSafeFragment( document );</p>
<p>wrapMap.optgroup = wrapMap.option;<br />
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;<br />
wrapMap.th = wrapMap.td;</p>
<p>// IE can&#8217;t serialize &lt;link&gt; and &lt;script&gt; tags normally<br />
if ( !jQuery.support.htmlSerialize ) {<br />
wrapMap._default = [ 1, "div&lt;div&gt;", "&lt;/div&gt;" ];<br />
}</p>
<p>jQuery.fn.extend({<br />
text: function( text ) {<br />
if ( jQuery.isFunction(text) ) {<br />
return this.each(function(i) {<br />
var self = jQuery( this );</p>
<p>self.text( text.call(this, i, self.text()) );<br />
});<br />
}</p>
<p>if ( typeof text !== &#8220;object&#8221; &amp;&amp; text !== undefined ) {<br />
return this.empty().append( (this[0] &amp;&amp; this[0].ownerDocument || document).createTextNode( text ) );<br />
}</p>
<p>return jQuery.text( this );<br />
},</p>
<p>wrapAll: function( html ) {<br />
if ( jQuery.isFunction( html ) ) {<br />
return this.each(function(i) {<br />
jQuery(this).wrapAll( html.call(this, i) );<br />
});<br />
}</p>
<p>if ( this[0] ) {<br />
// The elements to wrap the target around<br />
var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);</p>
<p>if ( this[0].parentNode ) {<br />
wrap.insertBefore( this[0] );<br />
}</p>
<p>wrap.map(function() {<br />
var elem = this;</p>
<p>while ( elem.firstChild &amp;&amp; elem.firstChild.nodeType === 1 ) {<br />
elem = elem.firstChild;<br />
}</p>
<p>return elem;<br />
}).append( this );<br />
}</p>
<p>return this;<br />
},</p>
<p>wrapInner: function( html ) {<br />
if ( jQuery.isFunction( html ) ) {<br />
return this.each(function(i) {<br />
jQuery(this).wrapInner( html.call(this, i) );<br />
});<br />
}</p>
<p>return this.each(function() {<br />
var self = jQuery( this ),<br />
contents = self.contents();</p>
<p>if ( contents.length ) {<br />
contents.wrapAll( html );</p>
<p>} else {<br />
self.append( html );<br />
}<br />
});<br />
},</p>
<p>wrap: function( html ) {<br />
return this.each(function() {<br />
jQuery( this ).wrapAll( html );<br />
});<br />
},</p>
<p>unwrap: function() {<br />
return this.parent().each(function() {<br />
if ( !jQuery.nodeName( this, &#8220;body&#8221; ) ) {<br />
jQuery( this ).replaceWith( this.childNodes );<br />
}<br />
}).end();<br />
},</p>
<p>append: function() {<br />
return this.domManip(arguments, true, function( elem ) {<br />
if ( this.nodeType === 1 ) {<br />
this.appendChild( elem );<br />
}<br />
});<br />
},</p>
<p>prepend: function() {<br />
return this.domManip(arguments, true, function( elem ) {<br />
if ( this.nodeType === 1 ) {<br />
this.insertBefore( elem, this.firstChild );<br />
}<br />
});<br />
},</p>
<p>before: function() {<br />
if ( this[0] &amp;&amp; this[0].parentNode ) {<br />
return this.domManip(arguments, false, function( elem ) {<br />
this.parentNode.insertBefore( elem, this );<br />
});<br />
} else if ( arguments.length ) {<br />
var set = jQuery(arguments[0]);<br />
set.push.apply( set, this.toArray() );<br />
return this.pushStack( set, &#8220;before&#8221;, arguments );<br />
}<br />
},</p>
<p>after: function() {<br />
if ( this[0] &amp;&amp; this[0].parentNode ) {<br />
return this.domManip(arguments, false, function( elem ) {<br />
this.parentNode.insertBefore( elem, this.nextSibling );<br />
});<br />
} else if ( arguments.length ) {<br />
var set = this.pushStack( this, &#8220;after&#8221;, arguments );<br />
set.push.apply( set, jQuery(arguments[0]).toArray() );<br />
return set;<br />
}<br />
},</p>
<p>// keepData is for internal use only&#8211;do not document<br />
remove: function( selector, keepData ) {<br />
for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {<br />
if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {<br />
if ( !keepData &amp;&amp; elem.nodeType === 1 ) {<br />
jQuery.cleanData( elem.getElementsByTagName(&#8220;*&#8221;) );<br />
jQuery.cleanData( [ elem ] );<br />
}</p>
<p>if ( elem.parentNode ) {<br />
elem.parentNode.removeChild( elem );<br />
}<br />
}<br />
}</p>
<p>return this;<br />
},</p>
<p>empty: function() {<br />
for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {<br />
// Remove element nodes and prevent memory leaks<br />
if ( elem.nodeType === 1 ) {<br />
jQuery.cleanData( elem.getElementsByTagName(&#8220;*&#8221;) );<br />
}</p>
<p>// Remove any remaining nodes<br />
while ( elem.firstChild ) {<br />
elem.removeChild( elem.firstChild );<br />
}<br />
}</p>
<p>return this;<br />
},</p>
<p>clone: function( dataAndEvents, deepDataAndEvents ) {<br />
dataAndEvents = dataAndEvents == null ? false : dataAndEvents;<br />
deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;</p>
<p>return this.map( function () {<br />
return jQuery.clone( this, dataAndEvents, deepDataAndEvents );<br />
});<br />
},</p>
<p>html: function( value ) {<br />
if ( value === undefined ) {<br />
return this[0] &amp;&amp; this[0].nodeType === 1 ?<br />
this[0].innerHTML.replace(rinlinejQuery, &#8220;&#8221;) :<br />
null;</p>
<p>// See if we can take a shortcut and just use innerHTML<br />
} else if ( typeof value === &#8220;string&#8221; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;<br />
(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &amp;&amp;<br />
!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {</p>
<p>value = value.replace(rxhtmlTag, &#8220;&lt;$1&gt;&lt;/$2&gt;&#8221;);</p>
<p>try {<br />
for ( var i = 0, l = this.length; i &lt; l; i++ ) {<br />
// Remove element nodes and prevent memory leaks<br />
if ( this[i].nodeType === 1 ) {<br />
jQuery.cleanData( this[i].getElementsByTagName(&#8220;*&#8221;) );<br />
this[i].innerHTML = value;<br />
}<br />
}</p>
<p>// If using innerHTML throws an exception, use the fallback method<br />
} catch(e) {<br />
this.empty().append( value );<br />
}</p>
<p>} else if ( jQuery.isFunction( value ) ) {<br />
this.each(function(i){<br />
var self = jQuery( this );</p>
<p>self.html( value.call(this, i, self.html()) );<br />
});</p>
<p>} else {<br />
this.empty().append( value );<br />
}</p>
<p>return this;<br />
},</p>
<p>replaceWith: function( value ) {<br />
if ( this[0] &amp;&amp; this[0].parentNode ) {<br />
// Make sure that the elements are removed from the DOM before they are inserted<br />
// this can help fix replacing a parent with child elements<br />
if ( jQuery.isFunction( value ) ) {<br />
return this.each(function(i) {<br />
var self = jQuery(this), old = self.html();<br />
self.replaceWith( value.call( this, i, old ) );<br />
});<br />
}</p>
<p>if ( typeof value !== &#8220;string&#8221; ) {<br />
value = jQuery( value ).detach();<br />
}</p>
<p>return this.each(function() {<br />
var next = this.nextSibling,<br />
parent = this.parentNode;</p>
<p>jQuery( this ).remove();</p>
<p>if ( next ) {<br />
jQuery(next).before( value );<br />
} else {<br />
jQuery(parent).append( value );<br />
}<br />
});<br />
} else {<br />
return this.length ?<br />
this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), &#8220;replaceWith&#8221;, value ) :<br />
this;<br />
}<br />
},</p>
<p>detach: function( selector ) {<br />
return this.remove( selector, true );<br />
},</p>
<p>domManip: function( args, table, callback ) {<br />
var results, first, fragment, parent,<br />
value = args[0],<br />
scripts = [];</p>
<p>// We can&#8217;t cloneNode fragments that contain checked, in WebKit<br />
if ( !jQuery.support.checkClone &amp;&amp; arguments.length === 3 &amp;&amp; typeof value === &#8220;string&#8221; &amp;&amp; rchecked.test( value ) ) {<br />
return this.each(function() {<br />
jQuery(this).domManip( args, table, callback, true );<br />
});<br />
}</p>
<p>if ( jQuery.isFunction(value) ) {<br />
return this.each(function(i) {<br />
var self = jQuery(this);<br />
args[0] = value.call(this, i, table ? self.html() : undefined);<br />
self.domManip( args, table, callback );<br />
});<br />
}</p>
<p>if ( this[0] ) {<br />
parent = value &amp;&amp; value.parentNode;</p>
<p>// If we&#8217;re in a fragment, just use that instead of building a new one<br />
if ( jQuery.support.parentNode &amp;&amp; parent &amp;&amp; parent.nodeType === 11 &amp;&amp; parent.childNodes.length === this.length ) {<br />
results = { fragment: parent };</p>
<p>} else {<br />
results = jQuery.buildFragment( args, this, scripts );<br />
}</p>
<p>fragment = results.fragment;</p>
<p>if ( fragment.childNodes.length === 1 ) {<br />
first = fragment = fragment.firstChild;<br />
} else {<br />
first = fragment.firstChild;<br />
}</p>
<p>if ( first ) {<br />
table = table &amp;&amp; jQuery.nodeName( first, &#8220;tr&#8221; );</p>
<p>for ( var i = 0, l = this.length, lastIndex = l &#8211; 1; i &lt; l; i++ ) {<br />
callback.call(<br />
table ?<br />
root(this[i], first) :<br />
this[i],<br />
// Make sure that we do not leak memory by inadvertently discarding<br />
// the original fragment (which might have attached data) instead of<br />
// using it; in addition, use the original fragment object for the last<br />
// item instead of first because it can end up being emptied incorrectly<br />
// in certain situations (Bug #8070).<br />
// Fragments from the fragment cache must always be cloned and never used<br />
// in place.<br />
results.cacheable || ( l &gt; 1 &amp;&amp; i &lt; lastIndex ) ?<br />
jQuery.clone( fragment, true, true ) :<br />
fragment<br />
);<br />
}<br />
}</p>
<p>if ( scripts.length ) {<br />
jQuery.each( scripts, evalScript );<br />
}<br />
}</p>
<p>return this;<br />
}<br />
});</p>
<p>function root( elem, cur ) {<br />
return jQuery.nodeName(elem, &#8220;table&#8221;) ?<br />
(elem.getElementsByTagName(&#8220;tbody&#8221;)[0] ||<br />
elem.appendChild(elem.ownerDocument.createElement(&#8220;tbody&#8221;))) :<br />
elem;<br />
}</p>
<p>function cloneCopyEvent( src, dest ) {</p>
<p>if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {<br />
return;<br />
}</p>
<p>var type, i, l,<br />
oldData = jQuery._data( src ),<br />
curData = jQuery._data( dest, oldData ),<br />
events = oldData.events;</p>
<p>if ( events ) {<br />
delete curData.handle;<br />
curData.events = {};</p>
<p>for ( type in events ) {<br />
for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {<br />
jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? &#8220;.&#8221; : &#8220;&#8221; ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );<br />
}<br />
}<br />
}</p>
<p>// make the cloned public data object a copy from the original<br />
if ( curData.data ) {<br />
curData.data = jQuery.extend( {}, curData.data );<br />
}<br />
}</p>
<p>function cloneFixAttributes( src, dest ) {<br />
var nodeName;</p>
<p>// We do not need to do anything for non-Elements<br />
if ( dest.nodeType !== 1 ) {<br />
return;<br />
}</p>
<p>// clearAttributes removes the attributes, which we don&#8217;t want,<br />
// but also removes the attachEvent events, which we *do* want<br />
if ( dest.clearAttributes ) {<br />
dest.clearAttributes();<br />
}</p>
<p>// mergeAttributes, in contrast, only merges back on the<br />
// original attributes, not the events<br />
if ( dest.mergeAttributes ) {<br />
dest.mergeAttributes( src );<br />
}</p>
<p>nodeName = dest.nodeName.toLowerCase();</p>
<p>// IE6-8 fail to clone children inside object elements that use<br />
// the proprietary classid attribute value (rather than the type<br />
// attribute) to identify the type of content to display<br />
if ( nodeName === &#8220;object&#8221; ) {<br />
dest.outerHTML = src.outerHTML;</p>
<p>} else if ( nodeName === &#8220;input&#8221; &amp;&amp; (src.type === &#8220;checkbox&#8221; || src.type === &#8220;radio&#8221;) ) {<br />
// IE6-8 fails to persist the checked state of a cloned checkbox<br />
// or radio button. Worse, IE6-7 fail to give the cloned element<br />
// a checked appearance if the defaultChecked value isn&#8217;t also set<br />
if ( src.checked ) {<br />
dest.defaultChecked = dest.checked = src.checked;<br />
}</p>
<p>// IE6-7 get confused and end up setting the value of a cloned<br />
// checkbox/radio button to an empty string instead of &#8220;on&#8221;<br />
if ( dest.value !== src.value ) {<br />
dest.value = src.value;<br />
}</p>
<p>// IE6-8 fails to return the selected option to the default selected<br />
// state when cloning options<br />
} else if ( nodeName === &#8220;option&#8221; ) {<br />
dest.selected = src.defaultSelected;</p>
<p>// IE6-8 fails to set the defaultValue to the correct value when<br />
// cloning other types of input fields<br />
} else if ( nodeName === &#8220;input&#8221; || nodeName === &#8220;textarea&#8221; ) {<br />
dest.defaultValue = src.defaultValue;<br />
}</p>
<p>// Event data gets referenced instead of copied if the expando<br />
// gets copied too<br />
dest.removeAttribute( jQuery.expando );<br />
}</p>
<p>jQuery.buildFragment = function( args, nodes, scripts ) {<br />
var fragment, cacheable, cacheresults, doc,<br />
first = args[ 0 ];</p>
<p>// nodes may contain either an explicit document object,<br />
// a jQuery collection or context object.<br />
// If nodes[0] contains a valid object to assign to doc<br />
if ( nodes &amp;&amp; nodes[0] ) {<br />
doc = nodes[0].ownerDocument || nodes[0];<br />
}</p>
<p>// Ensure that an attr object doesn&#8217;t incorrectly stand in as a document object<br />
// Chrome and Firefox seem to allow this to occur and will throw exception<br />
// Fixes #8950<br />
if ( !doc.createDocumentFragment ) {<br />
doc = document;<br />
}</p>
<p>// Only cache &#8220;small&#8221; (1/2 KB) HTML strings that are associated with the main document<br />
// Cloning options loses the selected state, so don&#8217;t cache them<br />
// IE 6 doesn&#8217;t like it when you put &lt;object&gt; or elements in a fragment<br />
// Also, WebKit does not clone &#8216;checked&#8217; attributes on cloneNode, so don&#8217;t cache<br />
// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501<br />
if ( args.length === 1 &amp;&amp; typeof first === &#8220;string&#8221; &amp;&amp; first.length &lt; 512 &amp;&amp; doc === document &amp;&amp;<br />
first.charAt(0) === &#8220;&lt;&#8221; &amp;&amp; !rnocache.test( first ) &amp;&amp;<br />
(jQuery.support.checkClone || !rchecked.test( first )) &amp;&amp;<br />
(!jQuery.support.unknownElems &amp;&amp; rnoshimcache.test( first )) ) {</p>
<p>cacheable = true;</p>
<p>cacheresults = jQuery.fragments[ first ];<br />
if ( cacheresults &amp;&amp; cacheresults !== 1 ) {<br />
fragment = cacheresults;<br />
}<br />
}</p>
<p>if ( !fragment ) {<br />
fragment = doc.createDocumentFragment();<br />
jQuery.clean( args, doc, fragment, scripts );<br />
}</p>
<p>if ( cacheable ) {<br />
jQuery.fragments[ first ] = cacheresults ? fragment : 1;<br />
}</p>
<p>return { fragment: fragment, cacheable: cacheable };<br />
};</p>
<p>jQuery.fragments = {};</p>
<p>jQuery.each({<br />
appendTo: &#8220;append&#8221;,<br />
prependTo: &#8220;prepend&#8221;,<br />
insertBefore: &#8220;before&#8221;,<br />
insertAfter: &#8220;after&#8221;,<br />
replaceAll: &#8220;replaceWith&#8221;<br />
}, function( name, original ) {<br />
jQuery.fn[ name ] = function( selector ) {<br />
var ret = [],<br />
insert = jQuery( selector ),<br />
parent = this.length === 1 &amp;&amp; this[0].parentNode;</p>
<p>if ( parent &amp;&amp; parent.nodeType === 11 &amp;&amp; parent.childNodes.length === 1 &amp;&amp; insert.length === 1 ) {<br />
insert[ original ]( this[0] );<br />
return this;</p>
<p>} else {<br />
for ( var i = 0, l = insert.length; i &lt; l; i++ ) {<br />
var elems = ( i &gt; 0 ? this.clone(true) : this ).get();<br />
jQuery( insert[i] )[ original ]( elems );<br />
ret = ret.concat( elems );<br />
}</p>
<p>return this.pushStack( ret, name, insert.selector );<br />
}<br />
};<br />
});</p>
<p>function getAll( elem ) {<br />
if ( typeof elem.getElementsByTagName !== &#8220;undefined&#8221; ) {<br />
return elem.getElementsByTagName( &#8220;*&#8221; );</p>
<p>} else if ( typeof elem.querySelectorAll !== &#8220;undefined&#8221; ) {<br />
return elem.querySelectorAll( &#8220;*&#8221; );</p>
<p>} else {<br />
return [];<br />
}<br />
}</p>
<p>// Used in clean, fixes the defaultChecked property<br />
function fixDefaultChecked( elem ) {<br />
if ( elem.type === &#8220;checkbox&#8221; || elem.type === &#8220;radio&#8221; ) {<br />
elem.defaultChecked = elem.checked;<br />
}<br />
}<br />
// Finds all inputs and passes them to fixDefaultChecked<br />
function findInputs( elem ) {<br />
var nodeName = ( elem.nodeName || &#8220;&#8221; ).toLowerCase();<br />
if ( nodeName === &#8220;input&#8221; ) {<br />
fixDefaultChecked( elem );<br />
// Skip scripts, get other children<br />
} else if ( nodeName !== &#8220;script&#8221; &amp;&amp; typeof elem.getElementsByTagName !== &#8220;undefined&#8221; ) {<br />
jQuery.grep( elem.getElementsByTagName(&#8220;input&#8221;), fixDefaultChecked );<br />
}<br />
}</p>
<p>jQuery.extend({<br />
clone: function( elem, dataAndEvents, deepDataAndEvents ) {<br />
var clone = elem.cloneNode(true),<br />
srcElements,<br />
destElements,<br />
i;</p>
<p>if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &amp;&amp;<br />
(elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem) ) {<br />
// IE copies events bound via attachEvent when using cloneNode.<br />
// Calling detachEvent on the clone will also remove the events<br />
// from the original. In order to get around this, we use some<br />
// proprietary methods to clear the events. Thanks to MooTools<br />
// guys for this hotness.</p>
<p>cloneFixAttributes( elem, clone );</p>
<p>// Using Sizzle here is crazy slow, so we use getElementsByTagName<br />
// instead<br />
srcElements = getAll( elem );<br />
destElements = getAll( clone );</p>
<p>// Weird iteration because IE will replace the length property<br />
// with an element if you are cloning the body and one of the<br />
// elements on the page has a name or id of &#8220;length&#8221;<br />
for ( i = 0; srcElements[i]; ++i ) {<br />
// Ensure that the destination node is not null; Fixes #9587<br />
if ( destElements[i] ) {<br />
cloneFixAttributes( srcElements[i], destElements[i] );<br />
}<br />
}<br />
}</p>
<p>// Copy the events from the original to the clone<br />
if ( dataAndEvents ) {<br />
cloneCopyEvent( elem, clone );</p>
<p>if ( deepDataAndEvents ) {<br />
srcElements = getAll( elem );<br />
destElements = getAll( clone );</p>
<p>for ( i = 0; srcElements[i]; ++i ) {<br />
cloneCopyEvent( srcElements[i], destElements[i] );<br />
}<br />
}<br />
}</p>
<p>srcElements = destElements = null;</p>
<p>// Return the cloned set<br />
return clone;<br />
},</p>
<p>clean: function( elems, context, fragment, scripts ) {<br />
var checkScriptType;</p>
<p>context = context || document;</p>
<p>// !context.createElement fails in IE with an error but returns typeof &#8216;object&#8217;<br />
if ( typeof context.createElement === &#8220;undefined&#8221; ) {<br />
context = context.ownerDocument || context[0] &amp;&amp; context[0].ownerDocument || document;<br />
}</p>
<p>var ret = [], j;</p>
<p>for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {<br />
if ( typeof elem === &#8220;number&#8221; ) {<br />
elem += &#8220;&#8221;;<br />
}</p>
<p>if ( !elem ) {<br />
continue;<br />
}</p>
<p>// Convert html string into DOM nodes<br />
if ( typeof elem === &#8220;string&#8221; ) {<br />
if ( !rhtml.test( elem ) ) {<br />
elem = context.createTextNode( elem );<br />
} else {<br />
// Fix &#8220;XHTML&#8221;-style tags in all browsers<br />
elem = elem.replace(rxhtmlTag, &#8220;&lt;$1&gt;&lt;/$2&gt;&#8221;);</p>
<p>// Trim whitespace, otherwise indexOf won&#8217;t work as expected<br />
var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),<br />
wrap = wrapMap[ tag ] || wrapMap._default,<br />
depth = wrap[0],<br />
div = context.createElement(&#8220;div&#8221;);</p>
<p>// Append wrapper element to unknown element safe doc fragment<br />
if ( context === document ) {<br />
// Use the fragment we&#8217;ve already created for this document<br />
safeFragment.appendChild( div );<br />
} else {<br />
// Use a fragment created with the owner document<br />
createSafeFragment( context ).appendChild( div );<br />
}</p>
<p>// Go to html and back, then peel off extra wrappers<br />
div.innerHTML = wrap[1] + elem + wrap[2];</p>
<p>// Move to the right depth<br />
while ( depth&#8211; ) {<br />
div = div.lastChild;<br />
}</p>
<p>// Remove IE&#8217;s autoinserted &lt;tbody&gt; from table fragments<br />
if ( !jQuery.support.tbody ) {</p>
<p>// String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt;<br />
var hasBody = rtbody.test(elem),<br />
tbody = tag === &#8220;table&#8221; &amp;&amp; !hasBody ?<br />
div.firstChild &amp;&amp; div.firstChild.childNodes :</p>
<p>// String was a bare &lt;thead&gt; or &lt;tfoot&gt;<br />
wrap[1] === &#8220;&lt;table&gt;&#8221; &amp;&amp; !hasBody ?<br />
div.childNodes :<br />
[];</p>
<p>for ( j = tbody.length &#8211; 1; j &gt;= 0 ; &#8211;j ) {<br />
if ( jQuery.nodeName( tbody[ j ], &#8220;tbody&#8221; ) &amp;&amp; !tbody[ j ].childNodes.length ) {<br />
tbody[ j ].parentNode.removeChild( tbody[ j ] );<br />
}<br />
}<br />
}</p>
<p>// IE completely kills leading whitespace when innerHTML is used<br />
if ( !jQuery.support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) {<br />
div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );<br />
}</p>
<p>elem = div.childNodes;<br />
}<br />
}</p>
<p>// Resets defaultChecked for any radios and checkboxes<br />
// about to be appended to the DOM in IE 6/7 (#8060)<br />
var len;<br />
if ( !jQuery.support.appendChecked ) {<br />
if ( elem[0] &amp;&amp; typeof (len = elem.length) === &#8220;number&#8221; ) {<br />
for ( j = 0; j &lt; len; j++ ) {<br />
findInputs( elem[j] );<br />
}<br />
} else {<br />
findInputs( elem );<br />
}<br />
}</p>
<p>if ( elem.nodeType ) {<br />
ret.push( elem );<br />
} else {<br />
ret = jQuery.merge( ret, elem );<br />
}<br />
}</p>
<p>if ( fragment ) {<br />
checkScriptType = function( elem ) {<br />
return !elem.type || rscriptType.test( elem.type );<br />
};<br />
for ( i = 0; ret[i]; i++ ) {<br />
if ( scripts &amp;&amp; jQuery.nodeName( ret[i], &#8220;script&#8221; ) &amp;&amp; (!ret[i].type || ret[i].type.toLowerCase() === &#8220;text/javascript&#8221;) ) {<br />
scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );</p>
<p>} else {<br />
if ( ret[i].nodeType === 1 ) {<br />
var jsTags = jQuery.grep( ret[i].getElementsByTagName( &#8220;script&#8221; ), checkScriptType );</p>
<p>ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );<br />
}<br />
fragment.appendChild( ret[i] );<br />
}<br />
}<br />
}</p>
<p>return ret;<br />
},</p>
<p>cleanData: function( elems ) {<br />
var data, id,<br />
cache = jQuery.cache,<br />
special = jQuery.event.special,<br />
deleteExpando = jQuery.support.deleteExpando;</p>
<p>for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {<br />
if ( elem.nodeName &amp;&amp; jQuery.noData[elem.nodeName.toLowerCase()] ) {<br />
continue;<br />
}</p>
<p>id = elem[ jQuery.expando ];</p>
<p>if ( id ) {<br />
data = cache[ id ];</p>
<p>if ( data &amp;&amp; data.events ) {<br />
for ( var type in data.events ) {<br />
if ( special[ type ] ) {<br />
jQuery.event.remove( elem, type );</p>
<p>// This is a shortcut to avoid jQuery.event.remove&#8217;s overhead<br />
} else {<br />
jQuery.removeEvent( elem, type, data.handle );<br />
}<br />
}</p>
<p>// Null the DOM reference to avoid IE6/7/8 leak (#7054)<br />
if ( data.handle ) {<br />
data.handle.elem = null;<br />
}<br />
}</p>
<p>if ( deleteExpando ) {<br />
delete elem[ jQuery.expando ];</p>
<p>} else if ( elem.removeAttribute ) {<br />
elem.removeAttribute( jQuery.expando );<br />
}</p>
<p>delete cache[ id ];<br />
}<br />
}<br />
}<br />
});</p>
<p>function evalScript( i, elem ) {<br />
if ( elem.src ) {<br />
jQuery.ajax({<br />
url: elem.src,<br />
async: false,<br />
dataType: &#8220;script&#8221;<br />
});<br />
} else {<br />
jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || &#8220;&#8221; ).replace( rcleanScript, &#8220;/*$0*/&#8221; ) );<br />
}</p>
<p>if ( elem.parentNode ) {<br />
elem.parentNode.removeChild( elem );<br />
}<br />
}</p>
<p>var ralpha = /alpha\([^)]*\)/i,<br />
ropacity = /opacity=([^)]*)/,<br />
// fixed for IE9, see #8346<br />
rupper = /([A-Z]|^ms)/g,<br />
rnumpx = /^-?\d+(?:px)?$/i,<br />
rnum = /^-?\d/,<br />
rrelNum = /^([\-+])=([\-+.\de]+)/,</p>
<p>cssShow = { position: &#8220;absolute&#8221;, visibility: &#8220;hidden&#8221;, display: &#8220;block&#8221; },<br />
cssWidth = [ "Left", "Right" ],<br />
cssHeight = [ "Top", "Bottom" ],<br />
curCSS,</p>
<p>getComputedStyle,<br />
currentStyle;</p>
<p>jQuery.fn.css = function( name, value ) {<br />
// Setting &#8216;undefined&#8217; is a no-op<br />
if ( arguments.length === 2 &amp;&amp; value === undefined ) {<br />
return this;<br />
}</p>
<p>return jQuery.access( this, name, value, true, function( elem, name, value ) {<br />
return value !== undefined ?<br />
jQuery.style( elem, name, value ) :<br />
jQuery.css( elem, name );<br />
});<br />
};</p>
<p>jQuery.extend({<br />
// Add in style property hooks for overriding the default<br />
// behavior of getting and setting a style property<br />
cssHooks: {<br />
opacity: {<br />
get: function( elem, computed ) {<br />
if ( computed ) {<br />
// We should always get a number back from opacity<br />
var ret = curCSS( elem, &#8220;opacity&#8221;, &#8220;opacity&#8221; );<br />
return ret === &#8220;&#8221; ? &#8220;1&#8243; : ret;</p>
<p>} else {<br />
return elem.style.opacity;<br />
}<br />
}<br />
}<br />
},</p>
<p>// Exclude the following css properties to add px<br />
cssNumber: {<br />
&#8220;fillOpacity&#8221;: true,<br />
&#8220;fontWeight&#8221;: true,<br />
&#8220;lineHeight&#8221;: true,<br />
&#8220;opacity&#8221;: true,<br />
&#8220;orphans&#8221;: true,<br />
&#8220;widows&#8221;: true,<br />
&#8220;zIndex&#8221;: true,<br />
&#8220;zoom&#8221;: true<br />
},</p>
<p>// Add in properties whose names you wish to fix before<br />
// setting or getting the value<br />
cssProps: {<br />
// normalize float css property<br />
&#8220;float&#8221;: jQuery.support.cssFloat ? &#8220;cssFloat&#8221; : &#8220;styleFloat&#8221;<br />
},</p>
<p>// Get and set the style property on a DOM Node<br />
style: function( elem, name, value, extra ) {<br />
// Don&#8217;t set styles on text and comment nodes<br />
if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {<br />
return;<br />
}</p>
<p>// Make sure that we&#8217;re working with the right name<br />
var ret, type, origName = jQuery.camelCase( name ),<br />
style = elem.style, hooks = jQuery.cssHooks[ origName ];</p>
<p>name = jQuery.cssProps[ origName ] || origName;</p>
<p>// Check if we&#8217;re setting a value<br />
if ( value !== undefined ) {<br />
type = typeof value;</p>
<p>// convert relative number strings (+= or -=) to relative numbers. #7345<br />
if ( type === &#8220;string&#8221; &amp;&amp; (ret = rrelNum.exec( value )) ) {<br />
value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );<br />
// Fixes bug #9237<br />
type = &#8220;number&#8221;;<br />
}</p>
<p>// Make sure that NaN and null values aren&#8217;t set. See: #7116<br />
if ( value == null || type === &#8220;number&#8221; &amp;&amp; isNaN( value ) ) {<br />
return;<br />
}</p>
<p>// If a number was passed in, add &#8216;px&#8217; to the (except for certain CSS properties)<br />
if ( type === &#8220;number&#8221; &amp;&amp; !jQuery.cssNumber[ origName ] ) {<br />
value += &#8220;px&#8221;;<br />
}</p>
<p>// If a hook was provided, use that value, otherwise just set the specified value<br />
if ( !hooks || !(&#8220;set&#8221; in hooks) || (value = hooks.set( elem, value )) !== undefined ) {<br />
// Wrapped to prevent IE from throwing errors when &#8216;invalid&#8217; values are provided<br />
// Fixes bug #5509<br />
try {<br />
style[ name ] = value;<br />
} catch(e) {}<br />
}</p>
<p>} else {<br />
// If a hook was provided get the non-computed value from there<br />
if ( hooks &amp;&amp; &#8220;get&#8221; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) {<br />
return ret;<br />
}</p>
<p>// Otherwise just get the value from the style object<br />
return style[ name ];<br />
}<br />
},</p>
<p>css: function( elem, name, extra ) {<br />
var ret, hooks;</p>
<p>// Make sure that we&#8217;re working with the right name<br />
name = jQuery.camelCase( name );<br />
hooks = jQuery.cssHooks[ name ];<br />
name = jQuery.cssProps[ name ] || name;</p>
<p>// cssFloat needs a special treatment<br />
if ( name === &#8220;cssFloat&#8221; ) {<br />
name = &#8220;float&#8221;;<br />
}</p>
<p>// If a hook was provided get the computed value from there<br />
if ( hooks &amp;&amp; &#8220;get&#8221; in hooks &amp;&amp; (ret = hooks.get( elem, true, extra )) !== undefined ) {<br />
return ret;</p>
<p>// Otherwise, if a way to get the computed value exists, use that<br />
} else if ( curCSS ) {<br />
return curCSS( elem, name );<br />
}<br />
},</p>
<p>// A method for quickly swapping in/out CSS properties to get correct calculations<br />
swap: function( elem, options, callback ) {<br />
var old = {};</p>
<p>// Remember the old values, and insert the new ones<br />
for ( var name in options ) {<br />
old[ name ] = elem.style[ name ];<br />
elem.style[ name ] = options[ name ];<br />
}</p>
<p>callback.call( elem );</p>
<p>// Revert the old values<br />
for ( name in options ) {<br />
elem.style[ name ] = old[ name ];<br />
}<br />
}<br />
});</p>
<p>// DEPRECATED, Use jQuery.css() instead<br />
jQuery.curCSS = jQuery.css;</p>
<p>jQuery.each(["height", "width"], function( i, name ) {<br />
jQuery.cssHooks[ name ] = {<br />
get: function( elem, computed, extra ) {<br />
var val;</p>
<p>if ( computed ) {<br />
if ( elem.offsetWidth !== 0 ) {<br />
return getWH( elem, name, extra );<br />
} else {<br />
jQuery.swap( elem, cssShow, function() {<br />
val = getWH( elem, name, extra );<br />
});<br />
}</p>
<p>return val;<br />
}<br />
},</p>
<p>set: function( elem, value ) {<br />
if ( rnumpx.test( value ) ) {<br />
// ignore negative width and height values #1599<br />
value = parseFloat( value );</p>
<p>if ( value &gt;= 0 ) {<br />
return value + &#8220;px&#8221;;<br />
}</p>
<p>} else {<br />
return value;<br />
}<br />
}<br />
};<br />
});</p>
<p>if ( !jQuery.support.opacity ) {<br />
jQuery.cssHooks.opacity = {<br />
get: function( elem, computed ) {<br />
// IE uses filters for opacity<br />
return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &#8220;&#8221; ) ?<br />
( parseFloat( RegExp.$1 ) / 100 ) + &#8220;&#8221; :<br />
computed ? &#8220;1&#8243; : &#8220;&#8221;;<br />
},</p>
<p>set: function( elem, value ) {<br />
var style = elem.style,<br />
currentStyle = elem.currentStyle,<br />
opacity = jQuery.isNumeric( value ) ? &#8220;alpha(opacity=&#8221; + value * 100 + &#8220;)&#8221; : &#8220;&#8221;,<br />
filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &#8220;&#8221;;</p>
<p>// IE has trouble with opacity if it does not have layout<br />
// Force it by setting the zoom level<br />
style.zoom = 1;</p>
<p>// if setting opacity to 1, and no other filters exist &#8211; attempt to remove filter attribute #6652<br />
if ( value &gt;= 1 &amp;&amp; jQuery.trim( filter.replace( ralpha, &#8220;&#8221; ) ) === &#8220;&#8221; ) {</p>
<p>// Setting style.filter to null, &#8220;&#8221; &amp; &#8221; &#8221; still leave &#8220;filter:&#8221; in the cssText<br />
// if &#8220;filter:&#8221; is present at all, clearType is disabled, we want to avoid this<br />
// style.removeAttribute is IE Only, but so apparently is this code path&#8230;<br />
style.removeAttribute( &#8220;filter&#8221; );</p>
<p>// if there there is no filter style applied in a css rule, we are done<br />
if ( currentStyle &amp;&amp; !currentStyle.filter ) {<br />
return;<br />
}<br />
}</p>
<p>// otherwise, set new filter values<br />
style.filter = ralpha.test( filter ) ?<br />
filter.replace( ralpha, opacity ) :<br />
filter + &#8221; &#8221; + opacity;<br />
}<br />
};<br />
}</p>
<p>jQuery(function() {<br />
// This hook cannot be added until DOM ready because the support test<br />
// for it is not run until after DOM ready<br />
if ( !jQuery.support.reliableMarginRight ) {<br />
jQuery.cssHooks.marginRight = {<br />
get: function( elem, computed ) {<br />
// WebKit Bug 13343 &#8211; getComputedStyle returns wrong value for margin-right<br />
// Work around by temporarily setting element display to inline-block<br />
var ret;<br />
jQuery.swap( elem, { &#8220;display&#8221;: &#8220;inline-block&#8221; }, function() {<br />
if ( computed ) {<br />
ret = curCSS( elem, &#8220;margin-right&#8221;, &#8220;marginRight&#8221; );<br />
} else {<br />
ret = elem.style.marginRight;<br />
}<br />
});<br />
return ret;<br />
}<br />
};<br />
}<br />
});</p>
<p>if ( document.defaultView &amp;&amp; document.defaultView.getComputedStyle ) {<br />
getComputedStyle = function( elem, name ) {<br />
var ret, defaultView, computedStyle;</p>
<p>name = name.replace( rupper, &#8220;-$1&#8243; ).toLowerCase();</p>
<p>if ( !(defaultView = elem.ownerDocument.defaultView) ) {<br />
return undefined;<br />
}</p>
<p>if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {<br />
ret = computedStyle.getPropertyValue( name );<br />
if ( ret === &#8220;&#8221; &amp;&amp; !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {<br />
ret = jQuery.style( elem, name );<br />
}<br />
}</p>
<p>return ret;<br />
};<br />
}</p>
<p>if ( document.documentElement.currentStyle ) {<br />
currentStyle = function( elem, name ) {<br />
var left, rsLeft, uncomputed,<br />
ret = elem.currentStyle &amp;&amp; elem.currentStyle[ name ],<br />
style = elem.style;</p>
<p>// Avoid setting ret to empty string here<br />
// so we don&#8217;t default to auto<br />
if ( ret === null &amp;&amp; style &amp;&amp; (uncomputed = style[ name ]) ) {<br />
ret = uncomputed;<br />
}</p>
<p>// From the awesome hack by Dean Edwards<br />
// <a href="http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291" rel="nofollow">http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291</a></p>
<p>// If we&#8217;re not dealing with a regular pixel number<br />
// but a number that has a weird ending, we need to convert it to pixels<br />
if ( !rnumpx.test( ret ) &amp;&amp; rnum.test( ret ) ) {</p>
<p>// Remember the original values<br />
left = style.left;<br />
rsLeft = elem.runtimeStyle &amp;&amp; elem.runtimeStyle.left;</p>
<p>// Put in the new values to get a computed value out<br />
if ( rsLeft ) {<br />
elem.runtimeStyle.left = elem.currentStyle.left;<br />
}<br />
style.left = name === &#8220;fontSize&#8221; ? &#8220;1em&#8221; : ( ret || 0 );<br />
ret = style.pixelLeft + &#8220;px&#8221;;</p>
<p>// Revert the changed values<br />
style.left = left;<br />
if ( rsLeft ) {<br />
elem.runtimeStyle.left = rsLeft;<br />
}<br />
}</p>
<p>return ret === &#8220;&#8221; ? &#8220;auto&#8221; : ret;<br />
};<br />
}</p>
<p>curCSS = getComputedStyle || currentStyle;</p>
<p>function getWH( elem, name, extra ) {</p>
<p>// Start with offset property<br />
var val = name === &#8220;width&#8221; ? elem.offsetWidth : elem.offsetHeight,<br />
which = name === &#8220;width&#8221; ? cssWidth : cssHeight;</p>
<p>if ( val &gt; 0 ) {<br />
if ( extra !== &#8220;border&#8221; ) {<br />
jQuery.each( which, function() {<br />
if ( !extra ) {<br />
val -= parseFloat( jQuery.css( elem, &#8220;padding&#8221; + this ) ) || 0;<br />
}<br />
if ( extra === &#8220;margin&#8221; ) {<br />
val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;<br />
} else {<br />
val -= parseFloat( jQuery.css( elem, &#8220;border&#8221; + this + &#8220;Width&#8221; ) ) || 0;<br />
}<br />
});<br />
}</p>
<p>return val + &#8220;px&#8221;;<br />
}</p>
<p>// Fall back to computed then uncomputed css if necessary<br />
val = curCSS( elem, name, name );<br />
if ( val &lt; 0 || val == null ) {<br />
val = elem.style[ name ] || 0;<br />
}<br />
// Normalize &#8220;&#8221;, auto, and prepare for extra<br />
val = parseFloat( val ) || 0;</p>
<p>// Add padding, border, margin<br />
if ( extra ) {<br />
jQuery.each( which, function() {<br />
val += parseFloat( jQuery.css( elem, &#8220;padding&#8221; + this ) ) || 0;<br />
if ( extra !== &#8220;padding&#8221; ) {<br />
val += parseFloat( jQuery.css( elem, &#8220;border&#8221; + this + &#8220;Width&#8221; ) ) || 0;<br />
}<br />
if ( extra === &#8220;margin&#8221; ) {<br />
val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;<br />
}<br />
});<br />
}</p>
<p>return val + &#8220;px&#8221;;<br />
}</p>
<p>if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {<br />
jQuery.expr.filters.hidden = function( elem ) {<br />
var width = elem.offsetWidth,<br />
height = elem.offsetHeight;</p>
<p>return ( width === 0 &amp;&amp; height === 0 ) || (!jQuery.support.reliableHiddenOffsets &amp;&amp; ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem, &#8220;display&#8221; )) === &#8220;none&#8221;);<br />
};</p>
<p>jQuery.expr.filters.visible = function( elem ) {<br />
return !jQuery.expr.filters.hidden( elem );<br />
};<br />
}</p>
<p>var r20 = /%20/g,<br />
rbracket = /\[\]$/,<br />
rCRLF = /\r?\n/g,<br />
rhash = /#.*$/,<br />
rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL<br />
rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,<br />
// #7653, #8125, #8152: local protocol detection<br />
rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,<br />
rnoContent = /^(?:GET|HEAD)$/,<br />
rprotocol = /^\/\//,<br />
rquery = /\?/,<br />
rscript = /&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi,<br />
rselectTextarea = /^(?:select|textarea)/i,<br />
rspacesAjax = /\s+/,<br />
rts = /([?&amp;])_=[^&amp;]*/,<br />
rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,</p>
<p>// Keep a copy of the old load method<br />
_load = jQuery.fn.load,</p>
<p>/* Prefilters<br />
* 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)<br />
* 2) These are called:<br />
*    &#8211; BEFORE asking for a transport<br />
*    &#8211; AFTER param serialization (s.data is a string if s.processData is true)<br />
* 3) key is the dataType<br />
* 4) the catchall symbol &#8220;*&#8221; can be used<br />
* 5) execution will start with transport dataType and THEN continue down to &#8220;*&#8221; if needed<br />
*/<br />
prefilters = {},</p>
<p>/* Transports bindings<br />
* 1) key is the dataType<br />
* 2) the catchall symbol &#8220;*&#8221; can be used<br />
* 3) selection will start with transport dataType and THEN go to &#8220;*&#8221; if needed<br />
*/<br />
transports = {},</p>
<p>// Document location<br />
ajaxLocation,</p>
<p>// Document location segments<br />
ajaxLocParts,</p>
<p>// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression<br />
allTypes = ["*/"] + ["*"];</p>
<p>// #8138, IE may throw an exception when accessing<br />
// a field from window.location if document.domain has been set<br />
try {<br />
ajaxLocation = location.href;<br />
} catch( e ) {<br />
// Use the href attribute of an A element<br />
// since IE will modify it given document.location<br />
ajaxLocation = document.createElement( &#8220;a&#8221; );<br />
ajaxLocation.href = &#8220;&#8221;;<br />
ajaxLocation = ajaxLocation.href;<br />
}</p>
<p>// Segment location into parts<br />
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];</p>
<p>// Base &#8220;constructor&#8221; for jQuery.ajaxPrefilter and jQuery.ajaxTransport<br />
function addToPrefiltersOrTransports( structure ) {</p>
<p>// dataTypeExpression is optional and defaults to &#8220;*&#8221;<br />
return function( dataTypeExpression, func ) {</p>
<p>if ( typeof dataTypeExpression !== &#8220;string&#8221; ) {<br />
func = dataTypeExpression;<br />
dataTypeExpression = &#8220;*&#8221;;<br />
}</p>
<p>if ( jQuery.isFunction( func ) ) {<br />
var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),<br />
i = 0,<br />
length = dataTypes.length,<br />
dataType,<br />
list,<br />
placeBefore;</p>
<p>// For each dataType in the dataTypeExpression<br />
for ( ; i &lt; length; i++ ) {<br />
dataType = dataTypes[ i ];<br />
// We control if we&#8217;re asked to add before<br />
// any existing element<br />
placeBefore = /^\+/.test( dataType );<br />
if ( placeBefore ) {<br />
dataType = dataType.substr( 1 ) || &#8220;*&#8221;;<br />
}<br />
list = structure[ dataType ] = structure[ dataType ] || [];<br />
// then we add to the structure accordingly<br />
list[ placeBefore ? "unshift" : "push" ]( func );<br />
}<br />
}<br />
};<br />
}</p>
<p>// Base inspection function for prefilters and transports<br />
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,<br />
dataType /* internal */, inspected /* internal */ ) {</p>
<p>dataType = dataType || options.dataTypes[ 0 ];<br />
inspected = inspected || {};</p>
<p>inspected[ dataType ] = true;</p>
<p>var list = structure[ dataType ],<br />
i = 0,<br />
length = list ? list.length : 0,<br />
executeOnly = ( structure === prefilters ),<br />
selection;</p>
<p>for ( ; i &lt; length &amp;&amp; ( executeOnly || !selection ); i++ ) {<br />
selection = list[ i ]( options, originalOptions, jqXHR );<br />
// If we got redirected to another dataType<br />
// we try there if executing only and not done already<br />
if ( typeof selection === &#8220;string&#8221; ) {<br />
if ( !executeOnly || inspected[ selection ] ) {<br />
selection = undefined;<br />
} else {<br />
options.dataTypes.unshift( selection );<br />
selection = inspectPrefiltersOrTransports(<br />
structure, options, originalOptions, jqXHR, selection, inspected );<br />
}<br />
}<br />
}<br />
// If we&#8217;re only executing or nothing was selected<br />
// we try the catchall dataType if not done already<br />
if ( ( executeOnly || !selection ) &amp;&amp; !inspected[ "*" ] ) {<br />
selection = inspectPrefiltersOrTransports(<br />
structure, options, originalOptions, jqXHR, &#8220;*&#8221;, inspected );<br />
}<br />
// unnecessary when only executing (prefilters)<br />
// but it&#8217;ll be ignored by the caller in that case<br />
return selection;<br />
}</p>
<p>// A special extend for ajax options<br />
// that takes &#8220;flat&#8221; options (not to be deep extended)<br />
// Fixes #9887<br />
function ajaxExtend( target, src ) {<br />
var key, deep,<br />
flatOptions = jQuery.ajaxSettings.flatOptions || {};<br />
for ( key in src ) {<br />
if ( src[ key ] !== undefined ) {<br />
( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];<br />
}<br />
}<br />
if ( deep ) {<br />
jQuery.extend( true, target, deep );<br />
}<br />
}</p>
<p>jQuery.fn.extend({<br />
load: function( url, params, callback ) {<br />
if ( typeof url !== &#8220;string&#8221; &amp;&amp; _load ) {<br />
return _load.apply( this, arguments );</p>
<p>// Don&#8217;t do a request if no elements are being requested<br />
} else if ( !this.length ) {<br />
return this;<br />
}</p>
<p>var off = url.indexOf( &#8221; &#8221; );<br />
if ( off &gt;= 0 ) {<br />
var selector = url.slice( off, url.length );<br />
url = url.slice( 0, off );<br />
}</p>
<p>// Default to a GET request<br />
var type = &#8220;GET&#8221;;</p>
<p>// If the second parameter was provided<br />
if ( params ) {<br />
// If it&#8217;s a function<br />
if ( jQuery.isFunction( params ) ) {<br />
// We assume that it&#8217;s the callback<br />
callback = params;<br />
params = undefined;</p>
<p>// Otherwise, build a param string<br />
} else if ( typeof params === &#8220;object&#8221; ) {<br />
params = jQuery.param( params, jQuery.ajaxSettings.traditional );<br />
type = &#8220;POST&#8221;;<br />
}<br />
}</p>
<p>var self = this;</p>
<p>// Request the remote document<br />
jQuery.ajax({<br />
url: url,<br />
type: type,<br />
dataType: &#8220;html&#8221;,<br />
data: params,<br />
// Complete callback (responseText is used internally)<br />
complete: function( jqXHR, status, responseText ) {<br />
// Store the response as specified by the jqXHR object<br />
responseText = jqXHR.responseText;<br />
// If successful, inject the HTML into all the matched elements<br />
if ( jqXHR.isResolved() ) {<br />
// #4825: Get the actual response in case<br />
// a dataFilter is present in ajaxSettings<br />
jqXHR.done(function( r ) {<br />
responseText = r;<br />
});<br />
// See if a selector was specified<br />
self.html( selector ?<br />
// Create a dummy div to hold the results<br />
jQuery(&#8220;&lt;div&gt;&#8221;)<br />
// inject the contents of the document in, removing the scripts<br />
// to avoid any &#8216;Permission Denied&#8217; errors in IE<br />
.append(responseText.replace(rscript, &#8220;&#8221;))</p>
<p>// Locate the specified elements<br />
.find(selector) :</p>
<p>// If not, just inject the full result<br />
responseText );<br />
}</p>
<p>if ( callback ) {<br />
self.each( callback, [ responseText, status, jqXHR ] );<br />
}<br />
}<br />
});</p>
<p>return this;<br />
},</p>
<p>serialize: function() {<br />
return jQuery.param( this.serializeArray() );<br />
},</p>
<p>serializeArray: function() {<br />
return this.map(function(){<br />
return this.elements ? jQuery.makeArray( this.elements ) : this;<br />
})<br />
.filter(function(){<br />
return this.name &amp;&amp; !this.disabled &amp;&amp;<br />
( this.checked || rselectTextarea.test( this.nodeName ) ||<br />
rinput.test( this.type ) );<br />
})<br />
.map(function( i, elem ){<br />
var val = jQuery( this ).val();</p>
<p>return val == null ?<br />
null :<br />
jQuery.isArray( val ) ?<br />
jQuery.map( val, function( val, i ){<br />
return { name: elem.name, value: val.replace( rCRLF, &#8220;\r\n&#8221; ) };<br />
}) :<br />
{ name: elem.name, value: val.replace( rCRLF, &#8220;\r\n&#8221; ) };<br />
}).get();<br />
}<br />
});</p>
<p>// Attach a bunch of functions for handling common AJAX events<br />
jQuery.each( &#8220;ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend&#8221;.split( &#8221; &#8221; ), function( i, o ){<br />
jQuery.fn[ o ] = function( f ){<br />
return this.bind( o, f );<br />
};<br />
});</p>
<p>jQuery.each( [ "get", "post" ], function( i, method ) {<br />
jQuery[ method ] = function( url, data, callback, type ) {<br />
// shift arguments if data argument was omitted<br />
if ( jQuery.isFunction( data ) ) {<br />
type = type || callback;<br />
callback = data;<br />
data = undefined;<br />
}</p>
<p>return jQuery.ajax({<br />
type: method,<br />
url: url,<br />
data: data,<br />
success: callback,<br />
dataType: type<br />
});<br />
};<br />
});</p>
<p>jQuery.extend({</p>
<p>getScript: function( url, callback ) {<br />
return jQuery.get( url, undefined, callback, &#8220;script&#8221; );<br />
},</p>
<p>getJSON: function( url, data, callback ) {<br />
return jQuery.get( url, data, callback, &#8220;json&#8221; );<br />
},</p>
<p>// Creates a full fledged settings object into target<br />
// with both ajaxSettings and settings fields.<br />
// If target is omitted, writes into ajaxSettings.<br />
ajaxSetup: function( target, settings ) {<br />
if ( settings ) {<br />
// Building a settings object<br />
ajaxExtend( target, jQuery.ajaxSettings );<br />
} else {<br />
// Extending ajaxSettings<br />
settings = target;<br />
target = jQuery.ajaxSettings;<br />
}<br />
ajaxExtend( target, settings );<br />
return target;<br />
},</p>
<p>ajaxSettings: {<br />
url: ajaxLocation,<br />
isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),<br />
global: true,<br />
type: &#8220;GET&#8221;,<br />
contentType: &#8220;application/x-www-form-urlencoded&#8221;,<br />
processData: true,<br />
async: true,<br />
/*<br />
timeout: 0,<br />
data: null,<br />
dataType: null,<br />
username: null,<br />
password: null,<br />
cache: null,<br />
traditional: false,<br />
headers: {},<br />
*/</p>
<p>accepts: {<br />
xml: &#8220;application/xml, text/xml&#8221;,<br />
html: &#8220;text/html&#8221;,<br />
text: &#8220;text/plain&#8221;,<br />
json: &#8220;application/json, text/javascript&#8221;,<br />
&#8220;*&#8221;: allTypes<br />
},</p>
<p>contents: {<br />
xml: /xml/,<br />
html: /html/,<br />
json: /json/<br />
},</p>
<p>responseFields: {<br />
xml: &#8220;responseXML&#8221;,<br />
text: &#8220;responseText&#8221;<br />
},</p>
<p>// List of data converters<br />
// 1) key format is &#8220;source_type destination_type&#8221; (a single space in-between)<br />
// 2) the catchall symbol &#8220;*&#8221; can be used for source_type<br />
converters: {</p>
<p>// Convert anything to text<br />
&#8220;* text&#8221;: window.String,</p>
<p>// Text to html (true = no transformation)<br />
&#8220;text html&#8221;: true,</p>
<p>// Evaluate text as a json expression<br />
&#8220;text json&#8221;: jQuery.parseJSON,</p>
<p>// Parse text as xml<br />
&#8220;text xml&#8221;: jQuery.parseXML<br />
},</p>
<p>// For options that shouldn&#8217;t be deep extended:<br />
// you can add your own custom options here if<br />
// and when you create one that shouldn&#8217;t be<br />
// deep extended (see ajaxExtend)<br />
flatOptions: {<br />
context: true,<br />
url: true<br />
}<br />
},</p>
<p>ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),<br />
ajaxTransport: addToPrefiltersOrTransports( transports ),</p>
<p>// Main method<br />
ajax: function( url, options ) {</p>
<p>// If url is an object, simulate pre-1.5 signature<br />
if ( typeof url === &#8220;object&#8221; ) {<br />
options = url;<br />
url = undefined;<br />
}</p>
<p>// Force options to be an object<br />
options = options || {};</p>
<p>var // Create the final options object<br />
s = jQuery.ajaxSetup( {}, options ),<br />
// Callbacks context<br />
callbackContext = s.context || s,<br />
// Context for global events<br />
// It&#8217;s the callbackContext if one was provided in the options<br />
// and if it&#8217;s a DOM node or a jQuery collection<br />
globalEventContext = callbackContext !== s &amp;&amp;<br />
( callbackContext.nodeType || callbackContext instanceof jQuery ) ?<br />
jQuery( callbackContext ) : jQuery.event,<br />
// Deferreds<br />
deferred = jQuery.Deferred(),<br />
completeDeferred = jQuery.Callbacks( &#8220;once memory&#8221; ),<br />
// Status-dependent callbacks<br />
statusCode = s.statusCode || {},<br />
// ifModified key<br />
ifModifiedKey,<br />
// Headers (they are sent all at once)<br />
requestHeaders = {},<br />
requestHeadersNames = {},<br />
// Response headers<br />
responseHeadersString,<br />
responseHeaders,<br />
// transport<br />
transport,<br />
// timeout handle<br />
timeoutTimer,<br />
// Cross-domain detection vars<br />
parts,<br />
// The jqXHR state<br />
state = 0,<br />
// To know if global events are to be dispatched<br />
fireGlobals,<br />
// Loop variable<br />
i,<br />
// Fake xhr<br />
jqXHR = {</p>
<p>readyState: 0,</p>
<p>// Caches the header<br />
setRequestHeader: function( name, value ) {<br />
if ( !state ) {<br />
var lname = name.toLowerCase();<br />
name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;<br />
requestHeaders[ name ] = value;<br />
}<br />
return this;<br />
},</p>
<p>// Raw string<br />
getAllResponseHeaders: function() {<br />
return state === 2 ? responseHeadersString : null;<br />
},</p>
<p>// Builds headers hashtable if needed<br />
getResponseHeader: function( key ) {<br />
var match;<br />
if ( state === 2 ) {<br />
if ( !responseHeaders ) {<br />
responseHeaders = {};<br />
while( ( match = rheaders.exec( responseHeadersString ) ) ) {<br />
responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];<br />
}<br />
}<br />
match = responseHeaders[ key.toLowerCase() ];<br />
}<br />
return match === undefined ? null : match;<br />
},</p>
<p>// Overrides response content-type header<br />
overrideMimeType: function( type ) {<br />
if ( !state ) {<br />
s.mimeType = type;<br />
}<br />
return this;<br />
},</p>
<p>// Cancel the request<br />
abort: function( statusText ) {<br />
statusText = statusText || &#8220;abort&#8221;;<br />
if ( transport ) {<br />
transport.abort( statusText );<br />
}<br />
done( 0, statusText );<br />
return this;<br />
}<br />
};</p>
<p>// Callback for when everything is done<br />
// It is defined here because jslint complains if it is declared<br />
// at the end of the function (which would be more logical and readable)<br />
function done( status, nativeStatusText, responses, headers ) {</p>
<p>// Called once<br />
if ( state === 2 ) {<br />
return;<br />
}</p>
<p>// State is &#8220;done&#8221; now<br />
state = 2;</p>
<p>// Clear timeout if it exists<br />
if ( timeoutTimer ) {<br />
clearTimeout( timeoutTimer );<br />
}</p>
<p>// Dereference transport for early garbage collection<br />
// (no matter how long the jqXHR object will be used)<br />
transport = undefined;</p>
<p>// Cache response headers<br />
responseHeadersString = headers || &#8220;&#8221;;</p>
<p>// Set readyState<br />
jqXHR.readyState = status &gt; 0 ? 4 : 0;</p>
<p>var isSuccess,<br />
success,<br />
error,<br />
statusText = nativeStatusText,<br />
response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,<br />
lastModified,<br />
etag;</p>
<p>// If successful, handle type chaining<br />
if ( status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304 ) {</p>
<p>// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.<br />
if ( s.ifModified ) {</p>
<p>if ( ( lastModified = jqXHR.getResponseHeader( &#8220;Last-Modified&#8221; ) ) ) {<br />
jQuery.lastModified[ ifModifiedKey ] = lastModified;<br />
}<br />
if ( ( etag = jqXHR.getResponseHeader( &#8220;Etag&#8221; ) ) ) {<br />
jQuery.etag[ ifModifiedKey ] = etag;<br />
}<br />
}</p>
<p>// If not modified<br />
if ( status === 304 ) {</p>
<p>statusText = &#8220;notmodified&#8221;;<br />
isSuccess = true;</p>
<p>// If we have data<br />
} else {</p>
<p>try {<br />
success = ajaxConvert( s, response );<br />
statusText = &#8220;success&#8221;;<br />
isSuccess = true;<br />
} catch(e) {<br />
// We have a parsererror<br />
statusText = &#8220;parsererror&#8221;;<br />
error = e;<br />
}<br />
}<br />
} else {<br />
// We extract error from statusText<br />
// then normalize statusText and status for non-aborts<br />
error = statusText;<br />
if ( !statusText || status ) {<br />
statusText = &#8220;error&#8221;;<br />
if ( status &lt; 0 ) {<br />
status = 0;<br />
}<br />
}<br />
}</p>
<p>// Set data for the fake xhr object<br />
jqXHR.status = status;<br />
jqXHR.statusText = &#8220;&#8221; + ( nativeStatusText || statusText );</p>
<p>// Success/Error<br />
if ( isSuccess ) {<br />
deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );<br />
} else {<br />
deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );<br />
}</p>
<p>// Status-dependent callbacks<br />
jqXHR.statusCode( statusCode );<br />
statusCode = undefined;</p>
<p>if ( fireGlobals ) {<br />
globalEventContext.trigger( &#8220;ajax&#8221; + ( isSuccess ? &#8220;Success&#8221; : &#8220;Error&#8221; ),<br />
[ jqXHR, s, isSuccess ? success : error ] );<br />
}</p>
<p>// Complete<br />
completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );</p>
<p>if ( fireGlobals ) {<br />
globalEventContext.trigger( &#8220;ajaxComplete&#8221;, [ jqXHR, s ] );<br />
// Handle the global AJAX counter<br />
if ( !( &#8211;jQuery.active ) ) {<br />
jQuery.event.trigger( &#8220;ajaxStop&#8221; );<br />
}<br />
}<br />
}</p>
<p>// Attach deferreds<br />
deferred.promise( jqXHR );<br />
jqXHR.success = jqXHR.done;<br />
jqXHR.error = jqXHR.fail;<br />
jqXHR.complete = completeDeferred.add;</p>
<p>// Status-dependent callbacks<br />
jqXHR.statusCode = function( map ) {<br />
if ( map ) {<br />
var tmp;<br />
if ( state &lt; 2 ) {<br />
for ( tmp in map ) {<br />
statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];<br />
}<br />
} else {<br />
tmp = map[ jqXHR.status ];<br />
jqXHR.then( tmp, tmp );<br />
}<br />
}<br />
return this;<br />
};</p>
<p>// Remove hash character (#7531: and string promotion)<br />
// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)<br />
// We also use the url parameter if available<br />
s.url = ( ( url || s.url ) + &#8220;&#8221; ).replace( rhash, &#8220;&#8221; ).replace( rprotocol, ajaxLocParts[ 1 ] + &#8220;//&#8221; );</p>
<p>// Extract dataTypes list<br />
s.dataTypes = jQuery.trim( s.dataType || &#8220;*&#8221; ).toLowerCase().split( rspacesAjax );</p>
<p>// Determine if a cross-domain request is in order<br />
if ( s.crossDomain == null ) {<br />
parts = rurl.exec( s.url.toLowerCase() );<br />
s.crossDomain = !!( parts &amp;&amp;<br />
( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||<br />
( parts[ 3 ] || ( parts[ 1 ] === &#8220;http:&#8221; ? 80 : 443 ) ) !=<br />
( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &#8220;http:&#8221; ? 80 : 443 ) ) )<br />
);<br />
}</p>
<p>// Convert data if not already a string<br />
if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &#8220;string&#8221; ) {<br />
s.data = jQuery.param( s.data, s.traditional );<br />
}</p>
<p>// Apply prefilters<br />
inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );</p>
<p>// If request was aborted inside a prefiler, stop there<br />
if ( state === 2 ) {<br />
return false;<br />
}</p>
<p>// We can fire global events as of now if asked to<br />
fireGlobals = s.global;</p>
<p>// Uppercase the type<br />
s.type = s.type.toUpperCase();</p>
<p>// Determine if request has content<br />
s.hasContent = !rnoContent.test( s.type );</p>
<p>// Watch for a new set of requests<br />
if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {<br />
jQuery.event.trigger( &#8220;ajaxStart&#8221; );<br />
}</p>
<p>// More options handling for requests with no content<br />
if ( !s.hasContent ) {</p>
<p>// If data is available, append data to url<br />
if ( s.data ) {<br />
s.url += ( rquery.test( s.url ) ? &#8220;&amp;&#8221; : &#8220;?&#8221; ) + s.data;<br />
// #9682: remove data so that it&#8217;s not used in an eventual retry<br />
delete s.data;<br />
}</p>
<p>// Get ifModifiedKey before adding the anti-cache parameter<br />
ifModifiedKey = s.url;</p>
<p>// Add anti-cache in url if needed<br />
if ( s.cache === false ) {</p>
<p>var ts = jQuery.now(),<br />
// try replacing _= if it is there<br />
ret = s.url.replace( rts, &#8220;$1_=&#8221; + ts );</p>
<p>// if nothing was replaced, add timestamp to the end<br />
s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? &#8220;&amp;&#8221; : &#8220;?&#8221; ) + &#8220;_=&#8221; + ts : &#8220;&#8221; );<br />
}<br />
}</p>
<p>// Set the correct header, if data is being sent<br />
if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {<br />
jqXHR.setRequestHeader( &#8220;Content-Type&#8221;, s.contentType );<br />
}</p>
<p>// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.<br />
if ( s.ifModified ) {<br />
ifModifiedKey = ifModifiedKey || s.url;<br />
if ( jQuery.lastModified[ ifModifiedKey ] ) {<br />
jqXHR.setRequestHeader( &#8220;If-Modified-Since&#8221;, jQuery.lastModified[ ifModifiedKey ] );<br />
}<br />
if ( jQuery.etag[ ifModifiedKey ] ) {<br />
jqXHR.setRequestHeader( &#8220;If-None-Match&#8221;, jQuery.etag[ ifModifiedKey ] );<br />
}<br />
}</p>
<p>// Set the Accepts header for the server, depending on the dataType<br />
jqXHR.setRequestHeader(<br />
&#8220;Accept&#8221;,<br />
s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?<br />
s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &#8220;*&#8221; ? &#8220;, &#8221; + allTypes + &#8220;; q=0.01&#8243; : &#8220;&#8221; ) :<br />
s.accepts[ "*" ]<br />
);</p>
<p>// Check for headers option<br />
for ( i in s.headers ) {<br />
jqXHR.setRequestHeader( i, s.headers[ i ] );<br />
}</p>
<p>// Allow custom headers/mimetypes and early abort<br />
if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {<br />
// Abort if not done already<br />
jqXHR.abort();<br />
return false;</p>
<p>}</p>
<p>// Install callbacks on deferreds<br />
for ( i in { success: 1, error: 1, complete: 1 } ) {<br />
jqXHR[ i ]( s[ i ] );<br />
}</p>
<p>// Get transport<br />
transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );</p>
<p>// If no transport, we auto-abort<br />
if ( !transport ) {<br />
done( -1, &#8220;No Transport&#8221; );<br />
} else {<br />
jqXHR.readyState = 1;<br />
// Send global event<br />
if ( fireGlobals ) {<br />
globalEventContext.trigger( &#8220;ajaxSend&#8221;, [ jqXHR, s ] );<br />
}<br />
// Timeout<br />
if ( s.async &amp;&amp; s.timeout &gt; 0 ) {<br />
timeoutTimer = setTimeout( function(){<br />
jqXHR.abort( &#8220;timeout&#8221; );<br />
}, s.timeout );<br />
}</p>
<p>try {<br />
state = 1;<br />
transport.send( requestHeaders, done );<br />
} catch (e) {<br />
// Propagate exception as error if not done<br />
if ( state &lt; 2 ) {<br />
done( -1, e );<br />
// Simply rethrow otherwise<br />
} else {<br />
jQuery.error( e );<br />
}<br />
}<br />
}</p>
<p>return jqXHR;<br />
},</p>
<p>// Serialize an array of form elements or a set of<br />
// key/values into a query string<br />
param: function( a, traditional ) {<br />
var s = [],<br />
add = function( key, value ) {<br />
// If value is a function, invoke it and return its value<br />
value = jQuery.isFunction( value ) ? value() : value;<br />
s[ s.length ] = encodeURIComponent( key ) + &#8220;=&#8221; + encodeURIComponent( value );<br />
};</p>
<p>// Set traditional to true for jQuery &lt;= 1.3.2 behavior.<br />
if ( traditional === undefined ) {<br />
traditional = jQuery.ajaxSettings.traditional;<br />
}</p>
<p>// If an array was passed in, assume that it is an array of form elements.<br />
if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {<br />
// Serialize the form elements<br />
jQuery.each( a, function() {<br />
add( this.name, this.value );<br />
});</p>
<p>} else {<br />
// If traditional, encode the &#8220;old&#8221; way (the way 1.3.2 or older<br />
// did it), otherwise encode params recursively.<br />
for ( var prefix in a ) {<br />
buildParams( prefix, a[ prefix ], traditional, add );<br />
}<br />
}</p>
<p>// Return the resulting serialization<br />
return s.join( &#8220;&amp;&#8221; ).replace( r20, &#8220;+&#8221; );<br />
}<br />
});</p>
<p>function buildParams( prefix, obj, traditional, add ) {<br />
if ( jQuery.isArray( obj ) ) {<br />
// Serialize array item.<br />
jQuery.each( obj, function( i, v ) {<br />
if ( traditional || rbracket.test( prefix ) ) {<br />
// Treat each array item as a scalar.<br />
add( prefix, v );</p>
<p>} else {<br />
// If array item is non-scalar (array or object), encode its<br />
// numeric index to resolve deserialization ambiguity issues.<br />
// Note that rack (as of 1.0.0) can&#8217;t currently deserialize<br />
// nested arrays properly, and attempting to do so may cause<br />
// a server error. Possible fixes are to modify rack&#8217;s<br />
// deserialization algorithm or to provide an option or flag<br />
// to force array serialization to be shallow.<br />
buildParams( prefix + &#8220;[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]&#8220;, v, traditional, add );<br />
}<br />
});</p>
<p>} else if ( !traditional &amp;&amp; obj != null &amp;&amp; typeof obj === &#8220;object&#8221; ) {<br />
// Serialize object item.<br />
for ( var name in obj ) {<br />
buildParams( prefix + &#8220;[" + name + "]&#8220;, obj[ name ], traditional, add );<br />
}</p>
<p>} else {<br />
// Serialize scalar item.<br />
add( prefix, obj );<br />
}<br />
}</p>
<p>// This is still on the jQuery object&#8230; for now<br />
// Want to move this to jQuery.ajax some day<br />
jQuery.extend({</p>
<p>// Counter for holding the number of active queries<br />
active: 0,</p>
<p>// Last-Modified header cache for next request<br />
lastModified: {},<br />
etag: {}</p>
<p>});</p>
<p>/* Handles responses to an ajax request:<br />
* &#8211; sets all responseXXX fields accordingly<br />
* &#8211; finds the right dataType (mediates between content-type and expected dataType)<br />
* &#8211; returns the corresponding response<br />
*/<br />
function ajaxHandleResponses( s, jqXHR, responses ) {</p>
<p>var contents = s.contents,<br />
dataTypes = s.dataTypes,<br />
responseFields = s.responseFields,<br />
ct,<br />
type,<br />
finalDataType,<br />
firstDataType;</p>
<p>// Fill responseXXX fields<br />
for ( type in responseFields ) {<br />
if ( type in responses ) {<br />
jqXHR[ responseFields[type] ] = responses[ type ];<br />
}<br />
}</p>
<p>// Remove auto dataType and get content-type in the process<br />
while( dataTypes[ 0 ] === &#8220;*&#8221; ) {<br />
dataTypes.shift();<br />
if ( ct === undefined ) {<br />
ct = s.mimeType || jqXHR.getResponseHeader( &#8220;content-type&#8221; );<br />
}<br />
}</p>
<p>// Check if we&#8217;re dealing with a known content-type<br />
if ( ct ) {<br />
for ( type in contents ) {<br />
if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {<br />
dataTypes.unshift( type );<br />
break;<br />
}<br />
}<br />
}</p>
<p>// Check to see if we have a response for the expected dataType<br />
if ( dataTypes[ 0 ] in responses ) {<br />
finalDataType = dataTypes[ 0 ];<br />
} else {<br />
// Try convertible dataTypes<br />
for ( type in responses ) {<br />
if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {<br />
finalDataType = type;<br />
break;<br />
}<br />
if ( !firstDataType ) {<br />
firstDataType = type;<br />
}<br />
}<br />
// Or just use first one<br />
finalDataType = finalDataType || firstDataType;<br />
}</p>
<p>// If we found a dataType<br />
// We add the dataType to the list if needed<br />
// and return the corresponding response<br />
if ( finalDataType ) {<br />
if ( finalDataType !== dataTypes[ 0 ] ) {<br />
dataTypes.unshift( finalDataType );<br />
}<br />
return responses[ finalDataType ];<br />
}<br />
}</p>
<p>// Chain conversions given the request and the original response<br />
function ajaxConvert( s, response ) {</p>
<p>// Apply the dataFilter if provided<br />
if ( s.dataFilter ) {<br />
response = s.dataFilter( response, s.dataType );<br />
}</p>
<p>var dataTypes = s.dataTypes,<br />
converters = {},<br />
i,<br />
key,<br />
length = dataTypes.length,<br />
tmp,<br />
// Current and previous dataTypes<br />
current = dataTypes[ 0 ],<br />
prev,<br />
// Conversion expression<br />
conversion,<br />
// Conversion function<br />
conv,<br />
// Conversion functions (transitive conversion)<br />
conv1,<br />
conv2;</p>
<p>// For each dataType in the chain<br />
for ( i = 1; i &lt; length; i++ ) {</p>
<p>// Create converters map<br />
// with lowercased keys<br />
if ( i === 1 ) {<br />
for ( key in s.converters ) {<br />
if ( typeof key === &#8220;string&#8221; ) {<br />
converters[ key.toLowerCase() ] = s.converters[ key ];<br />
}<br />
}<br />
}</p>
<p>// Get the dataTypes<br />
prev = current;<br />
current = dataTypes[ i ];</p>
<p>// If current is auto dataType, update it to prev<br />
if ( current === &#8220;*&#8221; ) {<br />
current = prev;<br />
// If no auto and dataTypes are actually different<br />
} else if ( prev !== &#8220;*&#8221; &amp;&amp; prev !== current ) {</p>
<p>// Get the converter<br />
conversion = prev + &#8221; &#8221; + current;<br />
conv = converters[ conversion ] || converters[ "* " + current ];</p>
<p>// If there is no direct converter, search transitively<br />
if ( !conv ) {<br />
conv2 = undefined;<br />
for ( conv1 in converters ) {<br />
tmp = conv1.split( &#8221; &#8221; );<br />
if ( tmp[ 0 ] === prev || tmp[ 0 ] === &#8220;*&#8221; ) {<br />
conv2 = converters[ tmp[1] + &#8221; &#8221; + current ];<br />
if ( conv2 ) {<br />
conv1 = converters[ conv1 ];<br />
if ( conv1 === true ) {<br />
conv = conv2;<br />
} else if ( conv2 === true ) {<br />
conv = conv1;<br />
}<br />
break;<br />
}<br />
}<br />
}<br />
}<br />
// If we found no converter, dispatch an error<br />
if ( !( conv || conv2 ) ) {<br />
jQuery.error( &#8220;No conversion from &#8221; + conversion.replace(&#8221; &#8220;,&#8221; to &#8220;) );<br />
}<br />
// If found converter is not an equivalence<br />
if ( conv !== true ) {<br />
// Convert with 1 or 2 converters accordingly<br />
response = conv ? conv( response ) : conv2( conv1(response) );<br />
}<br />
}<br />
}<br />
return response;<br />
}</p>
<p>var jsc = jQuery.now(),<br />
jsre = /(\=)\?(&amp;|$)|\?\?/i;</p>
<p>// Default jsonp settings<br />
jQuery.ajaxSetup({<br />
jsonp: &#8220;callback&#8221;,<br />
jsonpCallback: function() {<br />
return jQuery.expando + &#8220;_&#8221; + ( jsc++ );<br />
}<br />
});</p>
<p>// Detect, normalize options and install callbacks for jsonp requests<br />
jQuery.ajaxPrefilter( &#8220;json jsonp&#8221;, function( s, originalSettings, jqXHR ) {</p>
<p>var inspectData = s.contentType === &#8220;application/x-www-form-urlencoded&#8221; &amp;&amp;<br />
( typeof s.data === &#8220;string&#8221; );</p>
<p>if ( s.dataTypes[ 0 ] === &#8220;jsonp&#8221; ||<br />
s.jsonp !== false &amp;&amp; ( jsre.test( s.url ) ||<br />
inspectData &amp;&amp; jsre.test( s.data ) ) ) {</p>
<p>var responseContainer,<br />
jsonpCallback = s.jsonpCallback =<br />
jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,<br />
previous = window[ jsonpCallback ],<br />
url = s.url,<br />
data = s.data,<br />
replace = &#8220;$1&#8243; + jsonpCallback + &#8220;$2&#8243;;</p>
<p>if ( s.jsonp !== false ) {<br />
url = url.replace( jsre, replace );<br />
if ( s.url === url ) {<br />
if ( inspectData ) {<br />
data = data.replace( jsre, replace );<br />
}<br />
if ( s.data === data ) {<br />
// Add callback manually<br />
url += (/\?/.test( url ) ? &#8220;&amp;&#8221; : &#8220;?&#8221;) + s.jsonp + &#8220;=&#8221; + jsonpCallback;<br />
}<br />
}<br />
}</p>
<p>s.url = url;<br />
s.data = data;</p>
<p>// Install callback<br />
window[ jsonpCallback ] = function( response ) {<br />
responseContainer = [ response ];<br />
};</p>
<p>// Clean-up function<br />
jqXHR.always(function() {<br />
// Set callback back to previous value<br />
window[ jsonpCallback ] = previous;<br />
// Call if it was a function and we have a response<br />
if ( responseContainer &amp;&amp; jQuery.isFunction( previous ) ) {<br />
window[ jsonpCallback ]( responseContainer[ 0 ] );<br />
}<br />
});</p>
<p>// Use data converter to retrieve json after script execution<br />
s.converters["script json"] = function() {<br />
if ( !responseContainer ) {<br />
jQuery.error( jsonpCallback + &#8221; was not called&#8221; );<br />
}<br />
return responseContainer[ 0 ];<br />
};</p>
<p>// force json dataType<br />
s.dataTypes[ 0 ] = &#8220;json&#8221;;</p>
<p>// Delegate to script<br />
return &#8220;script&#8221;;<br />
}<br />
});</p>
<p>// Install script dataType<br />
jQuery.ajaxSetup({<br />
accepts: {<br />
script: &#8220;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&#8221;<br />
},<br />
contents: {<br />
script: /javascript|ecmascript/<br />
},<br />
converters: {<br />
&#8220;text script&#8221;: function( text ) {<br />
jQuery.globalEval( text );<br />
return text;<br />
}<br />
}<br />
});</p>
<p>// Handle cache&#8217;s special case and global<br />
jQuery.ajaxPrefilter( &#8220;script&#8221;, function( s ) {<br />
if ( s.cache === undefined ) {<br />
s.cache = false;<br />
}<br />
if ( s.crossDomain ) {<br />
s.type = &#8220;GET&#8221;;<br />
s.global = false;<br />
}<br />
});</p>
<p>// Bind script tag hack transport<br />
jQuery.ajaxTransport( &#8220;script&#8221;, function(s) {</p>
<p>// This transport only deals with cross domain requests<br />
if ( s.crossDomain ) {</p>
<p>var script,<br />
head = document.head || document.getElementsByTagName( &#8220;head&#8221; )[0] || document.documentElement;</p>
<p>return {</p>
<p>send: function( _, callback ) {</p>
<p>script = document.createElement( &#8220;script&#8221; );</p>
<p>script.async = &#8220;async&#8221;;</p>
<p>if ( s.scriptCharset ) {<br />
script.charset = s.scriptCharset;<br />
}</p>
<p>script.src = s.url;</p>
<p>// Attach handlers for all browsers<br />
script.onload = script.onreadystatechange = function( _, isAbort ) {</p>
<p>if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {</p>
<p>// Handle memory leak in IE<br />
script.onload = script.onreadystatechange = null;</p>
<p>// Remove the script<br />
if ( head &amp;&amp; script.parentNode ) {<br />
head.removeChild( script );<br />
}</p>
<p>// Dereference the script<br />
script = undefined;</p>
<p>// Callback if not abort<br />
if ( !isAbort ) {<br />
callback( 200, &#8220;success&#8221; );<br />
}<br />
}<br />
};<br />
// Use insertBefore instead of appendChild  to circumvent an IE6 bug.<br />
// This arises when a base node is used (#2709 and #4378).<br />
head.insertBefore( script, head.firstChild );<br />
},</p>
<p>abort: function() {<br />
if ( script ) {<br />
script.onload( 0, 1 );<br />
}<br />
}<br />
};<br />
}<br />
});</p>
<p>var // #5280: Internet Explorer will keep connections alive if we don&#8217;t abort on unload<br />
xhrOnUnloadAbort = window.ActiveXObject ? function() {<br />
// Abort all pending requests<br />
for ( var key in xhrCallbacks ) {<br />
xhrCallbacks[ key ]( 0, 1 );<br />
}<br />
} : false,<br />
xhrId = 0,<br />
xhrCallbacks;</p>
<p>// Functions to create xhrs<br />
function createStandardXHR() {<br />
try {<br />
return new window.XMLHttpRequest();<br />
} catch( e ) {}<br />
}</p>
<p>function createActiveXHR() {<br />
try {<br />
return new window.ActiveXObject( &#8220;Microsoft.XMLHTTP&#8221; );<br />
} catch( e ) {}<br />
}</p>
<p>// Create the request object<br />
// (This is still attached to ajaxSettings for backward compatibility)<br />
jQuery.ajaxSettings.xhr = window.ActiveXObject ?<br />
/* Microsoft failed to properly<br />
* implement the XMLHttpRequest in IE7 (can&#8217;t request local files),<br />
* so we use the ActiveXObject when it is available<br />
* Additionally XMLHttpRequest can be disabled in IE7/IE8 so<br />
* we need a fallback.<br />
*/<br />
function() {<br />
return !this.isLocal &amp;&amp; createStandardXHR() || createActiveXHR();<br />
} :<br />
// For all other browsers, use the standard XMLHttpRequest object<br />
createStandardXHR;</p>
<p>// Determine support properties<br />
(function( xhr ) {<br />
jQuery.extend( jQuery.support, {<br />
ajax: !!xhr,<br />
cors: !!xhr &amp;&amp; ( &#8220;withCredentials&#8221; in xhr )<br />
});<br />
})( jQuery.ajaxSettings.xhr() );</p>
<p>// Create transport if the browser can provide an xhr<br />
if ( jQuery.support.ajax ) {</p>
<p>jQuery.ajaxTransport(function( s ) {<br />
// Cross domain only allowed if supported through XMLHttpRequest<br />
if ( !s.crossDomain || jQuery.support.cors ) {</p>
<p>var callback;</p>
<p>return {<br />
send: function( headers, complete ) {</p>
<p>// Get a new xhr<br />
var xhr = s.xhr(),<br />
handle,<br />
i;</p>
<p>// Open the socket<br />
// Passing null username, generates a login popup on Opera (#2865)<br />
if ( s.username ) {<br />
xhr.open( s.type, s.url, s.async, s.username, s.password );<br />
} else {<br />
xhr.open( s.type, s.url, s.async );<br />
}</p>
<p>// Apply custom fields if provided<br />
if ( s.xhrFields ) {<br />
for ( i in s.xhrFields ) {<br />
xhr[ i ] = s.xhrFields[ i ];<br />
}<br />
}</p>
<p>// Override mime type if needed<br />
if ( s.mimeType &amp;&amp; xhr.overrideMimeType ) {<br />
xhr.overrideMimeType( s.mimeType );<br />
}</p>
<p>// X-Requested-With header<br />
// For cross-domain requests, seeing as conditions for a preflight are<br />
// akin to a jigsaw puzzle, we simply never set it to be sure.<br />
// (it can always be set on a per-request basis or even using ajaxSetup)<br />
// For same-domain requests, won&#8217;t change header if already provided.<br />
if ( !s.crossDomain &amp;&amp; !headers["X-Requested-With"] ) {<br />
headers[ "X-Requested-With" ] = &#8220;XMLHttpRequest&#8221;;<br />
}</p>
<p>// Need an extra try/catch for cross domain requests in Firefox 3<br />
try {<br />
for ( i in headers ) {<br />
xhr.setRequestHeader( i, headers[ i ] );<br />
}<br />
} catch( _ ) {}</p>
<p>// Do send the request<br />
// This may raise an exception which is actually<br />
// handled in jQuery.ajax (so no try/catch here)<br />
xhr.send( ( s.hasContent &amp;&amp; s.data ) || null );</p>
<p>// Listener<br />
callback = function( _, isAbort ) {</p>
<p>var status,<br />
statusText,<br />
responseHeaders,<br />
responses,<br />
xml;</p>
<p>// Firefox throws exceptions when accessing properties<br />
// of an xhr when a network error occured<br />
// <a href="http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)" rel="nofollow">http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)</a><br />
try {</p>
<p>// Was never called and is aborted or complete<br />
if ( callback &amp;&amp; ( isAbort || xhr.readyState === 4 ) ) {</p>
<p>// Only called once<br />
callback = undefined;</p>
<p>// Do not keep as active anymore<br />
if ( handle ) {<br />
xhr.onreadystatechange = jQuery.noop;<br />
if ( xhrOnUnloadAbort ) {<br />
delete xhrCallbacks[ handle ];<br />
}<br />
}</p>
<p>// If it&#8217;s an abort<br />
if ( isAbort ) {<br />
// Abort it manually if needed<br />
if ( xhr.readyState !== 4 ) {<br />
xhr.abort();<br />
}<br />
} else {<br />
status = xhr.status;<br />
responseHeaders = xhr.getAllResponseHeaders();<br />
responses = {};<br />
xml = xhr.responseXML;</p>
<p>// Construct response list<br />
if ( xml &amp;&amp; xml.documentElement /* #4958 */ ) {<br />
responses.xml = xml;<br />
}<br />
responses.text = xhr.responseText;</p>
<p>// Firefox throws an exception when accessing<br />
// statusText for faulty cross-domain requests<br />
try {<br />
statusText = xhr.statusText;<br />
} catch( e ) {<br />
// We normalize with Webkit giving an empty statusText<br />
statusText = &#8220;&#8221;;<br />
}</p>
<p>// Filter status for non standard behaviors</p>
<p>// If the request is local and we have data: assume a success<br />
// (success with no data won&#8217;t get notified, that&#8217;s the best we<br />
// can do given current implementations)<br />
if ( !status &amp;&amp; s.isLocal &amp;&amp; !s.crossDomain ) {<br />
status = responses.text ? 200 : 404;<br />
// IE &#8211; #1450: sometimes returns 1223 when it should be 204<br />
} else if ( status === 1223 ) {<br />
status = 204;<br />
}<br />
}<br />
}<br />
} catch( firefoxAccessException ) {<br />
if ( !isAbort ) {<br />
complete( -1, firefoxAccessException );<br />
}<br />
}</p>
<p>// Call complete if needed<br />
if ( responses ) {<br />
complete( status, statusText, responses, responseHeaders );<br />
}<br />
};</p>
<p>// if we&#8217;re in sync mode or it&#8217;s in cache<br />
// and has been retrieved directly (IE6 &amp; IE7)<br />
// we need to manually fire the callback<br />
if ( !s.async || xhr.readyState === 4 ) {<br />
callback();<br />
} else {<br />
handle = ++xhrId;<br />
if ( xhrOnUnloadAbort ) {<br />
// Create the active xhrs callbacks list if needed<br />
// and attach the unload handler<br />
if ( !xhrCallbacks ) {<br />
xhrCallbacks = {};<br />
jQuery( window ).unload( xhrOnUnloadAbort );<br />
}<br />
// Add to list of active xhrs callbacks<br />
xhrCallbacks[ handle ] = callback;<br />
}<br />
xhr.onreadystatechange = callback;<br />
}<br />
},</p>
<p>abort: function() {<br />
if ( callback ) {<br />
callback(0,1);<br />
}<br />
}<br />
};<br />
}<br />
});<br />
}</p>
<p>var elemdisplay = {},<br />
iframe, iframeDoc,<br />
rfxtypes = /^(?:toggle|show|hide)$/,<br />
rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,<br />
timerId,<br />
fxAttrs = [<br />
// height animations<br />
[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],<br />
// width animations<br />
[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],<br />
// opacity animations<br />
[ "opacity" ]<br />
],<br />
fxNow;</p>
<p>jQuery.fn.extend({<br />
show: function( speed, easing, callback ) {<br />
var elem, display;</p>
<p>if ( speed || speed === 0 ) {<br />
return this.animate( genFx(&#8220;show&#8221;, 3), speed, easing, callback );</p>
<p>} else {<br />
for ( var i = 0, j = this.length; i &lt; j; i++ ) {<br />
elem = this[ i ];</p>
<p>if ( elem.style ) {<br />
display = elem.style.display;</p>
<p>// Reset the inline display of this element to learn if it is<br />
// being hidden by cascaded rules or not<br />
if ( !jQuery._data(elem, &#8220;olddisplay&#8221;) &amp;&amp; display === &#8220;none&#8221; ) {<br />
display = elem.style.display = &#8220;&#8221;;<br />
}</p>
<p>// Set elements which have been overridden with display: none<br />
// in a stylesheet to whatever the default browser style is<br />
// for such an element<br />
if ( display === &#8220;&#8221; &amp;&amp; jQuery.css(elem, &#8220;display&#8221;) === &#8220;none&#8221; ) {<br />
jQuery._data( elem, &#8220;olddisplay&#8221;, defaultDisplay(elem.nodeName) );<br />
}<br />
}<br />
}</p>
<p>// Set the display of most of the elements in a second loop<br />
// to avoid the constant reflow<br />
for ( i = 0; i &lt; j; i++ ) {<br />
elem = this[ i ];</p>
<p>if ( elem.style ) {<br />
display = elem.style.display;</p>
<p>if ( display === &#8220;&#8221; || display === &#8220;none&#8221; ) {<br />
elem.style.display = jQuery._data( elem, &#8220;olddisplay&#8221; ) || &#8220;&#8221;;<br />
}<br />
}<br />
}</p>
<p>return this;<br />
}<br />
},</p>
<p>hide: function( speed, easing, callback ) {<br />
if ( speed || speed === 0 ) {<br />
return this.animate( genFx(&#8220;hide&#8221;, 3), speed, easing, callback);</p>
<p>} else {<br />
var elem, display,<br />
i = 0,<br />
j = this.length;</p>
<p>for ( ; i &lt; j; i++ ) {<br />
elem = this[i];<br />
if ( elem.style ) {<br />
display = jQuery.css( elem, &#8220;display&#8221; );</p>
<p>if ( display !== &#8220;none&#8221; &amp;&amp; !jQuery._data( elem, &#8220;olddisplay&#8221; ) ) {<br />
jQuery._data( elem, &#8220;olddisplay&#8221;, display );<br />
}<br />
}<br />
}</p>
<p>// Set the display of the elements in a second loop<br />
// to avoid the constant reflow<br />
for ( i = 0; i &lt; j; i++ ) {<br />
if ( this[i].style ) {<br />
this[i].style.display = &#8220;none&#8221;;<br />
}<br />
}</p>
<p>return this;<br />
}<br />
},</p>
<p>// Save the old toggle function<br />
_toggle: jQuery.fn.toggle,</p>
<p>toggle: function( fn, fn2, callback ) {<br />
var bool = typeof fn === &#8220;boolean&#8221;;</p>
<p>if ( jQuery.isFunction(fn) &amp;&amp; jQuery.isFunction(fn2) ) {<br />
this._toggle.apply( this, arguments );</p>
<p>} else if ( fn == null || bool ) {<br />
this.each(function() {<br />
var state = bool ? fn : jQuery(this).is(&#8220;:hidden&#8221;);<br />
jQuery(this)[ state ? "show" : "hide" ]();<br />
});</p>
<p>} else {<br />
this.animate(genFx(&#8220;toggle&#8221;, 3), fn, fn2, callback);<br />
}</p>
<p>return this;<br />
},</p>
<p>fadeTo: function( speed, to, easing, callback ) {<br />
return this.filter(&#8220;:hidden&#8221;).css(&#8220;opacity&#8221;, 0).show().end()<br />
.animate({opacity: to}, speed, easing, callback);<br />
},</p>
<p>animate: function( prop, speed, easing, callback ) {<br />
var optall = jQuery.speed( speed, easing, callback );</p>
<p>if ( jQuery.isEmptyObject( prop ) ) {<br />
return this.each( optall.complete, [ false ] );<br />
}</p>
<p>// Do not change referenced properties as per-property easing will be lost<br />
prop = jQuery.extend( {}, prop );</p>
<p>function doAnimation() {<br />
// XXX &#8216;this&#8217; does not always have a nodeName when running the<br />
// test suite</p>
<p>if ( optall.queue === false ) {<br />
jQuery._mark( this );<br />
}</p>
<p>var opt = jQuery.extend( {}, optall ),<br />
isElement = this.nodeType === 1,<br />
hidden = isElement &amp;&amp; jQuery(this).is(&#8220;:hidden&#8221;),<br />
name, val, p, e,<br />
parts, start, end, unit,<br />
method;</p>
<p>// will store per property easing and be used to determine when an animation is complete<br />
opt.animatedProperties = {};</p>
<p>for ( p in prop ) {</p>
<p>// property name normalization<br />
name = jQuery.camelCase( p );<br />
if ( p !== name ) {<br />
prop[ name ] = prop[ p ];<br />
delete prop[ p ];<br />
}</p>
<p>val = prop[ name ];</p>
<p>// easing resolution: per property &gt; opt.specialEasing &gt; opt.easing &gt; &#8216;swing&#8217; (default)<br />
if ( jQuery.isArray( val ) ) {<br />
opt.animatedProperties[ name ] = val[ 1 ];<br />
val = prop[ name ] = val[ 0 ];<br />
} else {<br />
opt.animatedProperties[ name ] = opt.specialEasing &amp;&amp; opt.specialEasing[ name ] || opt.easing || &#8216;swing&#8217;;<br />
}</p>
<p>if ( val === &#8220;hide&#8221; &amp;&amp; hidden || val === &#8220;show&#8221; &amp;&amp; !hidden ) {<br />
return opt.complete.call( this );<br />
}</p>
<p>if ( isElement &amp;&amp; ( name === &#8220;height&#8221; || name === &#8220;width&#8221; ) ) {<br />
// Make sure that nothing sneaks out<br />
// Record all 3 overflow attributes because IE does not<br />
// change the overflow attribute when overflowX and<br />
// overflowY are set to the same value<br />
opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];</p>
<p>// Set display property to inline-block for height/width<br />
// animations on inline elements that are having width/height animated<br />
if ( jQuery.css( this, &#8220;display&#8221; ) === &#8220;inline&#8221; &amp;&amp;<br />
jQuery.css( this, &#8220;float&#8221; ) === &#8220;none&#8221; ) {</p>
<p>// inline-level elements accept inline-block;<br />
// block-level elements need to be inline with layout<br />
if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === &#8220;inline&#8221; ) {<br />
this.style.display = &#8220;inline-block&#8221;;</p>
<p>} else {<br />
this.style.zoom = 1;<br />
}<br />
}<br />
}<br />
}</p>
<p>if ( opt.overflow != null ) {<br />
this.style.overflow = &#8220;hidden&#8221;;<br />
}</p>
<p>for ( p in prop ) {<br />
e = new jQuery.fx( this, opt, p );<br />
val = prop[ p ];</p>
<p>if ( rfxtypes.test( val ) ) {</p>
<p>// Tracks whether to show or hide based on private<br />
// data attached to the element<br />
method = jQuery._data( this, &#8220;toggle&#8221; + p ) || ( val === &#8220;toggle&#8221; ? hidden ? &#8220;show&#8221; : &#8220;hide&#8221; : 0 );<br />
if ( method ) {<br />
jQuery._data( this, &#8220;toggle&#8221; + p, method === &#8220;show&#8221; ? &#8220;hide&#8221; : &#8220;show&#8221; );<br />
e[ method ]();<br />
} else {<br />
e[ val ]();<br />
}</p>
<p>} else {<br />
parts = rfxnum.exec( val );<br />
start = e.cur();</p>
<p>if ( parts ) {<br />
end = parseFloat( parts[2] );<br />
unit = parts[3] || ( jQuery.cssNumber[ p ] ? &#8220;&#8221; : &#8220;px&#8221; );</p>
<p>// We need to compute starting value<br />
if ( unit !== &#8220;px&#8221; ) {<br />
jQuery.style( this, p, (end || 1) + unit);<br />
start = ( (end || 1) / e.cur() ) * start;<br />
jQuery.style( this, p, start + unit);<br />
}</p>
<p>// If a +=/-= token was provided, we&#8217;re doing a relative animation<br />
if ( parts[1] ) {<br />
end = ( (parts[ 1 ] === &#8220;-=&#8221; ? -1 : 1) * end ) + start;<br />
}</p>
<p>e.custom( start, end, unit );</p>
<p>} else {<br />
e.custom( start, val, &#8220;&#8221; );<br />
}<br />
}<br />
}</p>
<p>// For JS strict compliance<br />
return true;<br />
}</p>
<p>return optall.queue === false ?<br />
this.each( doAnimation ) :<br />
this.queue( optall.queue, doAnimation );<br />
},</p>
<p>stop: function( type, clearQueue, gotoEnd ) {<br />
if ( typeof type !== &#8220;string&#8221; ) {<br />
gotoEnd = clearQueue;<br />
clearQueue = type;<br />
type = undefined;<br />
}<br />
if ( clearQueue &amp;&amp; type !== false ) {<br />
this.queue( type || &#8220;fx&#8221;, [] );<br />
}</p>
<p>return this.each(function() {<br />
var i,<br />
hadTimers = false,<br />
timers = jQuery.timers,<br />
data = jQuery._data( this );</p>
<p>// clear marker counters if we know they won&#8217;t be<br />
if ( !gotoEnd ) {<br />
jQuery._unmark( true, this );<br />
}</p>
<p>function stopQueue( elem, data, i ) {<br />
var hooks = data[ i ];<br />
jQuery.removeData( elem, i, true );<br />
hooks.stop( gotoEnd );<br />
}</p>
<p>if ( type == null ) {<br />
for ( i in data ) {<br />
if ( data[ i ].stop &amp;&amp; i.indexOf(&#8220;.run&#8221;) === i.length &#8211; 4 ) {<br />
stopQueue( this, data, i );<br />
}<br />
}<br />
} else if ( data[ i = type + ".run" ] &amp;&amp; data[ i ].stop ){<br />
stopQueue( this, data, i );<br />
}</p>
<p>for ( i = timers.length; i&#8211;; ) {<br />
if ( timers[ i ].elem === this &amp;&amp; (type == null || timers[ i ].queue === type) ) {<br />
if ( gotoEnd ) {</p>
<p>// force the next step to be the last<br />
timers[ i ]( true );<br />
} else {<br />
timers[ i ].saveState();<br />
}<br />
hadTimers = true;<br />
timers.splice( i, 1 );<br />
}<br />
}</p>
<p>// start the next in the queue if the last step wasn&#8217;t forced<br />
// timers currently will call their complete callbacks, which will dequeue<br />
// but only if they were gotoEnd<br />
if ( !( gotoEnd &amp;&amp; hadTimers ) ) {<br />
jQuery.dequeue( this, type );<br />
}<br />
});<br />
}</p>
<p>});</p>
<p>// Animations created synchronously will run synchronously<br />
function createFxNow() {<br />
setTimeout( clearFxNow, 0 );<br />
return ( fxNow = jQuery.now() );<br />
}</p>
<p>function clearFxNow() {<br />
fxNow = undefined;<br />
}</p>
<p>// Generate parameters to create a standard animation<br />
function genFx( type, num ) {<br />
var obj = {};</p>
<p>jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {<br />
obj[ this ] = type;<br />
});</p>
<p>return obj;<br />
}</p>
<p>// Generate shortcuts for custom animations<br />
jQuery.each({<br />
slideDown: genFx( &#8220;show&#8221;, 1 ),<br />
slideUp: genFx( &#8220;hide&#8221;, 1 ),<br />
slideToggle: genFx( &#8220;toggle&#8221;, 1 ),<br />
fadeIn: { opacity: &#8220;show&#8221; },<br />
fadeOut: { opacity: &#8220;hide&#8221; },<br />
fadeToggle: { opacity: &#8220;toggle&#8221; }<br />
}, function( name, props ) {<br />
jQuery.fn[ name ] = function( speed, easing, callback ) {<br />
return this.animate( props, speed, easing, callback );<br />
};<br />
});</p>
<p>jQuery.extend({<br />
speed: function( speed, easing, fn ) {<br />
var opt = speed &amp;&amp; typeof speed === &#8220;object&#8221; ? jQuery.extend( {}, speed ) : {<br />
complete: fn || !fn &amp;&amp; easing ||<br />
jQuery.isFunction( speed ) &amp;&amp; speed,<br />
duration: speed,<br />
easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing<br />
};</p>
<p>opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &#8220;number&#8221; ? opt.duration :<br />
opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;</p>
<p>// normalize opt.queue &#8211; true/undefined/null -&gt; &#8220;fx&#8221;<br />
if ( opt.queue == null || opt.queue === true ) {<br />
opt.queue = &#8220;fx&#8221;;<br />
}</p>
<p>// Queueing<br />
opt.old = opt.complete;</p>
<p>opt.complete = function( noUnmark ) {<br />
if ( jQuery.isFunction( opt.old ) ) {<br />
opt.old.call( this );<br />
}</p>
<p>if ( opt.queue ) {<br />
jQuery.dequeue( this, opt.queue );<br />
} else if ( noUnmark !== false ) {<br />
jQuery._unmark( this );<br />
}<br />
};</p>
<p>return opt;<br />
},</p>
<p>easing: {<br />
linear: function( p, n, firstNum, diff ) {<br />
return firstNum + diff * p;<br />
},<br />
swing: function( p, n, firstNum, diff ) {<br />
return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;<br />
}<br />
},</p>
<p>timers: [],</p>
<p>fx: function( elem, options, prop ) {<br />
this.options = options;<br />
this.elem = elem;<br />
this.prop = prop;</p>
<p>options.orig = options.orig || {};<br />
}</p>
<p>});</p>
<p>jQuery.fx.prototype = {<br />
// Simple function for setting a style value<br />
update: function() {<br />
if ( this.options.step ) {<br />
this.options.step.call( this.elem, this.now, this );<br />
}</p>
<p>( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );<br />
},</p>
<p>// Get the current size<br />
cur: function() {<br />
if ( this.elem[ this.prop ] != null &amp;&amp; (!this.elem.style || this.elem.style[ this.prop ] == null) ) {<br />
return this.elem[ this.prop ];<br />
}</p>
<p>var parsed,<br />
r = jQuery.css( this.elem, this.prop );<br />
// Empty strings, null, undefined and &#8220;auto&#8221; are converted to 0,<br />
// complex values such as &#8220;rotate(1rad)&#8221; are returned as is,<br />
// simple values such as &#8220;10px&#8221; are parsed to Float.<br />
return isNaN( parsed = parseFloat( r ) ) ? !r || r === &#8220;auto&#8221; ? 0 : r : parsed;<br />
},</p>
<p>// Start an animation from one number to another<br />
custom: function( from, to, unit ) {<br />
var self = this,<br />
fx = jQuery.fx;</p>
<p>this.startTime = fxNow || createFxNow();<br />
this.end = to;<br />
this.now = this.start = from;<br />
this.pos = this.state = 0;<br />
this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? &#8220;&#8221; : &#8220;px&#8221; );</p>
<p>function t( gotoEnd ) {<br />
return self.step( gotoEnd );<br />
}</p>
<p>t.queue = this.options.queue;<br />
t.elem = this.elem;<br />
t.saveState = function() {<br />
if ( self.options.hide &amp;&amp; jQuery._data( self.elem, &#8220;fxshow&#8221; + self.prop ) === undefined ) {<br />
jQuery._data( self.elem, &#8220;fxshow&#8221; + self.prop, self.start );<br />
}<br />
};</p>
<p>if ( t() &amp;&amp; jQuery.timers.push(t) &amp;&amp; !timerId ) {<br />
timerId = setInterval( fx.tick, fx.interval );<br />
}<br />
},</p>
<p>// Simple &#8216;show&#8217; function<br />
show: function() {<br />
var dataShow = jQuery._data( this.elem, &#8220;fxshow&#8221; + this.prop );</p>
<p>// Remember where we started, so that we can go back to it later<br />
this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );<br />
this.options.show = true;</p>
<p>// Begin the animation<br />
// Make sure that we start at a small width/height to avoid any flash of content<br />
if ( dataShow !== undefined ) {<br />
// This show is picking up where a previous hide or show left off<br />
this.custom( this.cur(), dataShow );<br />
} else {<br />
this.custom( this.prop === &#8220;width&#8221; || this.prop === &#8220;height&#8221; ? 1 : 0, this.cur() );<br />
}</p>
<p>// Start by showing the element<br />
jQuery( this.elem ).show();<br />
},</p>
<p>// Simple &#8216;hide&#8217; function<br />
hide: function() {<br />
// Remember where we started, so that we can go back to it later<br />
this.options.orig[ this.prop ] = jQuery._data( this.elem, &#8220;fxshow&#8221; + this.prop ) || jQuery.style( this.elem, this.prop );<br />
this.options.hide = true;</p>
<p>// Begin the animation<br />
this.custom( this.cur(), 0 );<br />
},</p>
<p>// Each step of an animation<br />
step: function( gotoEnd ) {<br />
var p, n, complete,<br />
t = fxNow || createFxNow(),<br />
done = true,<br />
elem = this.elem,<br />
options = this.options;</p>
<p>if ( gotoEnd || t &gt;= options.duration + this.startTime ) {<br />
this.now = this.end;<br />
this.pos = this.state = 1;<br />
this.update();</p>
<p>options.animatedProperties[ this.prop ] = true;</p>
<p>for ( p in options.animatedProperties ) {<br />
if ( options.animatedProperties[ p ] !== true ) {<br />
done = false;<br />
}<br />
}</p>
<p>if ( done ) {<br />
// Reset the overflow<br />
if ( options.overflow != null &amp;&amp; !jQuery.support.shrinkWrapBlocks ) {</p>
<p>jQuery.each( [ "", "X", "Y" ], function( index, value ) {<br />
elem.style[ "overflow" + value ] = options.overflow[ index ];<br />
});<br />
}</p>
<p>// Hide the element if the &#8220;hide&#8221; operation was done<br />
if ( options.hide ) {<br />
jQuery( elem ).hide();<br />
}</p>
<p>// Reset the properties, if the item has been hidden or shown<br />
if ( options.hide || options.show ) {<br />
for ( p in options.animatedProperties ) {<br />
jQuery.style( elem, p, options.orig[ p ] );<br />
jQuery.removeData( elem, &#8220;fxshow&#8221; + p, true );<br />
// Toggle data is no longer needed<br />
jQuery.removeData( elem, &#8220;toggle&#8221; + p, true );<br />
}<br />
}</p>
<p>// Execute the complete function<br />
// in the event that the complete function throws an exception<br />
// we must ensure it won&#8217;t be called twice. #5684</p>
<p>complete = options.complete;<br />
if ( complete ) {</p>
<p>options.complete = false;<br />
complete.call( elem );<br />
}<br />
}</p>
<p>return false;</p>
<p>} else {<br />
// classical easing cannot be used with an Infinity duration<br />
if ( options.duration == Infinity ) {<br />
this.now = t;<br />
} else {<br />
n = t &#8211; this.startTime;<br />
this.state = n / options.duration;</p>
<p>// Perform the easing function, defaults to swing<br />
this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );<br />
this.now = this.start + ( (this.end &#8211; this.start) * this.pos );<br />
}<br />
// Perform the next step of the animation<br />
this.update();<br />
}</p>
<p>return true;<br />
}<br />
};</p>
<p>jQuery.extend( jQuery.fx, {<br />
tick: function() {<br />
var timer,<br />
timers = jQuery.timers,<br />
i = 0;</p>
<p>for ( ; i &lt; timers.length; i++ ) {<br />
timer = timers[ i ];<br />
// Checks the timer has not already been removed<br />
if ( !timer() &amp;&amp; timers[ i ] === timer ) {<br />
timers.splice( i&#8211;, 1 );<br />
}<br />
}</p>
<p>if ( !timers.length ) {<br />
jQuery.fx.stop();<br />
}<br />
},</p>
<p>interval: 13,</p>
<p>stop: function() {<br />
clearInterval( timerId );<br />
timerId = null;<br />
},</p>
<p>speeds: {<br />
slow: 600,<br />
fast: 200,<br />
// Default speed<br />
_default: 400<br />
},</p>
<p>step: {<br />
opacity: function( fx ) {<br />
jQuery.style( fx.elem, &#8220;opacity&#8221;, fx.now );<br />
},</p>
<p>_default: function( fx ) {<br />
if ( fx.elem.style &amp;&amp; fx.elem.style[ fx.prop ] != null ) {<br />
fx.elem.style[ fx.prop ] = fx.now + fx.unit;<br />
} else {<br />
fx.elem[ fx.prop ] = fx.now;<br />
}<br />
}<br />
}<br />
});</p>
<p>// Adds width/height step functions<br />
// Do not set anything below 0<br />
jQuery.each([ "width", "height" ], function( i, prop ) {<br />
jQuery.fx.step[ prop ] = function( fx ) {<br />
jQuery.style( fx.elem, prop, Math.max(0, fx.now) );<br />
};<br />
});</p>
<p>if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {<br />
jQuery.expr.filters.animated = function( elem ) {<br />
return jQuery.grep(jQuery.timers, function( fn ) {<br />
return elem === fn.elem;<br />
}).length;<br />
};<br />
}</p>
<p>// Try to restore the default display value of an element<br />
function defaultDisplay( nodeName ) {</p>
<p>if ( !elemdisplay[ nodeName ] ) {</p>
<p>var body = document.body,<br />
elem = jQuery( &#8220;&lt;&#8221; + nodeName + &#8220;&gt;&#8221; ).appendTo( body ),<br />
display = elem.css( &#8220;display&#8221; );<br />
elem.remove();</p>
<p>// If the simple way fails,<br />
// get element&#8217;s real default display by attaching it to a temp iframe<br />
if ( display === &#8220;none&#8221; || display === &#8220;&#8221; ) {<br />
// No iframe to use yet, so create it<br />
if ( !iframe ) {<br />
iframe = document.createElement( &#8220;iframe&#8221; );<br />
iframe.frameBorder = iframe.width = iframe.height = 0;<br />
}</p>
<p>body.appendChild( iframe );</p>
<p>// Create a cacheable copy of the iframe document on first call.<br />
// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML<br />
// document to it; WebKit &amp; Firefox won&#8217;t allow reusing the iframe document.<br />
if ( !iframeDoc || !iframe.createElement ) {<br />
iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;<br />
iframeDoc.write( ( document.compatMode === &#8220;CSS1Compat&#8221; ? &#8220;&lt;!doctype html&gt;&#8221; : &#8220;&#8221; ) + &#8220;&lt;html&gt;&lt;body&gt;&#8221; );<br />
iframeDoc.close();<br />
}</p>
<p>elem = iframeDoc.createElement( nodeName );</p>
<p>iframeDoc.body.appendChild( elem );</p>
<p>display = jQuery.css( elem, &#8220;display&#8221; );<br />
body.removeChild( iframe );<br />
}</p>
<p>// Store the correct default display<br />
elemdisplay[ nodeName ] = display;<br />
}</p>
<p>return elemdisplay[ nodeName ];<br />
}</p>
<p>var rtable = /^t(?:able|d|h)$/i,<br />
rroot = /^(?:body|html)$/i;</p>
<p>if ( &#8220;getBoundingClientRect&#8221; in document.documentElement ) {<br />
jQuery.fn.offset = function( options ) {<br />
var elem = this[0], box;</p>
<p>if ( options ) {<br />
return this.each(function( i ) {<br />
jQuery.offset.setOffset( this, options, i );<br />
});<br />
}</p>
<p>if ( !elem || !elem.ownerDocument ) {<br />
return null;<br />
}</p>
<p>if ( elem === elem.ownerDocument.body ) {<br />
return jQuery.offset.bodyOffset( elem );<br />
}</p>
<p>try {<br />
box = elem.getBoundingClientRect();<br />
} catch(e) {}</p>
<p>var doc = elem.ownerDocument,<br />
docElem = doc.documentElement;</p>
<p>// Make sure we&#8217;re not dealing with a disconnected DOM node<br />
if ( !box || !jQuery.contains( docElem, elem ) ) {<br />
return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };<br />
}</p>
<p>var body = doc.body,<br />
win = getWindow(doc),<br />
clientTop  = docElem.clientTop  || body.clientTop  || 0,<br />
clientLeft = docElem.clientLeft || body.clientLeft || 0,<br />
scrollTop  = win.pageYOffset || jQuery.support.boxModel &amp;&amp; docElem.scrollTop  || body.scrollTop,<br />
scrollLeft = win.pageXOffset || jQuery.support.boxModel &amp;&amp; docElem.scrollLeft || body.scrollLeft,<br />
top  = box.top  + scrollTop  &#8211; clientTop,<br />
left = box.left + scrollLeft &#8211; clientLeft;</p>
<p>return { top: top, left: left };<br />
};</p>
<p>} else {<br />
jQuery.fn.offset = function( options ) {</p>
<p>var elem = this[0];</p>
<p>if ( options ) {<br />
return this.each(function( i ) {<br />
jQuery.offset.setOffset( this, options, i );<br />
});<br />
}</p>
<p>if ( !elem || !elem.ownerDocument ) {<br />
return null;<br />
}</p>
<p>if ( elem === elem.ownerDocument.body ) {<br />
return jQuery.offset.bodyOffset( elem );<br />
}</p>
<p>var computedStyle,<br />
offsetParent = elem.offsetParent,<br />
prevOffsetParent = elem,<br />
doc = elem.ownerDocument,<br />
docElem = doc.documentElement,<br />
body = doc.body,<br />
defaultView = doc.defaultView,<br />
prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,<br />
top = elem.offsetTop,<br />
left = elem.offsetLeft;</p>
<p>while ( (elem = elem.parentNode) &amp;&amp; elem !== body &amp;&amp; elem !== docElem ) {<br />
if ( jQuery.support.fixedPosition &amp;&amp; prevComputedStyle.position === &#8220;fixed&#8221; ) {<br />
break;<br />
}</p>
<p>computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;<br />
top  -= elem.scrollTop;<br />
left -= elem.scrollLeft;</p>
<p>if ( elem === offsetParent ) {<br />
top  += elem.offsetTop;<br />
left += elem.offsetLeft;</p>
<p>if ( jQuery.support.doesNotAddBorder &amp;&amp; !(jQuery.support.doesAddBorderForTableAndCells &amp;&amp; rtable.test(elem.nodeName)) ) {<br />
top  += parseFloat( computedStyle.borderTopWidth  ) || 0;<br />
left += parseFloat( computedStyle.borderLeftWidth ) || 0;<br />
}</p>
<p>prevOffsetParent = offsetParent;<br />
offsetParent = elem.offsetParent;<br />
}</p>
<p>if ( jQuery.support.subtractsBorderForOverflowNotVisible &amp;&amp; computedStyle.overflow !== &#8220;visible&#8221; ) {<br />
top  += parseFloat( computedStyle.borderTopWidth  ) || 0;<br />
left += parseFloat( computedStyle.borderLeftWidth ) || 0;<br />
}</p>
<p>prevComputedStyle = computedStyle;<br />
}</p>
<p>if ( prevComputedStyle.position === &#8220;relative&#8221; || prevComputedStyle.position === &#8220;static&#8221; ) {<br />
top  += body.offsetTop;<br />
left += body.offsetLeft;<br />
}</p>
<p>if ( jQuery.support.fixedPosition &amp;&amp; prevComputedStyle.position === &#8220;fixed&#8221; ) {<br />
top  += Math.max( docElem.scrollTop, body.scrollTop );<br />
left += Math.max( docElem.scrollLeft, body.scrollLeft );<br />
}</p>
<p>return { top: top, left: left };<br />
};<br />
}</p>
<p>jQuery.offset = {</p>
<p>bodyOffset: function( body ) {<br />
var top = body.offsetTop,<br />
left = body.offsetLeft;</p>
<p>if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {<br />
top  += parseFloat( jQuery.css(body, &#8220;marginTop&#8221;) ) || 0;<br />
left += parseFloat( jQuery.css(body, &#8220;marginLeft&#8221;) ) || 0;<br />
}</p>
<p>return { top: top, left: left };<br />
},</p>
<p>setOffset: function( elem, options, i ) {<br />
var position = jQuery.css( elem, &#8220;position&#8221; );</p>
<p>// set position first, in-case top/left are set even on static elem<br />
if ( position === &#8220;static&#8221; ) {<br />
elem.style.position = &#8220;relative&#8221;;<br />
}</p>
<p>var curElem = jQuery( elem ),<br />
curOffset = curElem.offset(),<br />
curCSSTop = jQuery.css( elem, &#8220;top&#8221; ),<br />
curCSSLeft = jQuery.css( elem, &#8220;left&#8221; ),<br />
calculatePosition = ( position === &#8220;absolute&#8221; || position === &#8220;fixed&#8221; ) &amp;&amp; jQuery.inArray(&#8220;auto&#8221;, [curCSSTop, curCSSLeft]) &gt; -1,<br />
props = {}, curPosition = {}, curTop, curLeft;</p>
<p>// need to be able to calculate position if either top or left is auto and position is either absolute or fixed<br />
if ( calculatePosition ) {<br />
curPosition = curElem.position();<br />
curTop = curPosition.top;<br />
curLeft = curPosition.left;<br />
} else {<br />
curTop = parseFloat( curCSSTop ) || 0;<br />
curLeft = parseFloat( curCSSLeft ) || 0;<br />
}</p>
<p>if ( jQuery.isFunction( options ) ) {<br />
options = options.call( elem, i, curOffset );<br />
}</p>
<p>if ( options.top != null ) {<br />
props.top = ( options.top &#8211; curOffset.top ) + curTop;<br />
}<br />
if ( options.left != null ) {<br />
props.left = ( options.left &#8211; curOffset.left ) + curLeft;<br />
}</p>
<p>if ( &#8220;using&#8221; in options ) {<br />
options.using.call( elem, props );<br />
} else {<br />
curElem.css( props );<br />
}<br />
}<br />
};</p>
<p>jQuery.fn.extend({</p>
<p>position: function() {<br />
if ( !this[0] ) {<br />
return null;<br />
}</p>
<p>var elem = this[0],</p>
<p>// Get *real* offsetParent<br />
offsetParent = this.offsetParent(),</p>
<p>// Get correct offsets<br />
offset       = this.offset(),<br />
parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();</p>
<p>// Subtract element margins<br />
// note: when an element has margin: auto the offsetLeft and marginLeft<br />
// are the same in Safari causing offset.left to incorrectly be 0<br />
offset.top  -= parseFloat( jQuery.css(elem, &#8220;marginTop&#8221;) ) || 0;<br />
offset.left -= parseFloat( jQuery.css(elem, &#8220;marginLeft&#8221;) ) || 0;</p>
<p>// Add offsetParent borders<br />
parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], &#8220;borderTopWidth&#8221;) ) || 0;<br />
parentOffset.left += parseFloat( jQuery.css(offsetParent[0], &#8220;borderLeftWidth&#8221;) ) || 0;</p>
<p>// Subtract the two offsets<br />
return {<br />
top:  offset.top  &#8211; parentOffset.top,<br />
left: offset.left &#8211; parentOffset.left<br />
};<br />
},</p>
<p>offsetParent: function() {<br />
return this.map(function() {<br />
var offsetParent = this.offsetParent || document.body;<br />
while ( offsetParent &amp;&amp; (!rroot.test(offsetParent.nodeName) &amp;&amp; jQuery.css(offsetParent, &#8220;position&#8221;) === &#8220;static&#8221;) ) {<br />
offsetParent = offsetParent.offsetParent;<br />
}<br />
return offsetParent;<br />
});<br />
}<br />
});</p>
<p>// Create scrollLeft and scrollTop methods<br />
jQuery.each( ["Left", "Top"], function( i, name ) {<br />
var method = &#8220;scroll&#8221; + name;</p>
<p>jQuery.fn[ method ] = function( val ) {<br />
var elem, win;</p>
<p>if ( val === undefined ) {<br />
elem = this[ 0 ];</p>
<p>if ( !elem ) {<br />
return null;<br />
}</p>
<p>win = getWindow( elem );</p>
<p>// Return the scroll offset<br />
return win ? (&#8220;pageXOffset&#8221; in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :<br />
jQuery.support.boxModel &amp;&amp; win.document.documentElement[ method ] ||<br />
win.document.body[ method ] :<br />
elem[ method ];<br />
}</p>
<p>// Set the scroll offset<br />
return this.each(function() {<br />
win = getWindow( this );</p>
<p>if ( win ) {<br />
win.scrollTo(<br />
!i ? val : jQuery( win ).scrollLeft(),<br />
i ? val : jQuery( win ).scrollTop()<br />
);</p>
<p>} else {<br />
this[ method ] = val;<br />
}<br />
});<br />
};<br />
});</p>
<p>function getWindow( elem ) {<br />
return jQuery.isWindow( elem ) ?<br />
elem :<br />
elem.nodeType === 9 ?<br />
elem.defaultView || elem.parentWindow :<br />
false;<br />
}</p>
<p>// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods<br />
jQuery.each([ "Height", "Width" ], function( i, name ) {</p>
<p>var type = name.toLowerCase();</p>
<p>// innerHeight and innerWidth<br />
jQuery.fn[ "inner" + name ] = function() {<br />
var elem = this[0];<br />
return elem ?<br />
elem.style ?<br />
parseFloat( jQuery.css( elem, type, &#8220;padding&#8221; ) ) :<br />
this[ type ]() :<br />
null;<br />
};</p>
<p>// outerHeight and outerWidth<br />
jQuery.fn[ "outer" + name ] = function( margin ) {<br />
var elem = this[0];<br />
return elem ?<br />
elem.style ?<br />
parseFloat( jQuery.css( elem, type, margin ? &#8220;margin&#8221; : &#8220;border&#8221; ) ) :<br />
this[ type ]() :<br />
null;<br />
};</p>
<p>jQuery.fn[ type ] = function( size ) {<br />
// Get window width or height<br />
var elem = this[0];<br />
if ( !elem ) {<br />
return size == null ? null : this;<br />
}</p>
<p>if ( jQuery.isFunction( size ) ) {<br />
return this.each(function( i ) {<br />
var self = jQuery( this );<br />
self[ type ]( size.call( this, i, self[ type ]() ) );<br />
});<br />
}</p>
<p>if ( jQuery.isWindow( elem ) ) {<br />
// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode<br />
// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat<br />
var docElemProp = elem.document.documentElement[ "client" + name ],<br />
body = elem.document.body;<br />
return elem.document.compatMode === &#8220;CSS1Compat&#8221; &amp;&amp; docElemProp ||<br />
body &amp;&amp; body[ "client" + name ] || docElemProp;</p>
<p>// Get document width or height<br />
} else if ( elem.nodeType === 9 ) {<br />
// Either scroll[Width/Height] or offset[Width/Height], whichever is greater<br />
return Math.max(<br />
elem.documentElement["client" + name],<br />
elem.body["scroll" + name], elem.documentElement["scroll" + name],<br />
elem.body["offset" + name], elem.documentElement["offset" + name]<br />
);</p>
<p>// Get or set width or height on the element<br />
} else if ( size === undefined ) {<br />
var orig = jQuery.css( elem, type ),<br />
ret = parseFloat( orig );</p>
<p>return jQuery.isNumeric( ret ) ? ret : orig;</p>
<p>// Set the width or height on the element (default to pixels if value is unitless)<br />
} else {<br />
return this.css( type, typeof size === &#8220;string&#8221; ? size : size + &#8220;px&#8221; );<br />
}<br />
};</p>
<p>});</p>
<p>// Expose jQuery to the global object<br />
window.jQuery = window.$ = jQuery;<br />
})( window );</p>

<div class="wpa" style="position: relative; width:300px; text-align: center; padding: 0; margin: 10px auto; overflow: hidden; clear: both;">
<a style="position: absolute; text-align: left; display: block; font: 9px/1 sans-serif; text-decoration: underline;" href="http://en.wordpress.com/about-these-ads/" rel="nofollow">About these ads</a>
<script type="text/javascript">
		var wpcom_adclk_hovering = false;
		var wpcom_adclk_recorded = false;
		var wpcom_adclk_theme = "iTheme2";
		var wpcom_adclk_slot = "wpcom_below_post";
		var wpcom_adclk_network = ( typeof wpcom_adclk_network === "undefined" ) ? "" : wpcom_adclk_network ;

		jQuery(document).ready( function() {
			function wpcom_adclk_hover_yes() { wpcom_adclk_hovering = true; }
			function wpcom_adclk_hover_no() { wpcom_adclk_hovering = false; }
			jQuery(".wpa").click(wpcom_adclk_click);
			jQuery(".wpa iframe").hover( wpcom_adclk_hover_yes, wpcom_adclk_hover_no );
			jQuery(".wpa object").hover( wpcom_adclk_hover_yes, wpcom_adclk_hover_no );

			jQuery(window).blur( function() {
				if ( wpcom_adclk_hovering ) { wpcom_adclk_click(); }
			});
		});

		function wpcom_adclk_impression() {
			var stat_gif = document.location.protocol + "//stats.wordpress.com/g.gif?v=wpcom-no-pv";
			stat_gif += "&x_ads_imp_theme=" + wpcom_adclk_theme;
			stat_gif += "&x_ads_imp_placement="+wpcom_adclk_slot;
			stat_gif += "&x_ads_imp_network=" + wpcom_adclk_network;
			stat_gif += "&x_ads_imp_theme_network="+wpcom_adclk_theme+"_"+wpcom_adclk_network;
			new Image().src = stat_gif + "&baba=" + Math.random();
			return true;
		}

		function wpcom_adclk_click() {
			if (wpcom_adclk_recorded) { return true; } // no double counting
			var stat_gif = document.location.protocol + "//stats.wordpress.com/g.gif?v=wpcom-no-pv";
			stat_gif += "&x_ads_click_theme=" + wpcom_adclk_theme;
			stat_gif += "&x_ads_click_placement="+wpcom_adclk_slot;
			stat_gif += "&x_ads_click_network=" + wpcom_adclk_network;
			stat_gif += "&x_ads_click_theme_network="+wpcom_adclk_theme+"_"+wpcom_adclk_network;

			new Image().src = stat_gif + "&baba=" + Math.random();
			wpcom_adclk_recorded = true;
			var now=new Date(); var end=now.getTime()+250;
			while(true){now=new Date();if(now.getTime()>end){break;}}
			return true;
		}
	
if ( typeof GA_googleAddAttr == 'function' ) {
GA_googleAddAttr("AdOpt", "1");
GA_googleAddAttr("Origin", "other");
GA_googleAddAttr("LangId", "1");
GA_googleAddAttr("Domain", "hassancseku.wordpress.com");
GA_googleAddAttr("BlogId", "29860955");
GA_googleAddAttr("PageURL", "http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/");
GA_googleAddAttr("Autotag", "technology");
GA_googleAddAttr("Autotag", "science");
GA_googleAddAttr("Autotag", "entertainment");
GA_googleAddAttr("Tag", "jquery");
GA_googleAddAttr("theme_bg", "ffffff");
GA_googleAddAttr("theme_border", "dddddd");
GA_googleAddAttr("theme_text", "666666");
GA_googleAddAttr("theme_link", "026acb");
GA_googleAddAttr("theme_url", "026acb");
GA_googleAddAdSensePageAttr("google_page_url", "http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/");
GA_googleFillSlot("wpcom_below_post");
}
</script>
</div>
<style type="text/css">
div.wpa>div { margin-top: 1em; } #google_ads_div_wpcom_below_post_adsafe_ad_container { display: block !important; }
</style>
<script type="text/javascript">
jQuery( window ).load( function() {
    if ( jQuery(".wpa script[src*='shareth.ru']").length > 0 || jQuery(".wpa iframe[src*='boomvideo.tv']").length > 0 || jQuery(".wpa iframe[src*='viewablemedia.net']").length > 0 || jQuery(".wpa .sharethrough-placement").length > 0 ) {
        jQuery( '.wpa' ).css( 'width', '400px' );
    }
setTimeout(function(){if(typeof GS_googleAddAdSenseService !== 'function'){new Image().src=document.location.protocol+"//stats.wordpress.com/g.gif?v=wpcom-no-pv&x_noads=adblock&baba="+Math.random()}},100);
} );
</script>
<div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><div class="sharedaddy sd-sharing-enabled"><div class="robots-nocontent sd-block sd-social sd-social-icon-text sd-sharing"><h3 class="sd-title">Share this:</h3><div class="sd-content"><ul><li class="share-twitter"><a rel="nofollow" class="share-twitter sd-button share-icon" href="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/?share=twitter" title="Click to share on Twitter" id="sharing-twitter-6"><span>Twitter</span></a></li><li class="share-facebook"><a rel="nofollow" class="share-facebook sd-button share-icon" href="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/?share=facebook" title="Share on Facebook" id="sharing-facebook-6"><span>Facebook</span></a></li><li class="share-end"></li></ul></div></div></div><div class='sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded' id='like-post-wrapper-29860955-6-52abba3bba8da' data-src='//widgets.wp.com/likes/#blog_id=29860955&amp;post_id=6&amp;origin=hassancseku.wordpress.com&amp;obj_id=29860955-6-52abba3bba8da' data-name='like-post-frame-29860955-6-52abba3bba8da'><h3 class='sd-title'>Like this:</h3><div class='likes-widget-placeholder post-likes-widget-placeholder' style='height:55px'><span class='button'><span>Like</span></span> <span class="loading">Loading...</span></div><span class='sd-text-color'></span><a class='sd-link-color'></a></div></div>			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					By hassancseku
						<span class="sep"> &#149; </span>
			<span class="cat-links">
				Posted in <a href="http://hassancseku.wordpress.com/category/jquery/" title="View all posts in JQUERY" rel="category tag">JQUERY</a>			</span>
			
			
					
				<div class="comments-link">
			<a href="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/#respond" title="Comment on jQuery Alert Dialogs (Alert, Confirm, &amp; Prompt&nbsp;Replacements)"><span class="no-replies">0</span></a>		</div>
			</footer><!-- #entry-meta -->
</article><!-- #post-6 -->

					<nav id="nav-below">
		<h1 class="assistive-text section-heading">Post navigation</h1>

	
				<div class="nav-next"><a href="http://hassancseku.wordpress.com/2011/11/27/read-excel-file-in-cakephp/" rel="next">Read Excel File in&nbsp;CakePhp <span class="meta-nav">&rarr;</span></a></div>
	
	</nav><!-- #nav-below -->
	
					<div id="comments">
	
	
	
	
									<div id="respond" class="comment-respond">
				<h3 id="reply-title" class="comment-reply-title">Leave a Reply <small><a rel="nofollow" id="cancel-comment-reply-link" href="/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/#respond" style="display:none;">Cancel reply</a></small></h3>
									<form action="http://hassancseku.wordpress.com/wp-comments-post.php" method="post" id="commentform" class="comment-form">
																										


												<input type="hidden" id="highlander_comment_nonce" name="highlander_comment_nonce" value="bbb23b6082" /><input type="hidden" name="_wp_http_referer" value="/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/" />
<input type="hidden" name="hc_post_as" id="hc_post_as" value="guest" />

<div class="comment-form-field comment-textarea">
	<label for="comment">Enter your comment here...</label>
	<div id="comment-form-comment"><textarea id="comment" name="comment" title="Enter your comment here..."></textarea></div>
</div>

<div id="comment-form-identity">

	<div id="comment-form-nascar">
		<p>Fill in your details below or click an icon to log in:</p>
		<ul>
			<li class="selected" style="display:none;">
				<a href="#comment-form-guest" id="postas-guest" title="Guest">
					<span></span>
				</a>
			</li>
			<li>
				<a href="#comment-form-load-service:WordPress.com" id="postas-wordpress" title="WordPress.com">
					<span></span>
				</a>
			</li>
			<li>
				<a href="#comment-form-load-service:Twitter" id="postas-twitter" title="Twitter">
					<span></span>
				</a>
			</li>
			<li>
				<a href="#comment-form-load-service:Facebook" id="postas-facebook" title="Facebook">
					<span></span>
				</a>
			</li>
			<li>
			<iframe id="googleplus-sign-in" name="googleplus-sign-in" src="https://public-api.wordpress.com/connect/?googleplus-sign-in=1" width="24" height="24" scrolling="no" allowtransparency="true" seamless="seamless" frameborder="0"></iframe>
			</li>
		</ul>
	</div>

	<div id="comment-form-guest" class="comment-form-service selected">
		<div class="comment-form-padder">
			<div class="comment-form-avatar">
<a href="https://gravatar.com/site/signup/" target="_blank">				<img src="http://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25&amp;d=identicon&amp;forcedefault=y&amp;r=G" alt="Gravatar" width="25" class="no-grav" />
</a>			</div>

				<div class="comment-form-fields">
				<div class="comment-form-field comment-form-email">
					<label for="email">Email <span class="required">(required)</span> <span class="nopublish">(Address never made public)</span></label>
					<div class="comment-form-input"><input id="email" name="email" type="email" value="" /></div>
				</div>
				<div class="comment-form-field comment-form-author">
					<label for="author">Name <span class="required">(required)</span></label>
					<div class="comment-form-input"><input id="author" name="author" type="text" value="" /></div>
				</div>
				<div class="comment-form-field comment-form-url">
					<label for="url">Website</label>
					<div class="comment-form-input"><input id="url" name="url" type="text" value="" /></div>
				</div>
			</div>
	
		</div>
	</div>

	<div id="comment-form-wordpress" class="comment-form-service">
		<div class="comment-form-padder">
			<div class="comment-form-avatar">
				<img src="http://s2.wp.com/wp-content/mu-plugins/highlander-comments/images/wplogo.png?m=1289230950g" alt="WordPress.com Logo" width="25" class="no-grav" />
			</div>

				<div class="comment-form-fields">
				<input type="hidden" name="wp_avatar" id="wordpress-avatar" class="comment-meta-wordpress" value="" />
				<input type="hidden" name="wp_user_id" id="wordpress-user_id" class="comment-meta-wordpress" value="" />
				<input type="hidden" name="wp_access_token" id="wordpress-access_token" class="comment-meta-wordpress" value="" />
				<p class="comment-form-posting-as pa-wordpress"><strong></strong> You are commenting using your WordPress.com account. <span class="comment-form-log-out">(&nbsp;<a href="javascript:HighlanderComments.doExternalLogout( 'wordpress' );">Log&nbsp;Out</a>&nbsp;/&nbsp;<a href="#" onclick="javascript:HighlanderComments.switchAccount();return false;">Change</a>&nbsp;)</span></p>
			</div>
	
		</div>
	</div>

	<div id="comment-form-twitter" class="comment-form-service">
		<div class="comment-form-padder">
			<div class="comment-form-avatar">
				<img src="http://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25&amp;d=identicon&amp;forcedefault=y&amp;r=G" alt="Twitter picture" width="25" class="no-grav" />
			</div>

				<div class="comment-form-fields">
				<input type="hidden" name="twitter_avatar" id="twitter-avatar" class="comment-meta-twitter" value="" />
				<input type="hidden" name="twitter_user_id" id="twitter-user_id" class="comment-meta-twitter" value="" />
				<input type="hidden" name="twitter_access_token" id="twitter-access_token" class="comment-meta-twitter" value="" />
				<p class="comment-form-posting-as pa-twitter"><strong></strong> You are commenting using your Twitter account. <span class="comment-form-log-out">(&nbsp;<a href="javascript:HighlanderComments.doExternalLogout( 'twitter' );">Log&nbsp;Out</a>&nbsp;/&nbsp;<a href="#" onclick="javascript:HighlanderComments.switchAccount();return false;">Change</a>&nbsp;)</span></p>
			</div>
	
		</div>
	</div>

	<div id="comment-form-facebook" class="comment-form-service">
		<div class="comment-form-padder">
			<div class="comment-form-avatar">
				<img src="http://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25&amp;d=identicon&amp;forcedefault=y&amp;r=G" alt="Facebook photo" width="25" class="no-grav" />
			</div>

				<div class="comment-form-fields">
				<input type="hidden" name="fb_avatar" id="facebook-avatar" class="comment-meta-facebook" value="" />
				<input type="hidden" name="fb_user_id" id="facebook-user_id" class="comment-meta-facebook" value="" />
				<input type="hidden" name="fb_access_token" id="facebook-access_token" class="comment-meta-facebook" value="" />
				<p class="comment-form-posting-as pa-facebook"><strong></strong> You are commenting using your Facebook account. <span class="comment-form-log-out">(&nbsp;<a href="javascript:HighlanderComments.doExternalLogout( 'facebook' );">Log&nbsp;Out</a>&nbsp;/&nbsp;<a href="#" onclick="javascript:HighlanderComments.switchAccount();return false;">Change</a>&nbsp;)</span></p>
			</div>
	
		</div>
	</div>

	<div id="comment-form-googleplus" class="comment-form-service">
		<div class="comment-form-padder">
			<div class="comment-form-avatar">
				<img src="http://1.gravatar.com/avatar/ad516503a11cd5ca435acc9bb6523536?s=25&amp;d=identicon&amp;forcedefault=y&amp;r=G" alt="Google+ photo" width="25" class="no-grav" />
			</div>

				<div class="comment-form-fields">
				<input type="hidden" name="googleplus_avatar" id="googleplus-avatar" class="comment-meta-googleplus" value="" />
				<input type="hidden" name="googleplus_user_id" id="googleplus-user_id" class="comment-meta-googleplus" value="" />
				<input type="hidden" name="googleplus_access_token" id="googleplus-access_token" class="comment-meta-googleplus" value="" />
				<p class="comment-form-posting-as pa-googleplus"><strong></strong> You are commenting using your Google+ account. <span class="comment-form-log-out">(&nbsp;<a href="javascript:HighlanderComments.doExternalLogout( 'googleplus' );">Log&nbsp;Out</a>&nbsp;/&nbsp;<a href="#" onclick="javascript:HighlanderComments.switchAccount();return false;">Change</a>&nbsp;)</span></p>
			</div>
	
		</div>
	</div>


	<div id="comment-form-load-service" class="comment-form-service">
		<div class="comment-form-posting-as-cancel"><a href="javascript:HighlanderComments.cancelExternalWindow();">Cancel</a></div>
		<p>Connecting to %s</p>
	</div>

	
</div>

<script type="text/javascript">
var highlander_expando_javascript = function(){
	var input = document.createElement( 'input' ),
	    comment = jQuery( '#comment' );

	if ( 'placeholder' in input ) {
		comment.attr( 'placeholder', jQuery( '.comment-textarea label' ).remove().text() );
	}

	// Expando Mode: start small, then auto-resize on first click + text length
	jQuery( '#comment-form-identity' ).hide();
	jQuery( '#comment-form-subscribe' ).hide();
	jQuery( '#commentform .form-submit' ).hide();

	comment.css( { 'height':'10px' } ).one( 'focus', function() {
		var timer = setInterval( HighlanderComments.resizeCallback, 10 )
		jQuery( this ).animate( { 'height': HighlanderComments.initialHeight } ).delay( 100 ).queue( function(n) { clearInterval( timer ); HighlanderComments.resizeCallback(); n(); } );
		jQuery( '#comment-form-identity' ).slideDown();
		jQuery( '#comment-form-subscribe' ).slideDown();
		jQuery( '#commentform .form-submit' ).slideDown();
	});
}
jQuery(document).ready( highlander_expando_javascript );
</script>

<div id="comment-form-subscribe">
	<p class="comment-subscription-form"><input type="checkbox" name="subscribe" id="subscribe" value="subscribe" style="width: auto;" tabindex="6"/> <label class="subscribe-label" id="subscribe-label" for="subscribe" style="display: inline;">Notify me of follow-up comments via email.</label></p></div>

												<p class="form-submit">
							<input name="submit" type="submit" id="comment-submit" value="Post Comment" />
							<input type='hidden' name='comment_post_ID' value='6' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
						</p>
						
<input type="hidden" name="genseq" value="1386986043" />
<p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="e37047591b" /></p><script type='text/javascript' src='http://s2.wp.com/wp-content/mu-plugins/akismet-2.5/form.js?m=1308783962g'></script>
<p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="168"/></p>					</form>
							</div><!-- #respond -->
			<div style="clear: both"></div>
</div><!-- #comments -->

			
			</div><!-- #content -->
		</div><!-- #primary -->

		<div id="secondary" class="widget-area" role="complementary">
					<aside id="search-2" class="widget widget_search"><h1 class="widget-title">Article Search</h1>	<form method="get" id="searchform" action="http://hassancseku.wordpress.com/">
		<label for="s" class="assistive-text">Search</label>
		<input type="text" class="field" name="s" id="s" placeholder="Search &hellip;" />
		<input type="submit" class="submit" name="submit" id="searchsubmit" value="Search" />
	</form>
</aside>		</div><!-- #secondary .widget-area -->

		
	</div><!-- #main -->

	<footer id="colophon" role="contentinfo">
		<div id="site-generator">
						<a href="http://wordpress.com/?ref=footer" rel="generator">Blog at WordPress.com</a>.
			<span class="sep"> | </span>
			<a href="http://theme.wordpress.com/themes/itheme2/" title="Learn more about this theme">The iTheme2 Theme</a>. 		</div>
	</footer><!-- #colophon -->
</div><!-- #page -->


<script type="text/javascript">
var _qevents = _qevents || [], wpcomQuantcastData = {"qacct":"p-18-mFEk4J448M","labels":"language.en,type.wpcom,wp.loggedout,as"};
function wpcomQuantcastPixel( labels, options ) {
	var i, defaults = wpcomQuantcastData, data = { event: 'ajax' };

	labels  = labels  || '';
	options = options || {};

	if ( typeof labels != 'string' )
		options = labels;

	for ( i in defaults ) {
		data[i] = defaults[i];
	}

	for ( i in options ) {
		data[i] = options[i];
	}

	if ( data.labels ) {
		data.labels += ',' + labels;
	} else {
		data.labels = labels;
	}

	_qevents.push( data );
};
(function() {var elem = document.createElement('script');elem.src = (document.location.protocol == "https:" ? "https://secure" : "http://edge") + ".quantserve.com/quant.js";elem.async = true;elem.type = "text/javascript";var scpt = document.getElementsByTagName('script')[0];scpt.parentNode.insertBefore(elem, scpt);  })();
_qevents.push( wpcomQuantcastData );
</script>
<noscript><div style="display: none;"><img src="//pixel.quantserve.com/pixel/p-18-mFEk4J448M.gif?labels=language.en%2Ctype.wpcom%2Cwp.loggedout%2Cas" height="1" width="1" alt="" /></div></noscript>

<script type='text/javascript' src='//0.gravatar.com/js/gprofiles.js?ver=201350ae'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var WPGroHo = {"my_hash":""};
/* ]]> */
</script>
<script type='text/javascript' src='http://s2.wp.com/wp-content/mu-plugins/gravatar-hovercards/wpgroho.js?m=1380573781g'></script>

	<script>
		//initialize and attach hovercards to all gravatars
		jQuery( document ).ready( function( $ ) {
			Gravatar.profile_cb = function( hash, id ) {
				WPGroHo.syncProfileData( hash, id );
			};
			Gravatar.my_hash = WPGroHo.my_hash;
			Gravatar.init( 'body', '#wp-admin-bar-my-account' );
		});
	</script>

		<div style="display:none">
	</div>
<script type='text/javascript'>
/* <![CDATA[ */
var HighlanderComments = {"loggingInText":"Logging In\u2026","submittingText":"Posting Comment\u2026","postCommentText":"Post Comment","connectingToText":"Connecting to %s","commentingAsText":"%1$s: You are commenting using your %2$s account.","logoutText":"Log Out","loginText":"Log In","connectURL":"http:\/\/hassancseku.wordpress.com\/public.api\/connect\/?action=request","logoutURL":"http:\/\/hassancseku.wordpress.com\/wp-login.php?action=logout&_wpnonce=2836dde31a","homeURL":"http:\/\/hassancseku.wordpress.com\/","postID":"6","gravDefault":"identicon","enterACommentError":"Please enter a comment","enterEmailError":"Please enter your email address here","invalidEmailError":"Invalid email address","enterAuthorError":"Please enter your name here","gravatarFromEmail":"This picture will show whenever you leave a comment. Click to customize it.","logInToExternalAccount":"Log in to use details from one of these accounts.","change":"Change","changeAccount":"Change Account","comment_registration":"0","userIsLoggedIn":"","isJetpack":"0"};
/* ]]> */
</script>
<script type='text/javascript' src='http://s1.wp.com/_static/??/wp-content/js/jquery/jquery.autoresize.js,/wp-content/mu-plugins/highlander-comments/script.js?m=1383163422j'></script>

	<div id="bit" class="loggedout-follow-normal">
		<a class="bsub" href="javascript:void(0)"><span id='bsub-text'>Follow</span></a>
		<div id="bitsubscribe">

					<h3><label for="loggedout-follow-field">Follow &ldquo;hassancseku&rdquo;</label></h3>

			<form action="https://subscribe.wordpress.com" method="post" accept-charset="utf-8" id="loggedout-follow">
			<p>Get every new post delivered to your Inbox.</p>

			<p id="loggedout-follow-error" style="display: none;"></p>

			
			<p><input type="email" name="email" value="Enter your email address" onfocus='this.value=(this.value=="Enter your email address") ? "" : this.value;' onblur='this.value=(this.value=="") ? "Enter email address" : this.value;'  id="loggedout-follow-field"/></p>

			<input type="hidden" name="action" value="subscribe"/>
			<input type="hidden" name="blog_id" value="29860955"/>
			<input type="hidden" name="source" value="http://hassancseku.wordpress.com/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/"/>
			<input type="hidden" name="sub-type" value="loggedout-follow"/>

			<input type="hidden" id="_wpnonce" name="_wpnonce" value="070b81f86e" /><input type="hidden" name="_wp_http_referer" value="/2011/11/27/jquery-alert-dialogs-alert-confirm-prompt-replacements/" />
			<p id='bsub-subscribe-button'><input type="submit" value="Sign me up" /></p>
			</form>
					<div id='bsub-credit'><a href="http://wordpress.com/signup/?ref=lof">Powered by WordPress.com</a></div>
		</div><!-- #bitsubscribe -->
	</div><!-- #bit -->
	<script type="text/javascript">
	var skimlinks_pub_id = "725X584219"
	var skimlinks_sitename = "hassancseku.wordpress.com";
	</script>
	<script type="text/javascript" src="http://s.skimresources.com/js/725X1342.skimlinks.js"></script>
	<script type="text/javascript">
		WPCOM_sharing_counts = {"http:\/\/hassancseku.wordpress.com\/2011\/11\/27\/jquery-alert-dialogs-alert-confirm-prompt-replacements\/":6}	</script>
		<script type="text/javascript">
		jQuery(document).on( 'ready post-load', function(){
			jQuery( 'a.share-twitter' ).on( 'click', function() {
				window.open( jQuery(this).attr( 'href' ), 'wpcomtwitter', 'menubar=1,resizable=1,width=600,height=350' );
				return false;
			});
		});
		</script>
				<script type="text/javascript">
		jQuery(document).on( 'ready post-load', function(){
			jQuery( 'a.share-facebook' ).on( 'click', function() {
				window.open( jQuery(this).attr( 'href' ), 'wpcomfacebook', 'menubar=1,resizable=1,width=600,height=400' );
				return false;
			});
		});
		</script>
				<iframe src='http://widgets.wp.com/likes/master.html?ver=20131206#ver=20131206&amp;mp6=1' scrolling='no' id='likes-master' name='likes-master' style='display:none;'></iframe>
		<div id='likes-other-gravatars'><div class="likes-text"><span>%d</span> bloggers like this:</div><ul class="wpl-avatars sd-like-gravatars"></ul></div>
		<script type="text/javascript">
		//<![CDATA[
			var jetpackLikesWidgetQueue = [];
			var jetpackLikesWidgetBatch = [];
			var jetpackLikesMasterReady = false;

			function JetpackLikespostMessage( message, target ) {
				if ( "string" === typeof message ){
					try{
						message = JSON.parse( message );
					}
					catch(e) {
						return;
					}
				}

				pm( {
					target: target,
					type: 'likesMessage',
					data: message,
					origin: '*'
				} );
			}

			function JetpackLikesBatchHandler() {
				var requests = [];
				jQuery( 'div.jetpack-likes-widget-unloaded' ).each( function( i ) {
					if ( jetpackLikesWidgetBatch.indexOf( this.id ) > -1 )
						return;
					jetpackLikesWidgetBatch.push( this.id );
					var regex = /like-(post|comment)-wrapper-(\d+)-(\d+)-(\w+)/;
					var match = regex.exec( this.id );
					if ( ! match || match.length != 5 )
						return;

					var info = {
						blog_id: match[2],
						width:   this.width
					};

					if ( 'post' == match[1] ) {
						info.post_id = match[3];
					} else if ( 'comment' == match[1] ) {
						info.comment_id = match[3];
					}

					info.obj_id = match[4];

					requests.push( info );
				});

				if ( requests.length > 0 ) {
					JetpackLikespostMessage( { event: 'initialBatch', requests: requests }, window.frames['likes-master'] );
				}
			}

			function JetpackLikesMessageListener( event ) {
				if ( "undefined" == typeof event.event )
					return;

				if ( 'masterReady' == event.event ) {
					jQuery( document ).ready( function() {
						jetpackLikesMasterReady = true;

						var stylesData = {
								event: 'injectStyles'
						};

						if ( jQuery( 'iframe.admin-bar-likes-widget' ).length > 0 ) {
							JetpackLikespostMessage( { event: 'adminBarEnabled' }, window.frames[ 'likes-master' ] );

							stylesData.adminBarStyles = {
								background: jQuery( '#wpadminbar .quicklinks li#wp-admin-bar-wpl-like > a' ).css( 'background' )
							};
						}

						if ( !window.addEventListener )
							jQuery( '#wp-admin-bar-admin-bar-likes-widget' ).hide();

						stylesData.textStyles = {
							color: jQuery( '.sd-text-color').css( 'color' ),
							fontFamily: jQuery( '.sd-text-color' ).css( 'font-family' ),
							fontSize: jQuery( '.sd-text-color' ).css( 'font-size' ),
							direction: jQuery( '.sd-text-color' ).css( 'direction' ),
							fontWeight: jQuery( '.sd-text-color' ).css( 'font-weight' ),
							fontStyle: jQuery( '.sd-text-color' ).css( 'font-style' ),
							textDecoration: jQuery( '.sd-text-color' ).css('text-decoration')
						};

						stylesData.linkStyles = {
							color: jQuery( '.sd-link-color' ).css('color'),
							fontFamily: jQuery( '.sd-link-color' ).css('font-family'),
							fontSize: jQuery( '.sd-link-color' ).css('font-size'),
							textDecoration: jQuery( '.sd-link-color' ).css('text-decoration'),
							fontWeight: jQuery( '.sd-link-color' ).css( 'font-weight' ),
							fontStyle: jQuery( '.sd-link-color' ).css( 'font-style' )
						};

						JetpackLikespostMessage( stylesData, window.frames[ 'likes-master' ] );

						JetpackLikesBatchHandler();

						jQuery( document ).on( 'inview', 'div.jetpack-likes-widget-unloaded', function() {
							jetpackLikesWidgetQueue.push( this.id );
						});
					});
				}

				if ( 'showLikeWidget' == event.event ) {
					jQuery( '#' + event.id + ' .post-likes-widget-placeholder'  ).fadeOut( 'fast', function() {
						jQuery( '#' + event.id + ' .post-likes-widget' ).fadeIn( 'fast', function() {
							JetpackLikespostMessage( { event: 'likeWidgetDisplayed', blog_id: event.blog_id, post_id: event.post_id, obj_id: event.obj_id }, window.frames['likes-master'] );
						});
					});
				}

				if ( 'showOtherGravatars' == event.event ) {
					var $container = jQuery( '#likes-other-gravatars' );
					var $list = $container.find( 'ul' );

					$container.hide();
					$list.html( '' );

					$container.find( '.likes-text span' ).text( event.total );

					jQuery.each( event.likers, function( i, liker ) {
						$list.append( '<li class="' + liker.css_class + '"><a href="' + liker.profile_URL + '" class="wpl-liker" rel="nofollow" target="_parent"><img src="' + liker.avatar_URL + '" alt="' + liker.name + '" width="30" height="30" style="padding-right: 3px;" /></a></li>');
					} );

					var offset = jQuery( "[name='" + event.parent + "']" ).offset();

					$container.css( 'left', offset.left + event.position.left - 10 + 'px' );
					$container.css( 'top', offset.top + event.position.top - 33 + 'px' );

					var rowLength = Math.floor( event.width / 37 );
					var height = ( Math.ceil( event.likers.length / rowLength ) * 37 ) + 13;
					if ( height > 204 ) {
						height = 204;
					}

					$container.css( 'height', height + 'px' );
					$container.css( 'width', rowLength * 37 - 7 + 'px' );

					$list.css( 'width', rowLength * 37 + 'px' );

					$container.fadeIn( 'slow' );

					var scrollbarWidth = $list[0].offsetWidth - $list[0].clientWidth;
					if ( scrollbarWidth > 0 ) {
						$container.width( $container.width() + scrollbarWidth );
						$list.width( $list.width() + scrollbarWidth );
					}
				}
			}

			pm.bind( 'likesMessage', function(e) { JetpackLikesMessageListener(e); } );

			jQuery( document ).click( function( e ) {
				var $container = jQuery( '#likes-other-gravatars' );

				if ( $container.has( e.target ).length === 0 ) {
					$container.fadeOut( 'slow' );
				}
			});

			function JetpackLikesWidgetQueueHandler() {
				var wrapperID;
				if ( ! jetpackLikesMasterReady ) {
					setTimeout( JetpackLikesWidgetQueueHandler, 500 );
					return;
				}

				if ( jetpackLikesWidgetQueue.length > 0 ) {
					// We may have a widget that needs creating now
					var found = false;
					while( jetpackLikesWidgetQueue.length > 0 ) {
						// Grab the first member of the queue that isn't already loading.
						wrapperID = jetpackLikesWidgetQueue.splice( 0, 1 )[0];
						if ( jQuery( '#' + wrapperID ).hasClass( 'jetpack-likes-widget-unloaded' ) ) {
							found = true;
							break;
						}
					}
					if ( ! found ) {
						setTimeout( JetpackLikesWidgetQueueHandler, 500 );
						return;
					}
				} else if ( jQuery( 'div.jetpack-likes-widget-unloaded' ).length > 0 ) {
					// Grab any unloaded widgets for a batch request
					JetpackLikesBatchHandler();

					// Get the next unloaded widget
					wrapperID = jQuery( 'div.jetpack-likes-widget-unloaded' ).first()[0].id;
					if ( ! wrapperID ) {
						// Everything is currently loaded
						setTimeout( JetpackLikesWidgetQueueHandler, 500 );
						return;
					}
				}

				if ( 'undefined' === typeof wrapperID ) {
					setTimeout( JetpackLikesWidgetQueueHandler, 500 );
					return;
				}

				var $wrapper = jQuery( '#' + wrapperID );
				$wrapper.find( 'iframe' ).remove();

				if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
					$wrapper.find( '.post-likes-widget-placeholder' ).after( "<iframe class='post-likes-widget jetpack-likes-widget' name='" + $wrapper.data( 'name' ) + "' height='22px' width='68px' frameBorder='0' scrolling='no' src='" + $wrapper.data( 'src' ) + "'></iframe>" );
				} else {
					$wrapper.find( '.post-likes-widget-placeholder' ).after( "<iframe class='post-likes-widget jetpack-likes-widget' name='" + $wrapper.data( 'name' ) + "' height='55px' width='100%' frameBorder='0' src='" + $wrapper.data( 'src' ) + "'></iframe>" );
				}

				$wrapper.removeClass( 'jetpack-likes-widget-unloaded' ).addClass( 'jetpack-likes-widget-loading' );

				$wrapper.find( 'iframe' ).load( function( e ) {
					var $iframe = jQuery( e.target );
					$wrapper.removeClass( 'jetpack-likes-widget-loading' ).addClass( 'jetpack-likes-widget-loaded' );

					JetpackLikespostMessage( { event: 'loadLikeWidget', name: $iframe.attr( 'name' ), width: $iframe.width() }, window.frames[ 'likes-master' ] );

					if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
						$wrapper.find( 'iframe' ).Jetpack( 'resizeable' );
					}
				});
				setTimeout( JetpackLikesWidgetQueueHandler, 250 );
			}
			JetpackLikesWidgetQueueHandler();
		//]]>
		</script>
<script type='text/javascript'>
/* <![CDATA[ */
var recaptcha_options = {"lang":"en"};
/* ]]> */
</script>
<script type='text/javascript' src='http://s2.wp.com/_static/??/wp-content/js/devicepx.js,/wp-content/mu-plugins/post-flair/sharing/sharing.js?m=1373391538j'></script>
<script type="text/javascript">
// <![CDATA[
(function() {
try{
  if ( window.external &&'msIsSiteMode' in window.external) {
    if (window.external.msIsSiteMode()) {
      var jl = document.createElement('script');
      jl.type='text/javascript';
      jl.async=true;
      jl.src='/wp-content/plugins/ie-sitemode/custom-jumplist.php';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jl, s);
    }
  }
}catch(e){}
})();
// ]]>
</script><script src="http://s.stats.wordpress.com/w.js?21" type="text/javascript"></script>
<script type="text/javascript">
st_go({'blog':'29860955','v':'wpcom','tz':'0','user_id':'0','post':'6','subd':'hassancseku'});
ex_go({'crypt':'UE5XaGUuOTlwaD85flAmcm1mcmZsaDhkV11YdTdvUG14Q2VDQTR4LlUsLi82dU1mai9BMkEvYVRKb24/czlSc0R4QU9JUHVbSUw4amxBamh4JlYlLUVpTnBNSEthay9BclB1VG52TjhKQnBhMEl2YVg2d3dyLmhnR2FLL1grc080RzI3X1NWWnllQz9NSEY4NGdSR3paMno3Mm51by5sWG9wYWR5aHZ4cDVHS19JUXRIfl83Nz8tX2VjV016QnFHZiY/T3czQj8lQy90JWdKbVc0diUraG8ybnI3W0ksLGtDMX54PSZjW29bcmJLKzVacGFhTmV6QlJ4P1B8RVpWWl9daFNISU5UeGh+Q2VVb083SldNVjFvUjdMNmJDOGFrcXJV'});
addLoadEvent(function(){linktracker_init('29860955',6);});
	</script>
<noscript><img src="http://stats.wordpress.com/b.gif?v=noscript" style="height:0px;width:0px;overflow:hidden" alt="" /></noscript>
<script>
if ( 'object' === typeof wpcom_mobile_user_agent_info ) {

	wpcom_mobile_user_agent_info.init();
	var mobileStatsQueryString = "";
	
	if( false !== wpcom_mobile_user_agent_info.matchedPlatformName )
		mobileStatsQueryString += "&x_" + 'mobile_platforms' + '=' + wpcom_mobile_user_agent_info.matchedPlatformName;
	
	if( false !== wpcom_mobile_user_agent_info.matchedUserAgentName )
		mobileStatsQueryString += "&x_" + 'mobile_devices' + '=' + wpcom_mobile_user_agent_info.matchedUserAgentName;
	
	if( wpcom_mobile_user_agent_info.isIPad() )
		mobileStatsQueryString += "&x_" + 'ipad_views' + '=' + 'views';

	if( "" != mobileStatsQueryString ) {
		new Image().src = document.location.protocol + '//stats.wordpress.com/g.gif?v=wpcom-no-pv' + mobileStatsQueryString + '&baba=' + Math.random();
	}
	
}
</script>
</body>
</html>

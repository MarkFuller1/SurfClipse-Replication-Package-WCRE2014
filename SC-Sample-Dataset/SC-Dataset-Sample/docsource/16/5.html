
    
    <!-- classdoc.jsp -->
<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
	<title>java.net: public final class: URL</title>
	<style>
#jdoc {margin:10px 10px 10px 10px}
#pkg {font-size:1em;font-weight:bold}
#cls {font-size:2em;font-weight:bold}
body {margin:0 0 0 0; padding:0 0 0 0} 
table {margin-top:10px;background-color:#ffffff;}

th {background:#ddeeff;text-align:left}	
td {padding:5px 2px 2px 5px;border-top:1px solid #999999;margin:0 0 0 0}
pre {padding:0;margin:0}
.withborder {border-left:1px solid #999999;border-right:1px solid #999999;background-color:#eeeeee}
	</style>
	
	<script type="text/javascript">
	
	function src(m) {
	  s = 	document.getElementById(m);
	  i = document.getElementById(m+"i");
	  if (s != null && s.style.visibility!='visible') {
	   s.style.visibility='visible';
	   s.style.height="auto";
	   s.style.overflow='auto';
	   i.src = "/minus.gif";
	  } else if (s != null) {
	   s.style.visibility='hidden';
	   s.style.height="1px";
	   s.style.overflow='hidden';
	   i.src = "/plus.gif";
	  }
	}
	
	</script>
<style type="text/css">
#fixme {
	/* Netscape 4, IE 4.x-5.0/Win and other lesser browsers will use this */
  position: absolute; left: 0; top: 0;
}
body > div#fixme {
  /* used by Opera 5+, Netscape6+/Mozilla, Konqueror, Safari, OmniWeb 4.5+, iCab, ICEbrowser */
  position: fixed;
}
</style>
<!--[if gte IE 5.5]>
<style type="text/css">
div#fixme {
  /* IE5.5+/Win - this is more specific than the IE 5.0 version */
  left: expression( ( 0 + ( ignoreMe2 = document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft ) ) + 'px' );
  top: expression( ( 0 + ( ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop ) ) + 'px' );
}
</style>
<![endif]--></head><body>
<div id="fixme" style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px">
<div style="float:right"><a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&noui&jump=close&url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border=0> Save This Page</a></div>
<a href="/">Home</a> &#187; <a href="/projects/openjdk-7-java.html">openjdk-7</a> &#187; java &#187;  <a href='/docs/api/java/net/package-index.html'>net</a> &#187; 
[javadoc | 
 <a href="/html/api/java/net/URL.java.html">source</a>]
</div>
<div style="height:20px"></div>
<div id="jdoc">


<!-- classname.jsp -->
    
<span id="pkg">java.net</span><br>
    <span id="cls">public final class: URL</span> [javadoc | 
 <a href="/html/api/java/net/URL.java.html">source</a>]
    
    	<br><pre><a href=/docs/api/java/lang/Object.html>java.lang.Object</a>
 &nbsp; <img src=/inherit.gif><b>java.net.URL</b></pre>
    




<!-- end -->


<!-- classimplements.jsp -->
    <p><b>All Implemented Interfaces:</b>
		<br> &nbsp; &nbsp; <a href='/docs/api/java$io$Serializable.html'>java$io$Serializable</a></p>




<!-- end -->


    <!-- classcomment.jsp -->
    Class <code>URL</code> represents a Uniform Resource
Locator, a pointer to a "resource" on the World
Wide Web. A resource can be something as simple as a file or a
directory, or it can be a reference to a more complicated object,
such as a query to a database or to a search engine. More
information on the types of URLs and their formats can be found at:
<blockquote>
    <a href="http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html">
   <i>http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html</i></a>
</blockquote>
<p>
In general, a URL can be broken into several parts. The previous
example of a URL indicates that the protocol to use is
<code>http</code> (HyperText Transfer Protocol) and that the
information resides on a host machine named
<code>www.socs.uts.edu.au</code>. The information on that host
machine is named <code>/MosaicDocs-old/url-primer.html</code>. The exact
meaning of this name on the host machine is both protocol
dependent and host dependent. The information normally resides in
a file, but it could be generated on the fly. This component of
the URL is called the <i>path</i> component.
<p>
A URL can optionally specify a "port", which is the
port number to which the TCP connection is made on the remote host
machine. If the port is not specified, the default port for
the protocol is used instead. For example, the default port for
<code>http</code> is <code>80</code>. An alternative port could be
specified as:
<blockquote><pre>
    http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html
</pre></blockquote>
<p>
The syntax of <code>URL</code> is defined by  <a
href="http://www.ietf.org/rfc/rfc2396.txt"><i>RFC&nbsp;2396: Uniform
Resource Identifiers (URI): Generic Syntax</i></a>, amended by <a
href="http://www.ietf.org/rfc/rfc2732.txt"><i>RFC&nbsp;2732: Format for
Literal IPv6 Addresses in URLs</i></a>. The Literal IPv6 address format
also supports scope_ids. The syntax and usage of scope_ids is described
<a href="Inet6Address.html#scoped">here</a>.
<p>
A URL may have appended to it a "fragment", also known
as a "ref" or a "reference". The fragment is indicated by the sharp
sign character "#" followed by more characters. For example,
<blockquote><pre>
    http://java.sun.com/index.html#chapter1
</pre></blockquote>
<p>
This fragment is not technically part of the URL. Rather, it
indicates that after the specified resource is retrieved, the
application is specifically interested in that part of the
document that has the tag <code>chapter1</code> attached to it. The
meaning of a tag is resource specific.
<p>
An application can also specify a "relative URL",
which contains only enough information to reach the resource
relative to another URL. Relative URLs are frequently used within
HTML pages. For example, if the contents of the URL:
<blockquote><pre>
    http://java.sun.com/index.html
</pre></blockquote>
contained within it the relative URL:
<blockquote><pre>
    FAQ.html
</pre></blockquote>
it would be a shorthand for:
<blockquote><pre>
    http://java.sun.com/FAQ.html
</pre></blockquote>
<p>
The relative URL need not specify all the components of a URL. If
the protocol, host name, or port number is missing, the value is
inherited from the fully specified URL. The file component must be
specified. The optional fragment is not inherited.
<p>
The URL class does not itself encode or decode any URL components
according to the escaping mechanism defined in RFC2396. It is the
responsibility of the caller to encode any fields, which need to be
escaped prior to calling URL, and also to decode any escaped fields,
that are returned from URL. Furthermore, because URL has no knowledge
of URL escaping, it does not recognise equivalence between the encoded
or decoded form of the same URL. For example, the two URLs:<br>
<pre>    http://foo.com/hello world/ and http://foo.com/hello%20world</pre>
would be considered not equal to each other.
<p>
Note, the <a href='/docs/api/java/net/URI.html'>java.net.URI</a>  class does perform escaping of its
component fields in certain circumstances. The recommended way
to manage the encoding and decoding of URLs is to use <a href='/docs/api/java/net/URI.html'>java.net.URI</a> ,
and to convert between these two classes using <a href='#toURI()'>#toURI()</a>  and
<a href='URI.html#toURL()'>URI#toURL()</a> .
<p>
The <a href='URLEncoder.html'>URLEncoder</a>  and <a href='URLDecoder.html'>URLDecoder</a>  classes can also be
used, but only for HTML form encoding, which is not the same
as the encoding scheme defined in RFC2396.<ul><dd>author: <code>James</code> -  Gosling<br></dd><dd>since: <code>JDK1.0</code> - <br></dd></ul>



<!-- end -->



<!-- nestedclass.jsp -->
    



<!-- end -->


<!-- fieldsummary.jsp -->
    
<table width='100%'><tr><th colspan=3>Field Summary</td></tr><tr valign=top><td valign='top' nowrap>static final  &nbsp;long</td> <td class='withborder' nowrap><b>serialVersionUID</b>&nbsp; &nbsp; </td><td width='100%'>&nbsp;</td></tr><tr valign=top><td valign='top' nowrap>transient  &nbsp;<a href=/docs/api/java/net/InetAddress.html>InetAddress</a></td> <td class='withborder' nowrap><b>hostAddress</b>&nbsp; &nbsp; </td><td width='100%'>The host's IP address, used in equals and hashCode.
Computed on demand. An uninitialized or unknown hostAddress is null.&nbsp;</td></tr><tr valign=top><td valign='top' nowrap>transient  &nbsp;<a href=/docs/api/java/net/URLStreamHandler.html>URLStreamHandler</a></td> <td class='withborder' nowrap><b>handler</b>&nbsp; &nbsp; </td><td width='100%'>The URLStreamHandler for this URL.&nbsp;</td></tr><tr valign=top><td valign='top' nowrap>static  &nbsp;<a href=/docs/api/java/net/URLStreamHandlerFactory.html>URLStreamHandlerFactory</a></td> <td class='withborder' nowrap><b>factory</b>&nbsp; &nbsp; </td><td width='100%'>The URLStreamHandler factory.&nbsp;</td></tr><tr valign=top><td valign='top' nowrap>static  &nbsp;<a href=/docs/api/java/util/Hashtable.html>Hashtable</a></td> <td class='withborder' nowrap><b>handlers</b>&nbsp; &nbsp; </td><td width='100%'>A table of protocol handlers.&nbsp;</td></tr>





<!-- end -->




<!-- constructsummary.jsp -->
    <table width='100%'><tr><th>Constructor:</td></tr>
<tr><td><pre><a href='javascript:src("cs0")'><img id='cs0i' src=/plus.gif border=0></a> <a name='URL(String)'>public <b>URL</b>(<a href=/docs/api/java/lang/String.html>String</a> spec) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs0' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        this(null, spec);
}</pre></pre></pre><ul>Creates a <code>URL</code> object from the <code>String</code>
representation.
<p>
This constructor is equivalent to a call to the two-argument
constructor with a <code>null</code> first argument.</ul><ul><b>Parameters:</b><br><dd><code>spec</code> -    the <code>String</code> to parse as a URL.<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd><b>Also see:</b><br><dd>java.net.URL#URL(java.net.URL, java.lang.String)</dd><dd>exception: <code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd></ul></td></tr><tr><td><pre><a href='javascript:src("cs1")'><img id='cs1i' src=/plus.gif border=0></a> <a name='URL(URL, String)'>public <b>URL</b>(<a href=/docs/api/java/net/URL.html>URL</a> context,
    <a href=/docs/api/java/lang/String.html>String</a> spec) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs1' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        this(context, spec, null);
}</pre></pre></pre><ul>Creates a URL by parsing the given spec within a specified context.

The new URL is created from the given context URL and the spec
argument as described in
RFC2396 &quot;Uniform Resource Identifiers : Generic * Syntax&quot; :
<blockquote><pre>
         &lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;
</pre></blockquote>
The reference is parsed into the scheme, authority, path, query and
fragment parts. If the path component is empty and the scheme,
authority, and query components are undefined, then the new URL is a
reference to the current document. Otherwise, the fragment and query
parts present in the spec are used in the new URL.
<p>
If the scheme component is defined in the given spec and does not match
the scheme of the context, then the new URL is created as an absolute
URL based on the spec alone. Otherwise the scheme component is inherited
from the context URL.
<p>
If the authority component is present in the spec then the spec is
treated as absolute and the spec authority and path will replace the
context authority and path. If the authority component is absent in the
spec then the authority of the new URL will be inherited from the
context.
<p>
If the spec's path component begins with a slash character
&quot;/&quot; then the
path is treated as absolute and the spec path replaces the context path.
<p>
Otherwise, the path is treated as a relative path and is appended to the
context path, as described in RFC2396. Also, in this case,
the path is canonicalized through the removal of directory
changes made by occurences of &quot;..&quot; and &quot;.&quot;.
<p>
For a more detailed description of URL parsing, refer to RFC2396.</ul><ul><b>Parameters:</b><br><dd><code>context</code> -    the context in which to parse the specification.<br></dd><dd><code>spec</code> -       the <code>String</code> to parse as a URL.<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd><b>Also see:</b><br><dd>java.net.URL#URL(java.lang.String, java.lang.String,
                 int, java.lang.String)</dd><dd><a href='/docs/api/java/net/URLStreamHandler.html'>java.net.URLStreamHandler</a></dd><dd>java.net.URLStreamHandler#parseURL(java.net.URL,
                 java.lang.String, int, int)</dd><dd>exception: <code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd></ul></td></tr><tr><td><pre><a href='javascript:src("cs2")'><img id='cs2i' src=/plus.gif border=0></a> <a name='URL(String, String, String)'>public <b>URL</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol,
    <a href=/docs/api/java/lang/String.html>String</a> host,
    <a href=/docs/api/java/lang/String.html>String</a> file) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs2' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        this(protocol, host, -1, file);
}</pre></pre></pre><ul>Creates a URL from the specified <code>protocol</code>
name, <code>host</code> name, and <code>file</code> name. The
default port for the specified protocol is used.
<p>
This method is equivalent to calling the four-argument
constructor with the arguments being <code>protocol</code>,
<code>host</code>, <code>-1</code>, and <code>file</code>.

No validation of the inputs is performed by this constructor.</ul><ul><b>Parameters:</b><br><dd><code>protocol</code> -    the name of the protocol to use.<br></dd><dd><code>host</code> -        the name of the host.<br></dd><dd><code>file</code> -        the file on the host.<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd><b>Also see:</b><br><dd>java.net.URL#URL(java.lang.String, java.lang.String,
                 int, java.lang.String)</dd><dd>exception: <code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd></ul></td></tr><tr><td><pre><a href='javascript:src("cs3")'><img id='cs3i' src=/plus.gif border=0></a> <a name='URL(URL, String, URLStreamHandler)'>public <b>URL</b>(<a href=/docs/api/java/net/URL.html>URL</a> context,
    <a href=/docs/api/java/lang/String.html>String</a> spec,
    <a href=/docs/api/java/net/URLStreamHandler.html>URLStreamHandler</a> handler) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs3' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        String original = spec;
        int i, limit, c;
        int start = 0;
        String newProtocol = null;
        boolean aRef=false;
        boolean isRelative = false;
        // Check for permission to specify a handler
        if (handler != null) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                checkSpecifyHandler(sm);
            }
        }
        try {
            limit = spec.length();
            while ((limit  > 0) && (spec.charAt(limit - 1) < = ' ')) {
                limit--;        //eliminate trailing whitespace
            }
            while ((start <  limit) && (spec.charAt(start) < = ' ')) {
                start++;        // eliminate leading whitespace
            }
            if (spec.regionMatches(true, start, "url:", 0, 4)) {
                start += 4;
            }
            if (start <  spec.length() && spec.charAt(start) == '#') {
                /* we're assuming this is a ref relative to the context URL.
                 * This means protocols cannot start w/ '#', but we must parse
                 * ref URL's like: "hello:there" w/ a ':' in them.
                 */
                aRef=true;
            }
            for (i = start ; !aRef && (i <  limit) &&
                     ((c = spec.charAt(i)) != '/') ; i++) {
                if (c == ':') {
                    String s = spec.substring(start, i).toLowerCase();
                    if (isValidProtocol(s)) {
                        newProtocol = s;
                        start = i + 1;
                    }
                    break;
                }
            }
            // Only use our context if the protocols match.
            protocol = newProtocol;
            if ((context != null) && ((newProtocol == null) ||
                            newProtocol.equalsIgnoreCase(context.protocol))) {
                // inherit the protocol handler from the context
                // if not specified to the constructor
                if (handler == null) {
                    handler = context.handler;
                }
                // If the context is a hierarchical URL scheme and the spec
                // contains a matching scheme then maintain backwards
                // compatibility and treat it as if the spec didn't contain
                // the scheme; see 5.2.3 of RFC2396
                if (context.path != null && context.path.startsWith("/"))
                    newProtocol = null;
                if (newProtocol == null) {
                    protocol = context.protocol;
                    authority = context.authority;
                    userInfo = context.userInfo;
                    host = context.host;
                    port = context.port;
                    file = context.file;
                    path = context.path;
                    isRelative = true;
                }
            }
            if (protocol == null) {
                throw new MalformedURLException("no protocol: "+original);
            }
            // Get the protocol handler if not specified or the protocol
            // of the context could not be used
            if (handler == null &&
                (handler = getURLStreamHandler(protocol)) == null) {
                throw new MalformedURLException("unknown protocol: "+protocol);
            }
            this.handler = handler;
            i = spec.indexOf('#', start);
            if (i  >= 0) {
                ref = spec.substring(i + 1, limit);
                limit = i;
            }
            /*
             * Handle special case inheritance of query and fragment
             * implied by RFC2396 section 5.2.2.
             */
            if (isRelative && start == limit) {
                query = context.query;
                if (ref == null) {
                    ref = context.ref;
                }
            }
            handler.parseURL(this, spec, start, limit);
        } catch(MalformedURLException e) {
            throw e;
        } catch(Exception e) {
            MalformedURLException exception = new MalformedURLException(e.getMessage());
            exception.initCause(e);
            throw exception;
        }
}</pre></pre></pre><ul>Creates a URL by parsing the given spec with the specified handler
within a specified context. If the handler is null, the parsing
occurs as with the two argument constructor.</ul><ul><b>Parameters:</b><br><dd><code>context</code> -    the context in which to parse the specification.<br></dd><dd><code>spec</code> -       the <code>String</code> to parse as a URL.<br></dd><dd><code>handler</code> -    the stream handler for the URL.<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd><dd><code>SecurityException</code> - 
       if a security manager exists and its
       <code>checkPermission</code> method doesn't allow
       specifying a stream handler.<br></dd><b>Also see:</b><br><dd>java.net.URL#URL(java.lang.String, java.lang.String,
                 int, java.lang.String)</dd><dd><a href='/docs/api/java/net/URLStreamHandler.html'>java.net.URLStreamHandler</a></dd><dd>java.net.URLStreamHandler#parseURL(java.net.URL,
                 java.lang.String, int, int)</dd><dd>exception: <code>MalformedURLException</code> -   if no protocol is specified, or an
              unknown protocol is found, or <tt>spec</tt> is <tt>null</tt>.<br></dd><dd>exception: <code>SecurityException</code> - 
       if a security manager exists and its
       <code>checkPermission</code> method doesn't allow
       specifying a stream handler.<br></dd></ul></td></tr><tr><td><pre><a href='javascript:src("cs4")'><img id='cs4i' src=/plus.gif border=0></a> <a name='URL(String, String, int, String)'>public <b>URL</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol,
    <a href=/docs/api/java/lang/String.html>String</a> host,
    int port,
    <a href=/docs/api/java/lang/String.html>String</a> file) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs4' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        this(protocol, host, port, file, null);
}</pre></pre></pre><ul>Creates a <code>URL</code> object from the specified
<code>protocol</code>, <code>host</code>, <code>port</code>
number, and <code>file</code>.<p>

<code>host</code> can be expressed as a host name or a literal
IP address. If IPv6 literal address is used, it should be
enclosed in square brackets (<tt>'['</tt> and <tt>']'</tt>), as
specified by <a
href="http://www.ietf.org/rfc/rfc2732.txt">RFC&nbsp;2732</a>;
However, the literal IPv6 address format defined in <a
href="http://www.ietf.org/rfc/rfc2373.txt"><i>RFC&nbsp;2373: IP
Version 6 Addressing Architecture</i></a> is also accepted.<p>

Specifying a <code>port</code> number of <code>-1</code>
indicates that the URL should use the default port for the
protocol.<p>

If this is the first URL object being created with the specified
protocol, a <i>stream protocol handler</i> object, an instance of
class <code>URLStreamHandler</code>, is created for that protocol:
<ol>
<li>If the application has previously set up an instance of
    <code>URLStreamHandlerFactory</code> as the stream handler factory,
    then the <code>createURLStreamHandler</code> method of that instance
    is called with the protocol string as an argument to create the
    stream protocol handler.
<li>If no <code>URLStreamHandlerFactory</code> has yet been set up,
    or if the factory's <code>createURLStreamHandler</code> method
    returns <code>null</code>, then the constructor finds the
    value of the system property:
    <blockquote><pre>
        java.protocol.handler.pkgs
    </pre></blockquote>
    If the value of that system property is not <code>null</code>,
    it is interpreted as a list of packages separated by a vertical
    slash character '<code>|</code>'. The constructor tries to load
    the class named:
    <blockquote><pre>
        &lt;<i>package</i>&gt;.&lt;<i>protocol</i>&gt;.Handler
    </pre></blockquote>
    where &lt;<i>package</i>&gt; is replaced by the name of the package
    and &lt;<i>protocol</i>&gt; is replaced by the name of the protocol.
    If this class does not exist, or if the class exists but it is not
    a subclass of <code>URLStreamHandler</code>, then the next package
    in the list is tried.
<li>If the previous step fails to find a protocol handler, then the
    constructor tries to load from a system default package.
    <blockquote><pre>
        &lt;<i>system default package</i>&gt;.&lt;<i>protocol</i>&gt;.Handler
    </pre></blockquote>
    If this class does not exist, or if the class exists but it is not a
    subclass of <code>URLStreamHandler</code>, then a
    <code>MalformedURLException</code> is thrown.
</ol>

<p>Protocol handlers for the following protocols are guaranteed
to exist on the search path :-
<blockquote><pre>
    http, https, ftp, file, and jar
</pre></blockquote>
Protocol handlers for additional protocols may also be
available.

<p>No validation of the inputs is performed by this constructor.</ul><ul><b>Parameters:</b><br><dd><code>protocol</code> -    the name of the protocol to use.<br></dd><dd><code>host</code> -        the name of the host.<br></dd><dd><code>port</code> -        the port number on the host.<br></dd><dd><code>file</code> -        the file on the host<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd><b>Also see:</b><br><dd>java.lang.System#getProperty(java.lang.String)</dd><dd>java.net.URL#setURLStreamHandlerFactory(
                 java.net.URLStreamHandlerFactory)</dd><dd><a href='/docs/api/java/net/URLStreamHandler.html'>java.net.URLStreamHandler</a></dd><dd>java.net.URLStreamHandlerFactory#createURLStreamHandler(
                 java.lang.String)</dd><dd>exception: <code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd></ul></td></tr><tr><td><pre><a href='javascript:src("cs5")'><img id='cs5i' src=/plus.gif border=0></a> <a name='URL(String, String, int, String, URLStreamHandler)'>public <b>URL</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol,
    <a href=/docs/api/java/lang/String.html>String</a> host,
    int port,
    <a href=/docs/api/java/lang/String.html>String</a> file,
    <a href=/docs/api/java/net/URLStreamHandler.html>URLStreamHandler</a> handler) throws <a href=/docs/api/java/net/MalformedURLException.html>MalformedURLException</a> <pre id='cs5' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        if (handler != null) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                // check for permission to specify a handler
                checkSpecifyHandler(sm);
            }
        }
        protocol = protocol.toLowerCase();
        this.protocol = protocol;
        if (host != null) {
            /**
             * if host is a literal IPv6 address,
             * we will make it conform to RFC 2732
             */
            if (host.indexOf(':')  >= 0 && !host.startsWith("[")) {
                host = "["+host+"]";
            }
            this.host = host;
            if (port <  -1) {
                throw new MalformedURLException("Invalid port number :" +
                                                    port);
            }
            this.port = port;
            authority = (port == -1) ? host : host + ":" + port;
        }
        Parts parts = new Parts(file);
        path = parts.getPath();
        query = parts.getQuery();
        if (query != null) {
            this.file = path + "?" + query;
        } else {
            this.file = path;
        }
        ref = parts.getRef();
        // Note: we don't do validation of the URL here. Too risky to change
        // right now, but worth considering for future reference. -br
        if (handler == null &&
            (handler = getURLStreamHandler(protocol)) == null) {
            throw new MalformedURLException("unknown protocol: " + protocol);
        }
        this.handler = handler;
}</pre></pre></pre><ul>Creates a <code>URL</code> object from the specified
<code>protocol</code>, <code>host</code>, <code>port</code>
number, <code>file</code>, and <code>handler</code>. Specifying
a <code>port</code> number of <code>-1</code> indicates that
the URL should use the default port for the protocol. Specifying
a <code>handler</code> of <code>null</code> indicates that the URL
should use a default stream handler for the protocol, as outlined
for:
    java.net.URL#URL(java.lang.String, java.lang.String, int,
                     java.lang.String)

<p>If the handler is not null and there is a security manager,
the security manager's <code>checkPermission</code>
method is called with a
<code>NetPermission("specifyStreamHandler")</code> permission.
This may result in a SecurityException.

No validation of the inputs is performed by this constructor.</ul><ul><b>Parameters:</b><br><dd><code>protocol</code> -    the name of the protocol to use.<br></dd><dd><code>host</code> -        the name of the host.<br></dd><dd><code>port</code> -        the port number on the host.<br></dd><dd><code>file</code> -        the file on the host<br></dd><dd><code>handler</code> -     the stream handler for the URL.<br></dd><b>Throws:</b><br><dd><code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd><dd><code>SecurityException</code> - 
       if a security manager exists and its
       <code>checkPermission</code> method doesn't allow
       specifying a stream handler explicitly.<br></dd><b>Also see:</b><br><dd>java.lang.System#getProperty(java.lang.String)</dd><dd>java.net.URL#setURLStreamHandlerFactory(
                 java.net.URLStreamHandlerFactory)</dd><dd><a href='/docs/api/java/net/URLStreamHandler.html'>java.net.URLStreamHandler</a></dd><dd>java.net.URLStreamHandlerFactory#createURLStreamHandler(
                 java.lang.String)</dd><dd>SecurityManager#checkPermission</dd><dd><a href='/docs/api/java/net/NetPermission.html'>java.net.NetPermission</a></dd><dd>exception: <code>MalformedURLException</code> -   if an unknown protocol is specified.<br></dd><dd>exception: <code>SecurityException</code> - 
       if a security manager exists and its
       <code>checkPermission</code> method doesn't allow
       specifying a stream handler explicitly.<br></dd></ul></td></tr></table>





<!-- end -->


<!-- methodsummary.jsp -->
    <table width='100%'><tr><th>Method from <b>java.net.URL</b> Summary:</td></tr><tr><td>
<a href='/docs/api/java/net/URL.html#equals(Object)'>equals</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getAuthority'>getAuthority</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getContent'>getContent</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getContent(Class)'>getContent</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getDefaultPort'>getDefaultPort</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getFile'>getFile</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getHost'>getHost</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getPath'>getPath</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getPort'>getPort</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getProtocol'>getProtocol</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getQuery'>getQuery</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getRef'>getRef</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getURLStreamHandler(String)'>getURLStreamHandler</a>, &nbsp; <a href='/docs/api/java/net/URL.html#getUserInfo'>getUserInfo</a>, &nbsp; <a href='/docs/api/java/net/URL.html#hashCode'>hashCode</a>, &nbsp; <a href='/docs/api/java/net/URL.html#openConnection'>openConnection</a>, &nbsp; <a href='/docs/api/java/net/URL.html#openConnection(Proxy)'>openConnection</a>, &nbsp; <a href='/docs/api/java/net/URL.html#openStream'>openStream</a>, &nbsp; <a href='/docs/api/java/net/URL.html#sameFile(URL)'>sameFile</a>, &nbsp; <a href='/docs/api/java/net/URL.html#set(String, String, int, String, String)'>set</a>, &nbsp; <a href='/docs/api/java/net/URL.html#set(String, String, int, String, String, String, String, String)'>set</a>, &nbsp; <a href='/docs/api/java/net/URL.html#setURLStreamHandlerFactory(URLStreamHandlerFactory)'>setURLStreamHandlerFactory</a>, &nbsp; <a href='/docs/api/java/net/URL.html#toExternalForm'>toExternalForm</a>, &nbsp; <a href='/docs/api/java/net/URL.html#toString'>toString</a>, &nbsp; <a href='/docs/api/java/net/URL.html#toURI'>toURI</a></td></tr></table><table width='100%'><tr><th>Methods from <b>java.lang.Object</b>:</td></tr><tr><td>
<a href='/docs/api/java/lang/Object.html#clone'>clone</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#equals(Object)'>equals</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#finalize'>finalize</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#getClass'>getClass</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#hashCode'>hashCode</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#notify'>notify</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#notifyAll'>notifyAll</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#toString'>toString</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#wait'>wait</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#wait(long)'>wait</a>, &nbsp; <a href='/docs/api/java/lang/Object.html#wait(long, int)'>wait</a></td></tr></table><table width='100%'><tr><th>Method from <b>java.net.URL</b> Detail:</td></tr>
<tr><td><pre><a href='javascript:src("ms7")'><img id='ms7i' src=/plus.gif border=0></a> public boolean<a name='equals(Object)'> <b>equals</b>(<a href=/docs/api/java/lang/Object.html>Object</a> obj)</a> <pre id='ms7' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        if (!(obj instanceof URL))
            return false;
        URL u2 = (URL)obj;
        return handler.equals(this, u2);
}</pre></pre><ul>Compares this URL for equality with another object.<p>

If the given object is not a URL then this method immediately returns
<code>false</code>.<p>

Two URL objects are equal if they have the same protocol, reference
equivalent hosts, have the same port number on the host, and the same
file and fragment of the file.<p>

Two hosts are considered equivalent if both host names can be resolved
into the same IP addresses; else if either host name can't be
resolved, the host names must be equal without regard to case; or both
host names equal to null.<p>

Since hosts comparison requires name resolution, this operation is a
blocking operation. <p>

Note: The defined behavior for <code>equals</code> is known to
be inconsistent with virtual hosting in HTTP.</ul></td></tr><tr><td><pre><a href='javascript:src("ms8")'><img id='ms8i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getAuthority'> <b>getAuthority</b>()</a> <pre id='ms8' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return authority;
}</pre></pre><ul>Gets the authority part of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms9")'><img id='ms9i' src=/plus.gif border=0></a> public final <a href=/docs/api/java/lang/Object.html>Object</a><a name='getContent'> <b>getContent</b>()</a> throws <a href=/docs/api/java/io/IOException.html>IOException</a> <pre id='ms9' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return openConnection().getContent();
}</pre></pre><ul>Gets the contents of this URL. This method is a shorthand for:
<blockquote><pre>
    openConnection().getContent()
</pre></blockquote></ul></td></tr><tr><td><pre><a href='javascript:src("ms10")'><img id='ms10i' src=/plus.gif border=0></a> public final <a href=/docs/api/java/lang/Object.html>Object</a><a name='getContent(Class)'> <b>getContent</b>(<a href=/docs/api/java/lang/Class.html>Class</a>[] classes)</a> throws <a href=/docs/api/java/io/IOException.html>IOException</a> <pre id='ms10' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return openConnection().getContent(classes);
}</pre></pre><ul>Gets the contents of this URL. This method is a shorthand for:
<blockquote><pre>
    openConnection().getContent(Class[])
</pre></blockquote></ul></td></tr><tr><td><pre><a href='javascript:src("ms11")'><img id='ms11i' src=/plus.gif border=0></a> public int<a name='getDefaultPort'> <b>getDefaultPort</b>()</a> <pre id='ms11' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return handler.getDefaultPort();
}</pre></pre><ul>Gets the default port number of the protocol associated
with this <code>URL</code>. If the URL scheme or the URLStreamHandler
for the URL do not define a default port number,
then -1 is returned.</ul></td></tr><tr><td><pre><a href='javascript:src("ms12")'><img id='ms12i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getFile'> <b>getFile</b>()</a> <pre id='ms12' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return file;
}</pre></pre><ul>Gets the file name of this <code>URL</code>.
The returned file portion will be
the same as <CODE>getPath()</CODE>, plus the concatenation of
the value of <CODE>getQuery()</CODE>, if any. If there is
no query portion, this method and <CODE>getPath()</CODE> will
return identical results.</ul></td></tr><tr><td><pre><a href='javascript:src("ms13")'><img id='ms13i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getHost'> <b>getHost</b>()</a> <pre id='ms13' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return host;
}</pre></pre><ul>Gets the host name of this <code>URL</code>, if applicable.
The format of the host conforms to RFC 2732, i.e. for a
literal IPv6 address, this method will return the IPv6 address
enclosed in square brackets (<tt>'['</tt> and <tt>']'</tt>).</ul></td></tr><tr><td><pre><a href='javascript:src("ms14")'><img id='ms14i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getPath'> <b>getPath</b>()</a> <pre id='ms14' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return path;
}</pre></pre><ul>Gets the path part of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms15")'><img id='ms15i' src=/plus.gif border=0></a> public int<a name='getPort'> <b>getPort</b>()</a> <pre id='ms15' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return port;
}</pre></pre><ul>Gets the port number of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms16")'><img id='ms16i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getProtocol'> <b>getProtocol</b>()</a> <pre id='ms16' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return protocol;
}</pre></pre><ul>Gets the protocol name of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms17")'><img id='ms17i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getQuery'> <b>getQuery</b>()</a> <pre id='ms17' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return query;
}</pre></pre><ul>Gets the query part of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms18")'><img id='ms18i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getRef'> <b>getRef</b>()</a> <pre id='ms18' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return ref;
}</pre></pre><ul>Gets the anchor (also known as the "reference") of this
<code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms19")'><img id='ms19i' src=/plus.gif border=0></a> static <a href=/docs/api/java/net/URLStreamHandler.html>URLStreamHandler</a><a name='getURLStreamHandler(String)'> <b>getURLStreamHandler</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol)</a> <pre id='ms19' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        URLStreamHandler handler = (URLStreamHandler)handlers.get(protocol);
        if (handler == null) {
            boolean checkedWithFactory = false;
            // Use the factory (if any)
            if (factory != null) {
                handler = factory.createURLStreamHandler(protocol);
                checkedWithFactory = true;
            }
            // Try java protocol handler
            if (handler == null) {
                String packagePrefixList = null;
                packagePrefixList
                    = java.security.AccessController.doPrivileged(
                    new sun.security.action.GetPropertyAction(
                        protocolPathProp,""));
                if (packagePrefixList != "") {
                    packagePrefixList += "|";
                }
                // REMIND: decide whether to allow the "null" class prefix
                // or not.
                packagePrefixList += "sun.net.www.protocol";
                StringTokenizer packagePrefixIter =
                    new StringTokenizer(packagePrefixList, "|");
                while (handler == null &&
                       packagePrefixIter.hasMoreTokens()) {
                    String packagePrefix =
                      packagePrefixIter.nextToken().trim();
                    try {
                        String clsName = packagePrefix + "." + protocol +
                          ".Handler";
                        Class cls = null;
                        try {
                            cls = Class.forName(clsName);
                        } catch (ClassNotFoundException e) {
                            ClassLoader cl = ClassLoader.getSystemClassLoader();
                            if (cl != null) {
                                cls = cl.loadClass(clsName);
                            }
                        }
                        if (cls != null) {
                            handler  =
                              (URLStreamHandler)cls.newInstance();
                        }
                    } catch (Exception e) {
                        // any number of exceptions can get thrown here
                    }
                }
            }
            synchronized (streamHandlerLock) {
                URLStreamHandler handler2 = null;
                // Check again with hashtable just in case another
                // thread created a handler since we last checked
                handler2 = (URLStreamHandler)handlers.get(protocol);
                if (handler2 != null) {
                    return handler2;
                }
                // Check with factory if another thread set a
                // factory since our last check
                if (!checkedWithFactory && factory != null) {
                    handler2 = factory.createURLStreamHandler(protocol);
                }
                if (handler2 != null) {
                    // The handler from the factory must be given more
                    // importance. Discard the default handler that
                    // this thread created.
                    handler = handler2;
                }
                // Insert this handler into the hashtable
                if (handler != null) {
                    handlers.put(protocol, handler);
                }
            }
        }
        return handler;
}</pre></pre><ul>Returns the Stream Handler.</ul></td></tr><tr><td><pre><a href='javascript:src("ms20")'><img id='ms20i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='getUserInfo'> <b>getUserInfo</b>()</a> <pre id='ms20' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return userInfo;
}</pre></pre><ul>Gets the userInfo part of this <code>URL</code>.</ul></td></tr><tr><td><pre><a href='javascript:src("ms21")'><img id='ms21i' src=/plus.gif border=0></a> public synchronized int<a name='hashCode'> <b>hashCode</b>()</a> <pre id='ms21' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        if (hashCode != -1)
            return hashCode;
        hashCode = handler.hashCode(this);
        return hashCode;
}</pre></pre><ul>Creates an integer suitable for hash table indexing.<p>

The hash code is based upon all the URL components relevant for URL
comparison. As such, this operation is a blocking operation.<p></ul></td></tr><tr><td><pre><a href='javascript:src("ms23")'><img id='ms23i' src=/plus.gif border=0></a> public <a href=/docs/api/java/net/URLConnection.html>URLConnection</a><a name='openConnection'> <b>openConnection</b>()</a> throws <a href=/docs/api/java/io/IOException.html>IOException</a> <pre id='ms23' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return handler.openConnection(this);
}</pre></pre><ul>Returns a <a href='/docs/api/java/net/URLConnection.html'>URLConnection</a>  instance that
represents a connection to the remote object referred to by the
{@code URL}.

<P>A new instance of {@linkplain java.net.URLConnection URLConnection} is
created every time when invoking the
{@linkplain java.net.URLStreamHandler#openConnection(URL)
URLStreamHandler.openConnection(URL)} method of the protocol handler for
this URL.</P>

<P>It should be noted that a URLConnection instance does not establish
the actual network connection on creation. This will happen only when
calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.</P>

<P>If for the URL's protocol (such as HTTP or JAR), there
exists a public, specialized URLConnection subclass belonging
to one of the following packages or one of their subpackages:
java.lang, java.io, java.util, java.net, the connection
returned will be of that subclass. For example, for HTTP an
HttpURLConnection will be returned, and for JAR a
JarURLConnection will be returned.</P></ul></td></tr><tr><td><pre><a href='javascript:src("ms24")'><img id='ms24i' src=/plus.gif border=0></a> public <a href=/docs/api/java/net/URLConnection.html>URLConnection</a><a name='openConnection(Proxy)'> <b>openConnection</b>(<a href=/docs/api/java/net/Proxy.html>Proxy</a> proxy)</a> throws <a href=/docs/api/java/io/IOException.html>IOException</a> <pre id='ms24' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        if (proxy == null) {
            throw new IllegalArgumentException("proxy can not be null");
        }
        // Create a copy of Proxy as a security measure
        Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY : sun.net.ApplicationProxy.create(proxy);
        SecurityManager sm = System.getSecurityManager();
        if (p.type() != Proxy.Type.DIRECT && sm != null) {
            InetSocketAddress epoint = (InetSocketAddress) p.address();
            if (epoint.isUnresolved())
                sm.checkConnect(epoint.getHostName(), epoint.getPort());
            else
                sm.checkConnect(epoint.getAddress().getHostAddress(),
                                epoint.getPort());
        }
        return handler.openConnection(this, p);
}</pre></pre><ul>Same as <a href='#openConnection()'>#openConnection()</a> , except that the connection will be
made through the specified proxy; Protocol handlers that do not
support proxing will ignore the proxy parameter and make a
normal connection.

Invoking this method preempts the system's default ProxySelector
settings.</ul></td></tr><tr><td><pre><a href='javascript:src("ms25")'><img id='ms25i' src=/plus.gif border=0></a> public final <a href=/docs/api/java/io/InputStream.html>InputStream</a><a name='openStream'> <b>openStream</b>()</a> throws <a href=/docs/api/java/io/IOException.html>IOException</a> <pre id='ms25' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return openConnection().getInputStream();
}</pre></pre><ul>Opens a connection to this <code>URL</code> and returns an
<code>InputStream</code> for reading from that connection. This
method is a shorthand for:
<blockquote><pre>
    openConnection().getInputStream()
</pre></blockquote></ul></td></tr><tr><td><pre><a href='javascript:src("ms27")'><img id='ms27i' src=/plus.gif border=0></a> public boolean<a name='sameFile(URL)'> <b>sameFile</b>(<a href=/docs/api/java/net/URL.html>URL</a> other)</a> <pre id='ms27' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return handler.sameFile(this, other);
}</pre></pre><ul>Compares two URLs, excluding the fragment component.<p>

Returns <code>true</code> if this <code>URL</code> and the
<code>other</code> argument are equal without taking the
fragment component into consideration.</ul></td></tr><tr><td><pre><a href='javascript:src("ms28")'><img id='ms28i' src=/plus.gif border=0></a> protected  void<a name='set(String, String, int, String, String)'> <b>set</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol,
    <a href=/docs/api/java/lang/String.html>String</a> host,
    int port,
    <a href=/docs/api/java/lang/String.html>String</a> file,
    <a href=/docs/api/java/lang/String.html>String</a> ref)</a> <pre id='ms28' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        synchronized (this) {
            this.protocol = protocol;
            this.host = host;
            authority = port == -1 ? host : host + ":" + port;
            this.port = port;
            this.file = file;
            this.ref = ref;
            /* This is very important. We must recompute this after the
             * URL has been changed. */
            hashCode = -1;
            hostAddress = null;
            int q = file.lastIndexOf('?');
            if (q != -1) {
                query = file.substring(q+1);
                path = file.substring(0, q);
            } else
                path = file;
        }
}</pre></pre><ul>Sets the fields of the URL. This is not a public method so that
only URLStreamHandlers can modify URL fields. URLs are
otherwise constant.</ul></td></tr><tr><td><pre><a href='javascript:src("ms29")'><img id='ms29i' src=/plus.gif border=0></a> protected  void<a name='set(String, String, int, String, String, String, String, String)'> <b>set</b>(<a href=/docs/api/java/lang/String.html>String</a> protocol,
    <a href=/docs/api/java/lang/String.html>String</a> host,
    int port,
    <a href=/docs/api/java/lang/String.html>String</a> authority,
    <a href=/docs/api/java/lang/String.html>String</a> userInfo,
    <a href=/docs/api/java/lang/String.html>String</a> path,
    <a href=/docs/api/java/lang/String.html>String</a> query,
    <a href=/docs/api/java/lang/String.html>String</a> ref)</a> <pre id='ms29' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        synchronized (this) {
            this.protocol = protocol;
            this.host = host;
            this.port = port;
            this.file = query == null ? path : path + "?" + query;
            this.userInfo = userInfo;
            this.path = path;
            this.ref = ref;
            /* This is very important. We must recompute this after the
             * URL has been changed. */
            hashCode = -1;
            hostAddress = null;
            this.query = query;
            this.authority = authority;
        }
}</pre></pre><ul>Sets the specified 8 fields of the URL. This is not a public method so
that only URLStreamHandlers can modify URL fields. URLs are otherwise
constant.</ul></td></tr><tr><td><pre><a href='javascript:src("ms30")'><img id='ms30i' src=/plus.gif border=0></a> public static  void<a name='setURLStreamHandlerFactory(URLStreamHandlerFactory)'> <b>setURLStreamHandlerFactory</b>(<a href=/docs/api/java/net/URLStreamHandlerFactory.html>URLStreamHandlerFactory</a> fac)</a> <pre id='ms30' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        synchronized (streamHandlerLock) {
            if (factory != null) {
                throw new Error("factory already defined");
            }
            SecurityManager security = System.getSecurityManager();
            if (security != null) {
                security.checkSetFactory();
            }
            handlers.clear();
            factory = fac;
        }
}</pre></pre><ul>Sets an application's <code>URLStreamHandlerFactory</code>.
This method can be called at most once in a given Java Virtual
Machine.

<p> The <code>URLStreamHandlerFactory</code> instance is used to
construct a stream protocol handler from a protocol name.

<p> If there is a security manager, this method first calls
the security manager's <code>checkSetFactory</code> method
to ensure the operation is allowed.
This could result in a SecurityException.</ul></td></tr><tr><td><pre><a href='javascript:src("ms31")'><img id='ms31i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='toExternalForm'> <b>toExternalForm</b>()</a> <pre id='ms31' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return handler.toExternalForm(this);
}</pre></pre><ul>Constructs a string representation of this <code>URL</code>. The
string is created by calling the <code>toExternalForm</code>
method of the stream protocol handler for this object.</ul></td></tr><tr><td><pre><a href='javascript:src("ms32")'><img id='ms32i' src=/plus.gif border=0></a> public <a href=/docs/api/java/lang/String.html>String</a><a name='toString'> <b>toString</b>()</a> <pre id='ms32' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return toExternalForm();
}</pre></pre><ul>Constructs a string representation of this <code>URL</code>. The
string is created by calling the <code>toExternalForm</code>
method of the stream protocol handler for this object.</ul></td></tr><tr><td><pre><a href='javascript:src("ms33")'><img id='ms33i' src=/plus.gif border=0></a> public <a href=/docs/api/java/net/URI.html>URI</a><a name='toURI'> <b>toURI</b>()</a> throws <a href=/docs/api/java/net/URISyntaxException.html>URISyntaxException</a> <pre id='ms33' style='height:1px;overflow:hidden;visibility:hidden;width:100%'>{
        return new URI (toString());
}</pre></pre><ul>Returns a <a href='/docs/api/java/net/URI.html'>java.net.URI</a>  equivalent to this URL.
This method functions in the same way as <code>new URI (this.toString())</code>.
<p>Note, any URL instance that complies with RFC 2396 can be converted
to a URI. However, some URLs that are not strictly in compliance
can not be converted to a URI.</ul></td></tr></table>








<!-- end -->


</div>
</body></html>













<!-- end -->

